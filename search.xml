<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实验室/科研神器——免费快捷搭建内网穿透教程]]></title>
    <url>%2Fpost%2Fa2247683.html</url>
    <content type="text"><![CDATA[( • ̀ω•́ )✧博主更换输出主战场了=》少年心气的博客(/ω＼)(σﾟ∀ﾟ)σ..:*☆欢迎大家批评指教，一起来讨论进步~哎哟不错哦~(￣３￣)a 首先说一下我的需求：学院服务器是linux的系统；被分配了内网IP；不知道对应路由器在哪；需要外网(在宿舍)也能进行访问。 这里注意：虽然宿舍用的也是校园网，但是 服务器那边的路由器，可能只是被校园的网络管理员分配了一个公网IP；然而路由器进行了NAT/DHCP 进行了内网IP分配，使得服务器都可以访问到外网，然而外网（只知道一个公网IP，却不知道 我想访问的服务器是哪个）是访问不到 服务器的。 所以之前我们想到windows之间可以用teamviewer。但是服务器都是黑框，于是想到使用找到对应的公网IP路由器，直接进行端口转发，但是用的交换机、不是路由器，没有这个功能。于是使用teamviewer搭建对应的“威屁恩”（因为 自己没有预算，而且需要有一台公共服务器C，A B都能访问到， 在C上搭建 “威屁恩”），使得A B能够处于同一网段，于是就可以进行 网络访问；再进行一下 端口转发就好了。 奈何上面的想法都没有奏效，但是以上过程帮助我们理清了思路——内网穿透，需求不大 黑框能连接就行。 于是发现了下面这个神器。可以说是在该需求下，史上最好用的免费服务器来搭建内网穿透的方式了！ 前置条件 目标服务器22端口是开启的，也就是支持SSH，一般LINUX都支持; 小蚂蚁Jar版下载到linux上（ 别问为什么） ; 目标服务器需要安装JAVA运行环境（为了能够运行小蚂蚁jar版）; 小蚂蚁隧道一条 ; XShell （这个没必要解释了吧）。 客户端配置 进入小蚂蚁官网 新建一条隧道（无法注册或者新建的，建议下载客户端进行新建隧道） 具体配置见下图：从左到右依次为 二级域名：【自己设置】你需要给出的shell连接用的外网域名； 返回端口：【自动返回】shell时填写的端口； 服务器IP：【自己填写】ifconfig命令查看linux服务器的内网IP，并填写上；、 转发端口：【自己填写】因为这里我们要进行ssh连接，所以固定填写22； 其它：协议选择 socket由此设置完成后，记下你这条隧道的域名，以及它的外网端口下一步就是在穿透的目标服务器中，运行小蚂蚁jar版本。 Linux端配置 linux用户直接在终端一路cd到jar包存放路径； 然后输入 nohup java -Dfile.encoding=utf-8 -jar xiaomy_nat.jar 账号 密码 &amp;（这里在输入到-jar 时可以双击tab看文件列表提示）； jar包启动完成后可以在.out文件里看看是否穿透成功。 下一步就是进行外网电脑，ssh连接服务器，看是否正常。 XShell连接 打开XShell，新建一个连接，文件协议选ssh,主机名填第一步客户端配置的域名，端口号填第一步的端口号； 账号密码就是你登录目标服务器所使用的服务器账号密码； 点击连接，有警告直接点确定就可以； 接受并保存连接密钥； 连接成功！ 总结至此小蚂蚁版本内网穿透大成功！满足了黑框的所有需求，而且免费~有更高需要的可以选择付费版本（终身使用的也挺划算）。赞美一波~ Nice 大兄弟~ P.S. 有问题可以加入一起讨论，群主真的不错。=》“小蚂蚁内网穿透交流群”[6#5#4!9@6@3~5@3@8] P.P.S. linux服务器的内网IP如果变动了 相应的小蚂蚁客户端也要修改内网IP，然后重启linux jar包！这时才能保证就算，windows客户端的小蚂蚁关闭了，linux上的 小蚂蚁客户端也一直运行着，进行同一网段的内网连接。]]></content>
      <categories>
        <category>工具</category>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>科研利器</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据处理和模型评估与选择]]></title>
    <url>%2Fpost%2Ff3b66b3.html</url>
    <content type="text"><![CDATA[简介正确使用数据处理、模型评估和模型算法选择技术无论是对机器学习学术研究还是工业场景应用都至关重要。 数据处理在使用数据进行建模或分析之前，对其进行一定的处理；并且在应用机器学习算法分析结果之后对模型数据进行处理和特征提取/选择的过程。 数据标准化数据离散化数据抽样数据降维数据清理相似度计算模型评估与选择（简要一提）模型评估现实任务中，我们往往有许多算法可以选择，甚至对于同一个学习算法，使用不同的参数配置时，也会产生不同的模型。然而在选择中，无法直接得到泛化误差，而训练误差又由于过拟合现象的存在不适合作为标准。所以我们通过增强模型泛化能力，得到适合进行 模型评估的泛化误差进行评估并进而做出选择。 性能度量然而，对学习器的泛化性能进行评估，不仅需要有效可行的饰演顾及方法，还需要有衡量模型泛化能力的评价标准。这就是性能度量——模型评价方法。 应用机器学习算法建议（简要一提）这些诊断法的执行和实现，是需要花些 时间的，有时候确实需要花很多时间来理解和实现，但这样做的确是把时间用在了刀刃上，因为这些方法让你在开发学习算法时，节省了几个月的时间。 构建一个学习算法的推荐方法（简要一提） 从一个简单的能快速实现的算法开始，实现该算法并用交叉验证集数据测试这个算法；（可以在一般的情况下 检验算法的有效性） 绘制学习曲线，决定是增加更多数据，或者添加更多特征，还是其他选择； 进行误差分析：人工检查交叉验证集中我们算法中产生预测误差的实例，看看这些实例是否有某种系统化的趋势。 学习曲线（引出 特征提取和选择）【简单来说】学习曲线(learning curve)来判断模型状态：过拟合欠拟合 【详细来说】学习曲线是不同训练集大小，模型在训练集和验证集上的得分变化曲线。也就是以样本数为横坐标，训练和交叉验证集上的得分（如准确率）为纵坐标。learning curve可以帮助我们判断模型现在所处的状态：过拟合（overfiting / high variance） or 欠拟合（underfitting / high bias）模型欠拟合、过拟合、偏差和方差平衡 时对应的学习曲线如下图所示： （1）左上角的图中训练集和验证集上的曲线能够收敛。在训练集合验证集上准确率相差不大，却都很差。这说明模拟对已知数据和未知都不能进行准确的预测，属于高偏差。这种情况模型很可能是欠拟合。可以针对欠拟合采取对应的措施。欠拟合措施：我们可以增加模型参数（特征），比如，构建更多的特征，减小正则项。采用更复杂的模型此时通过增加数据量是不起作用的。（为什么？） （2）右上角的图中模型在训练集上和验证集上的准确率差距很大。说明模型能够很好的拟合已知数据，但是泛化能力很差，属于高方差。模拟很可能过拟合，要采取过拟合对应的措施。过拟合措施：我们可以增大训练集，降低模型复杂度，增大正则项，或者通过特征选择减少特征数，即做一下feature selection，挑出较好的feature的subset来做training （3）理想情况是找到偏差和方差都很小的情况，即收敛且误差较小。如右角的图。 LDA（区别于PCA） 排序：先重点-不紧急(但是 重要且有用！)其它放这里。 23:00-24:00 7:00-8:30 8:30:10:00 10:10-11:40 11:40-14:00 14:00-15:10 15:20-17:20 17:20-18:30 18:30-20:30 20:30-21:30 睡觉 起床吃饭+英语 基础+第三周 CNN 午休 上课(花书) 上课(花书) 吃饭+打印 整理上午+CNN笔记 总结+计划/ 买书？ 上传/输出blog]]></content>
      <categories>
        <category>MachineLearning</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode&Hexo快捷键和操作命令]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[VSCode中 非常好用的快捷命令多行操作 选中多行进行操作：Alt + 鼠标左键（或者 Ctrl+Alt + 上下按键） 加选下一个同名名称：Ctrl + d ( + u 是选择上一个) 基础操作 首先是F1/Ctrl+Shit+P万能键，谁用谁知道 Ctrl+G：跳转行号 Ctrl+P：文件切换 Ctrl + Shift + Tab 调出最近打开的文件列表 Ctrl + Tab 与上面一致，顺序不一致 Alt+↑↓：整行上下移动 Ctrl+↑↓：编辑器垂直滚动条上下移动，光标不动 Ctrl+Backspace/Delete：整词/连续空白删除 Ctrl+→←：光标整词移动 Ctrl+F查找/Ctrl+Shift+F在文件中查找（通用快捷键不再赘述） F12/Ctrl+左键点击函数：跳转到定义 Shift+F12：预览定义 代码调试 F5：调试/继续， F10：单步跳过， F11：单步进入， Shift+F11：跳出。 F9：切换断点 代码提示 Ctrl+空格：自动提示 集成终端快捷键 Shift + PgUp / PgDown: 页面上下翻屏 Ctrl + Home / End: 滚动到页面头部或尾部 Ctrl + Enter: 在下面插入新的一行 Ctrl + Shift + [ 折叠区域代码 Ctrl + Shift + ] 展开区域代码 插件介绍 Python（必备）VScode自带的官方插件 Anaconda Extension Pack可以自动补全anaconda包中的属性名称 Code Spell Checker单词拼写检查，非常推荐，有时候会拼错单词，这个不仅可以指出错误，还能提供正确单词的拼写方式。安装好之后，选中拼写错误的单词，旁边出现黄色小灯泡，点击选择单词，直接替换。 Autopep8/yapf自动格式化代码；(Alt + Shift + F) Settings Sync将VScode的配置上传到github，以后换机器，重装系统，随时下载，不用重新找教程了 vscode-icons文件图标主题，能够让你的各种文件一目了然，不用再去看扩展名，而且超级好看 SynthWave’84字体颜色主题，我个人非常喜欢的一套高亮字体方案 koroFileHeader文件头注释（ctrl+alt+i） 和函数头注释（ctrl+alt+t）工具，一键生成头注释 Markdown Preview Enhanced在VSCode中完美书写MarkDown和LaTex必备的预览插件 其它设置隐藏菜单栏这个属于个人习惯，如果你也感觉菜单栏很碍眼，可以点击查看-&gt;切换菜单栏，即可隐藏菜单栏。需要菜单栏的时候按Alt键即可查看 设置快捷键文件-&gt;首选项-&gt;键盘快捷方式，将需要的修改的快捷键的整个大括号里面的内容复制到右边keybindings.json文件中，然后修改“key”的值为你需要的快捷键即可。我这边只修改了复制一行和删除一行的快捷键。 常用hexo命令1234567891011121314 ·常见命令hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 ·缩写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。 需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 写博客新建post or page定位到我们的hexo根目录，执行命令： hexo new &#39;my-first-blog&#39;hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下： 123456title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面--- 以下是正文那么 hexo new page ‘postName’ 命令和 hexo new ‘postName’ 有什么区别呢？ hexo new page &quot;my-second-blog&quot;生成如下： 最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上 &lt;!--more--&gt; 即可。 Hexo中添加本地图片First1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image --save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 3 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 5 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。 Second本地source中建立img文件夹 &lt;img src=&quot;img/图片名.jpg&gt; 这个比较方便 Third图床，不太稳定。或者上传至七牛服务器。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post12$ hexo new "My New Post"$ hexo n More info: Writing Run server12$ hexo server$ hexo s More info: Server Generate static files12$ hexo generate$ hexo g More info: Generating Deploy to remote sites12$ hexo deploy$ hexo d More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>即用</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown中Latex语法梳理]]></title>
    <url>%2Fpost%2Fd8ef22e6.html</url>
    <content type="text"><![CDATA[笔者在学习MachineLearning和神经网络模型时,越发感到需要使用的数学公式变多了.于是乎为了方便自己进行ML笔记整理运用到的数学公式以及方便日后进行论文写作中熟悉使用LaTex语法.现将markdown中LaTeX数学公式语法进行整理.方便在需要的使用自取自用.推荐 Excel等表格在线转换器——LaTex 食用更加. 插入公式的方法 行内公式: $...$ 和 \(...\) 块内公式: $$...$$ 和 \[...\] 测试输出LaTex公式 BP算法 12345678910111213训练集 $\left\&#123;\left(x^&#123;(1)&#125;, y^&#123;(1)&#125;\right), \ldots,\left(x^&#123;(m)&#125;, y^&#123;(m)&#125;\right)\right\&#125;$设 $\Delta_&#123;i j&#125;^&#123;(l)&#125;=0(\text &#123; for all &#125; l, i, j)$$\begin&#123;array&#125;&#123;l&#125;&#123;\text &#123;For &#125; i=1 \text &#123; to &#125; m&#125;\end&#123;array&#125;$$$\begin&#123;array&#125;&#123;l&#125;&#123;\text &#123; Set &#125; a^&#123;(1)&#125;=x^&#123;(i)&#125;&#125; \\ &#123;\text &#123; Perform forward propagation to compute &#125; a^&#123;(l)&#125; \text &#123; for &#125; l=2,3, \ldots, L&#125; \\ &#123;\text &#123; Using &#125; y^&#123;(i)&#125;, \text &#123; compute &#125; \delta^&#123;(L)&#125;=a^&#123;(L)&#125;-y^&#123;(i)&#125;&#125; \\ &#123;\text &#123; Compute &#125; \delta^&#123;(L-1)&#125;, \delta^&#123;(l+1)&#125;, \ldots, \delta^&#123;(2)&#125;&#125; \\ &#123;\Delta_&#123;i j&#125;^&#123;(l)&#125; :=\Delta_&#123;i j&#125;^&#123;(l)&#125;+a_&#123;j&#125;^&#123;(l)&#125; \delta_&#123;i&#125;^&#123;(l+1)&#125;&#125;\end&#123;array&#125;$$$\begin&#123;array&#125;&#123;l&#125;&#123;D_&#123;i j&#125;^&#123;(l)&#125; :=\frac&#123;1&#125;&#123;m&#125; \Delta_&#123;i j&#125;^&#123;(l)&#125;+\lambda \Theta_&#123;i j&#125;^&#123;(l)&#125;&#125; &amp; &#123;\text &#123; if &#125; j \neq 0&#125; \\ &#123;D_&#123;i j&#125;^&#123;(l)&#125; :=\frac&#123;1&#125;&#123;m&#125; \Delta_&#123;i j&#125;^&#123;(l)&#125;&#125; &amp; &#123;\text &#123; if &#125; j=0&#125;\end&#123;array&#125;$其中 $\frac&#123;\partial&#125;&#123;\partial \Theta_&#123;i j&#125;^&#123;(l)&#125;&#125; J(\Theta)=D_&#123;i j&#125;^&#123;(l)&#125;$ 训练集 $\left\{\left(x^{(1)}, y^{(1)}\right), \ldots,\left(x^{(m)}, y^{(m)}\right)\right\}$ 设 $\Delta_{i j}^{(l)}=0(\text { for all } l, i, j)$ $\begin{array}{l}{\text {For } i=1 \text { to } m}\end{array}$ \begin{array}{l}{\text { Set } a^{(1)}=x^{(i)}} \\ {\text { Perform forward propagation to compute } a^{(l)} \text { for } l=2,3, \ldots, L} \\ {\text { Using } y^{(i)}, \text { compute } \delta^{(L)}=a^{(L)}-y^{(i)}} \\ {\text { Compute } \delta^{(L-1)}, \delta^{(l+1)}, \ldots, \delta^{(2)}} \\ {\Delta_{i j}^{(l)} :=\Delta_{i j}^{(l)}+a_{j}^{(l)} \delta_{i}^{(l+1)}}\end{array} $\begin{array}{l}{D_{i j}^{(l)} :=\frac{1}{m} \Delta_{i j}^{(l)}+\lambda \Theta_{i j}^{(l)}} &amp; {\text { if } j \neq 0} \\ {D_{i j}^{(l)} :=\frac{1}{m} \Delta_{i j}^{(l)}} &amp; {\text { if } j=0}\end{array}$ 其中 $\frac{\partial}{\partial \Theta_{i j}^{(l)}} J(\Theta)=D_{i j}^{(l)}$ LaTex运算符 运算符号 Latex公式 运算符号 Latex公式 &gt;= \(\geq\) ∐ $\coprod$ &lt;= $\leq$ ∑ $\sum$ ∼ $\sim$ ∏ $\prod$ ∽ $\backsim$ ⊅ $\not\supset$ ⊥ $$\bot$$ ⊂ $\subset$ ± $\pm$ ⊃ $\supset$ ⋅ $\cdot$ ∈ $\in$ × $\times$ ∉ $\notin$ ∗ $\ast$ ⊆ $\subseteq$ ÷ $\div$ ⊇ $\supseteq$ ≠ $\not=$ ⋂ $\bigcap$ ≈ $\approx$ ⋃ $\bigcup$ ≮ $\not&lt;$ ⋁ $\bigvee$ ∣ $\mid$ ⋁ $\bigvee$ log $\log$ ⋀ $\bigwedge$ log218 $\log_2{18}$ y^ $\hat{y}$ ln $\ln$ yˇ $\check{y}$ lg $\lg$ y˘ $\breve{y}$ ∠ $\angle$ ≪ $\ll$ 30∘ $30^\circ$ ≫ $\gg$ sin $\sin$ lim $\lim$ cos $\cos$ ∞ $\infty$ tan $\tan$ ∇ $\nabla$ cot $\cot$ ∮ $\oint$ csc $\csc$ ′ $\prime$ sec $\sec$ ⨀ $\bigodot$ ⨂ $\bigotimes$ ⨁ $\bigoplus$ LaTex数学表达式 名称 符号 数学表达式 Latex公式 上标 ^ ab $a^b$ 下标 _ ab $a_b$ 分数 \frac 1+ab+c $\frac{1 + a}{b + c}$ 求和 \sum ∑2xn $\sum{2x^n}$ 带范围求和 \sum_{ }^{ } ∑Nn=1 $\sum_{n=1}^N$ 累乘 \prod_{ }^{ } ∏Nn=12xn $\prod_{n=1}^{N}{2x^n}$ 开方 \sqrt[ ]{ } 100−−−√2 $\sqrt[2]{100}$ 积分 \int_{ }^{ } ∫51f(x)dx $\int^5_1{f(x)}{\rm d}x$ 二重积分 \iint_{ }^{ } ∬51f(x)dx $\iint^5_1{f(x)}{\rm d}x$ 三重积分 \iiint_{ }^{ } ∭51f(x)dx $\iiint^5_1{f(x)}{\rm d}x$ 正无穷 $\infty$ +∞ $+\infty$ 正无穷 $\infty$ −∞ $-\infty$ 极限 limn→+∞n $\lim_{n\rightarrow+\infty} n$ 箭头 箭头符号 Latex公式 ↑ $\uparrow$ ↓ $\downarrow$ ⇑ $\Uparrow$ ⇓ $\Downarrow$ → $\rightarrow$ ← $\leftarrow$ ⇒ $\Rightarrow$ ⇐ $\Leftarrow$ ⟶ $\longrightarrow$ ⟵ $\longleftarrow$ ⟹ $\Longrightarrow$ ⟸ $\Longleftarrow$ f:xt↦yt $f: {\mathbf x_t} \mapsto {\mathbf y_t}$ ⟺ \Longleftrightarrow 括号和分隔符 ()、[]和|表示符号本身，使用 \{\} 来表示 {}。当要显示大号的括号或分隔符时，要用 \left 和 \right 命令。 Latex公式 显示 $$\langle...\rangle$$ ⟨…⟩ $$\lceil...\rceil$$ ⌈…⌉ $$\lfloor...\rfloor$$ ⌊…⌋ $$\lbrace...\rbrace$$ {…} 字体转换 Latex公式 说明 显示实例 \rm 罗马体 AA \cal 花体 BB \it 意大利体 CC \Bbb 黑板粗体 DD \bf 粗体 EE \mit 数学斜体 FF \sf 等线体 GG \scr 手写体 HH \tt 打字机体 MM \frak 旧德式字体 NN \boldsymbol 黑体 X,x 实例1： $ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)实例2：大括号和行标的使用123456789101112131415$$f\left( \left[ \frac&#123; 1+\left\&#123;x,y\right\&#125; &#125;&#123; \left( \frac&#123;x&#125;&#123;y&#125;+\frac&#123;y&#125;&#123;x&#125; \right) \left(u+1\right) &#125;+a \right]^&#123;3/2&#125;\right)\tag&#123;行标&#125;$$ f\left( \left[ \frac{ 1+\left\{x,y\right\} }{ \left( \frac{x}{y}+\frac{y}{x} \right) \left(u+1\right) }+a \right]^{3/2} \right) \tag{行标}省略号 数学公式中常见的省略号有两种 \ldots 表示与文本底线对齐的省略号 \cdots 表示与文本中线对齐的省略号 实例：$f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2$$ f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2矢量输入 使用 \vec{矢量}可以产生一个矢量。也可以使用 \overrightarrow命令自定义字母上方的符号。 实例1：$\vec{a} \cdot \vec{b}=0$$ \vec{a} \cdot \vec{b}=0实例2：$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$ \overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}字体转换使用 {\字体 {需转换的部分字符}} 命令可以转换字符字体。其中 \字体 部分可以参照下表选择合适的字体。公式默认为意大利体. Latex公式 说明 显示实例 \rm 罗马体 A \cal 花体 B \it 意大利体 C \Bbb 黑板粗体 D \bf 粗体 E \mit 数学斜体 F \sf 等线体 G \scr 手写体 H \tt 打字机体 M \frak 旧德式字体 N \boldsymbol 黑体 X,x]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>即用</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WE_ACAN]]></title>
    <url>%2Fpost%2Fb7bad590.html</url>
    <content type="text"><![CDATA[( • ̀ω•́ )✧【请在输入密码后阅读全文】(我不休息我还能继续**⊂(‘ω’⊂ )))Σ≡=─༄༅༄༅༄༅༄༅༄༅ Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>页面</category>
      </categories>
      <tags>
        <tag>正能量</tag>
        <tag>少年初心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA\CUDA\cuDNN环境安装(解决循环登录问题)和Anaconda安装使用]]></title>
    <url>%2Fpost%2Fef6f3008.html</url>
    <content type="text"><![CDATA[关于Ubuntu显卡驱动的安装-解决循环登录\挂载\卸载问题 由于AC自己本人刚开始在实验室使用ubuntu系统时,电脑自带多张显卡 配置有点问题,导致循环登录—-噩梦般的两天未果,隧重装. AC的显卡驱动安装过程以及一些操作再次记录下来,以飨后来者. NVIDIA显卡驱动安装 禁用 nouveau 驱动（nouveau是 ubuntu16.04 默认安装的第三方开源驱动，安装cuda会跟nouveau冲突，需要先禁用） 先查看 nouveau 是否被禁用，输入以下命令，若有输出，则说明 nouveau 在运行中 lsmod | grep nouveau 修改 /etc/modprobe.d/blacklist.conf 文件 sudo vim /etc/modprobe.d/blacklist.conf 在末尾加入 blacklist nouveau options nouveau modeset=0 执行以下命令，并重启 sudo update-initramfs –u 再执行以下命令，查看 nouveau 是否已被禁用，若无任何输出，说明禁用成功 lsmod | grep nouveau 官网下载驱动在英伟达的官网上查找你自己电脑的显卡型号然后下载相应的驱动。网址：http://www.nvidia.cn/page/home.html 我下载的版本：NVIDIA-Linux-x86_64-418.56.run（注意不同的版本最后安装执行的具体选项不同） 下载后的run文件拷贝至home目录下。 进入命令行界面在ubuntu下按ctrl+alt+f1进入命令行界面， 然后在命令行界面下输入： sudo service lightdm stop //这个是关闭图形界面，不执行会出错。 然后卸载掉原有驱动： sudo apt-get remove nvidia-* （若安装过其他版本或其他方式安装过驱动执行此项） 安装驱动 给驱动run文件赋予执行权限： sudo chmod a+x NVIDIA-Linux-x86_64-396.18.run 安装： sudo ./NVIDIA-Linux-x86_64-396.18.run -no-x-check -no-nouveau-check -no-opengl-files //只有禁用opengl这样安装才不会出现循环登陆的问题 -no-x-check：安装驱动时关闭X服务 -no-nouveau-check：安装驱动时禁用nouveau -no-opengl-files：只安装驱动文件，不安装OpenGL文件 安装过程中的选项：（这是copy别人的，自己的没记住，我也是尝试选择了好多遍才安装好） The distribution-provided pre-install script failed! Are you sure you want to continue? 选择 yes 继续。Would you like to register the kernel module souces with DKMS? This will allow DKMS to automatically build a new module, if you install a different kernel later? 选择 No 继续。问题没记住，选项是：install without signing问题大概是：Nvidia’s 32-bit compatibility libraries? 选择 No 继续。Would you like to run the nvidia-xconfigutility to automatically update your x configuration so that the NVIDIA x driver will be used when you restart x? Any pre-existing x confile will be backed up. 选择 Yes 继续 这些选项如果选择错误可能会导致安装失败，没关系，只要前面不出错，多尝试几次就好。 挂在驱动\测试显示驱动 挂载Nvidia驱动： modprobe nvidia 检查驱动是否安装成功： nvidia-smi 其他操作Ubuntu 16.04 安装 CUDA10.1(解决循环登陆的问题)Ubuntu16.04系统run方式安装nvidia显卡驱动 注意： 我是在 Intel 集显驱动下面进行的安装，即当前图形化界面是用 Intel 集显，准备只用NVIDIA 独显做计算，所以用 —no-opengl-libs 选项设为不安装 OpenGL 的库；之前 cuda 版本的安装好像是以命令行交互的方式让你选择是否选择安装 OpenGL，但在 cuda10.1 这个版本，只能通过添加命令行参数的方法来选择不安装 OpenGL； 若不小心安装了 OpenGL，则后面会遇到循环登陆的问题，原因就是 NVIDIA显卡 的 OpenGL 库覆盖了当前 Intel 显卡的库，解决办法是再登入到文本命令行模式，用以下命令先卸载 cuda 和 NVIDIA驱动，再按正确的步骤重新安装 sudo /usr/local/cuda-10.1/bin/cuda-uninstaller sudo /usr/bin/nvidia-uninstall 挂载驱动 挂载Nvidia驱动： modprobe nvidia 检查驱动是否安装成功： nvidia-smi 关闭图形化界面-进入文本命令行模式 文本命令行模式运行 runfile 文件安装CUDA 按 Ctrl + Alt + F1 键进入文本命令行模式，输入用户名和密码 先关闭图形化界面:sudo service lightdm stop 其它环境安装CUDAcuDNN 库文件下载拷贝Anaconda下载Anaconda安装网上有许多安装tensorflow的方法，什么源码安装、pip安装等等，折腾了半天，把自己搞晕了也没安装成功，笔者最后采用conda安装，简单方便之极！！！ 1、创建虚拟环境：（至于为什么要用虚拟环境，以后大家就明白了，它可以让我们在虚拟环境里为所欲为而不影响外部配置，现在照做就是了） conda create -n tf 2、激活虚拟环境：（就是进入到这个虚拟环境里面） source activate tf PS:如果要退出：输入 source deactivate tf 3、下面我们在虚拟环境里安装tensorflow: 激活虚拟环境后，我们开始用conda安装吧！ 1） 先确定自己要安装的tensorflow的版本是CPU的还是GPU的，如何确定呢？ 如果你还不知道GPU是啥，那你计算机里肯定没有安装cuda、cudnn 、显卡那些东西，那就安装CPU版本； 如果你之前折腾过cuda安装，那你肯定明白自己要用GPU版本的，不过前提当然是你确定你已经将cuda装好了哈哈哈，不禁笑 了，因为笔者也被cuda折磨过； 2）安装CPU版本： conda install tensorflow 3)安装GPU版本： conda install tensorflow-gpu 4)漫长的等待后，看看自己是否安装成功： 在python下导入tensorflow试试：(不报错就成功啦) import tensorflow as tf 至此，安装配置完成！如果你计算机有块不错的显卡，还是用GPU吧。 欢迎交流，谢谢指正！ Anaconda操作环境添加强烈建议默认即可，按enter继续下一步，注意这里按ctrl + c 直接会终止安装。接下来先等待安装即可。看到Thank you for installing Anaconda3! 表示安装成功。anaconda会自动将环境变量添加到PATH里面，如果后面你发现输出conda提示没有该命令，那么你需要source ~/.bashrc 这样就是更新环境变量，就可以正常使用了。如果发现这样还是没用，那么需要收到添加环境变量编辑~/.basrc 文件，在最后面加上 export PATH=/home/aeasringnar/anaconda3/bin:$PATH 保存退出后：source ~/.bashrc再次输入conda list测试看看，应该就是没有问题啦！ 然后安装会提示Do you wish to proceed with the installation of Microsoft VSCode? (是否需要安装vscode)这里根据自己的选择yes or no然后就可以享用anaconda了！ conda命令的使用写在前面，conda默认的虚拟环境目录为：~/anaconda3/envs 1、查看conda 版本 1conda --version 2、更新conda 以及 设置国内镜像 更新conda 123conda update condaconda update anacondaconda update anaconda-navigator 设置国内镜像添加源 12345# 清华源：conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --set show_channel_urls yes 查看源列表1conda config --show channels 删除镜像源12conda config --remove channels [源地址]conda config --remove-key channels 删除所有源地址 3、查看conda帮助 123conda --help# 或conda -h 4、新建虚拟环境 12conda create --name &lt;env_name&gt; &lt;package_names&gt;# eg: conda create -n python27 python=2.7 注意： 即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。 即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。 如果要安装指定的版本号，则只需要在包名后面以=和版本号的形式执行。如：conda create –name python2 python=2.7，即创建一个名为“python2”的环境，环境中安装版本为2.7的python。 如果要在新创建的环境中创建多个包，则直接在后以空格隔开，添加多个包名即可。如：conda create -n conda-test python=3.6 numpy pandas，即创建一个名为“conda-test ”的环境，环境中安装版本为3.6的python，同时也安装了numpy和pandas。 –name同样可以替换为-n。 5、切换conda环境 1source activate env_name 6、退出虚拟环境 1source deactivate 7、显示安装过的所有虚拟环境 12345conda info --envs#或conda info -e#或conda env list 8、复制环境 1conda create --name new_env_name --clone copied_env_name 注意： copied_env_name即为被复制/克隆环境名。 new_env_name即为复制之后新环境的名称。 其它：导出环境：conda env export &gt; env.yamlconda env create -n new_env -f env.yamlpip freeze &gt; requirements.txtpip install -r requirements.txt 9、删除环境 1conda remove --name env_name --all 10、包管理 精确查找包 1conda search --full-name 查找的包名 模糊查找包 1conda search 查找的内容 获取当前环境中已安装的包信息 1conda list 指定环境安装包 1conda install --name 环境名 要安装的包名 注意： 要指定版本时 1conda install --name conda-test django=2.0.6 表示在conda-test环境中安装 django并制定版本为2.0.6 在当前环境中安装包 1conda install &lt;要安装的包名&gt; 最后，如果conda安装不上的包，或者没有的包，可以使用pip安装（对应版本下载下来安装也可以） 1pip install &lt;安装的包名&gt; 指定channel安装 1conda install --channel https:... 更新安装包 123conda update packagename=x.x.x # 或者conda update packagename 移除包 1conda remove packagename]]></content>
      <categories>
        <category>ubuntu</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>即用</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python机器学习中常用类库的使用]]></title>
    <url>%2Fpost%2F7b07799b.html</url>
    <content type="text"><![CDATA[[TOC] 本文引用和使用的类库 import numpy as np import matplotlib.pyplot as plt from sklearn import datasets Jupyter Notebook’s Learning to writingToolbar 可以进行 Cell代码行的编写运行 可以切换Cell编写模式——为Markdown的模式 Help当中可以快速浏览并且更改使用的快捷键 快捷键 a/b 快速插入一行(在相应的选中行的上面或者下方) x 剪切/删除一行 m 切换为markdown模式 y 切换为coding模式 优点每次不用总是重新加载数据只需要加载一次就可以！所以方便注意：下面定义的变量，在上方也可以用！除非点击Kernel——Restart &amp; run all 以上就可以充值变量上下文。 Jupyter Notebook 高级-魔法命令12345%run #调用并且 加载对应的脚本/方法。%timeit #只能写一句话！测试 耗费时间%%timeit #测试下面耗时%time #测试一句话的cpu和人类感知的实际时间%%time #测试多行代码耗时 %run? #查看对应方法的 帮助文档lsmagic #查看当前环境下，所有的魔法命令numpy.array基础选择为什么不选择ListPython List 的特点12345678910111213141516L = [i for i in range(10)]# 像是cell 可以放置多种不同类型的元素在List中。# List十分灵活import arrayarr = array.array('i',[ i for i in range(10) ])#array模块是python中实现的一种高效的数组存储类型。它和list相似，但是所有的数组成员必须是同一种类型，在创建数组的时候，就确定了数组的类型#array.array(typecode,[initializer]) --typecode:元素类型代码；initializer:初始化器，若数组为空，则省略初始化器arr = array.array('i',[0,1,1,3])print(arr)#array('i', [0, 1, 1, 3])#array.typecode -- 对象属性print('\n 输出 用于创建数组的类型代码字符：')print(arr.typecode)# 输出 用于创建数组的类型代码字符：#i 区别List 、 array、 numpy.array Python的List不要求存储同样的类型，带来效率问题。 array的缺点是没有将数据当做向量或者矩阵，不支持基本运算。 nparr.dtype —— 只有一种类型的数据类型在nparr中！ 而且 nparr可以有 整型 和 浮点型 而且 nparr可以用来生成 矩阵和向量之类的。 使用 range 创建list列表 range(start, stop[, step]) 参数说明： start: 计数从 start 开始。默认是从 0 开始。例如range（5）等&gt;价于range（0， 5）; stop: 计数到 stop 结束，但不包括 stop。例如：range（0， &gt;5） 是[0, 1, 2, 3, 4]没有5 step：步长，默认为1。例如：range（0， 5） 等价于 range(0, &gt;5, 1) 函数方法 np.arange(0, 20, 2) [0, 20) 步长为2的 np.linspace(0, 20, 10) [0, 20] 区间中截取出10个数字 np.random.randint( 0, 10, 10/(3,5) ) [0,10)的随机10 个数字；或者 3行5列！ np.random.random( 10/(3, 5) ) 0-1之间均匀的浮点数 np.random.seed( 666 ) 给予一个伪随机数，就能对应生成确定的随机矩阵。 np.random.normal( 10, 100, (3,5)) 默认：均值为0 方差为1,的随机的浮点数。上面是均值为10、方差为100的 3行5列的矩阵！ np.random.uniform( 0., 10., size = 100 ) 产生100个 [0,100) 的浮点数 查看文档 np.random? help(np.random) 其它创建numpy.array的方法 np.zeros(10) np.ones((3,5)) np.full( (3,5), 666 ) numpy.arrary 的基本操作 X = np.arange(15).reshape((3, 5)) 15个元素 重新构成3*5的矩阵 X.ndim #2(二维数组) X.shape #(3,5) 注意: X.shape[0] == 3 X.size #15数据访问方法多维数组不建议:X[0][0]建议使用：X[0, 0]切片切片访问： x[0:5:2] 【0,5） 步长为2 NOT XX[:2, :3] #前两行的 前三列X[ :, 0] #取第一列 子矩阵 在父亲矩阵中使用的引用！所以也会改变 父亲矩阵！除非 X[:2, :3].copy() —— 来进行非引用拷贝 Reshape不改变 原来的数据、而是改变成矩阵！但是需要复制！不会 B = x.reshape(1, 10) B 注意这个有两个维度！ array([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]) x.reshape( 2, -1) 注意这里是让 x转化成两行的元素，自动化分列数 np.array的合并和分割np.concatenate() A = np.array([[1, 2, 3], [4, 5, 6]]) np.concatenate([A, A]) array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [4, 5, 6]]) np.concatenate([A, A], axis=1) array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]]) 默认为：(轴)axis=0，表示进行第一维度链接等于1 表示进行第二维度连接 np.concatenate([A, z.reshape(1, -1)]) 注意concat 只能进行相同纬度的叠加！需要把z向量转化为 矩阵！ np.vstack([A, z]) 进行A z的纵向链接， 相当于加上一行，在自己这一行后面 np.hstack([A, z]) #加上一列 进行A z的横向矩阵链接, 相当于加上一列，在自己这一行一列 后面 强制转化 数据类型x = np.array( X, dtype=float ) np.slit() x1, x2, x3 = np.split(x, [3, 7]) 切分点 0—2 3—6 7—9（x = 0—9) A1, A2 = np.split(A, [2], axis=1) 切分矩阵，默认0-第一维度-行方向 第二行切割注意：矩阵是从第0行开始的！，所以 第二行在A2中！ upper, lower = np.vsplit(A, [2]) 进行垂直方向 上下切分矩阵。 left, right = np.hsplit(A , [2]) 进行水平方向 进行左右切分 y = array([[ 3], [ 7], [11], [15]]) 为了进行4行1列的矩阵—转变为向量 y[:, 0] 抽出所有的行，只要第一列。变为：array([ 3, 7, 11, 15]) —— 向量了！ 是为了，对数据进行 预处理而进行学习使用的！ np.delete()X.shape(150,2)X_new = np.delete( X, 138, axis=0 )直接把X的第138行给删除了 numpy.array中的运算numpy直接就能 数组看做矩阵、向量进行运算！Universal Functionsnumpy 遵循这个直接运算要求而且快！ 直接 + - ×/ 浮点数出发// 证书的出发！x ** 2 幂运算x % 21 / x np.abs() np.sin() np.cos() np.tan() np.exp(x) #e的x次方 np.power(3, x) #3的x次方 np.log(x) #以e为底的 函数 np.log2(x) # 以2为底的函数 np.log10(x) #以10为底的 函数矩阵运算 A + - BAB 是指对应元素及进行运算！ 不是标准矩阵之间惩罚 A.dot(B)A和B 两矩阵进行标准的惩罚运算。 A.T矩阵转置方法。向量v和矩阵A的运算 v+A相当于: np.vstack([v] * A.shape[0]) + A np.tile(v, (2, 1))堆叠向量v， 行堆叠2次，列堆叠1次相当于上方！ v*Av.dot(A) —— 矩阵乘法！ A.dot(v) —— v会根据矩阵A进行 自动调整自己是行向量，还是列向量！ 矩阵的逆 np.linalg.inv(A) linear algebra //线性代数方阵才有 逆矩阵 pinvA = np.linalg.pinv(X) 伪 逆矩阵！可求出不是方阵的伪逆矩阵！ X.dot(pinvA) 仍然是一个 方阵. 向量的模 w1 = np.linalg.norm(w) 求出向量w的模 w / w1 对应求出 w的单位向量 矩阵的聚合操作 np.sum(L) np.min() / np.max() 等同于 array.min() np.sum( X, axis=0 ) 沿着行方向进行运算 相加，所以最终是列加和。 np.prod(X) X中进行乘积 np.mean(X) / np.median(X) 求均值 和 中位数 np.percentile( big_arrary, q=50 ) 找百分位 for percent in [0,25,50,75,100]: np.var(big_array) / np.std(big_array) 求方差/ 标准差 索引arg方式 为了查看最小值，以及最小值的位置在哪 np.argmin(x)198532 == x[198532]排序和使用索引 np.random.shuffle(x)直接进行乱序处理 np.sort(x)返回修改后的数组 x.sort()排好x的顺序 np.sort(X , axis=1)沿着列进行排序， 把每一行排好顺序了。 np.argsort(x)拍好 索引顺序的数组，通过索引，找大小。 np.partition(x, 3)标定点3， 小于3的在左边， 大于3的在右边 np.argpartition(x, 3)仍然是进行 索引的标定3将数组打乱随机排列 两种方法： np.random.shuffle(x)：在原数组上进行，改变自身序列，无返回值。 np.random.permutation(x)：不在原数组上进行，返回新的数组，不改变自身数组。 Fancy Indexing x[3:9:2] 2为步长 进行索引 ind = [3, 5 ,8] x[ind] 对应进行索引！ ind = np.array([[0, 2], [1, 3]]) x[ind] 对应进行索引，根据ind索引，建立 新的x矩阵。 col = np.array([1, 2, 3]) x[:2, col] x中前两行的第0行 和 第1行， 1 2 3列 col = [True, False, True, False] x[ 1:3, col] numpy.array的比较 example_digits = noisy_digits[y==0,:][:10] 只要对应前十行 x &gt; 3 返回bool值 np.sum(x&lt;=3) //统计x中 小于等于3的个数。 np.count_nonzero(x&lt;=3) np.any(x==0) //true 有就行 np.all(x&gt;=0) //true np.sum( x%2==0 ) np.sum(x%2==0, axis=1) np.all( x &gt; 0, axis=1 ) np.sum( (x&gt;3) &amp; (x&lt;10) ) np.sum( (x%2==0) | (x &gt; 10) ) np.sum( ~(x==0) ) x[x[:,3]%3==0, :] 最后一列被三整除为 0，3个True——转化为第0行和第3行 Pandas Pandas进行预处理——然后转化为 numpy——再把numpy加入到 sklearn之中进行处理、操作！ 以上！numpy进行机器学习矩阵进行处理的方法，完成。因为 sklearn是需要numpy的数据进行操作的，然而Pandas方便进行处理，所以 需要进行这样的过度。 matplotlib 基础 import matplotlib as mpl import matplotlib.pyplot as pltplt.plot绘制直线图 plt.plot(x, y, color=”red”, linestyle=”—“, label=”cos(x)” ) 应该再加上： plt.legend() 用来显示对应曲线的图例 plt.show() linestyle 绘制出来 : -, — -不同的图像形式。 plt.xlim(-5, 15) plt.ylim(0, 1) 更改 x，y轴的范围. plt.axis([-1 ,11 ,-2 ,2]) plt.xlabel(“”x value)/ pltylabel(“y value”) plt.title(“添加对应标题.”)plt.scatter 绘制散点图 plot.scatter(x, siny, alpha=0.5) 通常绘制二维特征/两个特征的时候 用散点图。不透明度—— 0完全透明，1完全不透明。 plt.scatter(X[y==0,0], X[y==0,1], color=”red”, marker=”o”)plt.scatter(X[y==1,0], X[y==1,1], color=”blue”, marker=”+”)plt.scatter(X[y==2,0], X[y==2,1], color=”green”, marker=”x”)plt.show() 高斯核函数讲解123456789l1, l2 = -1, 1X_new = np.empty((len(x), 2))# 将一维数据 映射到二维上面了，利用 高斯核函数.for i, data in enumerate(x): X_new[i, 0] = gaussian(data, l1) X_new[i, 1] = gaussian(data, l2)# enumerate( x ) 讲x的数值放入到data中，索引放入到i中. 关键学会 enumerate的使用。 读取数据和简单的数据探索 from sklearn import datasets iris = datasets.load_iris() # 鸢尾花数据集 iris.keys() iris.data #相对应的数据 iris.target #相对应的种类123456y = iris.targetplt.scatter(X[y==0,0], X[y==0,1], color="red") #找出鸢尾花对应的种类所在行，#然后显示 这一行的，0\1两个特征～ OK～plt.scatter(X[y==1,0], X[y==1,1], color="blue")plt.scatter(X[y==2,0], X[y==2,1], color="green")plt.show() 数据处理代码操作注意事项 使用copy（）数值y = digits.targety = digits.target.copy() # 这样写作为一个拷贝才正确 使用try excepttry: return 2 precision recall / (precision + recall) except: return 0.0]]></content>
      <categories>
        <category>Python</category>
        <category>library</category>
        <category>MachineLearning</category>
      </categories>
      <tags>
        <tag>即用</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scikit-learn在机器学习算法中的代码使用]]></title>
    <url>%2Fpost%2F24123a35.html</url>
    <content type="text"><![CDATA[简单线性回归的实现zip()12345678910111213&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) # 打包为元组的列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(a,c) # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; a1, a2 = zip(*zipped) # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6] 划分数据样本1234567891011121314151617181920212223def train_test_split(X, y, test_ratio=0.2, seed=None): """将数据 X 和 y 按照test_ratio分割成X_train, X_test, y_train, y_test""" assert X.shape[0] == y.shape[0], \ "the size of X must be equal to the size of y" assert 0.0 &lt;= test_ratio &lt;= 1.0, \ "test_ration must be valid" if seed: np.random.seed(seed) shuffled_indexes = np.random.permutation(len(X)) test_size = int(len(X) * test_ratio) test_indexes = shuffled_indexes[:test_size] train_indexes = shuffled_indexes[test_size:] X_train = X[train_indexes] y_train = y[train_indexes] X_test = X[test_indexes] y_test = y[test_indexes] return X_train, X_test, y_train, y_test 根据 test_ratio划分样本为80% 20%…… scikit-learn中的MSE和MAE 12345from sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_absolute_error mean_squared_error(y_test, y_predict)mean_absolute_error(y_test, y_predict) metrics 衡量指标 scikit-learn当中的 SGD1234567# 此处SGDRegressor只能用于 线性模型！from sklearn.linear_model import SGDRegressorsgd_reg = SGDRegressor(n_iter=100) #n_iter是 默认为5！%time sgd_reg.fit(X_train_standard, y_train)sgd_reg.score(X_test_standard, y_test) kNN计算技巧Counter1234567891011121314topK_y = [y_train[neighbor] for neighbor in nearest[:k]]topK_y # 距离x最近的k个点的 类别y&gt;[1, 1, 1, 1, 1, 0]from collections import Countervotes = Counter(topK_y)&gt;Counter(&#123;0: 1, 1: 5&#125;)votes.most_common(1) # 找出票数最多的1个元素！ ‘1’&gt;[(1, 5)]predict_y = votes.most_common(1)[0][0]predict_y # 最终预测的y的数值！ 相关难点12345np.argsort(distances) # 数值排序 返回对应的索引，找最近的k个点from collections import Countervotes = Counter(topK_y)&gt;Counter(&#123;0: 1, 1: 5&#125;) 模仿scikit-learn对于 kNN的封装123456789101112class KNNClassifier: def __init__(self, k): # 相当于 构造函数 """初始化kNN分类器""" assert k &gt;= 1, "k must be valid" self.k = k self._X_train = None # 添加下划线，表示为私有变量 self._y_train = None# 断言 多维度kNN算法》 必须有： 预测值和 训练值的特征个数必须相同！ assert X_predict.shape[1] == self._X_train.shape[1], \ "the feature number of X_predict must be equal to X_train" 训练数据和 测试数据12345678910111213141516#train_test_split#分离出一部分数据做训练，另外一部分数据做测试。shuffled_indexes = np.random.permutation(len(X)) # X个数个 索引的随机排列test_ratio = 0.2test_size = int(len(X) * test_ratio)# 获得测试 和 训练数据集的索引下表————再使用 Fancy Indexing进行索引输出.test_indexes = shuffled_indexes[:test_size]train_indexes = shuffled_indexes[test_size:]X_train = X[train_indexes]y_train = y[train_indexes]X_test = X[test_indexes]y_test = y[test_indexes] kNN准确度-模型选择 与 超参数 超参数：在算法运行前需要决定的参数 模型参数：算法过程中学习的参数 注意：kNN没有模型参数，但是k是典型的超参数. 寻找好的超参数领域知识： 在领域库添加（此处不用） 经验数值： k=5则是经验知识 实验搜索： 不断实验，搜索最好的 找到10之后， 还是可以在8-20之中继续查找。 k近邻算法增加 距离权重参数！（不仅仅通过 最近距离的投票方法。） 距离 欧拉距离 曼哈顿距离 明可夫斯基距离 最终KNeighborsClassifier 的超参数有：k, p, weights —— 两个两个的进行网格搜索，实验寻找最好的超参数。 网格搜索 和 更多kNN中的超参数Grid Searchsklearn中使用方法 from sklearn import datasets from sklearn.model_slection import train_test_split from sklearn.neighbors import KNeighborsClassifier sk_knn_clf = KNeighborsClassfier( n_neighbors = 3, weights=”uniform/distance”, p=1 )GridSearchCV—— 交叉验证 from sklearn.model_selection import GridSearchCV grid_search = GridSearchCV( knn_clf, param_grid， n_jobs=-1, verbose = 2 ) n_jobs自动进行核分配verbose = 2 整数值越大，输出的数值 越详细。 grid_search.fit(X_train, y_train) grid_saerch.best_estimator_ #返回一个最佳的knn_clf() 对象！ grid_search.best_score_ grid_saerch.best_params_ 更多的超参数 KNeighborsClassifier 还有一个 metrics参数 对应： identifier class name args distance function “euclidean” EuclideanDistance sqrt(sum((x - y)^2)) “manhattan” ManhattanDistance sum(\ x - y\ ) “chebyshev” ChebyshevDistance max(\ x - y\ ) “minkowski” MinkowskiDistance p sum(\ x - y\ ^p)^(1/p) “wminkowski” WMinkowskiDistance p, w sum(\ w * (x - y)\ ^p)^(1/p) “seuclidean” SEuclideanDistance V sqrt(sum((x - y)^2 / V)) “mahalanobis” MahalanobisDistance V or VI sqrt((x - y)’ V^-1 (x - y)) 数据归一化 如果不进行相应变量的参数归一化，很容易被 对应变量的大小进行主导x: 1 5y: 200 100 这样就被y主导，不能反应每一个变量的特征 sklearn使用 数据归一化 from sklearn.preprocessing import StandardScaler123456789101112standardScalar = StandardScaler()standardScalar.fit( X_train ) # 获得自己的均值和方差standardScalar.mean_#standardScalar.std_standardScalar.scale_#更换为 描述数据统计分布范围#X_train/X_test 进行数据归一化处理standardScalar.transform( X_train )X_train = standardScalar.transform( X_train ) #这个样才行X_test_standard = standardScalar.transform( X_test ) 内部Scalar的 自我实现1234567891011121314151617def fit( self,X ): assert X.ndim == 2, "The dimension of X must be 2" #此处只是进行二维的 矩阵进行求解！ # 对每一列进行均值求解 self.mean_ = np.array([ np.mean( X[:,i] for i in range( X.shape[1] ) ) ]) self.scale_ = np.array( [np.std( X[:,i] for i in range( X.shape[1] ) )] ) return self# 特别注意 每一列加上 `range()` 而且需要每一列进行计算。def transform(self,X ): assert X.shape[1] == len( self.mean_ ),\ "the feature number of X must be eqial to mean_ and std_" restX = np.empty( shape=X.shape, dtype=float ) fof col in range( X.shape[1] ): restX[:, col] = ( X[:,col] - self.mean_[col] ) / self.scale_[col] return restX 同样也可以进行 MinMaxScalar的importimport sklearn.preprocessing import StandardScaler scikit-learn中的 PCAfrom sklearn.decomposition import PCA1234567pca = PCA(n_components=1)pca.fit(X)pca.components_ # 因为scikit learn中用的不是梯度上升法进行的求解，因此方向相反 不需要在意。X_reduction = pca.transform(X)X_restore = pca.inverse_transform(X_reduction) PCA当中 我们应该，设置降维到多少 维度呢？ pca.explained_variance_ratio_ pca当中 每一个维度，占方差 贡献的重要程度—— 根据重要程度 进行分类！ 通过绘制 折线图，查看前多少维度 贡献多少。123plt.plot([i for i in range(X_train.shape[1])], [np.sum(pca.explained_variance_ratio_[:i+1]) for i in range(X_train.shape[1])])plt.show() scikit-learn 已经给我们封装1234567891011121314pca = PCA(0.95) # n_components 不用传，直接传输贡献率pca.fit(X_train)X_train_reduction = pca.transform(X_train)X_test_reduction = pca.transform(X_test)%%time knn_clf = KNeighborsClassifier()knn_clf.fit(X_train_reduction, y_train)knn_clf.score(X_test_reduction, y_test)# 降低到28维 看可； 权衡 是否想要 为了加快时间，而牺牲精度的方法# 降低到2维， 方便进行图形的查看 降低到28维 看可； 权衡 是否想要 为了加快时间，而牺牲精度的方法降低到2维， 方便进行图形的查看 MNIST数据集 进行更大量、更正规的 机器学习的方法应用 使用PCA进行降维 训练时间和预测时间都减少了 而且有可能因为 降维去除了噪音，有可能准确率更高了！ PCA降噪 平常有可能数据有噪音抖动，还有可能 测量过程中有了噪音。 作用：降低纬度 丢失信息 去除了噪音 sklearn中的数据 预处理方法 数据处理中一般处理方法： 数据加载和预处理为标准的数组数据/方便进行获取和数组建立操作 进行训练样本和测试样本的划分 进行训练和测试 样本的数据归一化操作 根据不同的 分类/回归任务，选用不同的方法 进行数据的再处理和加工 多项式回归进行升维度 knn可以直接进行 k近邻分类 数据集划分12from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.2, random_state=666) 数据尺度 归一化12345from sklearn.preprocessing import StandardScaler standardScalar = StandardScaler() standardScalar.fit(X_train)standardScalar.transform(X_train) 多项式回归（8-212345678910111213141516from sklearn.preprocessing import PolynomialFeaturespoly = PolynomialFeatures(degree=2) #最多添加二次方poly.fit(X)X2 = poly.transform(X)# 多项式回归 化为 线性回归进行测试from sklearn.linear_model import LinearRegressionlin_reg2 = LinearRegression()lin_reg2.fit(X2, y)y_predict2 = lin_reg2.predict(X2)plt.scatter(x, y)plt.plot(np.sort(x), y_predict2[np.argsort(x)], color='r')plt.show() 进行数据的升维，多项式回归的预处理方法 多项式特征 数据归一化 线性回归使用 Pipeline123456789101112131415161718192021x = np.random.uniform(-3, 3, size=100)X = x.reshape(-1, 1)y = 0.5 * x**2 + x + 2 + np.random.normal(0, 1, 100)from sklearn.pipeline import Pipelinefrom sklearn.preprocessing import StandardScalerfrom sklearn.linear_model import LinearRegressionpoly_reg = Pipeline([ ("poly", PolynomialFeatures(degree=2)), ("std_scaler", StandardScaler()), ("lin_reg", LinearRegression())])poly_reg.fit(X, y)y_predict = poly_reg.predict(X)plt.scatter(x, y)plt.plot(np.sort(x), y_predict[np.argsort(x)], color='r')plt.show() new一个管道，传入相应的数据集； 数据集就能沿着管道依次进行 执行。得到最后的结果！虽然 sklearn没有给我们封装 多项式回归方法，但是我们可以用Pipeline进行 多种方法封装，并进行操作。 评价标准 均方误差:1234from sklearn.metrics import mean_squared_errory_predict = lin_reg.predict(X)mean_squared_error(y, y_predict) 岭回归123456789101112131415# 使用岭回归 不再是线性回归了.from sklearn.linear_model import Ridgedef RidgeRegression(degree, alpha): return Pipeline([ ("poly", PolynomialFeatures(degree=degree)), ("std_scaler", StandardScaler()), ("ridge_reg", Ridge(alpha=alpha)) ])ridge1_reg = RidgeRegression(20, 0.0001) # 因为theta很大，所以设置小店开始实验ridge1_reg.fit(X_train, y_train)y1_predict = ridge1_reg.predict(X_test)mean_squared_error(y_test, y1_predict) # 原理：过拟合是的theta太大了，现在就是限制theta大小 由于上面的 alpha占比重小，所以 不太会考虑theta对于损失函数的影响，造成了 theta过大的问题。 12# More:ridge4_reg = RidgeRegression(20, 10000000)# 越大表明损失函数，对于theta大小所占比重考虑越多！所以越平滑。 LASSO回归12345678from sklearn.linear_model import Lassodef LassoRegression(degree, alpha): return Pipeline([ ("poly", PolynomialFeatures(degree=degree)), ("std_scaler", StandardScaler()), ("lasso_reg", Lasso(alpha=alpha)) ]) train_test_split 改进——使用交叉验证进行 模型构建使用三叠交叉验证( Cross Validation )12345678910111213141516171819202122232425262728from sklearn.model_selection import cross_val_scoreknn_clf = KNeighborsClassifier()cross_val_score(knn_clf, X_train, y_train, cv=2)# array([ 0.98895028, 0.97777778, 0.96629213])best_k, best_p, best_score = 0, 0, 0for k in range(2, 11): for p in range(1, 6): knn_clf = KNeighborsClassifier(weights="distance", n_neighbors=k, p=p) # 注意这里两行进行了修改 scores = cross_val_score(knn_clf, X_train, y_train) score = np.mean(scores) if score &gt; best_score: best_k, best_p, best_score = k, p, score print("Best K =", best_k)print("Best P =", best_p)print("Best Score =", best_score)#Best K = 2#Best P = 2#Best Score = 0.982359987401best_knn_clf = KNeighborsClassifier(weights="distance", n_neighbors=2, p=2)best_knn_clf.fit(X_train, y_train)best_knn_clf.score(X_test, y_test)# 最后再使用 测试数据集 进行最终模型性能的衡量标准。# 0.98052851182197498 使用网格搜索——进行相应的 超参数的寻找123456789101112from sklearn.model_selection import GridSearchCVparam_grid = [ &#123; 'weights': ['distance'], 'n_neighbors': [i for i in range(2, 11)], 'p': [i for i in range(1, 6)] &#125;]grid_search = GridSearchCV(knn_clf, param_grid, verbose=1)grid_search.fit(X_train, y_train) 逻辑回归算法（Logistic Regression） 逻辑回归实际是分类问题讲样本的特征和样本发生的概率联系起来，概率是一个数。又称为回归问题。 性能度量 泛化能力度量123456789101112131415161718192021222324252627282930313233343536373839# ./metricsimport numpy as npfrom math import sqrt# 进行分类准确度度量def accuracy_score(y_true, y_predict): """计算y_true和y_predict之间的准确率""" assert len(y_true) == len(y_predict), \ "the size of y_true must be equal to the size of y_predict" return np.sum(y_true == y_predict) / len(y_true)def mean_squared_error(y_true, y_predict): """计算y_true和y_predict之间的MSE""" assert len(y_true) == len(y_predict), \ "the size of y_true must be equal to the size of y_predict" return np.sum((y_true - y_predict)**2) / len(y_true)def root_mean_squared_error(y_true, y_predict): """计算y_true和y_predict之间的RMSE""" return sqrt(mean_squared_error(y_true, y_predict))def mean_absolute_error(y_true, y_predict): """计算y_true和y_predict之间的MAE""" assert len(y_true) == len(y_predict), \ "the size of y_true must be equal to the size of y_predict" return np.sum(np.absolute(y_true - y_predict)) / len(y_true)# 回归算法中，统一准确率 进行算法性能评估def r2_score(y_true, y_predict): """计算y_true和y_predict之间的R Square""" return 1 - mean_squared_error(y_true, y_predict)/np.var(y_true) 逻辑回归，添加多项式 和 模型正则化123456789def PolynomialLogisticRegression(degree, C, penalty='l2'): return Pipeline([ ('poly', PolynomialFeatures(degree=degree)), ('std_scaler', StandardScaler()), ('log_reg', LogisticRegression(C=C, penalty=penalty)) ])poly_log_reg4 = PolynomialLogisticRegression(degree=20, C=0.1, penalty='l1')poly_log_reg4.fit(X_train, y_train) 逻辑回归当中进行 多分类操作1234567891011# OvR 多分类手段方法# 默认是 ovr，即：默认scikitlearn 逻辑回归可以进行多分类问题。log_reg = LogisticRegression(multi_class="ovr", solver="liblinear")log_reg.fit(X_train, y_train)log_reg.score(X_test, y_test)# OvO 多分类手段方法log_reg2 = LogisticRegression(multi_class="multinomial", solver="newton-cg")log_reg2.fit(X_train, y_train)log_reg2.score(X_test, y_test) sklearn 封装了OVR和OVO123456from sklearn.multiclass import OneVsRestClassifier#from sklearn.multiclass import OneVsOneClassifierovr = OneVsRestClassifier(log_reg)ovr.fit(X_train, y_train)ovr.score(X_test, y_test) 以上可以传入所有的 二分类器进行，多分类 任务！～ 分类中的评价方法混淆矩阵混淆矩阵相关的实现123456789101112131415def TP(y_true, y_predict): assert len(y_true) == len(y_predict) return np.sum((y_true == 1) &amp; (y_predict == 1))TP(y_test, y_log_predict)def precision_score(y_true, y_predict): tp = TP(y_true, y_predict) fp = FP(y_true, y_predict) try: return tp / (tp + fp) except: return 0.0 precision_score(y_test, y_log_predict) 混淆矩阵 scikit-learn中的实现1234567891011# 混淆矩阵from sklearn.metrics import confusion_matrixconfusion_matrix(y_test, y_log_predict)# 精准率from sklearn.metrics import precision_scoreprecision_score(y_test, y_log_predict)# 召回率from sklearn.metrics import recall_scorerecall_score(y_test, y_log_predict) 混淆矩阵中的比较——学习器性能的好坏分类评价方法在F1-score中的实现应用方法123456789from sklearn.metrics import confusion_matrixfrom sklearn.metrics import precision_scoreprecision_score( y_test, y_predict )from sklearn.metrics import recall_score recall_score( y_test, y_predict) from sklearn.metrics import f1_scoref1_score( y_test, y_predict )# 全都是分别：第一个 y_treu；第二个 y_predict 更改阈值12345decision_scores = log_reg.decision_function(X_test)y_predict_2 = np.array(decision_scores &gt;= 5, dtype='int')confusion_matrix(y_test, y_predict_2)precision_score(y_test, y_predict_2) recall_score(y_test, y_predict_2) Precision-Recall 曲线 绘制12345from sklearn.metrics import precision_recall_curveprecisions, recalls, thresholds = precision_recall_curve(y_test, decision_scores)# 注意，p r最终数值为0&amp;1 ，对应thresholds没有数值；即 thresholds少一个数值。 ROC曲线绘制123456from sklearn.metrics import roc_curvefprs, tprs, thresholds = roc_curve(y_test, decision_scores)from sklearn.metrics import roc_auc_scoreroc_auc_score(y_test, decision_scores) 注意对于 有偏的数据还是应该使用p-r对应查看；roc_auc_score对应用来查看 比较算法/超参数使用对于分类算法好坏孰优孰劣！ 多分类问题 在scikit-learn中的应用1234567891011121314151617from sklearn.metrics import precision_scoreprecision_score(y_test, y_predict, average="micro")from sklearn.metrics import confusion_matrixconfusion_matrix(y_test, y_predict)# 绘制错误矩阵图像（灰度值进行显示）cfm = confusion_matrix(y_test, y_predict)row_sums = np.sum(cfm, axis=1)err_matrix = cfm / row_sumsnp.fill_diagonal(err_matrix, 0)plt.matshow(err_matrix, cmap=plt.cm.gray)plt.show()# 相应进行 1-8 1-9犯错误更多，改进1-8 1-9进行阈值更改的改进！# 真实环境中，有可能 是样本错误 或 算法细节问题：上一行问题。 MORE：TensorFlow初接触TensorFlow数据流图和概念解析 怎样与开发者建立联系。 未来重复类型的工作都会交给人工智能进行操作。人类主要从事偏创造类和情感类的 工作。 支撑向量机硬间隔SVM 与kNN类似都现需要进行 数据归一化1234567891011121314151617from sklearn.preprocessing import StandardScalerstandardScaler = StandardScaler()standardScaler.fit(X)X_standard = standardScaler.transform(X)from sklearn.svm import LinearSVCsvc = LinearSVC(C=1e9)svc.fit(X_standard, y)# support vector classifierfrom sklearn.svm import LinearSVCsvc = LinearSVC(C=1e9)svc.fit(X_standard, y) 注意：上方引入的只是线性SVM进行分类的svm算法注意 ：svc.coef_ 和 svc.intercept_ 对应 w0 * x0 + w1 * x1 + b = 0 软间隔SVM并 绘制超平面123456789101112131415w = model.coef_[0]b = model.intercept_[0]# w0*x0 + w1*x1 + b = 0# =&gt; x1 = -w0/w1 * x0 - b/w1plot_x = np.linspace(axis[0], axis[1], 200)up_y = -w[0]/w[1] * plot_x - b/w[1] + 1/w[1]down_y = -w[0]/w[1] * plot_x - b/w[1] - 1/w[1]# 利用这个布尔数组 进行上面数组的筛选.up_index = (up_y &gt;= axis[2]) &amp; (up_y &lt;= axis[3])down_index = (down_y &gt;= axis[2]) &amp; (down_y &lt;= axis[3])plt.plot(plot_x[up_index], up_y[up_index], color='black')plt.plot(plot_x[down_index], down_y[down_index], color='black') 处理高度非线性特征分类-使用svm方法使用多项式特征的SVM12345678910111213from sklearn.preprocessing import PolynomialFeatures, StandardScalerfrom sklearn.svm import LinearSVCfrom sklearn.pipeline import Pipelinedef PolynomialSVC(degree, C=1.0): return Pipeline([ ("poly", PolynomialFeatures(degree=degree)), ("std_scaler", StandardScaler()), ("linearSVC", LinearSVC(C=C)) ])poly_svc = PolynomialSVC(degree=3)poly_svc.fit(X, y) # 不进行实际预测，所以不 “train_test_split"了！ 使用多项式核函数的SVM 注意： SVM算法本身也是 带有多项式化方法的——核函数123456789101112from sklearn.svm import SVCdef PolynomialKernelSVC(degree, C=1.0): return Pipeline([ ("std_scaler", StandardScaler()), ("kernelSVC", SVC(kernel="poly", degree=degree, C=C)) ])poly_kernel_svc = PolynomialKernelSVC(degree=3)poly_kernel_svc.fit(X, y)# 然后进行图像化展示，并不是为了进行预测！ 高斯核函数讲解123456789l1, l2 = -1, 1X_new = np.empty((len(x), 2))# 将一维数据 映射到二维上面了，利用 高斯核函数.for i, data in enumerate(x): X_new[i, 0] = gaussian(data, l1) X_new[i, 1] = gaussian(data, l2)# enumerate( x ) 讲x的数值放入到data中，索引放入到i中. 使用高斯核函数（RBF）的sklearn方法&gt; 123456789101112from sklearn.preprocessing import StandardScalerfrom sklearn.pipeline import Pipelinefrom sklearn.svm import SVCdef RBFKernelSVC(gamma): return Pipeline([ ("std_scaler", StandardScaler()), ("svc", SVC(ke rnel="rbf", gamma=gamma)) ])svc = RBFKernelSVC(gamma=1)svc.fit(X, y) SVM思想解决回归问题12345678910from sklearn.svm import LinearSVRfrom sklearn.svm import SVRfrom sklearn.preprocessing import StandardScalerfrom sklearn.pipeline import Pipelinedef StandardLinearSVR(epsilon=0.1): return Pipeline([ ('std_scaler', StandardScaler()), ('linearSVR', LinearSVR(epsilon=epsilon)) ]) 注意：SVR之于 前面的SVC相应的用法相似，但是参数不同. 决策树 在sklearn中的使用决策树使用1234from sklearn.tree import DecisionTreeClassifierdt_clf = DecisionTreeClassifier(max_depth=2, criterion="entropy", random_state=42)dt_clf.fit(X, y) 决策树其他参数12345678910111213141516# 决策树中 至少需要多少个样本数据才能继续 拆分下去dt_clf3 = DecisionTreeClassifier(min_samples_split=10)dt_clf3.fit(X, y)# 越高越不容易过拟合# 越小越容易过拟合——拆分的很小——所以过拟合# 对于叶子结点 至少要有几个样本dt_clf4 = DecisionTreeClassifier(min_samples_leaf=6)dt_clf4.fit(X, y)# 决策树最大叶子结点个数dt_clf5 = DecisionTreeClassifier(max_leaf_nodes=4)dt_clf5.fit(X,y)# 叶子节点个数越多——越复杂 越容易过拟合 min_samples_split min_samples_leaf min_weight_fraction_leaf max_depth max_leaf_nodes min_features 更多scikit-learn决策树的参数和详细解释，相请参照这里. 决策树解决回归问题叶子节点包含相应的数据，如果包含的是类别的话。 参数都一样，区别在于 叶子结点是分类结果、还是回归结果？12345678910111213from sklearn.tree import DecisionTreeRegressordt_reg = DecisionTreeRegressor()dt_reg.fit(X_train, y_train)dt_reg.score(X_test, y_test)## 0.58605479243964098# 显然过拟合了！加入了自己本身的特征！# 回归算法决策树很容易过拟合dt_reg.score(X_train, y_train)## 1.0 集成学习进行多方面算法集成kNN逻辑回归SVM决策树神经网络贝叶斯 最后进行投票，少数服从多数VotingClassifier 集成学习-投票集成使用：12345678910111213from sklearn.ensemble import VotingClassifier# 投票分类（参数为分类器）；voting='hard' —— 少数服从多数voting_clf = VotingClassifier(estimators=[ ('log_clf', LogisticRegression()), ('svm_clf', SVC()), ('dt_clf', DecisionTreeClassifier(random_state=666))], voting='hard') # 可以在 把每个算法调节到最优之后，再进行集成！voting_clf.fit(X_train, y_train)voting_clf.score(X_test, y_test) soft-classifier 更合理的投票，应该有权值—— 专家的话语应该权重更大！12345678910voting_clf2 = VotingClassifier(estimators=[ ('log_clf', LogisticRegression()), ('svm_clf', SVC(probability=True)), ('dt_clf', DecisionTreeClassifier(random_state=666))], voting='soft')# 使用soft voting classifier必须要求集合中每个模型都能估计概率！voting_clf2.fit(X_train, y_train)voting_clf2.score(X_test, y_test) 入门完成 如何集成更多分类器，给我们更好地表现呢？虽然有很多机器学习方法，但是从投票角度看，仍然不够多我们需要创建更多的子模型！集成更多的子模型子模型之间不能一致！子模型之间要有差异性！ 创建差异性——没格子模型只看样本数据的一部分。可以每个子模型只看100个样本数据！每个子模型不需要太高的准确率（但是也不能太低！） 12345678910111213from sklearn.tree import DecisionTreeClassifierfrom sklearn.ensemble import BaggingClassifier# n_estimators 几个样本模型# max_samples 每个模型要看几个样本# bootstrap=True 放回取样bagging_clf2 = BaggingClassifier(DecisionTreeClassifier(), n_estimators=5000, max_samples=100, bootstrap=True)bagging_clf2.fit(X_train, y_train)bagging_clf2.score(X_test, y_test)# 训练使用对应参数进行 不放回取样和模型管理 OOB（OUT-of-bag） 使用那些为渠道的样本做测试和验证 12345678910111213from sklearn.tree import DecisionTreeClassifierfrom sklearn.ensemble import BaggingClassifierbagging_clf = BaggingClassifier(DecisionTreeClassifier(), n_estimators=500, max_samples=100, bootstrap=True, oob_score=True)bagging_clf.fit(X, y)bagging_clf.oob_score_ # 通过OOB使用计算出来—— 泛化能力、准确度的结果# 讲OOB当做了 测试训练集## 0.91800000000000004 由此看出 Bagging思路非常容易进行并行化处理的方法 增加参数—— n_jobs 使用多个核进行处理12345678910111213141516random_subspaces_clf = BaggingClassifier(DecisionTreeClassifier(), n_estimators=500, max_samples=500, bootstrap=True, oob_score=True, max_features=1, bootstrap_features=True)random_subspaces_clf.fit(X, y)random_subspaces_clf.oob_score_# 随机特征取样random_patches_clf = BaggingClassifier(DecisionTreeClassifier(), n_estimators=500, max_samples=100, bootstrap=True, oob_score=True, max_features=1, bootstrap_features=True)random_patches_clf.fit(X, y)random_patches_clf.oob_score_#随机特征+随机样本取样 随机森林 由多个树组成的森林叫做随机森林 简单使用12345678910111213from sklearn.ensemble import RandomForestClassifier# 也是使用Bagging进行随机取样的，所以可以有 决策树类似分类器rf_clf = RandomForestClassifier(n_estimators=500, oob_score=True, random_state=666, n_jobs=-1)rf_clf.fit(X, y)rf_clf.oob_score_## 0.89200000000000002rf_clf2 = RandomForestClassifier(n_estimators=500, max_leaf_nodes=16, oob_score=True, random_state=666, n_jobs=-1)rf_clf2.fit(X, y)rf_clf2.oob_score_## 0.90600000000000003 注意在sklearn中的使用，RF相当于是 结合了BaggingClassifier和 DecisionTreeClassifier 参数使用！都有用到！ MORE 使用ExtraTree进行 分类123456from sklearn.ensemble import ExtraTreesClassifieret_clf = ExtraTreesClassifier(n_estimators=500, bootstrap=True, oob_score=True, random_state=666, n_jobs=-1)et_clf.fit(X, y)et_clf.oob_score_ 分类相应的对应有 回归方法——Regressor123from sklearn.ensemble import BaggingRegressorfrom sklearn.ensemble import RandomForestRegressorfrom sklearn.ensemble import ExtraTreesRegressor BoostingAda Boosting 每次一步步赋予权重进行修正12345678from sklearn.tree import DecisionTreeClassifierfrom sklearn.ensemble import AdaBoostClassifier# 关键是学习算法（基学习器） 和 一步步赋予权重ada_clf = AdaBoostClassifier( DecisionTreeClassifier(max_depth=2), n_estimators=500)ada_clf.fit(X_train, y_train) Gradient Boosting&gt;123456from sklearn.ensemble import GradientBoostingClassifiergb_clf = GradientBoostingClassifier(max_depth=2, n_estimators=30)gb_clf.fit(X_train, y_train)gb_clf.score(X_test, y_test) Boosting解决回归问题12from sklearn.ensemble import AdaBoostRegressorfrom sklearn.ensemble import GradientBoostingRegressor]]></content>
      <categories>
        <category>Python</category>
        <category>scikit-learn</category>
        <category>MachineLearning</category>
      </categories>
      <tags>
        <tag>即用</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决hexo多台电脑之间同步访问和百度无法索引hexo博客的问题]]></title>
    <url>%2Fpost%2F7caa71b9.html</url>
    <content type="text"><![CDATA[声明本文重点讲解如何进行hexo多台电脑之间同步访问问题；带过一下利用coding.net网站进行百度SEO优化问题；其他一些操作错误的小细节请自行百度或者与我联系。感恩。 场景进入研究生生活之后，需要在A实验室（或者工作单位）之中进行博客的日常码字和管理；然而有时候回到B宿舍（或者家里）之后又想更新blog。然而囿于hexo静态博客，无法像wp那样进行后台的管理和编写，只能在本地进行同步和上传，无奈想起使用协同代码管理服务————git. 选择前一阵和小伙伴们做比赛的时候，由于暂时需要进行代码的保密工作，所以选择了码云进行代码托管和协同工作。github被微软收购之后，在今年1月份突然宣布了要将私有代码托管服务转变为免费的项目！（本来在收购之前 博主还特意备份了一下github的代码…… ：）于是乎今天使用github来进行hexo原始文件的同步处理操作。 关于百度无法索引hexo博客需要ssh连接coding网站，并且在 hexo—_config.xml当中的 deploy一项中添加相关hexo d之后的代码。因为coding也是支持进行hexo静态博客的建立的，同样和github一样，只能建立一个相关的博客。（不愿意用码云 也是考虑到，这样一下子就要运用到 三个 代码托管平台啦！） 上传blog到git这个操作建议在blog进度最新的PC上进行的，否则后面解决冲突会比较麻烦在github上添加公钥，repository建立新等过程略过不讲。 删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件 有些插件或者主题是git上下过来安装的话，每个文件夹下都会有对应的.git 文件夹，记得先删掉，否则会和blog仓库冲突（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。##.git文件夹被删除后整个文件对应的git仓库状态也会被清空##) .gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：123/.deploy_git/public /_config.yml .deploy_git是hexo默认的.git配置文件夹，不需要同步 public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多 即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去 初始化仓库blog 根目录下执行以下代码： 12git initgit remote add origin &apos;server&apos; 注意： server 指的是 git版本的不是 https版本的。（此处没有单引号） origin是指本地分支， remote add操作会将本地仓库映射到云端。 添加本地文件到仓库并同步到git上123git add . #添加blog目录下所有文件，注意有个`.`（`.gitignore`声明过的文件不包含在内)git commit -m &quot;first commit&quot; #添加更新说明git push -u origin master #推送更新到云端服务器 在执行这步之前一定要注意检查下.gitignore文件的内容，看看是否正确的把一些文件夹忽略掉了。如果加错了的话可以用 git rm -r —cached . 撤销添加操作。 以上 云端备份工作已经完成。 将git的内容同步到本地 假设之前将A电脑里的内容备份到git了，现在B电脑准备同步内容。1234567891011git initgit remote add origin &lt;server&gt; #将本地文件和云端仓库映射起来。这步不可以跳过git fetch --allgit reset --hard origin/master``` ## 更新文章后的同步操作假设在B电脑上写完了文章，也`hexo d -g`发布完了，这时候需要将新文章的md文件更新上去。（其实就是提交更新给git，会的可以无视了）同一个bash界面下：```git git add . 这时候可以用git status查看状态，一般会显示刚刚更改过的文件状态。如：12345On branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: db.json new file: source/_posts/test.md 上面的输出状态即说明’db.json’文件做了更改，source/_posts目录下新增了’test.md’文件。 然后对更改添加说明并推送到远程仓库.12git commit -m &apos;更新信息&apos;git push 当显示类似如下提示的时候，即表示备份成功12To git@git.oschina.net:xxxx/blog-backup.git + 2c77e1e...5616bc6 master -&gt; master (forced update) 再到A电脑上的时候，只需要1git pull 即可同步更新~ 给git配置sock5代理由于某些众所周知的缘故，所以github时不时的有时候速度会很慢，这种情况下本地代理就派上用场了。这里以给git的SSH传输方式配置本地SS代理为例说下配置过程： 打开~/.ssh/config文件。 在Host github *.github.com下添加以下字段： 1Proxycommand ssh -S 127.0.0.1:1080 %h %p 测试连接保存退出后重启git bash。输入ssh -vT git@github.com，当返回Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.的时候即说明配置成功. 这之后github的所有流量都会走本地的ss代理。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>即用</tag>
        <tag>解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask的核心机制-关于请求处理流程和请求|应用上下文]]></title>
    <url>%2Fpost%2F57058f23.html</url>
    <content type="text"><![CDATA[学习一样东西不能只停留在表面，我们要探索其中的细节，学习作者的编程思想，这样才能更进一步。 关于WSGIWSGI(全称Web Server Gateway Interface)，是为 Python 语言定义的Web服务器和Web应用程序之间的一种简单而通用的接口，它封装了接受HTTP请求、解析HTTP请求、发送HTTP，响应等等的这些底层的代码和操作，使开发者可以高效的编写Web应用。一个简单的使用WSGI的App例子： 123def application(environ, start_response): start_response('200 OK', [('Content-Type', 'text/html')]) return [b'&lt;h1&gt;Hello, I Am WSGI!&lt;/h1&gt;'] environ: 一个包含全部HTTP请求信息的字典，由WSGI Server解包HTTP请求生成。 start_response: 一个WSGI Server提供的函数，调用可以发送响应的状态码和HTTP报文头， 函数在返回前必须调用一次start_response()。 application()应当返回一个可以迭代的对象(HTTP正文)。application()函数由WSGI Server直接调用和提供参数。 Python内置了一个WSGIREF的WSGI Server，不过性能不是很好，一般只用在开发环境。可以选择其他的如Gunicorn。 ![dream](http://pic.aclear.top/WSGIServer-APP-dealprocess.png) WSGI Server 和 App交互图 Flask的上下文对象Flask有两种Context(上下文)，分别是 RequestContext 请求上下文 Request 请求的对象，封装了Http请求(environ)的内容 Session 根据请求中的cookie，重新载入该访问者相关的会话信息。 AppContext 程序上下文 g 处理请求时用作临时存储的对象。每次请求都会重设这个变量 current_app 当前激活程序的程序实例 生命周期： current_app的生命周期最长，只要当前程序实例还在运行，都不会失效。 Request和g的生命周期为一次请求期间，当请求处理完成后，生命周期也就完结了 Session就是传统意义上的session了。只要它还未失效（用户未关闭浏览器、没有超过设定的失效时间），那么不同的请求会共用同样的session。 Flask处理流程 ![dream](http://pic.aclear.top/flask-dealprocess.jpg) Flask处理流程 第一步：创建上下文Flask根据WSGI Server封装的请求等的信息(environ)新建RequestContext对象 和AppContext对象 123456789# 声明对象# LocalStack LocalProxy 都由Werkzeug提供# 我们不深究他的细节，那又是另外一个故事了，我们只需知道他的作用就行了# LocalStack 是栈结构，可以将对象推入、弹出# 也可以快速拿到栈顶对象。当然，所有的修改都只在本线程可见。_request_ctx_stack = LocalStack()_app_ctx_stack = LocalStack()# 如果调用一个LocalStack实例， 能返回一个 LocalProxy 对象# 这个对象始终指向 这个LocalStack实例的栈顶元素。# 如果栈顶元素不存在，访问这个 LocalProxy 的时候会抛出 RuntimeError异常# LocalProxy对象你只需暂时理解为栈里面的元素即可了current_app = LocalProxy(_find_app)request = LocalProxy(partial(_lookup_req_object, 'request'))session = LocalProxy(partial(_lookup_req_object, 'session'))g = LocalProxy(partial(_lookup_app_object, 'g')) 12345678910# RequestContextclass RequestContext(object): def __init__(self, app, environ, request=None): self.app = app if request is None: request = app.request_class(environ) self.request = request self.url_adapter = app.create_url_adapter(self.request) self.flashes = None self.session = None 1234567#AppContextclass AppContext(object): def __init__(self, app): self.app = app self.url_adapter = app.create_url_adapter(None) self.g = app.app_ctx_globals_class() self._refcnt = 0 这里需要注意的是，RequestContext在初始化的时候，当前Flask的实例作为参数被传进来。虽然每次的请求处理都会创建一个RequestContext对象，但是每一次传入的app参数却是同一个。通过这个机制，可以使得: 由同一个Flask实例所创建的RequestContext，其成员变量app都是同一个Flask实例对象 。实现了多个RequestContext对应同一个current_app 的目的。 第二步:入栈将RequestContext对象push进_request_ctx_stack里面。在这次请求期间，访问request对象，session对象将指向这个栈的栈顶元素123456class RequestContext(object): def push(self): .... _app_ctx_stack.push(self) appcontext_pushed.send(self.app) AppContext对象push进_app_ctx_stack里面。在这次请求期间，访问g对象将指向这个栈的栈顶元素 12345class AppContext(object): def push(self): .... _request_ctx_stack.push(self) 第三步:请求分发response = self.full_dispatch_request()Flask将调用full_dispatch_request函数进行请求的分发，之所以不用给参数，是因为我们可以通过request对象获得这次请求的信息。full_dispatch_request将根据请求的url找到对应的蓝本里面的视图函数，并生成一个response对象。注意的是，在请求之外的时间，访问request对象是无效的，因为request对象依赖请求期间的_request_ctx_stack栈。 第四步:上下文对象出栈这次HTTP的响应已经生成了，就不需要两个上下文对象了。分别将两个上下文对象出栈，为下一次的HTTP请求做出准备。 第五步：响应WSGI调用Response对象，向WSGI Server返回其结果作为HTTP正文。Response对象是一个 可调用对象，当调用发生时，将首先执行WSGI服务器传入的start_response()函数 发送状态码和HTTP报文头。 最后附上Flask处理请求的wsgi_app函数123456789101112131415161718192021# environ: WSGI Server封装的HTTP请求信息# start_response: WSGI Server提供的函数，调用可以发送状态码和HTTP报文头def wsgi_app(self, environ, start_response): # 根据environ创建上下文 ctx = self.request_context(environ) # 把当前的request context,app context绑定到当前的context ctx.push() error = None try: try: #根据请求的URL，分发请求，经过视图函数处理后返回响应对象 response = self.full_dispatch_request() except Exception as e: error = e response = self.make_response(self.handle_exception(e)) return response(environ, start_response) finally: if self.should_ignore_error(error): error = None # 最后出栈 ctx.auto_pop(error) 参考资料汇智网:Flask框架-上下文对象 ：Flask核心机制Werkzeug(Flask)之Local、LocalStack和LocalProxy]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中相关知识点须知]]></title>
    <url>%2Fpost%2F4fb37b54.html</url>
    <content type="text"><![CDATA[python中*args **kw到底是什么意思*args是非关键字参数，用于元组，**kw是关键字参数，用于字典 举例： 1.*args def tupleArgs(arg1, arg2= ‘B’, *arg3): print(‘arg 1:%s ‘ % arg1) print(‘arg 2:%s ‘ % arg2) for eachArgNum in range(len(arg3)): print(‘the %d in arg 3 :%s ‘ % (eachArgNum,arg3[eachArgNum]))if __name__ == ‘__main__‘: tupleArgs(‘A’) # arg 1:A # arg 2:B tupleArgs(&#39;23&#39;,&#39;C&#39;) # arg 1:23 # arg 2:C tupleArgs(&#39;12&#39;,&#39;A&#39;,&#39;GF&#39;,&#39;L&#39;) # arg 1:12 # arg 2:A # the 0 in arg 3 :GF # the 1 in arg 3 :L **kw def dictArgs(kw1, kw2= &#39;B&#39;, **kw3): print(&#39;kw 1:%s &#39; % kw1) print(&#39;kw 2:%s &#39; % kw2) for eachKw in kw3: print(&#39;the %s ----&gt;:%s &#39; % (eachKw,kw3\[eachKw\])) if __name__ == ‘__main__‘: dictArgs(‘A’) # kw 1:A # kw 2:B dictArgs(&#39;23&#39;,&#39;C&#39;) # kw 1:23 # kw 2:C dictArgs(&#39;12&#39;,&#39;A&#39;, c = &#39;C&#39;,d = &#39;12121212&#39;) # kw 1:12 # kw 2:A # the d ----&gt;:12121212 # the c ----&gt;:C dictArgs(&#39;kw&#39;,c = &#39;C&#39;,d = &#39;12121212&#39;,kw = &#39;KW&#39;) # kw 1:kw # kw 2:B # the kw ----&gt;:KW # the d ----&gt;:12121212 # the c ----&gt;:C 其它意义1. 两个乘号就是乘方，比如24,结果就是2的4次方，结果是16 2. 一个乘号，如果操作数是两个数字，就是这两个数字相乘，如24,结果为8 3. 如果是字符串、列表、元组与一个整数N相乘，返回一个其所有元素重复N次的同类型对象，比如”str”3将返回字符串”strstrstr”]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python神器-virtualenv详解]]></title>
    <url>%2Fpost%2F7d46890d.html</url>
    <content type="text"><![CDATA[virtualenv介绍及基本使用virtualenv介绍在python开发中，我们可能会遇到一种情况，就是当前的项目依赖的是某一个版本，但是另一个项目依赖的是另一个版本，这样就会造成依赖冲突，而virtualenv就是解决这种情况的，virtualenv通过创建一个虚拟化的python运行环境，将我们所需的依赖安装进去的，不同项目之间相互不干扰，如下所示。 安装virtualenv安装virtualenv比较简单，无论是在linux系统上还是windows上都可以通过pip来进行安装，如下： pip install virtualenv如果安装不成功也可以下载virtualenv源码package，通过执行setup.py来安装virtualenv。同时因为python2和python3的不同，因此也有了两种pip和pip3两种python包安装工具，而两种工具安装的virtualenv也是不相同的，py2安装的virtualenv虚拟化出来的python运行环境是python2的，py3安装的virtualenv默认虚拟化环境则是python3的。 virtualenv运行使用创建虚拟化环境使用pycharm来作为本示例的编辑器，选择python2.7工作环境，新建工程 virtualenvDemo,在控制台中输入命令： virtualenv venv这时候便会在当前的项目中创建venv文件夹，为当前项目的虚拟python运行环境，如下： 我本机此时默认的python环境为python2.7，那么此时创建的虚拟环境就是以python2.7创建的虚拟化环境，如果需要选择一个python解释器来创建虚拟化环境，命令则为： virtualenv -p /usr/bin/python2.7 venv 此时还需将当前工程的interpreter改为当前的虚拟环境，要不然会不起作用，这个不再详述。 启用激活虚拟化环境的命令为： source venv/bin/activate 激活后，在控制台会有一个带有(venv)的标志，如下： 安装依赖在以上完成之后就可以通过命令pip install 来安装python包了，这里安装python包就不需要root权限了，直接就可以安装十分方便。在venv的环境中，使用pip安装的包都不会再是全局性的包，只会在当前的虚拟环境中起作用，避免了污染系统环境。 退出当前系统环境在控制台中输入命令deactivate后，就会推出当前的venv虚拟化环境。 virtualenv其他命令virtualenv各种其他命令如下： 1234567891011121314151617181920212223242526272829303132用法:$ virtualenv [OPTIONS] DEST_DIR 选项: –version 显示当前版本号。 -h, –help 显示帮助信息。 -v, –verbose 显示详细信息。 -q, –quiet 不显示详细信息。 -p PYTHON_EXE, –python=PYTHON_EXE 指定所用的python解析器的版本，比如 –python=python2.5 就使用2.5版本的解析器创建新的隔离环境。 默认使用的是当前系统安装(/usr/bin/python)的python解析器 –clear 清空非root用户的安装，并重头开始创建隔离环境。 –no-site-packages 令隔离环境不能访问系统全局的site-packages目录。 –system-site-packages 令隔离环境可以访问系统全局的site-packages目录。 –unzip-setuptools 安装时解压Setuptools或Distribute –relocatable 重定位某个已存在的隔离环境。使用该选项将修正脚本并令所有.pth文件使用相当路径。 –distribute 使用Distribute代替Setuptools，也可设置环境变量VIRTUALENV_DISTRIBUTE达到同样效要。 –extra-search-dir=SEARCH_DIRS 用于查找setuptools/distribute/pip发布包的目录。可以添加任意数量的–extra-search-dir路径。 –never-download 禁止从网上下载任何数据。此时，如果在本地搜索发布包失败，virtualenv就会报错。 –prompt==PROMPT 定义隔离环境的命令行前缀。 综上virtualenv就是一个搭建虚拟化的python环境，便于不同的项目在同一台机器上开发运行。 virtualenv更多的还是适用于本地开发不同的项目，但是在生产环境中还是使用docker给不同的项目创建不同的容器，各自分开运行为好，不宜放在一个单独的物理机中运行。 virtualenvwrapper用途Virtaulenvwrapper是virtualenv的扩展包，用于更方便管理虚拟环境，它可以做： 将所有虚拟环境整合在一个目录下 管理（新增，删除，复制）虚拟环境 切换虚拟环境 …安装Virtualenvwrapper安装Virtualenvwrapper前需要virtualenv已近安装$ pip install virtualenvwrapper 此时还不能使用virtualenvwrapper，默认virtualenvwrapper安装在/usr/local/bin下面，实际上你需要运行virtualenvwrapper.sh文件才行，先别急，打开这个文件看看,里面有安装步骤，我们照着操作把环境设置好。 1、创建目录用来存放虚拟环境mkdir $HOME/Envs编辑~/.zshrc或~/.bashrc（根据你使用shell类型决定） export WORKON_HOME=$HOME/Envs source /usr/local/bin/virtualenvwrapper.sh 运行：$ source ~/.zshrc 此时virtualenvwrapper就可以使用了。 virtualenvwrapper的基本使用方式1、列出虚拟环境列表workon 或者 lsvirtualenv新建虚拟环境mkvirtualenv [虚拟环境名称] 2、启动/切换虚拟环境workon [虚拟环境名称]3、删除虚拟环境rmvirtualenv [虚拟环境名称]4、离开虚拟环境，和virutalenv一样的命令deactivate 总结以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作能带来一定的帮助，如果有疑问大家可以留言交流，谢谢大家的支持。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android神器-Tasker应用教程]]></title>
    <url>%2Fpost%2F5fbe6b3a.html</url>
    <content type="text"><![CDATA[说在最前面● tasker的使用比较复杂，称它为神器，其实它能做出不同的软件功能。由于tasker太强大了，所以在制作阶段根本没有易用性可言。● tasker官方版本有7天的试用，售价约35.00RMB，以下此链接是一个破解过的，能用10年。相对来说破解版调试功能不能正常运行，但并不会对实际使用造成问题，对于不需要自己开发研究的朋友只要用破解版就行了。● 基本多数TX看到这么长的教程就不打算弄了，当然你要放弃我不拦你，但是你愿意跟着我，一步一步啃下去，相信不久你就会发现Android真正的魅力——什么才叫做智能机！ Tasker的定义每个软件，其实都有它们自己面向的功能范围，例如闹钟软件，那么它们定义为管理时间，达到指定时间后进行提醒，它们只管提醒，不会在乎你的信息，邮件，电量。因为不是它们的功能所在。定义为短信的软件，只管理短信，彩信收发，它不会去做与短信无关的事情。这些就是软件的定义，那么Tasker定义是什么呢？大家不去关注它，其实是因为很多人无法给它一个定义，也就根本不知道怎么更好利用它了。Tasker能做闹钟，能管理来电，能管短信，能美化，能省电，能管CPU，能保密，能防盗，能……还有很多。其实Tasker的定义是‘简易开发平台’，它上面所提到的功能，都是靠用户自己做命令来决定它如何工作，它就像口袋妖怪里的No.132百变怪一样，无性别无属性，但它能变成任何性别和属性。为什么叫做‘简易’呢？因为Tasker虽然是开发平台，但它却不需要写代码，相对来讲会容易理解一点（当然如果换作是程序员，倒是宁愿写代码）。可惜的是由于牺牲了代码，导致一些API或一些函数不能完全支持，变化能力也有所限制，但是够我们用了，当你能操作它时，你会发现其实够用了。tasker其实也支持脚本功能，也就能弥补代码问题，当然这是后话，是高级的使用方面了。 Tasker = 简易开发平台 Tasker 基本操作设想： 每天早上起床时自动播放喜欢的播客作为闹钟，同时音量会逐渐变大，再也不怕闹钟「毁歌」。 每天定时自动从 Pixiv 和 Bing 等网站获取壁纸然后自动更换。 运行地图软件自动打开 GPS，关闭软件时自动关闭 GPS。 利用彩云分钟级天气预报制作下雨预警（在下雨前 20 分钟自动发送通知/微信/短信提醒）。 静音模式如果有超过三次同一来电自动关闭静音模式，然后向对方发送一条说明短信。 利用人工智能自动回复短信。 定时开启与关闭小飞机。 Tasker相关入门与理解首先，我不喜欢传统那种系统式的学习方法，那样会给人感觉很枯燥无味，什么三月通的，我呸，我这里是30分钟通，3小时就用，3天就发明创造！我们需要的是一种只需要了解重点和原理，然后靠自己理解去举一反三，一边做一边学的方式。所以我不会在这里列出tasker的所有功能或给它们定义，如果你真的需要，你可以在我们机锋论坛里找到相关帖子。或者你可以在维基百科里找到相关内容，但是前提你要懂鸟语……1.让它动起来&nbsp; &nbsp;&nbsp;&nbsp;关于tasker，我们首先需要了解它的工作原理，对于语言逻辑比较好或者是学过写程序的同学应该会比较好理解，当然你如果没有以上条件，也没关系，这个帖子就是为了让你去了解它。每时每刻，你的手机都在发生不同的事件，例如信息来了，指定时间到了，运行了某个程序，手机某个按钮被按了，屏幕关闭或打开了，插上数据线了等……这些事件我们称为触发条件。只要条件符合了，那么tasker就会动起来，那么怎么动呢？那就要靠我们去给指令了。tasker也可以多条件，例如条件1：来电，条件2：屏幕向下。那么如果只满足其中一个条件，tasker不会触发命令，当两个条件都满足了，那么它才动。2.什么叫变量/常量&nbsp; &nbsp;&nbsp;&nbsp;量，在写程序里是常用到的东西，主要分：常量和变量。在tasker里也如此，只是有一定的格式或规则而已。变量通俗形容其实就像一个烟盒，它里面放有5根烟。那么它的名字叫：烟盒，量是：5 。转换来说变量名叫做%YanHe&nbsp;&nbsp;它里面的数字是5。如果%YanHe=%YanHe - 1 ，那么这时候烟盒里就变成4根烟了。这个盒子里面除了烟，也能放其他，或者我们不要放烟了，给它放一个纸条，叫做“再来一盒”。那么现在%YanHe就等于‘再来一盒’了。它能放数字，能放英语，能放中文，甚至能放一个运算结果，或者混合内容。&nbsp; &nbsp;&nbsp;&nbsp;常量。它是里面的内容是固定的，它就像一包新的烟。怎样也好，它都是20根烟（假定%XinYan是常量）。你只能知道里面的内容，却不能更改它。例如你20岁了，别人问你几岁，你说：“我的岁数等于一包烟里烟的数量。”那么别人就知道你是20了。变量%AGE=%XinYan，最后结果就是%AGE=20，当然，常量也是会变的，但只能系统改变它，你不能改变它，就像某天一包烟规格控制到只有10根了，那么这个常量也跟着是10了。常量在tasker里是已经固定的，并且提供。&nbsp; &nbsp;&nbsp;&nbsp;它们在tasker的规则：&nbsp; &nbsp;&nbsp;&nbsp;必须%开头，后面是大于等于三个数字或英文字母组合，第一个必须是字母，大小写敏感。变量可读写，常量只读。3.界面的要点&nbsp; &nbsp;&nbsp;&nbsp;● 每当你设置好一个配置后，对应的配置下面就会出现左右两个框框，左边的是条件框，右边的是代码框。&nbsp; &nbsp;&nbsp;&nbsp;● 配置后面的勾是代表是否运行的意思。 Tasker由以下几个部分组成： 配置文件：文件决定了触发条件，Tasker 提供了非常多样的触发条件，从特定地理位置到接到某个电话，从收到某条通知到手机倾斜了多少度应有尽有。甚至安装支持的第三方应用后还能拓展触发条件。在这个例子中触发条件是收到短信。 任务：任务是为了达到某个目的所做操作的集合，Tasker 满足触发条件后执行的就是一个或是多个任务，任务可以暂停，中止或者反转。在这个例子中任务是获取，然后复制验证码。 操作：操作时 Tasker 的基本「单位」，一个操作只能执行一种动作，多个操作组合起来的任务就能满足种各样千奇百怪的需求。比如获取验证码是一个操作，复制验证码也是一个操作。 场景（非必需）：上面三个已经可以组成完整的 Tasker 了。但是有的操作不仅是在后台默默执行，一些数据还需要被展示，这个时候就需要展示用的界面，在 Tasker 里面则是「场景」。场景有点像我们平时用的桌面小部件，Tasker 可以在图层，对话框甚至是 Activity 上绘制场景。场景的所有部分和所有动作都可以由用户自己定义。 帮助和支持●常见问题 最常见的问题无非就是设置失败，导致不能实现所说的功能，很多人都为此发私信给我，其实教程的内容和设置，都是我亲自做出来后，然后再一边一步一步重新做，一边写的教程，然后经过多次的核对并且在此试验。所以，如果发现不成功，请重新对着教程核对你的设置，一个一个细节，常见的是运算符号输入错误，缺少空格，大小写没注意，单词拼错。 例如乘号，在代码里应该用”*”表达，并不是”×”，”x”或”X”，除以号是”/“(保留小数)和”\”(四舍五入保留整数)，并不是”÷”。 例如进行一个变量运算 %VAR1 - %VAR2 ，很容易被写成 %VAR1-%VAR2 。 例如某变量 %LOSTBATT ，写成 %LOTSBATT 。 最后，就是请检查你的软件版本，是否最新版，自从我发这个教程以来，tasker已经进行多次升级。请尝试重新安装或更新版本。这些情况是非常容易出现的，却是导致你程序无法正常运行的主要原因。 由于软件的支持能力有限，某些新机型可能不能设置一些功能，那么我也无能为力了，请等待tasker的再次更新吧。●关于提供配置文件问题 之前曾经有个例子我提供了配置文件，可是基本大家都不能使用，因为tasker是需要付费后才能支持配置文件还原，但是我相信99.9%的人都是使用破解版的，所以无法导入。而且后来想想，我提供配置了，也就违反了这帖的初衷了，这里为了学习和交流，并不是培养伸手党，所以你要怨的话就怨吧，怨自己拿不起这个逆天的神器，我是不提供的了。●如何联系我和个人申明其实很多眼尖的朋友都会从我的ID判断这是不是QQ号，尝试着加。好了，我这里就说吧，这是我QQ号，你们可以加QQ群:137313213，我在里面，别直接加我了，太多人加了……QQ要满了我……。 请大家注意了： 第一，我不是软件作者，我只是对此软件的喜爱而进行比较深入的研究而已。作者是谁？我也不知道，我也想跟他聊聊并且更好利用这软件，本人官方语言支持中文英文日文。 第二，大家如果嫌我更新慢的话，请自行去维基百科找相关内容，那里很丰富，但是我发的教程都是来自自己的生活判断和出于对国人的习惯制作的，我只发实用的，精品的。我也有自己的生活和工作，好的灵感不是随时会有的，并且不一定成立，所以请不要催。 第三，加我QQ请填写验证内容，表明身份，否则一律不加的。也可以发E-mail：man19860704.lj@gmail.com。 第四，我希望加我的人是来自问我教程以外的扩展问题，并不是教程说了，却加我来验证真实，问一些已经解释好的问题。当然你如果确实不懂，但又很想要这个功能，我也很乐意为你解答。 第五，我是一名程序员，但我不懂JAVA，我不会开发Android软件，我只有开发经验与思路，所以请不要加我后让我为你做软件，如果你懂Android开发打算合作的话我很乐意。 第六，加我的人请确定已满十八岁，没有心脏病史，承受能力强，无语言障碍，做好五问一答的心理准备。本人男，GG们别看头像就过来跟我聊感情，我不喜这好，MM例外～ 正式教程初级篇 初级主要为指令设置，不涉及变量或更多。 第一刀：对应不同的程序，使用不同的CPU频率运行目的很简单：省电或者提高效能。 目前主流的CPU频率格式大约是500MB～1G左右，待机，打电话，发个信息，难道要让它1G去跑吗？高射炮打蚊啊！噢，有人想到SetCPU这软件了，那么再举例，我用手机玩连连看，最佳性能500MB够了，然后我再玩极品飞车，起码800MB以上，难道每次去设置SetCPU吗？就不能自动调整吗？我们这次要做的是SetCPU做不到的。 前些时间我玩暖暖温泉乡，其实800MB就够流畅运行了，但我CPU是1G，但是玩久了就发热，这经营类的游戏一长时间玩，热，耗电。那么我每次玩这游戏，就让手机自动调整为800MB吧！我们开始吧！打开tasker，点击 新建 - 确定 - 应用程序然后要等一会，等tasker加载程序列表，选择你需要自动调整的程序，这里以暖暖温泉乡为例，选中后按 完成新建任务 - 杂项 - CPU最高频率按后面的放大镜图标，选择：800000 &lt;——————-视你程序需求所定，能超频或降频（超频者请注意！请你确认你的手机真的能在指定频率里正常运行，否则会过热死机或导致严重后果，例如里程碑1本来是500M的，它能超到900MB而正常运行，但是P1000本来是1G，有些超到1.4就会死机）完成完成解释：当条件：某应用程序运行 满足后，将CPU的最大频率控制在我们要求的范围，最小频率就不用设置了，越小越好。点一下代码框（参考入门与理解），点击 添加退出任务新建任务 - 杂项 - CPU最高频率按后面的放大镜，选择你正常CPU的频率。完成完成解释：我们必须设置退出任务，其实它的意思就是当这应用程序结束后，将要做的动作，如果你不设置，那么就算退出了，手机会仍然以刚刚设定的频率运行，如果你本来就是降频运行就还好，但是如果你超频呢？那么待机也耗电了。应用这时候就完成了，不要小看这设置，它能直接影响你手机续航能力。我做过一个实验，同样长时间运行一个程序，续航能力就能加强20%以上～（注意了，请不要设置后台程序，否则会乱套的。） 第二刀：屏幕亮度高级控制，补全自动亮度的不足目的：省电是第一，接着大家有没有发现一点，系统自带的自动亮度不是很完美，有时在室内用，同一个位置，屏幕也会一会亮点一会暗点，纠结呢，但是我们固定了亮度后呢，太亮也耗电（屏幕是超级电池杀手），如果调成合适室内的，到室外阳光好的时候又觉得屏幕暗得看不清，晚上睡觉前床上看看小说，那个自动亮度虽然是暗了，但是还是觉得比需求中要亮很多，就这样重重复复，自动也不是，固定也不是，设置也烦，不设置也烦。有木有？有木有？ 所以我们这次要对手机的屏幕亮度进行缺点补全，既能最大化地省电，也能最大化地适应眼睛使用！ 首先我们整理一下思路和设计方向，假如： 8点起床，8点半到9点在上班路上，9点到下午5点在外工作，6点回到家，11点上床看看小说睡觉 8:00~8:30 ——— 8:30~18:00 ———— 18:00~23:00 ——— 23:00~8:00 固定室内亮度 室外自动亮度 固定室内亮度 晚上熄灯用最低亮度 动手！打开tasker，点击 新建 - 确定 - 时间8:008:30完成解释：呃……这次的教程基本大家都能从中文表达上知道是代表什么意思吧，应该不用解释了吧……新建任务 - 确定 - ‘+’ - 显示 - 自动亮度调整关完成‘+’ - 显示 - 显示亮度级别：90 &lt;—————室内亮度适当范围70～100，似乎你家里的亮度和你接受的范围忽略当前级别打勾立即生效打勾完成完成新建 - 确定 - 时间8:3118:00完成新建任务 - 确定 - ‘+’ - 显示 - 自动亮度调整开完成接着是跟第一个设置是一样的，只是时间段不一样（18:01~23:00），大家可以自己尝试设置，不行就继续看下面。新建 - 确定 - 时间18:0123:00完成新建任务 - 确定 - ‘+’ - 显示 - 自动亮度调整关完成‘+’ - 显示 - 显示亮度级别：90 &lt;—————室内亮度适当范围70～100，似乎你家里的亮度和你接受的范围忽略当前级别打勾立即生效打勾完成完成新建 - 确定 - 时间23:018:30完成新建任务 - 确定 - ‘+’ - 显示 - 显示亮度级别：40 &lt;—————晚上台灯亮度适当范围50～80，熄灯亮度适当范围30～50，这是我个人经验标准，并不代表所有，请大家实际试试合适自己的。忽略当前级别打勾立即生效打勾完成完成应用省电，护眼，省心，哈哈！希望大家喜欢！========================================== 第三刀：加快开机速度当系统使用时间长了，安装的软件多了，开机的时间就会越来越长，甚至会导致FC。有时候死机了，重启后还要拿着手机等开机完毕，那个也很纠结啊。我们这次利用超频的方法，在开机后对CPU进行超频，然后再调会正常频率，而实现加快开机速度的功能。动手！打开tasker，点击 新建 - 确定 - 事件 - 系统 - 设备已启动 - 新建任务 - 确定 - ‘+’ - 杂项 - CPU按一下 最高频率 后面的 放大镜 图标适当选择你手机能超频的频率，如1G的朋友，就选择1200000，好像MOTO的里程碑1，500MB的CPU，能稳定超到900MB，注意了！必须确定你的手机能稳定运行在指定的频率，否则可能导致不可逆后果！一般超频一两节就好了，别过分然后会出现一个警告，按 确定完成‘+’ - Tasker - 等待分 的地方，选择 2 &lt;——————（预计开机完成在两分钟内，自己按需求衡量）完成‘+’ - 杂项 - CPU按一下 最高频率 后面的 放大镜 图标选择你正常的CPU频率完成完成应用========================================== 中级篇 中级篇涉及到变量的使用，利用变量做出比较高级行为 第一刀：来电翻转静音实际应用里，当在某些特殊场合，你忘记给手机静音，却有人不知趣的来电，情急之下却令你手忙脚乱，这时你只要悠然地将手机翻个面，它就不响了，再悠然地离开，接电话。———&gt;! 可能某些TX说安卓不是自带这功能吗？答案是否的，某些手机可能在定制手机系统的时候就已经做上这功能（如HTC某些型号），但是很大部分人的手机却没有这功能，或者某些第三方Rom却没这功能，不要盲目认为系统本来就有这功能，有这功能的TX请路过。没有这功能的TX，我们就自己动手做～！打开tasker，点击 新建 - 确定 - State - 方向 - 面向下 - 完成新建任务 - 确定 - 按左下角的‘+’ - 变量 - 变量设置名称：%CALLVOL发往：0完成完成解释：我们首先要判断手机的现在状态是正面还是反面，由于重力的判断在tasker里是归类为条件，所以我们要事先将这个条件变为一个变量，这样才能带到下一个条件里判断，并且也能在别的条件进程在运行中动态改变。然后你会看到你添加的任务出来了，有两个框框，左边的写着‘方向’，右边写着‘变量设置…’，点一下右边的框框。选 添加退出任务 - 新建任务 - ‘+’ - 变量 - 变量设置名称：%CALLVOL发往：1完成完成解释：退出任务其实意思就是当前条件反过来的意思了，就是说面朝上了，那么我们也将它带到%CALL这个值里，0代表面朝下，1反之。新建 - 确定 - 事件 - 电话 - 电话振铃 - 优先级：最高 - 完成新建任务 - 变量 - 变量设置名称：%CALLVOLTIME发往：1完成解释：这里是初始化这行代码已被运行的次数。左下角‘+’ - Tasker - 等待1秒完成解释：等待1秒，如果不等待，tasker触发代码的时候会比来电响铃要早，那么就会设置静音失败，并且由于到最后代码是一个循环，所以我们等待一秒也能方便循环时间的计算。‘+’ - 铃声静音if 打勾第一个空%CALLVOL第二个空0完成解释：假如%CALLVOL为0（电话面向下了），那么静音。‘+’ - Tasker - 停止if 打勾%CALLVOL0完成解释：如果电话面向下了，那么进程的任务也完成了，就退出任务，不做多余操作了。否则的话继续走下面代码。‘+’ - 变量 - 变量设置%CALLVOLTIME%CALLVOLTIME + 1 &lt;—————注意运算符号之间有空格无匹配打勾完成解释：记录的代码已被运行次数。‘+’ - Tasker - 停止if 打勾%CALLVOLTIME点中间的～按钮，选 大于30 &lt;—————-这里是持续判断时长，秒为单位，例如30秒后翻不翻转它都不受理了，目的是省电，因为Tasker没有接通来电的条件，所以我们一般设置25～50完成解释：假如运行次数超过了指定的次数/秒，则停止进程，如果我们不停止，那么代码将无限制运行下去，最后导致的结果就是长时间工作而导致耗电。运行时间越短，越省电，但是翻转静音功能的判断时间也就越短。越长，相对就会耗电，虽然几十秒浪费不了你多少电，但是由于tasker无法判断接通电话的条件，所以无论你是在指定时间内将电话接了或者是挂了，这个进程还是会持续工作下去，所以没必要设置很大。适当设置在你常用范围内就行了。（其实真的要用到静音功能，难道还有人让它响了半天才静它吗？）‘+’ - Tasker - 转到操作数字2if 打勾%CALLVOL1完成完成解释：这里是跳回去第二行代码（的地方），做成一个循环，让响铃的时候一直让代码进行重复判断。前提是电话仍在正面（if %CALLVOL = 1）。应用教程完毕！～另外找台手机打电话给自己试试吧～！========================================== 第二刀：电量监控与预测器 利用tasker的功能，我们今天来自制一个电量监控器，它能统计你的使用时间，还能预测按照当前使用的情况，告诉你剩下待机时间。实际应用里，让你能更好的控制手机的电量消耗，而且用tasker制作的监控器，相比那些插件，要省电得多。传统的监控插件会不停在你的后台进行检测与更新，在这段时间里，你手机的电量在悄悄的流失，并且也不会告诉你在当前情况下如何更好的控制耗电。现在让我们的Android更强大吧！！打开tasker，点击 ‘任务’ - ‘新建任务’点左下角的 ‘+’ - 变量 - 变量设置，分别填入名称：%LOSTBATT发往：%SBATT - %BATT &lt;——-注意：运算符号之间互相有空格，下文相同。无匹配打勾完成解释：获得已失去电量，%SBATT是开机后或者USB拔出后设置的一个电量级别，%BATT是当前电量级别，%LOSTBATT就是失去的电量，失去电量=拔出后电量-当前电量‘+’ - 变量 - 变量设置，分别填入名称：%LOSTBATT发往：1 &lt;——-注意：运算符号之间互相有空格，下文相同。无匹配打勾if打勾%LOSTBATT 等于 0完成解释：因为后面要进行一个除法运算，所以如果%LOSTBATT小于0 会出错的，所以假如小于1，那么%LOSTBATT等于1，这里感谢kennyhuhu 同学的指出‘+’ - 变量 - 变量设置%STARSEC%UPS - %SUPS无匹配打勾完成解释：%UPS=开机持续时间，%SUPS=拔出USB充电前的持续时间，%STARSEC=当前有效的持续时间（秒），有效时间=开机时间-拔出前时间‘+’ - 变量 - 变量设置%STARMIN%STARSEC / 60无匹配打勾完成解释：将有效持续时间单位换成分钟‘+’ - 变量 - 变量设置%KEEPSEC%STARSEC / %LOSTBATT %SBATT无匹配打勾完成解释：计算剩余电量能用多少时间（秒），利用公式：持续时间/失去电量剩余电量。‘+’ - 变量 - 变量设置%KEEPSEC充电中无匹配打勾if打勾%KEEPSEC 小于 0完成解释：如果计算出的时间小于0，那么手机就是正在充电中，感谢kennyhuhu 同学提出建议。‘+’ - 变量 - 变量设置%KEEPTIME%KEEPSEC / 3600无匹配打勾完成解释：转换单位为小时。‘+’ - 警报 - 弹出框标题：剩余续航时间文字：（注意空格）自上次充电器拔出消耗电量 %LOSTBATT %运行时间 %STARMIN 分钟估计剩余待机 %KEEPTIME 小时完成右下角有个红叉，旁边的按钮是设置图标，随便自己选一个按 ‘完成’‘新建’ - 确定 - State - USB已连接 - ‘反转’打勾 - 完成 - 新建任务 - 确定‘+’ - 变量 - 变量设置%SBATT%BATT完成‘+’ - 变量 - 变量设置%SUPS%UPS完成完成解释：USB/充电器拔出后，将电量和持续时间都初始化一次，避免几天没关机，却计算了一直的开机时间，我们只需要充电后的有效时间。‘新建’- 确定 - 事件 - 系统 - 设备已启动 - 新建任务 - 确定‘+’ - 变量 - 变量设置%SBATT%BATT完成‘+’ - 变量 - 变量设置%SUPS%UPS完成完成解释：开机后初始化电量和持续时间。应用长按桌面空白处 - 插件/小部件 - 任务 - 剩余续航 - 创建小工具完毕！～========================================== 高级篇 高级篇是利用Tasker与其它软件融合发动合体技！~ 第一刀：美化桌面显示来电和信息统计首先，相信不少人看过类似这样的界面： 在有短信到或者漏接电话后的时候，则会变成这样： 很漂亮吧，今天就教大家如何制作这漂亮的界面。第一步，我们要先获得app，分别是Minimalistic text和tasker两个，前者（下文称MNML）可以在论坛搜索出来，有汉化过的，比较容易获得，或者有些TX已经在用了，只不过不知道如何做出这样的效果。后者就比较难找了，电子市场也难搜到，我就上传到附件里，自带中文，非常好。在弄之前，我们要先懂MNML怎么用，这个不在此教程范围内，请第一次使用的TX自行琢磨，下个汉化过的，上手不难，此教程里的MNML使用也不会高要求，主要是tasker。MNML是桌面的文字型美化软件，就像你上图看到的文字效果，就是用MNML做的，这次我们要利用它的一个高级功能：本地变量，很多TX都不会用这个功能，网上也几乎没有类似的中文教程，希望大家看完此教程后能举一反三弄出其他新花样～！好了，废话说多了，现在我们开始吧。我们先给这两个软件定义：MNML是一个显示用的界面软件，tasker是一个后台处理完数据，递给MNML显示出来的工具。（此教程跨过了基础设置的一点，可能一下内容难懂，但是按着设置就没错了，如果能理解就更好，本来SMS应该有无短信后面都是显示白色的数字，但是我这里是变成如果没新短信就是白色的0，否则就会变红色的统计数字）首先我们打开taskertasker界面：(我这个是有建立任务的) 按 新建要求输入配置文件命名，我们不用输入，直接确定。第一条件选择事件事件类别选择 电话 - 收到的短信 - 完成出来一个任务选择对话框，选新建任务 名称不用填，直接确定然后看到任务编辑窗口，类似这样：（我这个是已有任务的，大家的应该是空的） 我们点左下角的 出来操作类别，选 变量 - 变量设置然后会看到这样的界面： 名称填%MSG发往填%MSG + 1 &lt;——————-（中间有空格）无匹配打勾完成解释：这个设置表示了当满足条件“收到短信”时，我们赋予变量%MSG一个值，这个值就是比%MSG大1，例如%MSG这时候是1，那么+1后就变成2，这是统计短信数量用的。无匹配的意思应该是翻译上的问题，在英文版里显示是”进行计算”。接着我们做第二步。+ - 插件 - Minimalistic Text variable settings(MNML变量设置) - 编辑出来类似这样的界面： Variable name（输出变量名）填%MSGN &lt;———————（这个是之后要对应MNML的值，%MSGN代表无短信，变量可以自行定义，好记就可以了，%大写英文）Variable countent（变量连接）填空格 &lt;———————-不是‘空格’两字，是一个空格符号OK+ - 插件 - Minimalistic Text variable settings(MNML变量设置) - 编辑分别填%MSGC &lt;————————代表短信数量%MSG完成那么第一个任务设置完成了。点完成解释：这两个任务分别是各给MNML传递一个值，%MSGN=空白，代表没短信的情况下MNML显示空白，%MSGC=%MSG，代表有短信的情况下MNML的%MSGC值显示短信数量。这时回到主界面了，按 新建 - 确定 - 应用程序 - 选择你的短信软件例如我这里的是 超级短信 ，找出来点一下，然后按完成新建任务 - 确定 - + - 变量 - 变量设置名称填%MSG发往填0无匹配打勾完成解释：此任务意思是，当超级短信被运行（也就是查看短信了），那么将%MSG里的数量统计设置回0，就是说看过短信了，那么计数器变回0+ - 插件 - Minimalistic Text variable settings第一个填%MSGC 第二个填 空格完成再添加插件任务第一个填%MSGN第二个填0完成现在返回到了任务编辑界面，按完成解释：给MNML传递%MSGC为显示空白，给%MSGN传递0到这里我们对tasker的设置就完成了，右下角有个开关，确认它是开启，如果显示关闭，点它一下开启，否则tasker是不工作的。点应用就会退出tasker了。=================MNML部分=================好了，我们要开始添加MNML了在桌面空白处长按 - 插件 - MNML（SIZE大小方面的话自己衡量吧），然后就会进入MNML的设置模式了。显示背景（Show background） - 去勾显示阴影（Shadow settings） - 点进去 - 打勾 - 返回界面类型（Predefined layout） - 自定义（Coustom…）自定义界面（Custom layout）变成可选，点进去会看到长方形三个方块，长按它，拖到垃圾桶删除，都删，然后按右边的 + 号，选 其他（Misc），有两项，分别是 本地变量（Locale variable） 和 静态文本（Static text）。长按静态文本，拖到长方形里，再拖两个本地变量上去。 现在长方形一共有三个方块，按顺序分别是：| 静态文本 | 本地变量 | 本地变量 | | Static text | Locale variable | Locale variable | 点击一下静态文本的方框，显示内容（Static text）填：SMS:下面的 外观（Style）选择着重（Accented）点一下第一个 本地变量 方框变量名称（Variable name）填：%MSGC外观选择 非着重（Non-Accented）点第二个本地变量方框变量名称填%MSGN外观选 普通（Normal）按返回（就是手机的返回键）然后下面是字体外观设置，对应刚刚设置的外观进行设置，点 普通第一项是字体选择（Font family）可以选择你自己喜欢的字体，系统自带的字体很少，但是可以自行添加，后面会提到如何更换。找到 字体大小（SIZE），设置为 20 dip发光（Blur radius）可以自行设置，一般2～4就够了。返回然后设置 着重 ，和前面设置成一样就可以了。非着重将字体颜色（Color）设置成红色或粉红色，橙色也可以，看你怎么和你的主题搭配了。在点击动作（Tap behavior）那里选择 运行其他程序（Start another activity）选择程序（Select activity）一栏变可选，点进去，找到你的短信软件，例如超级短信，选它。往下看有一个全局设置（Global Settings），点进去，有个 字库位置（Fonts folder），将你喜欢的字库文件放到SD卡的某个位置，再从这里指定文件夹，那么在之前的字体选择就有你的字库了。退回去，点OK，这时候你的桌面就会出现一个显示着“SMS：”的图案了，当收到短信后面就会显示数量了，点它就会进入指定的程序了，但是为什么不是显示“SMS：0”呢？要点一下后出来才显示，那是因为tasker的条件没触发，所以那个变量是空白，什么都没有，就没显示了。对于完美主义者来说，每次开机都不是显示SMS：0，却只是SMS：，感觉不舒服，那么我们回到tasker，再给它加个条件吧。==========================================回到Tasker。新建事件 - 系统 - 设备已启动任务是变量设置%MSG0再加一个任务，插件%MSGC%MSG那么就完美了。至于来电漏接的地方，其实和短信的设置基本一样，我就不再大篇幅了，只是条件选择了来电漏接，自己试试动手吧。牛刀小试，玩出新花样：眼尖的TX可能会发现我发的图片里CALL是在没电话的时候不显示的，有电话才出来，是怎么做到的呢？其实是给插件赋值的时候，第二项填成 Call： %Call，那么就显示成Call：1这样子了，当点进拨号器后，就赋值空白，那么看上去就不见了～还有就是我的来电下面是会显示漏接人的姓名，那个是%CNAME变量，tasker自带的，有兴趣动手的朋友可以自己试试，只要理解了就不难。 第二刀：定时在桌面上显示你的余额和可用的免费信息不废话，我们先来看看图： 主要是为了让大家省心（做起来很不省心……），定时向10086发送一个短信，然后根据回复的内容将其显示在桌面上。 首先我们要有第三方软件 Minimalistic text ，在电子市场可以找到，机锋也可以找到，有汉化的，下文称MNML。 这次的教程，教大家两个tasker的变量功能，第一个是条件语句：if ，第二个是变量分割（split），我们必须先理解了这两个功能，才能更完美去完成这个任务，毕竟不是所有人都是用同样的SIM卡营运商，可能返回的短信内容不一样，照教程做就未必可以成功了，我是动感地带的卡，中国移不动的，如果你跟我一样，或许你能照抄教程…… 以理解教程说明为基础制作，如果你是一直不知道tasker所云，只是抄教程的话，那么你可以放弃这次的磨刀练习了。 第一个我们先讲讲分割，分割就是一段内容，我们指定一个关键字，分割后就会以关键字为点，将内容分成若干份，（关键字只能为一个字，在编程里其实能若干个字符的，但是我在Tasker里试了几次，发现好像只能1个字符，没办法，只能勉为其难做了）例如： %TEST=吃葡萄不吐葡萄皮 分割%TEST，关键字：葡 那么就会变成： %TEST1=吃 %TEST2=萄不吐 %TEST3=萄皮 内容会随关键字分割成0份到无限份，然后在被分割的变量名后面加上索引数字，所以%TEST分割后会变成 %TEST1，%TEST2 …… %TESTN，假如我们将%TEST2再分割，就变成 %TEST21，%TEST22 …… %TEST2N 实战例子：我发给10086查询余额后，它返回给我的内容： 尊敬的客户：您当前帐户余额58.20元，其中基本帐户为58.20元，赠送帐户为0.00元，（剩余免费短信128条） 月结为2011-08-14。温馨提醒：赠送话费不能扣减信息费。中国移动 短信内容会保存在tasker的常量：%SMSRB 里面， 首先我们分割关键字 “ ：” （注意全角半角问题，基本国内的这些短信都是全角） 就会变成 %SMSRB1 = 尊敬的客户 %SMSRB2 = 您当前帐户余额58.20元，其中基本帐户为58.20元，赠送帐户为0.00元，（剩余免费短信128条） 月结为2011-08-14。温馨提醒 %SMSRB3 = 赠送话费不能扣减信息费。中国移动 可以拿到我们需要的内容保存在了 %SMSRB2 里面，那么我们继续分割，分割关键字 “额”，出现： %SMSRB21 = 您当前帐户余 %SMSRB22 = 58.20元，其中基本帐户为58.20元，赠送帐户为0.00元，（剩余免费短信128条） 月结为2011-08-14。温馨提醒 关键内容在 %SMSRB22 里，继续分割“元” %SMSRB221 = 58.20 &lt;——————-我们要的内容 %SMSRB222 = ，其中基本帐户为58.20 %SMSRB223 = ，赠送帐户为0.00 %SMSRB224 = ，（剩余免费短信128条） 月结为2011-08-14。温馨提醒 我们将余额分离出来了！在 %SMSRB221 里，有木有！有木有！别急，先记下来，还有，除了余额我们还需要免费短信的数量，它在 %SMSRB224 里，我们再次分割，关键字 “信” %SMSRB2241 = ，（剩余免费短 %SMSRB2242 = 128条） 月结为2011-08-14。温馨提醒 将 %SMSRB2242 继续分，关键字是啥来着，相信你能看到这里应该知道了，对，没错关键字 “条”%SMSRB22421 = 128 &lt;-------------我们要的内容 %SMSRB22422 = ） 月结为2011-08-14。温馨提醒 哦耶，免费短信的数量就在 %SMSRB22421里面。 好啦，现在我们已经将两个最需要的内容都弄出来了，分别是：%SMSRB221 和 %SMSRB22421 。 第二个变量功能：条件语句，if 中文意思“如果”，简单理解，就是假如某某条件成立了，那么就进行下面的代码行，否则跳到 End If 处，假如没有 End If ，那么直接结束当前配置的所有代码。 相信如果你能看到这里，这个练习应该知道该如何制作了，只不过可能还是有点头晕晕的，或者有这概念了，只是不知道怎么弄，没事，其实制作起来没有上面的那么罗嗦，我只是讲解讲解，我们开始弄了！ 首先我们要先给10086发短信（不发短信它怎么回你呢？不回你你怎么去分割内容呢？没内容分割怎么显示呢？没显示这教程还有什么意义呢？没意义还活着干什么呢？没什么干那么就发信息呗，不发信息它怎么回你呢？………………）按 新建 - 确定 - 时间只留第一个勾，时间设置成你每天需要发短信的时间，例如0点，或者早上8点。完成新建任务 - 确定 - “+” - 电话 - 发送短信数字 &lt;--------------------哪个SB翻译的那么烂，Num就直接翻译成“数字”，明显这个是翻译成“号码”。10086内容ye &lt;--------------------这个是发送的内容，中国移动的查询代码是“ye”（余额），其他营运上的是怎样我就不知道了，大家按情况改吧。完成完成好了，定时发送发送短信的就这么简单，下面是重点了：新建 - 确定 - 事件 - 电话 - 收到的短信发件人10086完成解释：从这里开始一直到最后，解析跟原理都在前面的实战例子里面说得清楚了，这里也就不再重复了，我会累。新建任务 - 确定 - “+” - 变量 - 变量拆分名称%SMSRB &lt;--------------------这个是tasker里的一个常量，并不是我们自己定义的变量，它的功能就是保存最新短信内容。分离： &lt;--------------------注意！是 “：” ，而不是 “:” ，全角和半角的区别，全角的是特别宽点的，半角的光标会紧跟后面！完成“+” - 变量 - 变量拆分名称%SMSRB2 &lt;--------------------为什么是它？怎么来的？回去看之前的实战例子！ 分离额完成“+” - Tasker - If第一个填%SMSRB21第二个填您当前帐户总余 &lt;--------------------注意！是“您”，不是“你”，是“帐户”，不是“账户”，最后是“余”，不是“余额”，每一个字一定要对，否则就不成功。完成解释：在10086的短信里，相信未必只有一种内容，我们为了分辨出它究竟是不是我们所需要的，所以就要识别短信特征，就像杀毒软件一样，就是说，假如 %SMSRB21 的内容是我们指定的内容，那么就判断这信息就是我们要的那个，否则就直接结束代码，这里很关键，否则可能因为10086的骚扰信息导致你的显示出错。“+” - 变量 - 变量拆分名称%SMSRB22分离元完成“+” - 变量 - 变量拆分名称%SMSRB224分离信完成“+” - 变量 - 变量拆分名称%SMSRB2242分离条完成+ - 插件 - Minimalistic Text variable settings第一个填%SYYE第二个填 剩余话费：%SMSRB221 元 &lt;--------------------注意变量两边的空格完成+ - 插件 - Minimalistic Text variable settings第一个填%SYYE第二个填 免费短信：%SMSRB22421 条 &lt;--------------------注意变量两边的空格完成+ - 输入 - 按钮 默认Back完成解释：其实就是按一下返回键，干什么用滴？有部分童鞋应该会用一些第三方的短信软件，这些软件会收到短信后直接弹出框显示短信，按一下返回键就是取消它，不让它老是挡着，当然，这一条你可以弄上去，也可以不弄完成=================MNML部分=================tasker就设置完毕了，现在我们要设置MNML了。在桌面空白处长按 - 插件 - MNML（SIZE大小方面的话自己衡量吧，推荐2*1），然后就会进入MNML的设置模式了。显示背景（Show background） - 去勾显示阴影（Shadow settings） - 点进去 - 打勾 - 返回界面类型（Predefined layout） - 自定义（Coustom...）自定义界面（Custom layout）变成可选，点进去会看到长方形三个方块，长按它，拖到垃圾桶删除，都删，然后按右边的 + 号，选 其他（Misc），有两项，分别是 本地变量（Locale variable） 和 静态文本（Static text）。长按本地变量，拖到长方形里，右边有个绿色的减号，按一下，就会多一行，再放一个本地变量去第二行。------------------| 本地变量 | | Locale variable | ------------------| 本地变量 | | Locale variable | ------------------点击一下上面的本地变量的方框，变量名填：%SYYE点击一下下面的本地变量的方框，变量名填：%SYDX按返回（就是手机的返回键）==========================================剩余的就是什么字体大小啊，外观之类的，大家可以参考高级教程第一刀里面的解释，或者按个人喜好去设置吧，我不想多写了，一来罗嗦二来累……好了，教程到这里了，想立刻看看效果吗？手动发一条查询短信去看看吧！！ 超级篇 超级篇我们将tasker大技巧，打开脚本之路，发动终极技能。 第一刀：指定时间后台发送来电记录于收到短信到指定邮箱注意！这个第一刀的功能其实是比较敏感的，大家如何使用和修改，就见仁见智了，不要干坏事哦，如果你干坏事被XXOO了，我可不负任何责任的，先声明好了，如果你同意，就继续往下看吧！首先，我们需要Python语言支持工具，它叫“Python for Android”;我们先将它下载并运行后如下图： 按Install，等待下载安装脚本运行所需的文件。然后再下载脚本运行工具：“SL4A.apk”安装并运行，如下图所示： 如果看到跟我的是一样，那么表示你已经安装成功了，否则的话请重新安装“Python for Android”接着按菜单键-Preferences-Hide Notifications(各种内涵，懂英文的童鞋应该明白)最后一步了，下载一份脚本：“sendemailA.rar”解压，放到手机里，位置：sdcard/sl4a/scripts/ 里面。铺垫到此结束了，那么到底刚刚我们做了什么呢？首先，我们先让手机支持Python语言，脚本的制作就是用Python语言的，为什么非要它呢？因为SL4A支持的脚本是有指定语言的，好像只有三种，Python就是其中一种，tasker的脚本功能只支持SL4A，所以必须用它了～最后下载的那个就是已经做好的脚本了，我们只需要使用tasker就能完成任务了。至于Python脚本怎么写，就和这帖子的关系不大了……什么？想学？好！这样……以下省略16W字……。反正，相信懂Python的人不多，脚本我已经帮大家做好了，如果你懂，那么可以自己写其他功能来玩了，脚本能强大到什么程度呢？它能控制系统最底层的绝大部分功能，你如果足够强大，它能让你在Android里山寨个Windows出来！一些老外用它记录模拟火箭模型发射到坠落的各项数据：加速度，方向，弧线，高度，耗时，平衡度，阻力，动力，下坠起点位置等等，然后进行统计，用于开发大型火箭（或飞行器）的调试工程……我了个去啊，看他们视频在个火箭里包个G7，发射一次毁一台……好了，废话到这里了，现在开始tasker了。打开tasker+ - 确定 - 事件 - 电话 - 收到的短信 - 确定+ - 文件 - 写入文件文件：tasker/temp.txt&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&lt;———————————-这里是保存的文件位置，我们要先将收到的短信内容放到一个指定的文件里，这个内容其实可以自己去写，或者放在更隐蔽的地方……文字：%SMSRTsay:%SMSRB-解释：以上内容是从“%”开始到“-”，这个其实就是生成的文件格式。附加打勾确定确定+ - 确定 - 时间从：03:30&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&lt;————————————————-这里是设置发送邮件的时间，可自行设定，为什么是凌晨三点半呢？内涵……内涵……至：勾去掉确定新建任务 - 确定 - + - 变量 - 变量设置名称：%EMAIL_NAME发往：手机主人名字或自定确定+ - 变量 - 变量设置名称：%EMAIL_TO发往：接收的邮箱，ex:123123@gmail.com或qq.com等确定+ - 变量 - 变量设置名称：%EMAIL_SUBJECT发往：SMSChick确定+ - 变量 - 变量设置名称：%EMAIL_BODY发往：%DATE , %TIME&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&lt;—————————————注意空格！确定+ - 变量 - 变量设置名称：%EMAIL_ATTACH发往：/sdcard/tasker/temp.txt确定+ - 杂项 - 运行脚本名称：sendemailA.py传递变量：%EMAIL_NAME , %EMAIL_TO , %EMAIL_SUBJECT , %EMAIL_BODY , %EMAIL_ATTACH&nbsp; &nbsp;&nbsp;&nbsp;&lt;——————————————注意变量与逗号之间的空格！确定+ - 任务 - 等待分：3确定+ - 文件 - 删除文件文件：/sdcard/tasker/temp.txt遇到错误后继续运行任务：打勾确定确定好了，完成了，至于发来电内容，其实认真看过并制作过这个教程内容后，相信你能做到的，我这里就不大篇幅了，因为这帖子已经很大篇幅了………… The End…这功能该如何正确使用，请大家考虑后再弄，出什么事我可不负任何责任哦～！==========================================]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HccACan]]></title>
    <url>%2Fpost%2F3de28e71.html</url>
    <content type="text"><![CDATA[头脑风暴之主要事项是否每日一做 [ ] 英语口语-武大复试 [ ] OJ系统-机试刷题 [ ] 毕业设计-小程序编程笔记做好 [ ] 课外书-当当阅读（时间简史、未来简史、人类简史）、 [x] 更新博客英语口语-武大复试 机器学习、口语流利说OJ系统-机试刷题 c语言 Prime1r Plus C 武大OJ + 杭电OJ11页 + 考研题目OJ或者牛客网或者力扣毕业设计-小程序编程笔记做好 视频课程四天刷完 入门到实践课外书/吴恩达机器学习-当当阅读 时间简史、未来简史、人类简史作息时间表| 时间 | 事项 || —- | —- || 睡觉 | 23点40左右 不超过0点半左右 || 起床 | 7点半起床 || 早读—8.5-9.5/10点 | 运动吃饭+英语口语练习 || 10点—12点 | c + 复试OJ+邮件书写 || 13点30-14点 | 午休 || 14点-15点30 | 复试OJ+邮件书写 || 16点-17点30 | python + 小程序 || 19点-21点30 | python + 小程序 || 晚上 | 课外书 |]]></content>
      <categories>
        <category>页面</category>
        <category>日记之家</category>
      </categories>
      <tags>
        <tag>正能量</tag>
        <tag>计划反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise7-10 The Hard Way to Learn Python3.6]]></title>
    <url>%2Fpost%2F761c7c6c.html</url>
    <content type="text"><![CDATA[Using python 3.6 Test]]></content>
      <categories>
        <category>python</category>
        <category>毕业设计相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Exercise0-6 The Hard Way to Learn Python3.6]]></title>
    <url>%2Fpost%2Fdc5e1621.html</url>
    <content type="text"><![CDATA[# 学习配套书籍：https://www.jianshu.com/u/949b399ab14e # C:\\Users\\acanprince\\Desktop\\Project\\lpthw# No.1print(“Hello World!”)print(“Hello Again”)print(“I like typing this.”)print(“This is fun.”)print(‘Yay!Printing.’)print(“I’d muck rather you ‘not’.”)print(‘I “said do not touch this.’) # No.2 This is my # s test.print(“Hi # is here.”) print(“I will now count my chickens:”) print(“Hens”,25 + 30 / 6)# 果然先是乘除后是加减print(“Roosters”,100 - 25 * 3 % 4)print(“Now I will count the eggs:”) print(3 + 2 + 1 - 5 + 4 % 2 - 1 / 4 + 6) print(“Is it true that 3 + 2 &lt; 5 - 72?”) print(3 + 2 &lt; 5 - 72) print(“What is 3 + 2?”,3 + 2)print(“What is 5 - 7?”,5 - 7) print(“Oh, that’s why it’s False.”) print(“How about some more.”) print(“Is it greater?”,5 &gt; -2)print(“Is it greater or equal?”, 5 &gt;= -2)print(“Is it less or equal?”, 5 &lt;= -2) # python当中 整数和浮点数的比较：print(“————————“)print(“注意’is’ &amp; ‘==’区别.python当中 整数和浮点数的比较：”)a = 10b = 10c = 100d = 100e = 10.0f = 10.0print(a is b)print(c is d)print(e is f)print(a == e)print(a is e) print(“————————“)print(“注意 整数 和 浮点数的计算，会产生无限循环小数：”)print(3.14 - 3.0)print(‘’’在python中不建议直接将两个浮点数进行大小比较，或者做精确的计算，往往会得到意想不到的结果。当然，如果非要用，可以参考decimal模块的相关内容。’’’) # 测试python相关Decimal模块进行浮点数运算from decimal import Decimalprint(“测试使用Decimal模块进行浮点数计算：”)a = Decimal(‘3.14’)b = Decimal(‘3.0’)print(“Decimal函数：a - b = “,a - b) # — coding:utf-8 — # 格式化 字符串和变量打印# 更多的变量和打印 my_name = ‘Jiahao Zhang.AClear Zhang’my_age = 22 #not a liemy_height = 72 # inchesmy_weight = 78 # kgmy_eyes = ‘Brown’my_teeth = ‘White’my_hair = ‘Black’ print(“Let’s talk about %s.” % my_name)print(“He’s %d inches tall.” % my_height)print(“He’s %d kg heavy.” % my_weight)print(“Actually that’s not too heavy.”)print(“He’s got %s eyes and %s hair.” % (my_eyes, my_hair))print(“His teeth are usually %s depending on the coffe.” % my_teeth) print(“\\n\\n—-Another way to print.—-“)print(f”Let’s talk about {my_name}.”)print(f”He’s {my_height} inches tall.”)print(f”He’s {my_weight} kg heavy.”)print(f”Actually that’s not too heavy.”)print(f”He’s got {my_eyes} eyes and {my_hair} hair.”)print(f”His teeth are usually {my_teeth} depending on the coffe.”) # And this line is tricky, try to get it exactly right.total = my_age + my_height + my_weightprint(f”If I add {my_age}, {my_height}, {my_weight} then I got {total}.”) —-Another exercise—- # 附加练习height = 72 # inchescentimeters = height / 3.28 100weight = 171.96 # poundkilograms = weight 0.4536print(f’’’\\nStudy Drills:I’m {height} inches or {round(centimeters, 2)} centimeters.And My weight is {weight} pound or {round(kilograms, 2)} kilograms.\\n’’’) # ex6.py 查找一个字符串放进另外一个字符串的地方 四个点types_of_people = 10x = f”There are {types_of_people} types of people.” # 外面也是可以进行 F-string 格式化的！ binary = “binary”do_not = “don’t”y = f”Those who know {binary} and those who {do_not}.” # 外面进行 F-string 格式化！ print(x)print(y) print(f”I said: {x}”) # No1print(f”I also said: {y}”) # No2 hilarious = Falsejoke_evaluation = “Isn’t that joke is funny?! {}” print(joke_evaluation.format(hilarious)) # 王牌学习 点！ # No3 w = “This is the left side of……”e = “a string with a right side.” print(w + e) # 注意 是放置在一行上面。 # No4 # weight = 78 # kg# pound = weight / 0.4536# print(f”Now the {weight} kg translate into pound is {round(pound, 2)} pound.”)]]></content>
      <categories>
        <category>python</category>
        <category>毕业设计相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决win10安装Pyint失败]]></title>
    <url>%2Fpost%2Fe44d3bb6.html</url>
    <content type="text"><![CDATA[我的版本 pylint —version pylint 2.2.2 astroid 2.1.0 Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 17:00:18) [MSC v.1900 64 bit (AMD64)] 错误分析执行安装指令pip install pylint，出现错误，错误信息如下： Installing collected packages: wrapt, astroid, pylintRunning setup.py install for wrapt … errorException:Traceback (most recent call last):File “C:\\Users\\sigmarising\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\pip\\compat\\__init__.py”, line 73, in console_to_strreturn s.decode(sys.__stdout__.encoding)UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xa1 in position 43: invalid start byte During handling of the above exception, another exception occurred: Traceback (most recent call last):File “C:\\Users\\sigmarising\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\pip\\basecommand.py”, line 215, in mainstatus = self.run(options, args)File “C:\\Users\\sigmarising\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\pip\\commands\\install.py”, line 342, in runprefix=options.prefix_path,File “C:\\Users\\sigmarising\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\pip\\req\\req_set.py”, line 784, in install**kwargsFile “C:\\Users\\sigmarising\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\pip\\req\\req_install.py”, line 878, in installspinner=spinner,File “C:\\Users\\sigmarising\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\pip\\utils\\__init__.py”, line 676, in call_subprocessline = console_to_str(proc.stdout.readline())File “C:\\Users\\sigmarising\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\pip\\compat\\__init__.py”, line 75, in console_to_strreturn s.decode(‘utf_8’)UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xa1 in position 43: invalid start byte Windows上很多问题都是由于编码引起的，pylint安装失败也与编码有很大关系。 解决方案1.定位到以下文件： C:\\Users\\acanprince\\AppData\\Local\\Programs\\Python\\Python36\\Lib\\site-packages\\pip\\compat\\__init__.py 定位时需将路径中的_\\UsersNames_与_\\Python36_，更改为计算机具体情况 2.定位到文件的第75行，将源代码： return s.decode(‘utf_8’) 更改为： return s.decode(‘gbk’) 3.重新执行_pip install pylint_ 4.安装成功]]></content>
      <categories>
        <category>ComputerScience</category>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Win10上AppData中的Local，LocalNow和Roaming文件夹详细说明]]></title>
    <url>%2Fpost%2Fed2a9102.html</url>
    <content type="text"><![CDATA[几乎每个在Win10 PC上安装的程序都会在AppData文件夹中创建自己的文件夹，并将其所有相关信息存储在其中。 AppData或应用程序数据是Windows 10中的一个隐藏文件夹，可帮助保护用户数据和设置免遭删除和操作。 要访问它，必须在文件夹选项中选择“显示隐藏的文件和文件夹”。 可以在Windows文件资源管理器中直接粘贴以下内容，然后按Enter键将其打开： C:UsersAppData当您打开AppData文件夹时，您将看到三个文件夹： Local LocalLow Roaming. 如果一个程序想要有一组设置或多个用户使用的文件，那么它应该使用ProgramData文件夹 - 但是如果要为每个用户存储单独的文件夹，程序应该使用AppData文件夹。 让我们看看本地，本地和漫游文件夹是什么，它们的功能是什么。 本地，本地和漫游文件夹 这些文件夹中的每一个都是由Microsoft故意创建的，原因如下： 登录时性能更好 根据使用水平分离应用程序的数据。 本地文件夹 本地文件夹主要包含与安装程序相关的文件夹。包含在其中的数据（％localappdata％）不能与您的用户配置文件一起移动，因为它特定于PC，因此太大，无法与服务器同步。例如，Internet Explorer临时文件存储在Internet临时文件或Cookie文件夹下。此外，还有一个Microsoft文件夹，您可以在其中找到Windows活动的历史记录。 LocalLow文件夹 此LocalLow文件夹包含无法移动的数据。此外，它还具有较低的访问级别。例如，如果您以受保护或安全模式运行Web浏览器，该应用程序将只能从LocalLow文件夹访问数据。此外，LocalLow文件夹不是在第二台计算机上创建的。因此，访问LocalLow文件夹的任何应用程序可能会失败。 漫游文件夹 漫游文件夹是一种可以与服务器轻松同步的文件夹。它的数据可以随着用户的个人资料从PC移动到PC - 就像您在域上一样，您可以轻松地登录到任何计算机并访问其收藏夹，文档等。例如，如果您登录到域上的其他PC，您的网络浏览器收藏夹或书签将可用。这是公司中漫游简介的主要优点之一。用户配置文件数据（复制到服务器），自定义数据始终可用，无论员工使用何种系统。 简而言之： ProgramData文件夹包含不是用户特定的全局应用程序数据，可供计算机上的所有用户使用。任何全球数据都放在这里。 AppData文件夹包含用户特定的首选项和配置文件配置，并进一步分为三个子文件夹： 1.漫游文件夹包含可以从用户配置文件从计算机移动到计算机的数据 2.本地文件夹包含无法与用户配置文件一起移动的数据。 3.LocalLow文件夹包括低级访问数据，例如。 在受保护的模式下运行时浏览器的临时文件。 \-\-\-\-\-\-\-\-\-\-\-\-\-\- 1、Local和Roaming之间的区别：Local 比较大，非漫游应用数据。Roaming 一般是漫游应用数据。 2、Roaming和locallow之间的区别： roaming文件夹是Windows存放一些使用程序后产生的数据文件，如空间听音乐，登入的号码等而缓存的一些数据。 Appdata下有三个子文件夹local，locallow和roaming。 1、当解压缩包时如果不指定路径，系统就把压缩包解到local\\temp文件夹下，存放了一些解压文件，安装软件时就从这里调取数据特别是一些制图软件，体积非常大，占用很多空间。 2、locallow是用来存放共享数据，这两个文件夹下的文件就用优化大师清理，一般都可以清理无用的文件。 3、roaming文件夹也是存放一些使用程序后产生的数据文件，如 空间听音乐，登入 的号码等而缓存的一些数据，这些数据优化大师是清理不掉的，可以打开roaming文件夹里的文件全选定点击删除，删除不掉的就选择跳过，不过当你再使用程序时，这个文件夹又开始膨胀，又会缓存数 --------------------- 附：其中三个文件夹的作用，里面的文件可以随心所欲地删除。 C:\\Users\\用户名\\AppData\\Local\\Temp里面是临时文件。 C:\\Users\\用户名\\AppData\\Local\\Microsoft\\Windows\\Temporary Internet Files里面是IE缓存文件（默认是隐藏的）。 C:\\Users\\用户名\\AppData\\Local\\Microsoft\\Windows\\History里面是浏览器历史记录（默认是隐藏的）。 我的变量相关： Python 3.7安装目录 C:\\Users\\acanprince\\AppData\\Local\\Programs\\Python\\Python37\\Scripts C:\\Users\\acanprince\\AppData\\Local\\Programs\\Python\\Python36\\python.exe pylint安装目录 C:\\Users\\acanprince\\AppData\\Roaming\\Python\\Python37\\Scripts C:\\Users\\acanprince\\AppData\\Local\\Programs\\Python\\Python36\\Scripts VScode setting.json目录： C:\\Users\\acanprince\\AppData\\Roaming\\Code\\User snownlp C:\\Users\\acanprince\\AppData\\Local\\Programs\\Python\\Python37\\Lib\\site-packages\\snownlp C:\\Users\\acanprince\\AppData\\Local\\Programs\\Python\\Python36\\Lib\\site-packages\\snownlp]]></content>
      <categories>
        <category>ComputerScience</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发——Slay]]></title>
    <url>%2Fpost%2F75f7cc73.html</url>
    <content type="text"><![CDATA[1.一边实战项目、一边学习小程序基础知识 2.演进式讲解、关键是为什么用这个，怎么用这个。 3.循序渐进、从简单到复杂、从本地数据（假数据——到与服务器连接）到网络数据 一步步意识到错误到解决错误。 怎样去解构 设计图 从整体上——层次结构、整体框架结构、组件上进行开发 知识！ 新生事物、更新 实践式学习小程序开发。API 接口设计、变动思路去学习。 小程序特点： 1、小程序适合做简单的、用完即走的应用 2、适合低频的应用 3、性能要求不高的应用 哪些类型的应用适合小程序： .png) ·安装包 足够小，所以也是需要安装的；用完即走，不用关心是否安装太多应用；链接 人与服务——服务无处不在 （二维码 扫描之后，随时可用这个服务。） 小程序 性能优于webapp 、属于混合APP、原生应用、winPhone 的区别 小程序：商业 + 产品 角度思考是不同的！]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写在考研前76天]]></title>
    <url>%2Fpost%2Ff52a81e0.html</url>
    <content type="text"><![CDATA[来自——有道云笔记]]></content>
      <categories>
        <category>日记之家</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python第四节面向对象基础]]></title>
    <url>%2Fpost%2F800e61d6.html</url>
    <content type="text"><![CDATA[Python中所有的东西 都是类！Python 更强调的是应用是否一致，鸭子类型—是基于接口的，而不是有明确的继承关系的。区别于 Java的继承关系————在迭代器 一部分展现的特别好. 关于作业 ：翻转一个字符： def reverse(str_list, start, end): while( start &lt; end ): str_list[start],str_list[end] = str_list[end],str_list[start] start += 1 end -= 1setence = ‘Hello, how are you? Fine. ‘str_list = list(setence)i = 0while i &lt; len(str_list): if str_list[i] != ‘ ‘: #即不是空格 start = i end = start + 1 while ( end &lt; len(str_list) ) and str_list[end] != ‘ ‘: end += 1 reverse(str_list, start, end-1) i = end else: i+=1str_list.reverse()print(“”.join(str_list)) 字符串反转——先进行正向的每个word的翻转—再进行整个str_list的反转—最后把list # list join 为string 第四节：面向对象基础 print(&#39;you are %s&#39; %self.name) print(&#39;I am %s&#39; %name) print(&#39;\\n&#39;) # 根据Foo创建的对象obj1 = Foo()obj2 = Foo()obj1.hello(‘August’)obj2.hello(‘July’) you are JanI am Augustyou are JanI am July 所以说，这个 _self_ 就是个代指。代指了自己所在的class。你可以由 _self_ 点进所指class本身的函数。由此可见，_self_ 本身作为一个代词，并不一定要叫self。你也可以用个其他什么来代替。只不过，必须得是这个类的所有子方法的第一个参数： In [12]: # 创建类class Foo: # 这里我们可以创建一个类级别的变量 # 它不会随着由此类创建的变量而变化 name = ‘Jan’ def bar(july): print(‘Bar’) def hello(july, name): # 我这里把self改成了july， # 但是只要它作为第一参数的位置没变，它依旧是Foo Class的自我指代 print(‘you are %s’ %july.name) print(‘I am %s’ %name) print(‘\\n’)# 根据Foo创建的对象obj1 = Foo()obj2 = Foo()obj1.hello(‘August’)obj2.hello(‘July’) you are JanI am Augustyou are JanI am July 构造函数：构造函数，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值。 跟所有OOP语言一样，python也是有构造函数的，默认为: In [14]: # 创建类class Foo: def __init__(self):#这就是构造函数，它的职责是在模型创建的初期，就完成一些动作 #简单的说就是，自定义的初始化步骤： #同样，它需要self来指代本身这个class self.name=&#39;Jan&#39; def hello(self, name): print(&#39;you are %s&#39; %self.name) print(&#39;I am %s&#39; %name) print(&#39;\\n&#39;) # ==== 完毕 ===== 当你创建一个Foo类的时候，init会被自动跑一遍：obj = Foo()# 在我们的例子中，我们默认给self自己的name变量，赋值为’JAN‘# 此刻，当我们调用Foo的hello()方法时，hello自己的name变量，被赋值为’July’obj.hello(‘July’) you are JanI am July init是可以带更多的参数的，用以初始化我们的class本身。 比如说，你要初始化一个类的时候要用到一些外部参数: In [15]: # 创建类class Foo: def __init__(self, name2):# 你可以在这里附加上一些参数 # 这些参数将是你创建一个Foo类时的必要条件 self.name=name2 def hello(self, name): print(‘you are %s’ %self.name) print(‘I am %s’ %name) print(‘\\n’)# ==== 完毕 ===== 当你创建一个Foo类的时候，init会被自动跑一遍：# 此刻，你不可以直接跑Foo(),你需要填入一个参数：name2obj = Foo(‘Feb’)# 然后再调用hello, 并赋值Julyobj.hello(‘July’) you are FebI am July 由楼上这些例子，我们大概可以知道整个Python的OOP概念了： Class(类)就是一个把一堆Object(对象？)集合起来的地方。 在这里，无论是变量还是方法，他们享有基本一样的层级概念。只不过,方法要做一点事儿，而变量直接就是一个值。 访问限制我们刚刚看到，在调用obj的时候，可以直接调出name或者使用hello()。那么我们怎么知道什么时候可以调用他们，什么时候不可以呢？ 在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 举个学生的例子，我们可以用一个学生类来存储学生的信息，但是我们在外部可以接触到name，那么其实我们就是可以直接修改name的，这是不安全的 In [49]: class Student: def __init__(self, name, age): self.name = name self.age = age def detail(self): print(self.name) print(self.age)LiLei = Student(‘LiLei’, 12)LiLei.age = 20LiLei.detail() LiLei20 为了防止这种篡改年龄的事情发生，为了维护世界的和平，我们需要把关键的信息给做好隐藏： In [51]: class Student: def __init__(self, name, age): self.name = name self.age = age def detail(self): print(self.name) print(self.age)LiLei = Student(‘LiLei’, 12)LiLei.__age = 20LiLei.detail() LiLei12 看，如此一来，年龄就不会被更改了。 那么如何既保证安全，又能被外部修改呢？ 我们使用OOP家族传统理念：Getter+Setter In [52]: class Student(object): … def get_name(self): return self.name def get_age(self): return self.age In [53]: class Student(object): … def set_age(self, score): self.__age = age 至此，我们应该学会使用Class来定义我们自己的类了 接下来，我们来看看： 在Python中展现面向对象三大特性：面向对象的三大特性是指：封装、继承和多态。 封装指的就是把内容封装到某个地方，用于日后调用 它需要： 把内容封装在某处 从另一处调用被封装的内容 通过对象直接调用我们可以在存完一个内容以后，在类以外的地方，通过这个类的对象，来直接”点“调用 In [17]: class Student: # 假定我们初始化一个Student类的时候要做的就是，记录下每个学生的名字和年龄 def __init__(self, name, age): self.name = name self.age = age # 至此，我们用self指代student本身，并用name和age存下了他们的年龄和名字 # === 完毕 === 此时，我们新建一个学生obj1 = Student(‘July’, 18)print(obj1.name) # 直接调用obj1对象的name属性print(obj1.age) # 直接调用obj1对象的age属性obj2 = Student(‘Aug’, 73)print(obj2.name) # 直接调用obj2对象的name属性print(obj2.age) # 直接调用obj2对象的age属性 July18Aug73 通过self间接调用执行类中某一个方法时，通过self来调用了类自己的变量 In [18]: class Student: def __init__(self, name, age): self.name = name self.age = age def detail(self): print(self.name) print(self.age) # === 完毕 === 此时，我们新建一个学生obj1 = Student(‘July’, 18)obj1.detail() #Python默认将obj1传给self，所以其实我们做的是obj1.detail(obj1)# 那么，detail()内部的样貌其实就是：# print(obj1.name)# print(obj1.age)obj2 = Student(‘Aug’, 73)obj2.detail() July18Aug73 综上所述，对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象 中，然后通过对象直接或者self间接获取被封装的内容。 继承继承，面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容（爸爸有的儿子都有）。 例如，每个学生都有名字和年龄，木有问题。我们可以把这个作为我们的父亲类。 但是，每个学生自己，可能有自己不同的”方法“，比如，每个人有每个人不同的外号，不同的口号，不同的饮食习惯，不同的。。。。。 In [28]: # 我们首先创建一个学生类，这个类是所有学生的爸爸class Student: def __init__(self, name, age): self.name = name self.age = age def detail(self): print(self.name) print(self.age)# 然后，我们创建一个小学生类，小学生特点是，LOL sala无敌class PrimaryStudent(Student):#因为是继承于学生类，所以我们写在括号内 # 这里我们可以不写构造函数，于是我们就是直接沿用Student类的构造函数 def lol(self): # 我们有一些新的独有的方法，会被叠加起来 print(‘不服sala！’)# 接下来，我们创建一个大学生类，大学生特点是，额，每个人都有个妹子。。class CollegeStudent(Student): def __init__(self, name, age, gf): #这里，我们改写一下构造函数 # 于是爸爸的init会被直接overwrite self.name = name self.age = age self.gf = gf def gf_detail(self): print(self.gf)# 来，我们来创建一下obj1 = PrimaryStudent(‘小王’, 7)obj1.lol() # 独有的方法obj1.detail()#继承与爸爸的方法obj2 = CollegeStudent(‘王思聪’, 29, ‘张雨馨’)obj2.detail()obj2.gf_detail() 不服sala！小王7王思聪29张雨馨 所以，对于面向对象的继承来说，其实就是将多个类共有的方法提取到父类中，子类仅需继承父类而不必一一实现每个方法。 这样可以极大的提高效率，减少代码的重复。 问题来了，如果我想多认个干爹呢？Python和Java/C#的不同就是，Python可以多类继承，也就是，可以认很多干爹 但是干爹多了，就出了问题了。继承的时候，从谁先开始？ 有两种方式，分别是深度优先和广度优先 当本身的类是_经典类_的时候，就按照深度优先方式查找继承的方法 （即，找到一个爸爸，继续找这个爸爸的爸爸，爸爸的爸爸的爸爸。。。） 当本身的类是_新式类_的时候，就按照广度优先的方式查找 （即，找到一个爸爸，再找下一个爸爸，再找下一个爸爸，平辈之间查找） 那么为什么有_经典类_和_新类_之分呢？ 这是个历史遗留问题，_新类_ 统一了类(class)和类型(type)，所以其实也是社区推荐的写法，只不过。。很多程序员都很懒。。 在2.2之前，比如2.1版本中，类和类型是不同的，如a是ClassA的一个实例，那么a.__class__返回 ‘ class __main__.ClassA‘ ，type(a)返回总是&lt;type &#39;instance&#39;&gt;。而引入新类后，比如ClassB是个新类，b是ClassB的实例，b.__class__和type(b)都是返回‘class &#39;__main__.ClassB&#39; ，这样就统一了。 于是乎，在新版的Python中，这个经典类和新类的区别已经不存在，都统一使用广度优先。 我们先假设我们还活在python2.2的时代： In [ ]: 经典类的写法class c1: passclass c2(c1): pass 新类的写法class N1(object): passclass N2(N1): pass 可见，_新类_的标志就是，大家的老祖宗继承于一个系统级的类，叫Object 具体的，我们来看看： 经典类 In [36]: class D: def bar(self): print(‘D.bar’)class C(D): def bar(self): print(‘C.bar’)class B(D): passclass A(B, C): passa = A()# 执行bar方法时# 首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错# 所以，查找顺序：A —&gt; B —&gt; D —&gt; C# 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了a.bar() C.bar 新类 In [37]: class D(object): def bar(self): print(‘D.bar’)class C(D): def bar(self): print(‘C.bar’)class B(D): passclass A(B, C): passa = A()# 执行bar方法时# 首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错# 所以，查找顺序：A —&gt; B —&gt; C —&gt; D# 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了a.bar() C.bar 当然，对我们先现在而言，两种写法都得出_C.bar_ ；这说明，已经木有区别了。 多态Pyhon不支持多态并且也用不到多态，多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型（Duck Typing）”。 什么是鸭子类型？其实翻译成中文最好是叫：好猫类型。 也就是引用了小平同志的一句话，不管黑猫白猫抓到老鼠的就是好猫。 不同于强类型的语言，一个类型的obj只能一种事儿， 在Python中，只要是能“不报错运行”的类型，都可以塞进参数中去： In [48]: class F1: pass# 假设，S1是我们的正统类，它继承于根正苗红的F1，是我们的正统类class S1(F1): def show(self): print(‘S1.show’)# S2是路人甲，是个歪瓜裂枣，但是他自己也有一个叫show的方法。class S2: def show(self): print(‘S2.show’)# 在Java或C#中定义函数参数时，必须指定参数的类型，也即是说，我们如果用# Java写下面的Func，需要告知，obj是F1类还是其他什么东西。# 如果限定了F1，那么S2是不可以被采纳的。# 然而，在Python中，一切都是Obj，它不care你到底是什么类，直接塞进去就可以def Func(obj): “””Func函数需要接收一个F1类型或者F1子类的类型””” obj.show()s1_obj = S1()Func(s1_obj) # 在Func函数中传入S1类的对象 s1_obj，执行 S1 的show方法，结果：S1.shows2_obj = S2()Func(s2_obj) # 在Func函数中传入Ss类的对象 ss_obj，执行 Ss 的show方法，结果：S2.show S1.showS2.show 获取对象信息当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？ 用type()In [1]: type(123) Out[1]: int In [2]: type(‘str’) Out[2]: str In [3]: type(None) Out[3]: NoneType In [4]: type(abs) Out[4]: builtin_function_or_method In [9]: class a: def __init__(self): passtype(a) Out[9]: type 如何用语句判断是不是一种type呢？ In [10]: type(123)==type(456) Out[10]: True In [11]: type(‘abc’)==type(‘123’) Out[11]: True In [12]: type(‘abc’)==type(123) Out[12]: False In [18]: type(‘abc’)==str Out[18]: True In [22]: type([])==list Out[22]: True 用isinstance()isinstance()可以告诉我们，一个对象是否是某种类型（包括继承关系）。 In [23]: class A: passclass B(A): passclass C(B): passk=A()g=B()y=C()isinstance(y, C) Out[23]: True In [24]: isinstance(y, B) Out[24]: True 同理，isinstance()也可以当type()用 In [25]: isinstance(‘a’, str) Out[25]: True 使用dir()如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法： In [26]: dir(‘ABC’) Out[26]: [‘__add__‘, ‘__class__‘, ‘__contains__‘, ‘__delattr__‘, ‘__dir__‘, ‘__doc__‘, ‘__eq__‘, ‘__format__‘, ‘__ge__‘, ‘__getattribute__‘, ‘__getitem__‘, ‘__getnewargs__‘, ‘__gt__‘, ‘__hash__‘, ‘__init__‘, ‘__iter__‘, ‘__le__‘, ‘__len__‘, ‘__lt__‘, ‘__mod__‘, ‘__mul__‘, ‘__ne__‘, ‘__new__‘, ‘__reduce__‘, ‘__reduce_ex__’, ‘__repr__‘, ‘__rmod__‘, ‘__rmul__‘, ‘__setattr__‘, ‘__sizeof__‘, ‘__str__‘, ‘__subclasshook__‘, ‘capitalize’, ‘casefold’, ‘center’, ‘count’, ‘encode’, ‘endswith’, ‘expandtabs’, ‘find’, ‘format’, ‘format_map’, ‘index’, ‘isalnum’, ‘isalpha’, ‘isdecimal’, ‘isdigit’, ‘isidentifier’, ‘islower’, ‘isnumeric’, ‘isprintable’, ‘isspace’, ‘istitle’, ‘isupper’, ‘join’, ‘ljust’, ‘lower’, ‘lstrip’, ‘maketrans’, ‘partition’, ‘replace’, ‘rfind’, ‘rindex’, ‘rjust’, ‘rpartition’, ‘rsplit’, ‘rstrip’, ‘split’, ‘splitlines’, ‘startswith’, ‘strip’, ‘swapcase’, ‘title’, ‘translate’, ‘upper’, ‘zfill’] 类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的： In [27]: ‘ABC’.__len__() Out[27]: 3 我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法： In [28]: class MyObject: def __len__(self): return 100obj = MyObject()len(obj) Out[28]: 100 仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态： In [29]: class MyObject: def __init__(self): self.x = 9 def power(self): return self.x * self.xobj = MyObject() 紧接着，可以测试该对象的属性： In [30]: hasattr(obj, ‘x’) #有木有属性’x’ Out[30]: True In [31]: obj.x Out[31]: 9 In [32]: hasattr(obj, ‘y’) # 有属性’y’吗？ Out[32]: False In [33]: setattr(obj, ‘y’, 19) # 设置一个属性’y’ In [34]: hasattr(obj, ‘y’) # 有属性’y’吗？ Out[34]: True In [35]: getattr(obj, ‘y’) # 获取属性’y’ Out[35]: 19 In [36]: obj.y # 获取属性’y’ Out[36]: 19 可以传入一个default参数，如果属性不存在，就返回默认值： In [37]: getattr(obj, ‘z’, 404) # 获取属性’z’，如果不存在，返回默认值404 Out[37]: 404 也可以获得对象的方法： In [38]: hasattr(obj, ‘power’) # 有属性’power’吗？ Out[38]: True In [39]: getattr(obj, ‘power’) # 获取属性’power’ Out[39]:]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VS2015超永久代码防丢失）——托管代码到Git]]></title>
    <url>%2Fpost%2Fb19f29e.html</url>
    <content type="text"><![CDATA[VS2015 Git 源码管理工具简单入门 平时自己只是在和小组进行开发时才用的github.com，以为只用外国有，但是上传下载速度慢，所以一直自己没有用过。 最近自己写的小程序多了：1：担心代码丢失2：可以方便我们多终端查看代码3：发现开源中国也有git，速度也可以而且免费。可以创建私有项目！ 简单的Git+全宇宙最好用的IDE——Microsoft Visual Studio简直神器一枚所以才用了起来。 其实现在国内也有很多git平台了，大家不妨去试一下。另外一点是vs2015自带git使用起来很简单，不需要懂git命令行，很方便就能克隆和托管项目，网上也有一些vs2015链接git的教程，大家可以去搜一下。 虽然是方便，但是一开始用还是会遇到一些问题，就拿链接到oschina码云的gitee.com的git为例吧。 新建的项目需要托管到远程git，存储库设置-》添加远程的名称应该写origin，写成别的名称是不能发布的。origin是默认的远程版本库名称，约定俗成的； 新建项目点击发布按钮时如果提示“无法将分支 master 发布到远程 origin，因为远程存储库中已存在具有同一名称的分支。发布此分支将导致远程存储库中的分支发生非快进更新”，解决方法是先点击提取，然后到分支设置里合并本地和远程分支，然后再去发布就成功了。 另注明：VS2013有人说，当你在新建项目而不创建 ReadMe.md 时。会提示你自己用git 命令行进行 git仓库的创建——当然这样也能导入你本地的已存在的git项目了。也就不会和未有的master产生冲突了。目前只是听说，碰到问题时，可以朝这方面尝试下。 附加如何用 GIT BASH 提交已有项目到GIT： 快速设置— 如果你知道该怎么操作，直接使用下面的地址HTTPS SSH 我们强烈建议所有的git仓库都有一个README, LICENSE, .gitignore文件 Git入门？查看 帮助 , Visual Studio / TortoiseGit / Eclipse / Xcode 下如何连接本站, 如何导入项目 简易的命令行入门教程:Git 全局设置: git config —global user.name “*“git config —global user.email “aclearzhang@qq.com” 创建 git 仓库: mkdir OS_Unix_or_Linuxcd OS_Unix_or_Linuxgit inittouch README.mdgit add README.mdgit commit -m “first commit”git remote add origin 你的链接git push -u origin master 已有项目? touch README.md //新建说明文件git init //在当前项目目录中生成本地git管理,并建立一个隐藏.git目录git add . //添加当前目录中的所有文件到索引git commit -m “first commit” //提交到本地源码库，并附加提交注释git remote add origin 粘贴复制的地址 //添加到远程项目，别名为origingit push -u origin master //把本地源码库push到github 别名为origin的远程项目中，确认提交 更新代码： cd 根目录git add .git commit -m “update test” //检测文件改动并附加提交注释git push -u origin master //提交修改到项目主线 THE END. 1.VS Git插件 1.1 环境 VS2015+GitLab 1.2 Git操作过程图解 1.3 常见名词解释 拉取（Pull）：将远程版本库合并到本地版本库，相当于（Fetch+Meger） 获取（Fetch）：从远程版本库获得最新版本 合并（Meger）：将两个版本库进行合并操作 提交（Commit）：将所做的更改，存入本地暂存库 推送（Push）：将所做的更改，存入远程版本库 同步（Pull+Push）：先将远程库拉取，再将本地库推送到远程库，相当于（Pull+Push） 变基到（Switch）：切换分支（双击即可切换） 1.4 常用功能简单说明 【更改】 负责文件的修改、添加、忽略文件、删除文件提交到本地服务器，主要是：提交 【分支】 负责合并分支，切换分支，主要是合并、变基到、解决冲突 【同步】 远程Git存储库与本地Git存储库操作，主要是：推送、同步、拉取、获取 【设置】 设置用户名、密码、远程地址、对比工具等 2. **GitLab**创建远端Git存储库 2.1 GitLab中创建一个项目 2.2 填写项目名称 填写项目名称叫testDemo。其中Visibility Level根据项目需求设定 2.3 获取远程Git存储库地址 添加成功后，点击Projects会出现【Git的HTTP链接①】 3. **本地代码推送到远端Git存储库** 3.1 将DEMO项目添加到Git源码管理 3.2 选择源码管理为Git 3.3 填写提交注释，提交到本地Git存储库中 3.4 同步Git本地库到远端Git存储库 3.5 发布到远端Git存储库 下图将需要的【Git的HTTP链接①】填写好，点击发布（第一次需要Git用户名、密码）或者提前安装Git用命令行设置Git用户名密码 git config —global user.name “Your Name”git config —global user.email you@email.com 发布成功（最好从上图添加到存储库地址，如果从“设置”里第一次之前就添加好存储库地址，有可能“推送”是不可用的） 登录gitlabs查看发布项目 4. **工作中常见操作** 4.1 文件提交操作 【常见文件状态】 未操作状态： 修改状态： 添加状态： 删除状态：（只有在提交代码时候可见） 【提交代码:**方法一】** 1) 找到需要提交的文件或者找到解决方案，右键，找到源代码管理-&gt;提交 2) 同时在这里也可以做源码的查看历史记录、撤销、批注等 【提交代码:**方法二】 1）找到“团队资源管理器” 2）见到如下图，没有的话点击即可到主页 3）会出现整个项目的文件状态 排除的更改：一般是被排除的文件，如果不包含提交时候不会提交到源码中 未跟踪的文件**：未跟踪的文件有时候也会出现，一些没有通过VS2015直接添加的文件（找到目录人工添加文件就会出这个问题），不添加也不会提交到源码中 4.2 文件推送操作 找到团队资源管理器-&gt;同步-&gt;点击“推送”即可，注意一般master分支和有些分支是保护分支，只有特定账号可以推送，所以推送时候要及时切换分支并推送到正确分支上。 4.3 分支操作 4.3.1 分支介绍 找到资源管理器-&gt;分支 可以看到分支列表，如下图，黑体加粗的文字为当前分支（下图当前分支为master），remoters/origin为远端分支不能切换。注意：如果发现缺少分支，请通过资源管理器-&gt;同步-&gt;提取（或者拉取）功能得到分支列表 4.3.2 创建分支 找到克隆的分支，点击“从选定项创建本地分支…”，填写分支名即可 4.3.3 切换分支 双击本地分支即可切换，或者使用变基到。 4.3.4 合并分支 分支上，右键：合并自…，选择分支即可，“从分支合并”为源，“到当前分支”为目的 4.3.5 删除分支 右键删除分支即可（注意，当前分支不可删除、远端分支慎重删除） 4.4 解决冲突 本地Git存储库和远端Git存储库同个文件不匹配时候会出现，一般拉取、提取、同步、推送会出现冲突，然后人工解决冲突即可 如下图 在VS2013中使用git发布解决方案master分支的时候出现“无法将本地分支 master 发布到远程存储库 origin，因为此处已存在具有同一名称的分支。您可能需要重命名您的本地分支，然后重试”，如下图所示 其实官网创建时已经给出了解决办法： 1.创建项目的时候不需要选择自动创建ReadMe文件，如果已经创建可以选择清空项目 创建项目后（不含ReadMe文件）Code版块会自动跳转到该提示 根据该提示如果已经存在可以最后一项指令可以解决该问题： 控制台执行最后一组指令即可 1 2 3 cd existing_git_repo --进入GIT项目根目录 执行下述2个指令 git remote add origin https:``//git.oschina.net/weiki.shaw/yufukaweb.git git push -u origin master 再次点击同步 就可以了 C:\\Users\\acanprince\\Source\\Repos\\TestMFC1]]></content>
      <categories>
        <category>C++</category>
        <category>git</category>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python第五节文件访问与函数式编程入门]]></title>
    <url>%2Fpost%2F77be685a.html</url>
    <content type="text"><![CDATA[第5课 文件访问与函数式编程入门加号@七月在线 文本文件读写 二进制文件读写 文件和目录操作 序列化与反序列化 高阶函数 匿名函数 装饰器 偏函数 文本文件读写3种方法：第一种方法直接读入 In [ ]: file1 = open(“test.txt”)file2 = open(“output.txt”,”w”)while True: line = file1.readline() #这里可以进行逻辑处理 file2.write(&#39;&quot;&#39;+line\[:s\]+&#39;&quot;&#39;+&quot;,&quot;) if not line: break 记住文件处理完，关闭是个好习惯file1.close()file2.close() 读文件有3种方法： read()将文本文件所有行读到一个字符串中。 readline()是一行一行的读 readlines()是将文本文件中所有行读到一个list中，文本文件每一行是list的一个元素。 优点：readline()可以在读行过程中跳过特定行。 第二种方法：文件迭代器，用for循环的方法 In [ ]: file2 = open(“output.txt”,”w”)for line in open(“test.txt”): #这里可以进行逻辑处理 file2.write(&#39;&quot;&#39;+line\[:s\]+&#39;&quot;&#39;+&quot;,&quot;) 第三种方法：文件上下文管理器 In [ ]: 打开文件用with..open自带关闭文本的功能with open(‘somefile.txt’, ‘r’) as f: data = f.read()# loop整个文档with open(‘somefile.txt’, ‘r’) as f: for line in f: # 处理每一行# 写入文本with open(‘somefile.txt’, ‘w’) as f: f.write(text1) f.write(text2) …# 把要打印的line写入文件中with open(‘somefile.txt’, ‘w’) as f: print(line1, file=f) print(line2, file=f) 二进制文件读写Python默认读取的都是文本文件。要是想要读取二进制文件，需要把刚刚的’r’改成’rb’. In [ ]: f = open(‘EDC.jpg’, ‘rb’)print(f.read())# 输出 ‘\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00…’ # 十六进制表示的字节 简单说就是，任何非标准的文本文件（对于Py2来说，标准是ASCII，对于Py3来说，标准是unicode），你就需要用二进制读入这个文件，然后再用 .decode(‘…’)的方法来解码这个二进制文件： In [ ]: f = open(‘DegangGuo.txt’, ‘rb’)# 读入郭德纲老师的作文, 但是郭老师用的是参合着错别字的繁体编码，假设叫个”DeyunCode”# 那么你读入以后，就需要解码它u = f.read().decode(‘DeyunCode’) 文件和目录操作在图形界面的操作系统下，这个很简单，就是右键/拖拽 等等。 但是在Python的代码内该怎么做呢？ 基本操作用Python内置的os模块直接调用操作系统提供的接口函数： In [3]: import osos.name Out[3]: ‘posix’ 这里是通过OS告诉我们 我的操作系统的名字。 如果是posix，说明系统是#nix族，如果是nt，就是Windows 我们可以调用uname()来看看具体信息 环境变量在操作系统中定义的环境变量，全部保存在os.environ这个dict中，可以直接查看： In [ ]: os.environ 操作文件与目录查看、创建和删除目录可以这么调用： In [ ]: # 当前目录的绝对路径os.path.abspath(‘.’)# 比如这里返回：’/Users/EDC’# 在某个目录下创建一个新目录，# 首先把新目录的完整路径表示出来:os.path.join(‘/Users/EDC’, ‘Pictures’)# 这里你得到的是一个字符串，代表了新的文件夹是这个位置：/Users/EDC/Pictures/# 自己也可以拼起来，但是怕不同操作系统下的区分符问题，最好是用OS接口# 但是你还并没有创建任何的文件# 需要用mkdir创建：os.mkdir(‘/Users/EDC/Pictures/‘)# 同理，删除一个文件夹os.rmdir(‘/Users/EDC/Pictures/‘) 同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名： In [ ]: os.path.split(‘/Users/EDC/Pictures/AJiao.avi’)# (‘/Users/EDC/Pictures/‘, ‘AJiao.avi’) 或者靠os.path.splitext()得到文件扩展名： In [ ]: os.path.splitext(‘/Users/EDC/Pictures/AJiao.avi’)# (‘/Users/EDC/Pictures/AJiao’, ‘.avi’) 文件重命名： In [ ]: os.rename(‘JAV-001.avi’, ‘学习资料’) 删除文件 In [ ]: os.remove(‘学习资料’) 尴尬的是。。复制文件并不存在于os里。。(⊙﹏⊙)b 原因是复制这个操作，不是由操作系统提供的系统调用。 我们可以用上面的代码，读入一个文件，再写入一个文件，来达到复制的目的。 当然，Python作为一个Glue Language的调性，总有第三方库来帮我们stay lazy： Shutil就是其中一个。基本上可以看做是os的补充。它提供copyfile()方法，来复制你的文件: In [ ]: import shutilshutil.copyfile(‘/path/to/file’, ‘/path/to/other/file’) 这个库用起来比os爽很多。你们可以自己百度一下。看看文档。比较简单易用 小例子： 通过我们之前提过的方法，我们来看看怎么完成如下任务： 列出当前目录下的所有目录： In [ ]: [x for x in os.listdir(‘.’) if os.path.isdir(x)]# 你会得到一个list of 文件夹 只想列出.py文件： In [ ]: [x for x in os.listdir(‘.’) if os.path.isfile(x) and os.path.splitext(x)[1]==’.py’]# 列出所有的py文件 序列化和反序列化什么是序列化？ 程序运行的过程中，所有变量都是在内存中操作的，当程序一旦执行完毕，结束退出后，变量占有的内存就被操作系统回收了。 因此我们需要将某些数据持久化存储到磁盘中，下次运行的时候从磁盘中读取相关数据。 我们将变量从内存中变成可以存储或传输的过程称之为序列化，在Python中叫做pickling，在其它语言中也称之为 serialization、marshaling、flattening等等，说的都是一个意思。 反之，则为反序列化，称之为unpickling，把变量内容从序列化的对象重新读取到内存中。 序列化：In [ ]: import pickle# 此处定义一个dict字典对象d = dict(name=’思聪’, age=29, score=80)str = pickle.dumps(d) # 调用pickle的dumps函数进行序列化处理print(str)# 你可以看看它长什么样子# 定义和创建一个file文件对象，设定模式为wbf = open(‘dump.txt’, ‘wb’)# 将内容序列化写入到file文件中pickle.dump(d, f)f.close() # 最后关闭掉文件资源 反序列化：就是把刚刚的搞成的“序列化”的码，转成python看得懂的object In [ ]: import pickle# 从之前序列化的dump.txt文件里边读取内容f = open(‘dump.txt’, ‘rb’) # 设定文件选项模式为rbd = pickle.load(f) # 调用load做反序列处理过程f.close() # 关闭文件资源print(d)print(‘name is %s’ % d[‘name’]) 稍微注意一下，python2和python3里面的pickle不一样。 为了保证2，3的和谐，你可以用这个方法来保证你import正确： In [ ]: try: import cPickle as pickleexcept ImportError: import pickle 用JSON实现序列和反序列化同时，也许你们也会发现，这个pickle完的东西，是让人看不懂的。只有python自己可以把它unpickle回来。 如果我们有一个文件现在存下来，并且日后要在其他地方用到的话， 我们可以用JSON来做序列化。Python的数据结构跟Json有非常完美的兼容： JSON类型 Python类型 {} dict [] list “string” ‘str’或者u’unicode’ 1234.56 int或float true/false True/False null None 如果你有一个比较结构化的数据想要序列化，并且想要别的地方别的语言也能看得懂。那么你可以用JSON来做： In [ ]: import json# 定义dict字典对象d1 = dict(name=’小王’, age=20, score=80)str = json.dumps(d1) # 调用json的dumps函数进行json序列化处理print(str)# 调用json的loads函数进行反序列化处理d2 = json.loads(str) 高阶函数可以把别的函数作为参数传入的函数叫高阶函数。 举个例子：求绝对值的函数 abs() In [3]: abs(-10) Out[3]: 10 如果只写abs我们得到是它是一个叫abs的函数 In [2]: abs Out[2]: 上堂课我讲过，python里变量和函数都是object 那么就是说，abs这函数可以直接复制给另外一个变量： In [4]: f = absf(-9) Out[4]: 9 看，现在f有了abs的功能！既然如此，我们知道，函数本身就是可以作为一个变量。那我们的变量是可以作为另一个函数的参数的，那么一个函数也可以作为另一个函数的参数。 我们来看一个简单的高阶函数： In [5]: def add(x, y, f): return f(x) + f(y) 当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs： In [6]: add(-5, 6, abs) Out[6]: 11 匿名函数python 使用 lambda 来创建匿名函数。 lambda只是一个表达式，函数体比def简单很多。 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 最重要的一点，Lambda表达式可以体现你的逼格。华尔街和伦敦银行高街最逼的一群人都是自诩用且只用函数式编程的。什么是函数式编程？就是类似于全篇程序都用python中lambda这样的一行代码来解决问题。为什么他们逼？因为数学家们学编程的时候，脑子还在数学公式这条线上；他们不会写面对对象编程，只会死想出一条条公式来解决问题；其实这是智商堪忧的体现；但是因为投行基金们很倾向于聘用这群数学家转型的半吊子程序员；他们的使用习惯于是成了圈内高逼的体现；恩，葡萄就是这么酸。:P。 语法Lambda函数的语法只包含一个语句，如下： lambda [arg1 [,arg2,.....argn]]:expression 比如，我写个相加函数： In [7]: sum = lambda arg1, arg2: arg1 + arg2sum(10, 20) Out[7]: 30 楼上这个，实际上就是一个函数： def sum(arg1, arg2): return arg1 + arg2 除了Lambda本身，Python还提供了其他几个辅助工具，让你的函数式代码块更加牛逼： reducePython中的reduce内建函数是一个二元操作函数，他用来将一个数据集合(列表，元组等)中的所有数据进行如下操作：传给reduce中的函数func() (必须是一个二元操作函数)先对集合中的第1，2个数据进行操作，得到的结果再与第三个数据用func()函数运算，最后得到一个结果。 顾名思义，reduce就是要把一个list给缩成一个值。所以你必须用二元操作函数。 In [7]: from functools import reducel = [1,2,3,4,5]print(reduce(lambda x,y: x+y, l))# 这里代表着，把list中的值，一个个放进lamda的x,y中# 如果你给出一个初始值，可以放在list后面print(reduce(lambda x,y: x+y, l, 10))# 这样，x开始的时候被赋值为10，然后依次 1525 mapmap函数应用于每一个可迭代的项，返回的是一个结果list。如果有其他的可迭代参数传进来，map函数则会把每一个参数都以相应的处理函数进行迭代处理。map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。 格式：map(func, seq1[, seq2…] ) Python函数式编程中的map()函数是将func作用于seq中的每一个元素，并用一个列表给出返回值。 map可以使用任何的lambda函数操作，本质上是把原有的list根据lambda法则变成另外一个list In [2]: l = [1,2,3]new_list = list(map(lambda i: i+1, l))print(new_list)# Py3里，外面需要套个list：# 这是为了让里面的值给显示出来，要不然你会得到这是个map函数# 而不是里面的值。# Py2的童鞋不虚# 我们也可以把两个数组搞成一个单独的数组l2 = [4,5,6]new_list = list(map(lambda x,y: x+y, l, l2))print(new_list) [2, 3, 4][5, 7, 9] filterfilter()函数可以对序列做过滤处理，就是说可以使用一个自定的函数过滤一个序列，把序列的每一项传到自定义的过滤函数里处理，并返回结果做过滤。最终一次性返回过滤后的结果。 和map()类似，filter()也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 语法 filter(func, seq) In [7]: l = [100, 20, 24, 50, 110]new = list(filter(lambda x: x&lt;50, l))# 同理，py3得套个list来转化成list函数，便于打印出来print(new) [20, 24] 熟练运用以上三个玩意儿，你就可以一行写出几乎所有的复杂计算了。 装饰器装饰器就是函数的『包装』： 我们来看一个代码： In [9]: def hello(fn): def wrapper(): print(“hello, %s” % fn.__name__) fn() print(“goodby, %s” % fn.__name__) return wrapper@hellodef foo(): print(“i am foo”)foo() hello, fooi am foogoodby, foo 你可以看到如下的东西： 1）函数foo前面有个@hello的“注解”，hello就是我们前面定义的函数hello 2）在hello函数中，其需要一个fn的参数（这就用来做回调的函数） 3）hello函数中返回了一个inner函数wrapper，这个wrapper函数回调了传进来的fn，并在回调前后加了两条语句。 所以，本质上来讲，用@decorator来装饰某个函数时，其实是做了下面这件事儿： @decorator def func(): pass 变成 =====》 func = decorator(func) 再简单点说，就是把一个函数传到另外一个函数中，再调回给自己。 所以： hello(foo)返回了wrapper()函数，所以，foo其实变成了wrapper的一个变量，而后面的foo()执行其实变成了wrapper() 同理，我们也可以搞多个decorator： @decorator_one @decorator_two def func(): pass 相当于： func = decorator_one(decorator_two(func)) 你还可以给这个decorator带个参数： @decorator(arg1, arg2) def func(): pass 相当于： func = decorator(arg1,arg2)(func) 好了，讲这么多比较复杂，我们来看个网页编程的case: In [12]: def makeHtmlTag(tag, args, **kwds): def real_decorator(fn): css_class = “ class=’{0}’”.format(kwds[“css_class”]) \ if “css_class” in kwds else “” def wrapped(args, kwds): return “&lt;”+tag+css_class+”&gt;” + fn(*args, kwds) + “&lt;/“+tag+”&gt;” return wrapped return real_decorator@makeHtmlTag(tag=”b”, css_class=”bold_css”)@makeHtmlTag(tag=”i”, css_class=”italic_css”)def hello(): return “hello world”print(hello()) hello world 在上面这个例子中，我们可以看到：makeHtmlTag有两个参数。所以，为了让 hello = makeHtmlTag(arg1, arg2)(hello) 成功，makeHtmlTag 必需返回一个decorator（这就是为什么我们在makeHtmlTag中加入了real_decorator()的原因），这样一来，我们就可以进入到 decorator 的逻辑中去了—— decorator得返回一个wrapper，wrapper里回调hello。 这里插一个知识，我们看到parameters里面有个`(*args, **kwargds)`，指的是： 一个星星，指的是这里可以随便放多少个参数，内部提及的时候，当做一个list看。 两个星星指的也是随便多少个参数，但是这里可以带上参数的名字，比如（x=&#39;1&#39;, y=&#39;2&#39;），内部提及的时候，当做一个dict看。 Decorator这个东西，也可以写成class样式： In [13]: class myDecorator(object): def __init__(self, fn): print(“inside myDecorator.__init__()”) self.fn = fn def __call__(self): self.fn() print(“inside myDecorator.__call__()”)@myDecoratordef aFunction(): print(“inside aFunction()”)print(“Finished decorating aFunction()”)aFunction() inside myDecorator.__init__()Finished decorating aFunction()inside aFunction()inside myDecorator.__call__() 这个class样式的看起来比函数样式看着清楚点儿，这样我们再把刚刚的网页编程那段改一下，就得到： In [14]: class makeHtmlTagClass(object): def __init__(self, tag, css_class=””): self._tag = tag self._css_class = “ class=’{0}’”.format(css_class) \ if css_class !=”” else “” def __call__(self, fn): def wrapped(args, *kwargs): return “&lt;” + self._tag + self._css_class+”&gt;” \ + fn(*args, **kwargs) + &quot;&lt;/&quot; + self._tag + &quot;&gt;&quot; return wrapped @makeHtmlTagClass(tag=”b”, css_class=”bold_css”)@makeHtmlTagClass(tag=”i”, css_class=”italic_css”)def hello(name): return “Hello, {}”.format(name)print(hello(“Baby”)) Hello, Baby 装饰器的副作用： 因为decorator的因素，我们原本的函数其实已经变成了一个叫wrapper函数。 比如，你再调用__name__的时候，他会告诉你，这是 wrapper, 而不是 foo 或者 hello。 当然，虽然功能效果不变，但是有些处女座的童鞋会觉得很不爽。 所以，Python的functool包中提供了一个叫wrap的decorator来消除这样的副作用： In [17]: from functools import wrapsdef hello(fn): @wraps(fn) def wrapper(): print(“hello, %s” % fn.__name__) fn() print(“goodby, %s” % fn.__name__) return wrapper@hellodef foo(): ‘’’foo help doc’’’ print(“i am foo”) passfoo()print(foo.__name__)print(foo.__doc__) hello, fooi am foogoodby, foofoofoo help doc 来个经典例子： 斐波那契额数列递归法： In [8]: from functools import wrapsdef memo(fn): cache = {} miss = object() @wraps(fn) def wrapper(args): result = cache.get(args, miss) if result is miss: result = fn(args) cache[args] = result return result return wrapper@memodef fib(n): if n &lt; 2: return n return fib(n - 1) + fib(n - 2) 我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算fib(5)，于是其分解成fib(4) + fib(3)，而fib(4)分解成fib(3)+fib(2)，fib(3)又分解成fib(2)+fib(1)…… 你可看到，基本上来说，fib(3), fib(2), fib(1)在整个递归过程中被调用了两次。 而我们用decorator，在调用函数前查询一下缓存，如果没有才调用了，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。 偏函数Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。 偏函数又可以翻译成部分函数，大概意思就是说，只设置一部分参数。 举个例子，我们知道int()可以把字符串变成十进制数字： In [18]: int(‘12345’) Out[18]: 12345 但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换： In [19]: int(‘12345’, base=8) Out[19]: 5349 In [20]: int(‘12345’, 16) Out[20]: 74565 假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去： In [21]: def int2(x, base=2): return int(x, base) 这样，我们转换二进制就非常方便了： In [22]: int2(‘1000000’) Out[22]: 64 functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2： In [24]: import functoolsint2 = functools.partial(int, base=2)int2(‘1000000’) Out[24]: 64 所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值： In [25]: int2(‘1000000’, base=10) Out[25]: 1000000 最后，创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入： In [27]: int2 = functools.partial(int, base=2)int2(‘10010’) Out[27]: 18 实际上固定了int()函数的关键字参数base。 同理：我们刚刚说的**可以当成一个dict带入 In [29]: kw = {‘base’: 2}int(‘10010’, **kw) Out[29]: 18 继续同理，我们可以用*把一个list塞进来 In [30]: max2 = functools.partial(max, 10)max2(5, 6, 7) Out[30]: 10 相当于： In [31]: args = (10, 5, 6, 7)max(*args) Out[31]: 10 注意，10在最左边。 实战：今天的课程实践会结合上节课给你们的代码内容。 上节课我们讲了如果写个Dataset类来帮我们下载和处理数据。 这节课我们学习了文本的读入，那我们就来做做更加复杂的内容： 本节课的压缩包里有一个数据文件，是我们今天实战的数据。 这是美国亚利桑那州Pima印第安女人患有糖尿病状况的数据集（因为他们的得病率很高）。 这个数据是一个txt文件（其实是个csv），每一行就是一个数据条，长这样： 6,148,72,35,0,33.6,0.627,50,1 1,85,66,29,0,26.6,0.351,31,0 8,183,64,0,0,23.3,0.672,32,1 1,89,66,23,94,28.1,0.167,21,0 0,137,40,35,168,43.1,2.288,33,1 其中，前面N-1个数据，分别是一些身体的指标，比如：血压，血糖，身高，是否怀孕等等。 最后第N个数据点是记录她是否患有糖尿病，它只有0或者1两种可能。这也就是我们说的数据标签。 所以，这里我们脑海中应该浮现的数据结构如下： x = [ [6,148,72,35,0,33.6,0.627,50], [1,85,66,29,0,26.6,0.351,31], [8,183,64,0,0,23.3,0.672,32], ... ] y = [1,0,1,0,1,1,1,0,...] 所以，这是一个二元分类问题。 参照上一堂课的内容，我们要做如下的修改： Dataset这个类中的download_data函数要被修改，改成我们从外部读入数据的过程。并且要把我们的x和y分开储存，并返回。 我们这次依旧是以0.7的比率分开训练集和测试集。当我们得到区分开的 x_train, x_test, y_train, y_test以后，我们把这些个数据分别用Json或者Pickle的方法序列化在我们文件夹内。然后我们新建一个程序，从中反序列化我们处理好的数据。并进行之后的Machine Learning过程。 当我们把一个model训练好以后，我们代入全部的x_test数据，并得到我们预测出来的分类值y_preds。我们把这个值(list)与我们的y_test相互比较，用一些正确率统计的方法计算我们model的准确率，并用lambda函数来实现 预测数据的直接准确率怎么计算？ 准确率 = (对的数据数 / 全部数据数) * 100% 高级一点， 我们可以再实现一点其他准确率计算方式： AUC，MSE，… 详情可见附录的cheat sheet，或者自行百度。 OK！ 自己动手尝试一下吧！ 么么哒！ In [ ]:]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python第三节容器]]></title>
    <url>%2Fpost%2Fa807f4dd.html</url>
    <content type="text"><![CDATA[Python中所有的东西 都是类！Python 更强调的是应用是否一致，鸭子类型—是基于接口的，而不是有明确的继承关系的。区别于 Java的继承关系————在迭代器 一部分展现的特别好. 关于作业 ：翻转一个字符： def reverse(str_list, start, end): while( start &lt; end ): str_list[start],str_list[end] = str_list[end],str_list[start] start += 1 end -= 1setence = ‘Hello, how are you? Fine. ‘str_list = list(setence)i = 0while i &lt; len(str_list): if str_list[i] != ‘ ‘: #即不是空格 start = i end = start + 1 while ( end &lt; len(str_list) ) and str_list[end] != ‘ ‘: end += 1 reverse(str_list, start, end-1) i = end else: i+=1str_list.reverse()print(“”.join(str_list)) 字符串反转——先进行正向的每个word的翻转—再进行整个str_list的反转—最后把list # list join 为string 第三节—-本节要点： 容器 list/tuple dict set 切片 列表推导 生成器 迭代器 —-list 列表 序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。列表的数据项不需要具有相同的类型 tuple 元组（只读列表,不能写） li = [1, 2, 3, ‘456’, [1, 2, 3], {1: ‘one’, 2: ‘two’}] #这个是list元素中的print(type(list))print(type(li))# 元素访问print(li[0])print(li[-1]) # li[len(li) - 1]print(li[-2]) # li[len(li) - 2]# 查找元素位置print(li.index(‘456’))print(li.index([1, 2, 3]))# print(li.index(-1)) #会返回错误 不存在 -1，所以此时最好用 try catch 抛出异常尝试下.# 添加元素l_a = [1, 2, 3]l_a.append(4)l_a.append(5)l_b = [6, 7, 8]l_a.extend(l_b) # 试下用append是什么结果print(l_a)l_a = []if not l_a: print(‘Empty’) # not XX和is None不是一回事 所以应该为空 == False这样判断才对。if len(l_a) == 0: print(‘Empty’)for i in li: print(i)for i in range(len(li)): print(li[i])t = (1, 2, 3, ‘456’)print(type(t))# t[0] = ‘a’ #tuple元组 只读 不可改变！# t.append(‘x’)del(li[-1]) # del(list[index])del(li[1])del(li[-2])print(li) dict 字典 （key/value） 字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中。 set 集合 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算。 ---容器 - list/tuple基本操作 创建 添加元素（list only）：append, extend 删除元素（list only）：del, pop 根据索引读写（tuple只读） 判断容器是否为空 字符串转换 容器元素数量 遍历 参考代码：lesson_03_list_tuple.py 见上方 ---容器 - dict基本操作 初始化 访问 添加元素 修改元素 删除元素 判断key是否存在 判断容器是否为空 容器元素数量 遍历 参考代码：lesson_03_dict.py d = {‘a’: 1, ‘b’: 2, 1: ‘one’, 2: ‘two’, 3: [1, 2, 3]}print(type(dict))print(type(d))print(d)# 访问元素print(d[‘a’])print(d[1])print(d[3])# 判断key是否存在print(‘two’ in d)print(3 in d)del(d[3]) # del(dict[key])print(len(d))d[3] = [1, 2, 3, 4] #相当于添加了一项，所以dict里面是无序的d[3] = ‘1234’# 遍历for key in d: print(d[key])print(‘…’)for k, v in d.items(): print(k, v)print(‘…’)keys = d.keys()print(type(keys))print(keys) —-set 集合基本操作： 并/交/差集：|/union, &amp;/intersection, -/difference 对称差集：^/symmetric_difference（不同时出现在2个集合中的项） 包含关系：&gt;=/issuperset 添加元素 更新元素 删除元素 元素是否存在 容器元素数量 遍历 参考代码：lesson_04_set.py s_a = set([1, 2, 2, 3, 4, 5, 6])s_b = set([4, 5, 6, 7, 8, 9])print(s_a)print(s_b)# 判断元素是否存在print(5 in s_a)print(10 in s_b)# 并集print(s_a | s_b)print(s_a.union(s_b))# 交集print(s_a &amp; s_b)print(s_a.intersection(s_b))# 差集 A - (A &amp; B)print(s_a - s_b)print(s_a.difference(s_b))# 对称差 (A | B) - (A &amp; B)print(s_a ^ s_b)print(s_a.symmetric_difference(s_b))# 修改元素s_a.add(‘x’)s_a.update([4, 5, 60, 70])print(s_a)s_a.remove(70)print(s_a)# s_a.remove(100)print(len(s_a))for i in s_a: print(i)testSet = {-1 , 1}print(testSet)print(type(testSet))—-结果—-{1, 2, 3, 4, 5, 6, 7, 8, 9}{1, 2, 3, 4, 5, 6, 7, 8, 9}{4, 5, 6}{4, 5, 6}{1, 2, 3}{1, 2, 3}{1, 2, 3, 7, 8, 9}{1, 2, 3, 7, 8, 9}{1, 2, 3, 4, 5, 6, 70, ‘x’, 60}{1, 2, 3, 4, 5, 6, ‘x’, 60}8123456x60{1, -1} —-切片 存取序列（列表，元组，字符串）的任意一部分 格式：seq[开始索引:结束索引:步长] 默认值 负数索引 负数步长 参考代码：lesson_03_slice.py 大杀器 —— 关于 容器的切片print(“””—-容器的 切片开始—-“””)li = list(range(10))print(li)# 切片 [start:end:steps] &gt;= start &amp; &lt; endprint(li[2:5]) # [2, 3, 4]print(li[:4]) # [0, 1, 2, 3]print(li[5:]) # [5, 6, 7, 8, 9]print(li[0:20:3]) # [0, 3, 6, 9] 即超出索引大小，仍然按照自己的索引大小进行操作.# 负值怎么处理？print(li[5: -2]) # [5, 6, 7]]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【MFC】多边形的扫描转换算法]]></title>
    <url>%2Fpost%2Fdae6e7e.html</url>
    <content type="text"><![CDATA[前言：本程序在VS2015环境下面MFC工程-单文档-VS样式 建立 测试输出样本变量： int temp = 0;CStrrng str;str.Format(_T(“a = %d”),temp);MessageBox(str); 1. 目的：输入多边形顶点，对多边形进行填充，使用多边形扫描转换算法； 2. 实现： const int POINTNUM=6; //多边形点数. /**定义结构体用于活性边表AET和新边表NET*/typedef struct XET{ float x; float dx,ymax; struct XET next;}AET,NET;/**定义点结构体point**/struct point{ float x; float y;}polypoint[POINTNUM]={370,10,560,100,560,200,430,130,340,170,340,80};//多边形顶点//mypoint[POINTNUM]={100,100,200,100,200,200,100,200};//正方形// 250,50,550,150,550,400,250,250,100,350,100,100//{500,100,650,150,650,300,500,250,350,350,350,100};//多边形顶点/**计算最高点的y坐标(扫描到此结束)**/int MaxY=0;int MinY = 2000;int i;for( i = 0;i &lt; POINTNUM; i++ ){ if( polypoint[i].y &gt; MaxY ) { MaxY = polypoint[i].y; } if( polypoint[i].y &lt; MinY ) { MinY = polypoint[i].y; }}/**初始化AET表，即初始化活跃边表*/AET pAET = new AET;pAET-&gt;next = NULL;/**初始化NET表，即初始化边表**/NET pNET[1024];for( i = MinY;i &lt;= MaxY; i++ ){ pNET[i] = new NET; pNET[i]-&gt;next = NULL;}/**扫描并建立NET表，即建立边表*/for( i = MinY; i &lt;= MaxY; i++ ){ for( int j = 0;j &lt; POINTNUM; j++ ) { if( polypoint[j].y == i) { if( polypoint[ (j-1+POINTNUM) % POINTNUM ].y &gt; polypoint[j].y ) { NET p=new NET; p-&gt;x = polypoint[j].x; p-&gt;ymax = polypoint[ (j-1+POINTNUM) % POINTNUM ].y; p-&gt;dx = ( polypoint[ (j-1+POINTNUM)%POINTNUM ].x-polypoint[j].x ) / ( polypoint[ (j-1+POINTNUM) % POINTNUM ].y - polypoint[j].y ); p-&gt;next = pNET[i]-&gt;next; pNET[i]-&gt;next = p; } if( polypoint[ (j+1+POINTNUM ) % POINTNUM].y &gt; polypoint[j].y ) { NET p = new NET; p-&gt;x = polypoint[j].x; p-&gt;ymax = polypoint[ (j+1+POINTNUM) % POINTNUM ].y; p-&gt;dx = ( polypoint[ (j+1+POINTNUM) % POINTNUM ].x-polypoint[j].x ) / ( polypoint[ (j+1+POINTNUM) % POINTNUM ].y- polypoint[j].y ); p-&gt;next = pNET[i]-&gt;next; pNET[i]-&gt;next = p; } } }}/AET ptest1 = pNET[10]-&gt;next;AET ptest11 = pNET[10]-&gt;next-&gt;next;AET ptest111 = pNET[10]-&gt;next-&gt;next-&gt;next;AET ptest2 = pNET[80]-&gt;next;AET ptest22 = pNET[80]-&gt;next-&gt;next;AET ptest3 = pNET[100]-&gt;next;AET ptest33 = pNET[100]-&gt;next-&gt;next;AET ptest4 = pNET[130]-&gt;next;AET ptest44 = pNET[130]-&gt;next-&gt;next;AET ptest444 = pNET[130]-&gt;next-&gt;next-&gt;next;AET ptest5 = pNET[170]-&gt;next;AET ptest6 = pNET[200]-&gt;next; //**建立并更新活性边表AET*/for( i = MinY; i &lt;= MaxY; i++ ) // for循环中按下面的流程而不是《计算机图形学》徐长青第二版P38中Polygonfill算法中的while循环中的流程，{ // 这样可以处理书中的边界问题，无需开始时进行边缩短 //计算新的交点x,更新AET**/ NET p = pAET-&gt;next; while( p != NULL ) { p-&gt;x = p-&gt;x + p-&gt;dx; p = p-&gt;next; } //更新后新AET先排序**/ //断表排序,不再开辟空间 AET tq = pAET; p = pAET-&gt;next; tq-&gt;next = NULL; while( p != NULL ) { while( tq-&gt;next != NULL &amp;&amp; p-&gt;x &gt;= tq-&gt;next-&gt;x ) { tq = tq-&gt;next; } NET s = p-&gt;next; p-&gt;next = tq-&gt;next; tq-&gt;next = p; p = s; tq = pAET; } //(改进算法)先从AET表中删除ymax==i的结点**/ AET q = pAET; p = q-&gt;next; while( p != NULL ) { if( p-&gt;ymax == i) { q-&gt;next = p-&gt;next; delete p; p = q-&gt;next; } else { q = q-&gt;next; p = q-&gt;next; } } //将NET中的新点加入AET,并用插入法按X值递增排序**/ p = pNET[i]-&gt;next; q = pAET; while( p != NULL ) { while( q-&gt;next != NULL &amp;&amp; p-&gt;x &gt;= q-&gt;next-&gt;x) { q = q-&gt;next; } NET s = p-&gt;next; p-&gt;next = q-&gt;next; q-&gt;next = p; p = s; q = pAET; } /**配对填充颜色*/ p = pAET-&gt;next; while( p != NULL &amp;&amp; p-&gt;next != NULL ) { for(float j = p-&gt;x;j &lt;= p-&gt;next-&gt;x; j++) { pDC.SetPixel( static_cast(j), i, RGB(255,0,0) ); } // pDC.MoveTo( static_cast(p-&gt;x), i ); 用画直线来替换上面的设置像素点颜色，速度更快 // pDC.LineTo( static_cast(p-&gt;next-&gt;x), i ); p = p-&gt;next-&gt;next;//考虑端点情况 }}NET phead = NULL;NET pnext = NULL;//释放边表/for( i = MinY;i &lt;= MaxY;i++ ) //下面代码释放内存有点错误{ phead = pNET[i]; while( phead != NULL ) { pnext = phead-&gt;next; delete phead; phead = pnext; } pNET[i] = NULL;} ///释放活跃边表phead = pAET;while( phead != NULL ){ pnext = phead-&gt;next; delete phead; phead = pnext;} 上面建立的边表如下： 可以按照上面算法流程运行一次，可以发现算法可以正确运行 MFC实现：http://download.csdn.net/download/winernathan/4022374 若上面的for循环替换为《计算机图形学》徐长青第二版P38中Polygonfill算法中的while循环中的流程，如下所示： /**建立并更新活性边表AET*/ for( i = MinY; i &lt;= MaxY; i++ ) // for循环中按下面的流程而不是《计算机图形学》徐长青第二版P38中Polygonfill算法中的while循环中的流程， { // 这样可以处理书中的边界问题，无需开始时进行边缩短 NET p=pAET-&gt;next; AET q=pAET; //将NET中的新点加入AET,并用插入法按X值递增排序**/ p=pNET[i]-&gt;next; q=pAET; while(p) { while(q-&gt;next &amp;&amp; p-&gt;x &gt;= q-&gt;next-&gt;x) q=q-&gt;next; NET s=p-&gt;next; p-&gt;next=q-&gt;next; q-&gt;next=p; p=s; q=pAET; } /**配对填充颜色**/ p=pAET-&gt;next; while(p &amp;&amp; p-&gt;next) { for(float j=p-&gt;x;j&lt;=p-&gt;next-&gt;x;j++) pDC.SetPixel(static_cast(j),i,RGB(255,0,0)); p=p-&gt;next-&gt;next;//考虑端点情况 } //(改进算法)先从AET表中删除ymax==i的结点**/ q=pAET; p=q-&gt;next; while(p) { if(p-&gt;ymax==i) { q-&gt;next=p-&gt;next; delete p; p=q-&gt;next; } else { q=q-&gt;next; p=q-&gt;next; } } //计算新的交点x,更新AET**/ p=pAET-&gt;next; while(p) { p-&gt;x=p-&gt;x + p-&gt;dx; p=p-&gt;next; } //更新后新AET先排序*/ //断表排序,不再开辟空间 AET tq=pAET; p=pAET-&gt;next; tq-&gt;next=NULL; while(p) { while(tq-&gt;next &amp;&amp; p-&gt;x &gt;= tq-&gt;next-&gt;x) tq=tq-&gt;next; NET s=p-&gt;next; p-&gt;next=tq-&gt;next; tq-&gt;next=p; p=s; tq=pAET; } 可以发现y=80时，多边形内部并没有被填充，按照上面算法运行一次，可以发现其原因 算法思想参考： 《计算机图形学》徐长青第二版P38 转载来源：http://www.bccn.net/Article/kfyy/cjj/jszl/200810/8072.html 求出四条直线的两点式方程，按数学方法求两条直线交点不就OK啦？ 参考代码如下（需改进，要做四舍五入考虑）： C/C++ code //两点式交点//返回结果为-1时，无交点POINT AFX_API_EXPORT Intersection(SDLine l1, SDLine l2){ POINT lastP; DOUBLE k1,k2,b1,b2; //两条非垂直线 if(l1.x1-l1.x2!=0 &amp;&amp; l2.x1-l2.x2!=0) { b1=(l1.y1*l1.x2-l1.y2*l1.x1)/(l1.x2-l1.x1); b2=(l2.y1*l2.x2-l2.y2*l2.x1)/(l2.x2-l2.x1); k1=(l1.y1-l1.y2)/(l1.x1-l1.x2); k2=(l2.y1-l2.y2)/(l2.x1-l2.x2); if(k1-k2 != 0) { lastP.x=(b2-b1)/(k1-k2); lastP.y=(k1*b2-k2*b1)/(k1-k2); } else { lastP.x=-1; lastP.y=-1; } } //两条垂直线 if(l1.x1-l1.x2==0 &amp;&amp; l2.x1-l2.x2==0) { lastP.x=-1; lastP.y=-1; } //一条垂直线 if(l1.x1-l1.x2==0 &amp;&amp; l2.x1-l2.x2!=0) { b2=(l2.y1*l2.x2-l2.y2*l2.x1)/(l2.x2-l2.x1); k2=(l2.y1-l2.y2)/(l2.x1-l2.x2); lastP.x=l1.x1; lastP.y=k2l1.x1+b2; } //一条垂直线 if(l1.x1-l1.x2!=0 &amp;&amp; l2.x1-l2.x2==0) { b1=(l1.y1\l1.x2-l1.y2*l1.x1)/(l1.x2-l1.x1); k1=(l1.y1-l1.y2)/(l1.x1-l1.x2); lastP.x=l2.x1; lastP.y=k1*l2.x1+b1; } return lastP;}]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python第一二节]]></title>
    <url>%2Fpost%2Fd55cbe97.html</url>
    <content type="text"><![CDATA[Python 基础入门：调试方法见此链接. 第一节课 入门基础首先有爬虫和性能提升的测试. 本节课： python 应用场景丰富：接口测试、UI自动化、数据分析处理、机器学习与大数据分析，语法简单，技术成熟、大量的参考/例子代码. 你的生产力以及——解决问题的能力 是程序员必备的技能！生产力一定要牛批！ 效率提升： json——基于java的虚拟机去提升效率 或者用c++/c的底层在python中运用着去解决可能存在的慢的问题。 源的问题： pip install pandas //但是国外的源是需要翻墙的 pip list // 列举出已经安装上的包 pip -verbose install pandas //来查看自己安装这个包失败的原因/ 防火墙解决：——利用指定豆瓣的源 pip install -i —trusted-host http://pypi.douban.com/simple/ pandas 坑： pytz文件的不支持安装—— 去pandas官网上下载安装 建议: 在敲打代码的时候，语法细节不一定记得清楚。对于常用的语法最好在笔记本中记一下，用到了 复制粘贴一把。 推荐网站： https://lintcode.com/problem/ https://github.com/yingl/julyedu https://zhuanlan.zhihu.com/pythoner https://zhuanlan.zhihu.com/auxten https://zhuanlan.zhihu.com/zimei 语法相关——正式进入常量TrueFalseNone对象和容器classimportfromdel•判断•if•elif•else•is•in•assert•循环•for•while•continue //跳出当前循环•break•pass //什么都不做——因为缩进很是严格，pass 做一个填充、帮助编辑器、消除语义上的歧义.•异常•raise•try•except•finally•as•算术运算•+-/•%•*•//•比较运算•&gt;, &gt;=•&lt;, &lt;=•==•!=-print(100 2) //10000 幂指数-print(23 // 4) //只保留整数部分•逻辑运算•and•or•not•位运算•&gt;&gt;•&lt;&lt;•&amp;•|•^-print(not(c_1 == c_2)) #进行表示 异或的运算. # -- coding: utf-8 --# coding: utf-8 3.x不用担心上方 上方是进行 中文支持的操作添加.c_1 = Truec_2 = Falseprint(not(c_1 == c_2))print(16 &lt;&lt; 2)print(30 &lt;&lt; 3)print(70 &gt;&gt; 1)print(100 &gt;&gt;3) 位运算好处 ， 快速点def is_pow2(n): return (n &amp; (n-1)) == 0print(is_pow2(16))print(is_pow2(7))print(0b1101 &amp; 0b1011) #0b1001 9print(0b1101 | 0b1011) #0b1111 15print(0b1011 ^ 0b1011) #进行异或运算 0 单行注释“””第一行第二行注意这里 单双引号都是可以的!“”” 下面进行 换行和不换行str = “abcd” \ “efgh”print(str)str = “abcd\\nefgh”print(str)str = “””abcdefgh”””print(str) 对于转义字符print(“abcd’123’efgh”)print(‘abcd”123”efgh’)print(“abcd\\’123\\’efgh”)print(“你们好！”) 区别：1 3.x必须要加上()2 3.xUnicode编码3 除法运算，自动出现小数输出的结果print(1/3) 4 异常：3.x只能抛出继承自BaseException的异常5 range为实现惰性求值——了即只是你用到了这个数才给你分配这个数！现在rangee可以了 xrange取消这一个for i in range(5): print(i)x = [1,2,3,4,5]print(type(x))y = range(5)print(type(y)) 6 二进制和八进制 3.x必须强制携程0b1001和0o72367 不等式3.x 取消了 &lt;&gt; 表示的不等于 只有 != 了.8 表达式:3.x 必须使用repr函数9 多个模块改名:Queue-&gt;queue,repr-&gt;reprlib…数据类型方面:1 3.x取消了Long，统一为int2 新增bytes类型，并可与string相互转换3 dict的keys/items/values方法返回迭代器,iterkeys函数被废弃,has_key 被in取代.2个字节表示 16位的整数， 4个字节表示32位的整数print((1024).to_bytes(4, byteorder = “big”, signed = True)) #显示正常顺序的 16进制print((1024).to_bytes(4, byteorder = “little”, signed = False)) #显示反向的 16进制表示print((-1024).to_bytes(4, byteorder = “little”, signed = True)) #显示起始位为最小位 注意 前方有坑print((3124).to_bytes(2, byteorder = “big”)) #本来应该是 0x0c34 但是输出\\x0c4 #因为输出16进制 34时发现 asicall码是可打印字符4 #所以在出现灵异的事情的时候注意从asicall等本质上理解! print(“%x” % 3124)print(“%d” % 0x0c34) 输出： True642403512TrueFalse915abcdefghabcdefghabcdefghabcd’123’efghabcd”123”efghabcd’123’efgh你们好！0.33333333333333331234 b’\\x00\\x00\\x04\\x00’b’\\x00\\x04\\x00\\x00’b’\\x00\\xfc\\xff\\xff’b’\\x0c4’c343124 第二节： 变量和类型 常见字符串处理 条件判断 循环控制 函数 _•基本变量类型_•整数•浮点数•字符串•布尔值•空值•函数•模块•类型•自定义类型---_变量定义_ —— 在堆上分配相应的内存. 所以x=100 x=123.45 python可以进行数值类型的自由切换了！•变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。•基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。•变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。（弱类型）_变量赋值_•每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。（重要！！！）•等号（=）用来给变量赋值，等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。带有垃圾回收的语言——java所有的变量都是分配在堆上的，所以需要进行内存的回收堆：随分配随着创建，堆上全局的不清理栈：所有函数 是压入堆栈进行——所以 函数结束就会被清理干净了！---*_常见字符串处理_：•去除空格及特殊符号：strip, lstrip, rstrip•复制字符串：str1 = str2•连接字符串•str2 += str1•new_str = str2 + str1•查找字符串：pos = str1.index(str2)•比较字符串：cmp(str1, str2) //python3当中被移除了，所以直接 == &gt; &lt; 进行直接的比较即可！•字符串长度：len(str)•大小写转换•u_str = str.upper()•l_str = str.lower()注意： 空字符串(相当于false) 与 none字符串的区别：s3 = ‘’if s3 is None: print(“s3 is none”)elif not s3: print(“Empty!”)s4 = None;if s4 is None: print(“s3 is none”)elif not s4: print(“Empty!”)•首字母大写：str.capitalize(); string.capword(str) 大小写转换： s1=’abc’ print(s1.upper()) print(s1.upper().lower()) print(s1.capitalize()) //只是第一个字符大写•分割与合并字符串：split, splitlines, join //重要！# 分割和连接s = ‘abc,def,ghi’print(s.split(‘,’)) //返回[‘abc’,’def’,’ghi’]s = ‘123\\n456\\n789’numbers = s.splitlines() //按照行进行分割！print(numbers)print(‘-‘.join(numbers)) //abc-def-ghi 可以把结果进行合并回去！_—-What’s More:_•类型转换：int, float转换# 数字到字符串print(str(5))print(str(5.)) #5.0print(str(-5.23)) 字符转换成数字print(int(‘1234’))print(float(‘-23.456’))•格式化字符串# 格式化字符串print(‘Hello %s!’ % ‘world’)print(‘%d-%.2f-%s’ % (4, -2.3, ‘hello’))注意：1:%6.2f6表示数据表示至少6位,后面的.2表示小数点后保留两位比如2342.123415用这个表示的话，结果就是2342.12如果不足六位就会在前面补空格超过六位的话正常显示代码例子：int main(){float a=3425.1234;printf(“%6.2f”,a);return 0;}结果就是3425.12如果a=5.1234那结果就是： 5.12,前面有3个空格如果a=234525.123则结果过就是234525.122:转换 python不会自动补全print(int(‘123.45’)) #错误 因为自己字符要自己格式化成123 python不会给我们浮点数转换成整数print(float(‘123’)) #输出： 123.0print(int(‘110111’,2)) #55 2进制转换为 10进制 ，x进制转换为10进制！_—-常用的判断_# 常用判断s = ‘abcdefg’print(s.startswith(‘abc’))print(s.endswith(‘efg’))print(‘abcd1234’.isalnum()) #正常的字符print(‘\\tabcd1234’.isalnum()) #False 非正常的print(‘abcd’.isalpha()) #纯字母print(‘12345’.isdigit()) #纯数字print(‘ ‘.isspace()) #是不是空格print(‘acb125’.islower()) #是不是大写print(‘A1B2C’.isupper())print(‘Hello world!’.istitle()) #首字母是否大写 False 要想修改字符串：s = ‘asdaf’s = list(s)print(s) _—-条件判断：_if xx:elif xx:else:s4 = None;if s4 is None: #等价于 if not s4: print(“s3 is none”)elif not s4: print(“Empty!”)•真值判断•if x == True:•if x:•if not x:•空值判断•if x is None:•if not x:‘’ == False•比较•if a == b:•if a &gt; b:•…# for循环 s = 0for i in range(0, 101): #for i in 容器 range(start , end, step) s += iprint(s)# while循环s = 0i = 0while i &lt;= 100: s += i i += 1print(s)# continue/pass/breakfor i in range(0, 100, 1): if i &lt; 10: pass elif i &lt; 30: continue elif i &lt; 35: print(i) else: break 只打印了 30 31 32 33 34注意： python当中是没有 switch case的！ _•函数定义格式_ #可以返回一个 (1,2) 元组def func_name(arg_1, arg_2): print(arg_1, arg_2); return arg_1,arg_2r = func_name(1, 2)print(type(r),” “,r)•默认参数•可变参数：args，自动组装成tupledef func(x, y = 100): return x+yprint(func(y = 300,x = 200)) //python有自己的特性，直接在参数指定是哪个。 //这样就没有 特定的次序了！•关键字参数：args，自动组装成dict•命名关键字参数# 函数定义和默认参数def func(x, y = 500): print(x, y)func(150)func(100, 200)func(y = 300, x = 100) 可变参数 ！必须在最后!def func(name, *numbers): print(type(numbers)) #(1, 2, 3, 4, ‘abc’) #tuple - 元组 &lt;=&gt; 只读数组 print(numbers) print(numbers\[0\]) return &#39;Done&#39; func(‘Tom’, 1, 2, 3, 4, ‘abc’) #注意 1.即可在python这些个容器中，开始不用考虑元素类型！ 只是在后面计算时考虑类型进行计算# #2\. (1， 2) 在这里没有参数，所以不方便进行引用，所以考虑到用dic 字典类型 # 关键字参数def func(name, **kvs): # ** means key/value print(name) print(kvs)func(‘Jack’, china = ‘Beijing’, uk = ‘London’) #output is as list： Jack {&#39;china&#39;: &#39;BeiJing&#39;, &#39;uk&#39;: &#39;London&#39;} # 命名关键字参数def func(, china, uk): # 用于和普通参数做分割，args一样效果 print(china, uk)func(china = ‘Beijing’, uk = ‘London’) # 必须传入参数名# 复杂情况def func(a, b, c = 0, \args, **kvs): print(a, b, c, args, kvs)func(1, 2)func(1, 2, 3)func(1, 2, 3, ‘a’, ‘b’)func(1, 2, 3, ‘a’, ‘b’, china = ‘Beijing’, uk = ‘London’)func(1, 2, 3, (‘a’, ‘b’), *{‘china’:’Beijing’, ‘uk’:’London’}) #output： 1 2 0 () {} 1 2 3 () {} 1 2 3 (&#39;a&#39;, &#39;b&#39;) {} 1 2 3 (&#39;a&#39;, &#39;b&#39;) {&#39;china&#39;: &#39;Beijing&#39;, &#39;uk&#39;: &#39;London&#39;} 1 2 3 (&#39;a&#39;, &#39;b&#39;) {&#39;china&#39;: &#39;Beijing&#39;, &#39;uk&#39;: &#39;London&#39;} # 递归的经典例子！def fib(n): if n &lt; 1: raise ValueError elif (n == 1) or (n == 2): return 1 else: return fib(n - 1) + fib(n - 2)print(fib(1))print(fib(2))print(fib(3))print(fib(4))print(fib(5))print(fib(6))# hanoi塔问题：“””What’s More!”””“””def move(n,source,target,helper): if n == 1: print (source + ‘ -&gt; ‘ + target) else: move(n-1, source ,helper, target) print (source + ‘ -&gt; ‘ + target) move(n-1, helper, target, source)move(4, ‘A’, ‘B’, ‘C’)‘’’A -&gt; C: [2, 3, 4], [], [1]A -&gt; B: [3, 4], [2], [1]C -&gt; B: [3, 4], [1, 2]A -&gt; C: [4], [1, 2], [3]B -&gt; A: [1, 4], [2], [3]B -&gt; C: [1, 4], [], [2, 3]A -&gt; C: [4], [], [1, 2, 3]A -&gt; B: [], [4], [1, 2, 3]C -&gt; B: [], [1, 4], [2, 3]C -&gt; A: [2], [1, 4], [3]B -&gt; A: [1, 2], [4], [3]C -&gt; B: [1, 2], [3, 4], []A -&gt; C: [2], [3, 4], [1]A -&gt; B: [], [2, 3, 4], [1]C -&gt; B: [], [1, 2, 3, 4], []‘’’“””# 注意 python中 函数可以作为参数的！def_•函数调用_•函数名(参数名)•模块名.函数名(参数名)•带参数名调用_•什么是递归？_ python 中所有的对象都是 继承自object的类，都有自己的方法print(type(123))print(type(123.))print(type(123.45))print(type(“str”)) 开始容器的介绍print(“\\n关于容器”)print(type([1, 2, 3, ‘a’,’b’]))print(type((1, 2, 3, ‘a’,’b’)))print(type(set([1, 2, 3, ‘a’, ‘b’])))print(type({1: 2, 3: ‘a’,4:’b’})) 函数也是个对象def function(a ,b,c): print(a , b, c)print(type(function))import stringprint(type(string)) 定义类class MyClass(object): passprint(type(MyClass))myClass = MyClass();print(type(myClass)); python 所有都是对象！python 没有自己的变量类型try: print(x)except NameError: print(“NameError!”)print(“常见字符串的处理：”) python 当中字符串不能被修改s = “abc” s[0] = x 错误去除空格：s = “ addas fsad “print(s.strip())print(s.lstrip())print(s.rstrip()) 链接字符串s1 = ‘abc’s2 = ‘def’print(s1+ ‘\\n’ +s2) 大小写print(s1.upper())print(s1.upper().lower())print(s1.capitalize()) 空字符串(相当于false) 与 none字符串的区别：s3 = ‘’if s3 is None: print(“s3 is none”)elif not s3: print(“Empty!”)s4 = None;if s4 is None: print(“s3 is none”)elif not s4: print(“Empty!”)print(len(‘’)) 分割与链接s = ‘abc,def,ghi’splitted = s.split(‘,’)print(type(splitted))print(splitted)# 数字到字符串print(str(5))print(str(5.)) #5.0print(str(-5.23)) 字符转换成数字print(int(‘1234’))print(float(‘-23.456’))s = ‘asdaf’s = list(s)print(s) 关于 for循环count = 0;for i in range(0, 101): count += i;print(“count = “,count,”哈哈！”) 测试for j in range(0, 10): print(“当前测试的j: “,j); 测试 indexss=’abcd’dd=’efghabcd’position = dd.index(ss)print(“当前位置为：”,position)print(‘Hello %s!’ % ‘world’)print(‘%d-%.2f-%s’ % (4, -2.3, ‘hello’))print(“%1.2f-%s” % (-22.345,’你好!’)) 作业：print(‘打印10000以内的所有素数’) 第二小节：def func_name(arg_1, arg_2): print(arg_1, arg_2); return arg_1,arg_2r = func_name(1, 2)print(type(r),” “,r) 可变参数 ！必须在最后!def func(name, *numbers): print(type(numbers)) #(1, 2, 3, 4, ‘abc’) #tuple - 远足 &lt;=&gt; 只读数组 print(numbers) print(numbers\[0\]) return &#39;Done&#39; func(‘Tom’, 1, 2, 3, 4, ‘abc’) 字典类型 ** 意味着 key/valuedef funcc(name, **kvs): print(name) print(kvs)funcc(‘Jack’, china = ‘BeiJing’, uk = ‘London’) 有关于一些 复杂情况def func(a, b ,c = 0, *args, **kvs): print(a, b, c) print(args) print(kvs)func(1, 2)func(1, 2, 3)func(1, 2, 3, ‘a’, ‘b’)func(1, 2, 3, ‘a’, ‘b’, china = ‘Beijing’, uk = ‘London’)func(1, 2, 3, (‘a’, ‘b’), *{‘china’:’Beijing’, ‘uk’:’London’}) 有关于递归def my_sum(i): if i &lt; 0: raise ValueError elif i &lt;= 1: return i else: return i + my_sum(i-1)print(my_sum(1))print(my_sum(2))print(my_sum(3))print(my_sum(100)) 0 0 1 1f(n) = f(n-1) + f(n-2)def fib(n): if( n &lt; 1 ): raise ValueError elif( n&lt;= 2): return 1 else: return fib(n-1) + fib(n - 2)print(fib(1))print(fib(2))print(fib(3))print(fib(4))print(fib(5))print(fib(10)) #时间的 花费太长了. hanoi 问题def hanoi(n, source, target, helper): if n == 1: print(source ,’ -&gt; ‘, target) else: hanoi(n-1, source, helper, target) print(source ,’ -&gt; ‘, target) hanoi(n-1, helper, target, source)hanoi(4, ‘A’, ‘B’, ‘C’) 函数可以作为参数 -- 实现冒泡排序def cmp(x, y , cp = None): if not cp: if x &gt; y: return 1 elif x &lt; y: return -1 else: return 0 else: return cp(x, y) 全局 和 局部是隔离的不能用！def swap(x, y): temp = x; x = y; y = temp;def my_BubbleSort( x ): temp = 0; for i in range(0, len(x)-1, 1): for j in range(0, len(x)-i-1, 1): if x[j] &gt; x[j+1]: x[j],x[j+1] = x[j+1],x[j] “””temp = x[j]; x[j] = x[j+1]; x[j+1] = temp;””” print(x)x = [ 15, 225, 34, 42, 52, 6, 7856, 865, 954, 10]my_BubbleSort(x); python 实现打印10000以内的所有素数from math import sqrtdef primeNumber( n ): x = [] for i in range(2, n): flag = True; for j in range(2, int(sqrt(i))+1): if 0 == i%j: flag = False break if True == flag: print(i ,” “) x.append(i) return xx = primeNumber(100)print(x)“””What’s More!”””“””def move(n,source,target,helper): if n == 1: print (source + ‘ -&gt; ‘ + target) else: move(n-1, source ,helper, target) print (source + ‘ -&gt; ‘ + target) move(n-1, helper, target, source)move(4, ‘A’, ‘B’, ‘C’)‘’’A -&gt; C: [2, 3, 4], [], [1]A -&gt; B: [3, 4], [2], [1]C -&gt; B: [3, 4], [1, 2]A -&gt; C: [4], [1, 2], [3]B -&gt; A: [1, 4], [2], [3]B -&gt; C: [1, 4], [], [2, 3]A -&gt; C: [4], [], [1, 2, 3]A -&gt; B: [], [4], [1, 2, 3]C -&gt; B: [], [1, 4], [2, 3]C -&gt; A: [2], [1, 4], [3]B -&gt; A: [1, 2], [4], [3]C -&gt; B: [1, 2], [3, 4], []A -&gt; C: [2], [3, 4], [1]A -&gt; B: [], [2, 3, 4], [1]C -&gt; B: [], [1, 2, 3, 4], []‘’’“””]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前向传播以及BP（反向传播）.]]></title>
    <url>%2Fpost%2F9e23a3c4.html</url>
    <content type="text"><![CDATA[BP（backward propogation）神经网络 简单理解，神经网络就是一种高端的拟合技术。教程也非常多，但实际上个人觉得看看斯坦福的相关学习资料就足够，并且国内都有比较好的翻译： 人工神经网络概论，直接翻译与斯坦福教程：《神经网络 - Ufldl》 BP原理，直接翻译与斯坦福教程：《反向传导算法 - Ufldl》 网上公开课笔记：《Andrew Ng Machine Learning 专题【Neural Networks】下》三篇文章，详细的数学推导已经在里面，不赘述了。下面记录我在实现过程中碰到的一些总结与错误. 神经网络的过程 简单说，就是我有一堆已知的输入向量（每个向量可能有多维），每次读取一个向量（可能会有多维度），每个特征维度成为上图的输入层中一个输入节点。 每个维度的数值，将自己的一部分按照权值分配送给隐藏层。写程序时第一次的权值怎么办呢？其实（-1，1）随机化（绝不是0~1随机化）就好了，后续会逐渐修正。 这样隐含层每个节点同样有了自己的数值，同样道理，乘以权值再经过激活函数（根据需求选择，分类问题一般是 sigmoid 函数，数值拟合一般是 purelin 函数，也有特殊函数），最后传给输出节点。每个输出节点的每个值对应输出向量的一个特征维度 至此，我们完成了一次 forward pass 过程，方向是：输入层⇒⇒输出层。 熟悉神经网络的同学肯定知道，神经网络使用时有“训练”、“测试”两部分。我们现在考虑训练过程。每次 forward pass 过程之后，输出层的值与真实值之间，存在一个差，这个差记为 δδ。 此时我们根据公式，将误差作为参数传给隐藏层节点。 这些误差有什么用呢？还记得我们各个层之间的随机化的权值么？就是用来修正这个权值的。同理，修改输入层与隐藏层之间的权值，我们的视角到达输入层。 至此，我们完成了一次 backward pass 过程，方向是：输入层⇐⇐输出层。 第一个样本的一套做完了，即 forward pass + backward pass。 接下来呢？再做第二个样本的一套，并把误差与上一个样本误差相加；第三个样本的一套，加误差；……第N个样本的一套，加误差。等到所有样本都过了一遍，看误差和是否小于阈值（根据实际情况自由设定）时。如果不小于则进行下一整套样本，即： 清零误差；第一个样本，加误差；第二个样本，加误差；……第N个样本，加误差。误差和是否小于阈值…… 误差和达到阈值，妥了，不训练了此时输入一个测试样本，将各个特征维度的数值输入到输入层节点，一次 forward pass，得到的输出值就是我们的预测值。 易错点 既然这么通俗易懂，为什么实现中会出现错误呢？下面说说几个遇到的错误： 输入节点，究竟是每个样本的特征维度一个节点？还是每个样本一个节点？以为每个样本对应一个输出节点，是错误的。答案是每个特征一个输入节点； bias 必不可少！bias 是一个数值偏移量，不受上一层神经元的影响，在每个神经元汇总上一层的信息之后，都需要进行偏移之后再作为激活函数的输入。开头教程中有说明，这是为什么呢？举个例子，如果我们学习 XOR 问题，2个输入节点是0、0，如果没有 bias 所有隐含层节点都是同一个值，产生对称失效问题； 神经网络有多少隐含层、每个隐含层多少神经元、学习效率，都是需要调试的。没有确解，但要保证每次循环中，样本的误差和呈下降趋势 最后，是我参考的C++实现代码： ·BP神经网络头文件 pragma onceinclude include include include include using namespace std; define innode 2 //输入结点数define hidenode 4 //隐含结点数define hidelayer 1 //隐含层数define outnode 1 //输出结点数define learningRate 0.9//学习速率，alpha// --- -1~1 随机数产生器 —-inline double get_11Random() // -1 ~ 1{ return ((2.0(double)rand()/RAND_MAX) - 1);}// --- sigmoid 函数 —-inline double sigmoid(double x){ double ans = 1 / (1+exp(-x)); return ans;}// --- 输入层节点。包含以下分量：—-// 1.value: 固定输入值；// 2.weight: 面对第一层隐含层每个节点都有权值；// 3.wDeltaSum: 面对第一层隐含层每个节点权值的delta值累积typedef struct inputNode{ double value; vector weight, wDeltaSum;}inputNode;// --- 输出层节点。包含以下数值：—-// 1.value: 节点当前值；// 2.delta: 与正确输出值之间的delta值；// 3.rightout: 正确输出值// 4.bias: 偏移量// 5.bDeltaSum: bias的delta值的累积，每个节点一个typedef struct outputNode // 输出层节点{ double value, delta, rightout, bias, bDeltaSum;}outputNode;// --- 隐含层节点。包含以下数值：—-// 1.value: 节点当前值；// 2.delta: BP推导出的delta值；// 3.bias: 偏移量// 4.bDeltaSum: bias的delta值的累积，每个节点一个// 5.weight: 面对下一层（隐含层/输出层）每个节点都有权值；// 6.wDeltaSum： weight的delta值的累积，面对下一层（隐含层/输出层）每个节点各自积累typedef struct hiddenNode // 隐含层节点{ double value, delta, bias, bDeltaSum; vector weight, wDeltaSum;}hiddenNode;// --- 单个样本 —-typedef struct sample{ vector in, out;}sample;// --- BP神经网络 —-class BpNet{public: BpNet(); //构造函数 void forwardPropagationEpoc(); // 单个样本前向传播 void backPropagationEpoc(); // 单个样本后向传播 void training (static vector sampleGroup, double threshold);// 更新 weight, bias void predict (vector&amp; testGroup); // 神经网络预测 void setInput (static vector sampleIn); // 设置学习样本输入 void setOutput(static vector sampleOut); // 设置学习样本输出public: double error; inputNode inputLayer[innode]; // 输入层（仅一层） outputNode outputLayer[outnode]; // 输出层（仅一层） hiddenNode hiddenLayer[hidelayer][hidenode]; // 隐含层（可能有多层）}; ·BP神经网络源文件 include “BPnet.h”using namespace std;BpNet::BpNet(){ srand((unsigned)time(NULL)); // 随机数种子 error = 100.f; // error初始值，极大值即可 // 初始化输入层 for (int i = 0; i &lt; innode; i++) { inputLayer[i] = new inputNode(); for (int j = 0; j &lt; hidenode; j++) { inputLayer[i]-&gt;weight.push_back(get_11Random()); inputLayer[i]-&gt;wDeltaSum.push_back(0.f); } } // 初始化隐藏层 for (int i = 0; i &lt; hidelayer; i++) { if (i == hidelayer - 1) { for (int j = 0; j &lt; hidenode; j++) { hiddenLayer[i][j] = new hiddenNode(); hiddenLayer[i][j]-&gt;bias = get_11Random(); for (int k = 0; k &lt; outnode; k++) { hiddenLayer[i][j]-&gt;weight.push_back(get_11Random()); hiddenLayer[i][j]-&gt;wDeltaSum.push_back(0.f); } } } else { for (int j = 0; j &lt; hidenode; j++) { hiddenLayer[i][j] = new hiddenNode(); hiddenLayer[i][j]-&gt;bias = get_11Random(); for (int k = 0; k &lt; hidenode; k++) {hiddenLayer[i][j]-&gt;weight.push_back(get_11Random());} } } } // 初始化输出层 for (int i = 0; i &lt; outnode; i++) { outputLayer[i] = new outputNode(); outputLayer[i]-&gt;bias = get_11Random(); }}void BpNet::forwardPropagationEpoc(){ // forward propagation on hidden layer for (int i = 0; i &lt; hidelayer; i++) { if (i == 0) { for (int j = 0; j &lt; hidenode; j++) { double sum = 0.f; for (int k = 0; k &lt; innode; k++) { sum += inputLayer[k]-&gt;value inputLayer[k]-&gt;weight[j]; } sum += hiddenLayer[i][j]-&gt;bias; hiddenLayer[i][j]-&gt;value = sigmoid(sum); } } else { for (int j = 0; j &lt; hidenode; j++) { double sum = 0.f; for (int k = 0; k &lt; hidenode; k++) { sum += hiddenLayer[i-1][k]-&gt;value hiddenLayer[i-1][k]-&gt;weight[j]; } sum += hiddenLayer[i][j]-&gt;bias; hiddenLayer[i][j]-&gt;value = sigmoid(sum); } } } // forward propagation on output layer for (int i = 0; i &lt; outnode; i++) { double sum = 0.f; for (int j = 0; j &lt; hidenode; j++) { sum += hiddenLayer[hidelayer-1][j]-&gt;value hiddenLayer[hidelayer-1][j]-&gt;weight[i]; } sum += outputLayer[i]-&gt;bias; outputLayer[i]-&gt;value = sigmoid(sum); }}void BpNet::backPropagationEpoc(){ // backward propagation on output layer // -- compute delta for (int i = 0; i &lt; outnode; i++) { double tmpe = fabs(outputLayer[i]-&gt;value-outputLayer[i]-&gt;rightout); error += tmpe tmpe / 2; outputLayer[i]-&gt;delta = (outputLayer[i]-&gt;value-outputLayer[i]-&gt;rightout)(1-outputLayer[i]-&gt;value)outputLayer[i]-&gt;value; } // backward propagation on hidden layer // -- compute delta for (int i = hidelayer - 1; i &gt;= 0; i—) // 反向计算 { if (i == hidelayer - 1) { for (int j = 0; j &lt; hidenode; j++) { double sum = 0.f; for (int k=0; kdelta hiddenLayer[i][j]-&gt;weight[k];} hiddenLayer[i][j]-&gt;delta = sum (1 - hiddenLayer[i][j]-&gt;value) hiddenLayer[i][j]-&gt;value; } } else { for (int j = 0; j &lt; hidenode; j++) { double sum = 0.f; for (int k=0; kdelta hiddenLayer[i][j]-&gt;weight[k];} hiddenLayer[i][j]-&gt;delta = sum (1 - hiddenLayer[i][j]-&gt;value) hiddenLayer[i][j]-&gt;value; } } } // backward propagation on input layer // -- update weight delta sum for (int i = 0; i &lt; innode; i++) { for (int j = 0; j &lt; hidenode; j++) { inputLayer[i]-&gt;wDeltaSum[j] += inputLayer[i]-&gt;value hiddenLayer[0][j]-&gt;delta; } } // backward propagation on hidden layer // -- update weight delta sum &amp; bias delta sum for (int i = 0; i &lt; hidelayer; i++) { if (i == hidelayer - 1) { for (int j = 0; j &lt; hidenode; j++) { hiddenLayer[i][j]-&gt;bDeltaSum += hiddenLayer[i][j]-&gt;delta; for (int k = 0; k &lt; outnode; k++) { hiddenLayer[i][j]-&gt;wDeltaSum[k] += hiddenLayer[i][j]-&gt;value outputLayer[k]-&gt;delta; } } } else { for (int j = 0; j &lt; hidenode; j++) { hiddenLayer[i][j]-&gt;bDeltaSum += hiddenLayer[i][j]-&gt;delta; for (int k = 0; k &lt; hidenode; k++) { hiddenLayer[i][j]-&gt;wDeltaSum[k] += hiddenLayer[i][j]-&gt;value hiddenLayer[i+1][k]-&gt;delta; } } } } // backward propagation on output layer // -- update bias delta sum for (int i = 0; i &lt; outnode; i++) outputLayer[i]-&gt;bDeltaSum += outputLayer[i]-&gt;delta;}void BpNet::training(static vector sampleGroup, double threshold){ int sampleNum = sampleGroup.size(); while(error &gt; threshold) //for (int curTrainingTime = 0; curTrainingTime &lt; trainingTime; curTrainingTime++) { cout &lt;&lt; “training error: “ &lt;&lt; error &lt;&lt; endl; error = 0.f; // initialize delta sum for (int i = 0; i &lt; innode; i++) inputLayer[i]-&gt;wDeltaSum.assign(inputLayer[i]-&gt;wDeltaSum.size(), 0.f); for (int i = 0; i &lt; hidelayer; i++){ for (int j = 0; j &lt; hidenode; j++) { hiddenLayer[i][j]-&gt;wDeltaSum.assign(hiddenLayer[i][j]-&gt;wDeltaSum.size(), 0.f); hiddenLayer[i][j]-&gt;bDeltaSum = 0.f; } } for (int i = 0; i &lt; outnode; i++) outputLayer[i]-&gt;bDeltaSum = 0.f; for (int iter = 0; iter &lt; sampleNum; iter++) { setInput(sampleGroup[iter].in); setOutput(sampleGroup[iter].out); forwardPropagationEpoc(); backPropagationEpoc(); } // backward propagation on input layer // -- update weight for (int i = 0; i &lt; innode; i++) { for (int j = 0; j &lt; hidenode; j++) { inputLayer[i]-&gt;weight[j] -= learningRate inputLayer[i]-&gt;wDeltaSum[j] / sampleNum; } } // backward propagation on hidden layer // -- update weight &amp; bias for (int i = 0; i &lt; hidelayer; i++) { if (i == hidelayer - 1) { for (int j = 0; j &lt; hidenode; j++) { // bias hiddenLayer[i][j]-&gt;bias -= learningRate hiddenLayer[i][j]-&gt;bDeltaSum / sampleNum; // weight for (int k = 0; k &lt; outnode; k++) { hiddenLayer[i][j]-&gt;weight[k] -= learningRate hiddenLayer[i][j]-&gt;wDeltaSum[k] / sampleNum; } } } else { for (int j = 0; j &lt; hidenode; j++) { // bias hiddenLayer[i][j]-&gt;bias -= learningRate hiddenLayer[i][j]-&gt;bDeltaSum / sampleNum; // weight for (int k = 0; k &lt; hidenode; k++) { hiddenLayer[i][j]-&gt;weight[k] -= learningRate hiddenLayer[i][j]-&gt;wDeltaSum[k] / sampleNum; } } } } // backward propagation on output layer // -- update bias for (int i = 0; i &lt; outnode; i++) { outputLayer[i]-&gt;bias -= learningRate outputLayer[i]-&gt;bDeltaSum / sampleNum; } }}void BpNet::predict(vector&amp; testGroup){ int testNum = testGroup.size(); for (int iter = 0; iter &lt; testNum; iter++) { testGroup[iter].out.clear(); setInput(testGroup[iter].in); // forward propagation on hidden layer for (int i = 0; i &lt; hidelayer; i++) { if (i == 0) { for (int j = 0; j &lt; hidenode; j++) { double sum = 0.f; for (int k = 0; k &lt; innode; k++) { sum += inputLayer[k]-&gt;value inputLayer[k]-&gt;weight[j]; } sum += hiddenLayer[i][j]-&gt;bias; hiddenLayer[i][j]-&gt;value = sigmoid(sum); } } else { for (int j = 0; j &lt; hidenode; j++) { double sum = 0.f; for (int k = 0; k &lt; hidenode; k++) { sum += hiddenLayer[i-1][k]-&gt;value hiddenLayer[i-1][k]-&gt;weight[j]; } sum += hiddenLayer[i][j]-&gt;bias; hiddenLayer[i][j]-&gt;value = sigmoid(sum); } } } // forward propagation on output layer for (int i = 0; i &lt; outnode; i++) { double sum = 0.f; for (int j = 0; j &lt; hidenode; j++) { sum += hiddenLayer[hidelayer-1][j]-&gt;value hiddenLayer[hidelayer-1][j]-&gt;weight[i]; } sum += outputLayer[i]-&gt;bias; outputLayer[i]-&gt;value = sigmoid(sum); testGroup[iter].out.push_back(outputLayer[i]-&gt;value); } }}void BpNet::setInput(static vector sampleIn){ for (int i = 0; i &lt; innode; i++) inputLayer[i]-&gt;value = sampleIn[i];}void BpNet::setOutput(static vector sampleOut){ for (int i = 0; i &lt; outnode; i++) outputLayer[i]-&gt;rightout = sampleOut[i];} ·BP神经网络main函数实现：（我们这里使用典型非线性问题：XOR 测试）： include “BPnet.h”int main(){ BpNet testNet; // 学习样本 vector samplein[4]; vector sampleout[4]; samplein[0].push_back(0); samplein[0].push_back(0); sampleout[0].push_back(0); samplein[1].push_back(0); samplein[1].push_back(1); sampleout[1].push_back(1); samplein[2].push_back(1); samplein[2].push_back(0); sampleout[2].push_back(1); samplein[3].push_back(1); samplein[3].push_back(1); sampleout[3].push_back(0); sample sampleInOut[4]; for (int i = 0; i &lt; 4; i++) { sampleInOut[i].in = samplein[i]; sampleInOut[i].out = sampleout[i]; } vector sampleGroup(sampleInOut, sampleInOut + 4); testNet.training(sampleGroup, 0.0001); // 测试数据 vector testin[4]; vector testout[4]; testin[0].push_back(0.1); testin[0].push_back(0.2); testin[1].push_back(0.15); testin[1].push_back(0.9); testin[2].push_back(1.1); testin[2].push_back(0.01); testin[3].push_back(0.88); testin[3].push_back(1.03); sample testInOut[4]; for (int i = 0; i &lt; 4; i++) testInOut[i].in = testin[i]; vector testGroup(testInOut, testInOut + 4); // 预测测试数据，并输出结果 testNet.predict(testGroup); for (int i = 0; i &lt; testGroup.size(); i++) { for (int j = 0; j &lt; testGroup[i].in.size(); j++) cout &lt;&lt; testGroup[i].in[j] &lt;&lt; “\\t”; cout &lt;&lt; “— prediction :”; for (int j = 0; j &lt; testGroup[i].out.size(); j++) cout &lt;&lt; testGroup[i].out[j] &lt;&lt; “\\t”; cout &lt;&lt; endl; } system(“pause”); return 0;} -- 最终的实验结果基本正确：]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[科普-机器学习、深度学习、神经网络、深度神经网络之间有何区别？]]></title>
    <url>%2Fpost%2Ff59f2a56.html</url>
    <content type="text"><![CDATA[真应了《笑傲江湖》里那句：“有人的地方就会有江湖，有江湖就有恩怨。”只是这次的江湖和恩怨都源自人工智能而不是人。 今年1月中旬，纽约大学教授马库斯发表一篇万字长文，以问答形式，分14个问题回应那些对他的观点表示质疑的人，其中涉及纽约大学教授、脸书首席AI科学家杨立昆、AAAI前主席托马斯·迪特里奇，魁北克大学教授、谷歌的数学博士等也卷入了论战中。 这不是论战的第一回合，1月初，马库斯就提出了自己关于深度学习的十大观点，引得杨立昆直摆手：他说的都不对。 究竟是什么样的争议让AI界的大神们辩论火力如此密集，连战数日，费劲口舌、逐字力争呢？机器学习和深度学习变得越来越火。突然之间，不管是了解的还是不了解的，所有人都在谈论机器学习和深度学习。无论你是否主动关注过数据科学，你应该已经听说过这两个名词了。 为了展示他们的火热程度，我在 Google trend 上搜索了这些关键字： 如果你想让自己弄清楚机器学习和深度学习的区别，请阅读本篇文章，我将用通俗易懂的语言为你介绍他们之间的差别。下文详细解释了机器学习和深度学习中的术语。并且，我比较了他们两者的不同，别说明了他们各自的使用场景。 什么是机器学习和深度学习?让我们从基础知识开始：什么是机器学习？和什么是深度学习？如果你对此已有所了解，随时可以跳过本部分。 什么是机器学习？一言以蔽之，由 Tom Mitchell 给出的被广泛引用的机器学习的定义给出了最佳解释。下面是其中的内容： “计算机程序可以在给定某种类别的任务 T 和性能度量 P 下学习经验 E ，如果其在任务 T 中的性能恰好可以用 P 度量，则随着经验 E 而提高。” 是不是读起来很绕口呢？让我们用简单的例子来分解下这个描述。 示例 1：机器学习和根据人的身高估算体重 假设你想创建一个能够根据人的身高估算体重的系统（也许你出自某些理由对这件事情感兴趣）。那么你可以使用机器学习去找出任何可能的错误和数据捕获中的错误，首先你需要收集一些数据，让我们来看看你的数据是什么样子的： 图中的每一个点对应一个数据，我们可以画出一条简单的斜线来预测基于身高的体重。 什么是深度学习?“深度学习是一种特殊的机器学习，通过学习将世界使用嵌套的概念层次来表示并实现巨大的功能和灵活性，其中每个概念都定义为与简单概念相关联，而更为抽象的表示则以较不抽象的方式来计算。” 这也有点让人混乱。下面使用一个简单示例来分解下此概念。 示例: 猫 vs. 狗 我们举一个动物辨识的例子，其中我们的系统必须识别给定的图像中的动物是猫还是狗。阅读下此文，以了解深度学习在解决此类问题上如何比机器学习领先一步。 1.模式识别、机器学习、深度学习的区别与联系 模式识别：过去、程序/机器做智能的事、决策树等 机器学习：热点领域、给数据+学习数据 深度学习：前言领域、强调模型 2.早年神经网络被淘汰的原因 耗时、局部最优、竞争对手、over-fitting、参数 3.深度学习的实质 及其 与浅层学习的区别 深度学习实质：多隐层+海量数据——&gt;学习有用特征—–&gt;提高分类或预测准确性 区别：（1）DL强调模型深度 （2）DL突出特征学习的重要性：特征变换+非人工 4.神经网络的发展（背景之类的） MP模型+sgn—-&gt;单层感知机（只能线性）+sgn— Minsky 低谷 —&gt;多层感知机+BP+sigmoid—- (低谷) —&gt;深度学习+pre-training+ReLU/sigmoid 5.DL解决过拟合的方法 数据扩容、dropout技术 6.介绍dropout技术 修改神经网络本身来避免过拟合、训练网络的一种trike。 步骤：repeat { 随机‘删除’+BP获权值} 为何会避免过拟合：训练多个“半数网络”，随着训练的进行，大部分正确，小部分错误（不影响） 7.推导BP算法 http://blog.csdn.net/hungryof/article/details/50436231 8.BP算法为什么不能适应于深度学习 BP为传统多层感知机的训练方法，&lt;=5层&gt; （1）梯度越来越稀疏（梯度扩散&lt;—-非凸目标函数） （2）局部最小=””&gt; NOTE：解决其中局部最小值的方法：（1）多组不同随机参数，取最好参数 （2）启发式优化算法：模拟退火 或 遗传 （3）随机梯度下降 9.深度学习与传统神经网络之间的区别与联系 联系：分层结构 区别：训练机制（初始值） 10.介绍DNN（原理和应用） DNN：深度神经网络，广义上包含CNN，DBN，RNN等 优点：层数多，抽象能力强，模拟更复杂模型 应用：图像处理、语音识别、文本分类。。。 11.什么是深度学习、深度学习的训练过程是什么 无监督预训练(Layerwise Pre-Training)+有监督微调（fine-tune） 过程：（1）自下而上非监督学习特征 （2）自顶向下有监督微调 12.深度学习常用方法 全连接DNN（相邻层相互连接、层内无连接）： AutoEncoder(尽可能还原输入)、Sparse Coding（在AE上加入L1规范）、RBM（解决概率问题）—–&gt;特征探测器——&gt;栈式叠加 贪心训练 RBM—-&gt;DBN 解决全连接DNN的全连接问题—–&gt;CNN 解决全连接DNN的无法对时间序列上变化进行建模的问题—–&gt;RNN—解决时间轴上的梯度消失问题——-&gt;LSTM 13.RBM用途 （1）编码、降维 （2）得到权重矩阵和偏移量，供BP网络初始化训练 （3）可作为生成模型使用 （4）可作为判别模型使用 14.介绍DBN DBN是一个概率生成模型。 组成：多个RBM+BP网络 训练过程：（1）无监督训练每一层RBM网络、特征向量映射到不同特征空间、尽可能保留特征信息（贪心算法） （2）DBN最后一层设置为BP网络，有监督微调 RBM训练可以看作对一个深层BP网络的网络权值参数的初始化—-&gt;克服容易局部最优+训练时间长 优点：不用人工选取特征 缺点：（1）有标签样本集 （2）学习过程慢 （3）参数不当可能导致局部最优 公式推导： http://blog.csdn.net/app_12062011/article/details/54313082 15.介绍CNN 重点：局部感受域、权值共享 组成：卷基层、子采样层（池化层） 训练过程：不同小随机数初始参数—-&gt;repeat{ 前向传播（特征提取层C层—-&gt;特征映射层S层） + 后向传播 } 广义上的优点：（1）识别位移、缩放及其他形式扭曲不变性的二维图形 （2）隐式从训练数据中学习特征 （3）同一特征映射面的神经元权值相同—–&gt;课并行学习 （4）局部权值共享—-&gt;在语音识别、图像处理方面有优势、更接近实际生物神经网络、降低网络复杂性、避免特征提取和分类过程中的数据重建复杂度 较一般神经网络在图像处理方面的优点：（1）图像和网络拓扑更好吻合 （2）特征提取和模式分类同时进行，并同时在训练中产生 （3）权值共享—–&gt;减少参数、结构简单、适应性更强 应用：语音分析、图像识别等]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[打造个人IP——要想吃到鱼，你得像鱼儿一样思考]]></title>
    <url>%2Fpost%2F1c5651de.html</url>
    <content type="text"><![CDATA[1、怎样找到自己最精准的定位？ 需要研究三个方面，即作为定位基础的用户认知、定位导向的竞争对手和定位条件的自身。 2、如何进行用户研究 1）界定主要目标群体 2）研究用户是怎么思考的 3、如何站在用户角度思考用户行为 需要用到“心智阶梯”这个咨询工具，包括：“品牌阶梯”和“特性阶梯”。 1）品牌阶梯 在大脑对产品和品牌进行分类时，可想象成在大脑中形成了一个个梯子，每个梯子代表一类产品，每一个梯级代表一个品牌。 2）特性阶梯 1.物理特性 进行购买决策时，一般会有会有几个选择标准，这些标准，有的来自产品本身的特性，即物理特性。 2.精神特性 指的是购买标准来自外界赋予的精神层面的特性。 —02堂课程——定位三角：访谈和专家访谈 长远来看，不存在“拿着望远镜，都找不到对手” 本期要点： 1、如何研究竞争对手 1）界定主要竞争对手 2）发掘顾客为什么购买对手的理由？ 2、界定主要竞争对手的三条标准 1）市场比自己大的 2）对方的产品和自己是替代关系的 3）在替代过程中，能凸显自身的优势 3、如何发掘顾客购买对手的理由 到一线去问真实的顾客、把自己当做真实的顾客，把产品和相关知识，抛在脑后。 4、评估自身 评估外部资源和内部资源 1）外部资源指的是品牌是不是符合之前留在顾客心中的认知？是不是有冲突？ 2）内部资源指的是自己的产品或服务能不能填补发现的特性空缺？自己的资金是不是充足，能不能保障自己把这个山头给攻克下来？]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[近期学术导师制与SRT（大学生实践训练）结题总结与反思]]></title>
    <url>%2Fpost%2F6d36da8.html</url>
    <content type="text"><![CDATA[2018-4-14 近期我也终于在四月中旬完成了最终的所有项目的结题，也许之后还需要小改一下。 不过在近期的不断开发或者训练过程中发现了我的优势与不足，也明白了自己今后需要走的路， 现在将此时此刻的所思所想记录在此，不忘过去、不畏将来。 擅长： 擅长进行代码、算法的局部书写与实现、往往你都是在知道这种方法可行之后、才去进行响应方向的实践与探索； 擅长追随正能量、认为更加美好 能够提升自我和认知自我的美好的 人或事物在一起；也喜欢进行探索、设计； 擅长进行不断地努力进行自我提高，但是要真正的静下心来、不断量变、反思总结； 不擅长： 主次不够分明、学会抓住重点； 劳逸结合不够好、运动太少； 代码的全局性架构太少、不会软件工程的思想，进行相应的开发，静下心来一步步的实现； 建议： 多多进行全局性的思维与规划、做事学会流程图式的分解——大事情规划为小事情一步步解决； 学会抓住重点，不要将时间浪费在思考所谓的小事情上，抽出一点时间来锻炼身体！ 学会真正的忙——超脱、简单、静心 真正的闲，是心灵中超然物外;真正的忙，是工作里浑然忘我。真正的退，是处世时自然低调;真正的进，是做事中泰然担当。 真正的静，是生命里寂然涤思;真正的动，是世路上毅然向前。真正的记，是脑海里珍藏印记;真正的忘，是微笑里坦荡无余。 真正的情，是经历人生风雨，不忘初心，依然一路同行！]]></content>
      <categories>
        <category>总结反思</category>
        <category>日记之家</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[转]Struts2日期类型转换]]></title>
    <url>%2Fpost%2F6ae4c62.html</url>
    <content type="text"><![CDATA[Struts2日期类型转换 xs.setCssj(new java.sql.Date(xs.getCssj().getTime()));//在传入时可选择更改为sql.Date - 但是用 util.Date 也是可以的 由于我们在Struts2 jsp页面传给action之前的日期类型被——struts2的内置类型转换器给转换成了String类型&lt;或者是 转换器会根据目前所在的浏览器的语言类型，进行相应的日期类型的转换，只不过不是struts2对应的 内置相应语言的 日期罢了&gt;，所以为了统一所有的兼容性，我们就是需要进行-手动的 全局也好、局部属性的类型格式的string-date的转换. —-MORE—-在Java Web开发中，进行上述转换一般有以下几种：1、在Servlet中，这一切的转换我们得自己写代码完成；2、在Struts1.x中，我们通过apachecommons-beanutils中的converters来帮助完成这些事情；3、在Struts2中，使用的则是基于ongl的类型转换；……由于类型转换的通用性，因而Web框架都会实现大多数类型的转换功能，而不需要程序员编码实现。然而，对于java.util.Date这种类型的转换，各大框架似乎做得都不尽如人意。如：在Struts1.x中，该类型的转换就会有问题，很多人建议使用java.sql.Date这种类型来解决日期转换的问题（实际上可以自定义一个类型转换器来解决该问题）。在Struts2中，这个问题似乎依然存在，也许你从来没有遇到过。在开发的过程中，也许就像你一样，我没有对日期类型的转换做任何特殊的处理，而且Struts2也很好的帮我完成了转换。然而同事测试的时候却出现了一个“莫名其妙”的问题：输入一个常用格式的日期类型yyyy-MM-dd，到后台却报错：找不到对应的set方法——setEffDate(Ljava.lang.String)。的确，程序中只有setEffDate(java.util.Date)这个方法，没有setEffDate(Ljava.lang.String)这个方法。从Ljava.lang.String可以看出，传到后台的String类型并没有转换成Date类型，因而报错。查看struts2的源码：在XWorkBasicConverter类中private Object doConvertToDate(Map context, Object value, Class toType) ｛ 。。。。。｝发现使用 locale 来进行日期的格式化。而日期格式YYYY-MM-DD 只有在中文的语言环境才会有。查看DateFormat中关于SHORT、MEDIUM、LONG的说明，可以知道，对于yyyy-MM-dd这种日期类型，在英语语言中是没法匹配的，由于Struts2匹配日期时，使用了Locale，可见，IE浏览器默认的语言环境是英语。一经查看，果然如此，把中文设置为默认语言环境，再测试，没问题了。针对这个问题，我们没法要求客户一定设置中文为默认浏览器的语言环境。因而对于Date类型的转换，可以自己定义一个转换器。因而对于Date类型的转换，可以自己定义一个转换器。参考http://www.javaeye.com/wiki/struts2/1365-passing-parameters-in-struts2中的一个类型转换器定义（不适合国际化的环境），如需要，你可以定义自己的转换器可以将该转换器注册为全局的：在classpath下建立xwork-conversion.properties文件，内容为：java.util.Date=你的类型转换器的完整限定类名 针对日期类java.util.Date进行类型转换，要求客户端使用“yyyy-MM-dd”，“yyyy/MM/dd”中的任意一种输入，并以“yyyy-MM-dd”的格式输出，该类型转换应用于全局范围 先定义一个实体类： package cn.entity;import java.util.Date;public class User { private String username;//名字 private Integer age;//年龄 private Date birthday;//生日 public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; }} 创建Action： package cn.action;import cn.entity.User;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport{ private User user; public String execute(){ System.out.println(“姓名:”+user.getUsername()); System.out.println(“生日:”+user.getBirthday()); return SUCCESS; } public User getUser() { return user; } public void setUser(User user) { this.user = user; }} 创建类型转换器 StrutsTypeContentType类是抽象类，定义了两个抽象方法，用于不同的转换方向 1.public Object convertFromString(Map context, String[] values, Class toType)：将一个或多个字符串值转换为指定的类型 2.public String convertToString(Map context, Object object)：将指定对象转化为字符串 如果继承StrutsTypeContentType类编写自定义类型转换器，需重载以上两个抽象方法。 package cn.strutstypeconverter;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Map;import org.apache.struts2.util.StrutsTypeConverter;import com.opensymphony.xwork2.conversion.TypeConversionException;public class DateConverter extends StrutsTypeConverter{ //支持转换的多种日期格式，可增加时间格式 private final DateFormat[] dfs={ new SimpleDateFormat(“yyyy年MM月dd日”), new SimpleDateFormat(“yyyy-MM-dd”), new SimpleDateFormat(“MM/dd/yy”), new SimpleDateFormat(“yyyy.MM.dd”), new SimpleDateFormat(“yy.MM.dd”), new SimpleDateFormat(“yyyy/MM/dd”) }; /** * 将指定格式字符串转换为日期类型 / @Override public Object convertFromString(Map context, String[] values, Class toType) { String dateStr=values[0]; //获取日期的字符串 for (int i = 0; i &lt; dfs.length; i++) { //遍历日期支持格式，进行转换 try { return dfs[i].parse(dateStr); } catch (Exception e) { continue; } } //如果遍历完毕后仍没有转换成功，表示出现转换异常 throw new TypeConversionException(); } /\* * 将日期转换为指定的字符串格式 */ @Override public String convertToString(Map context, Object object) { Date date=(Date) object; //输出格式是yyyy-MM-dd return new SimpleDateFormat(“yyyy-MM-dd”).format(date); }} Struts2提供了两种方式配置转换器 1.应用于全局范围的类型转换器 在src目录创建xwork-conversion.properties java.util.Date=cn.strutstypeconverter.DateConverter 2.应用于特定类的类型转换器 在特定类的相同目录下创建一个名为ClassName-conversion.properties的属性文件 user.birthday=cn.strutstypeconverter.DateConverter 配置struts.xml： &lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE struts PUBLIC “-//Apache Software Foundation//DTD Struts Configuration 2.0//EN” “http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt; success.jsp index.jsp 开发输入与展示页面 index.jsp： &lt;%@ page language=”java” import=”java.util.*” pageEncoding=”utf-8”%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+”://“+request.getServerName()+”:”+request.getServerPort()+path+”/“;%&gt;&lt;%@taglib uri=”/struts-tags” prefix=”s”%&gt;&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”&gt; My JSP 'index.jsp' starting page 用户名: 年龄: 生日: success.jsp： &lt;%@ page language=”java” import=”java.util.*” pageEncoding=”utf-8”%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+”://“+request.getServerName()+”:”+request.getServerPort()+path+”/“;%&gt;&lt;%@taglib uri=”/struts-tags” prefix=”s”%&gt;&lt;%@taglib uri=”http://java.sun.com/jsp/jstl/core“ prefix=”c”%&gt;&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”&gt; My JSP 'index.jsp' starting page 成功 效果展示： 或 作者：Monodrama 出处：http://www.cnblogs.com/jingpeipei/ 本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文链接，否则保留追究法律责任的权利。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hibernate存取图片小实例]]></title>
    <url>%2Fpost%2F172ad485.html</url>
    <content type="text"><![CDATA[一般网站在处理用户上传图片时通常采用两种策略：一是直接把图片存入数据库中的Blob字段；二是数据库中只存储图片的在服务器上的路径信息 ，图片存放在分门别类的文件中，使用的时候从数据库读取路径信息到页面img元素即可．在此不讨论两种方案的优劣，我只是写了个hibernate的例子来实现第一种策略．例子很简单，t_user表主要两个字段，name和photo，其中photo字段类型为Blob．在此例中数据库我采用mysql，oracle的Blob字段比较特殊，你必须自定义类型，具体的请自行搜索，这方面的资料很多． //User.java package com.denny_blue.hibernate;import java.io.Serializable;import java.sql.Blob;public class User implements Serializable{ private Integer id; private String name; private Blob photo; /** * @return the id / public User(){ } public Integer getId() { return id; } /\* * @param id the id to set / public void setId(Integer id) { this.id = id; } /\* * @return the name / public String getName() { return name; } /\* * @param name the name to set / public void setName(String name) { this.name = name; } /\* * @return the photo / public Blob getPhoto() { return photo; } /\* * @param photo the photo to set */ public void setPhoto(Blob photo) { this.photo = photo; } } 类User有３个属性，id,name,photo，相应的getter和setter方法以及一个无参构造函数．应该注意的是photo的类型java.sql.Blob 相应的user.hbm.xml应该如下： &lt;?xml version=”1.0”?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN” “http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt; &lt;/hibernate-mapping&gt; 对应的hibernate.cfg.xml配置文件，不再列出，请参照hibernate文档自行设定． ＯＫ，做了这一步，我们写个测试类来进行单元测试： package com.denny_blue.test;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.sql.Blob;import org.hibernate.Hibernate;import org.hibernate.HibernateException;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.denny_blue.hibernate.User;import junit.framework.TestCase;public class HibernateTest extends TestCase { private Session session; protected void setUp() throws Exception { try{ Configuration config=new Configuration().configure(); SessionFactory sf=config.buildSessionFactory(); session=sf.openSession(); }catch(HibernateException e){ e.printStackTrace(); } } protected void tearDown() throws Exception { try{ session.close(); }catch(HibernateException e){ e.printStackTrace(); } } public void testSave()throws FileNotFoundException,IOException{ User user=new User(); user.setName(“jordan”); FileInputStream in=new FileInputStream(“C://test.gif”); Blob photo=Hibernate.createBlob(in); user.setPhoto(photo); Transaction tx=null; try{ tx=session.beginTransaction(); session.saveOrUpdate(user); tx.commit(); }catch(HibernateException e){ if(tx!=null) tx.rollback(); e.printStackTrace(); }finally{ in.close(); } } public void testLoad()throws Exception{ try{ User user=(User)session.load(User.class, new Integer(1)); Blob photo=user.getPhoto(); InputStream in=photo.getBinaryStream(); FileOutputStream out=new FileOutputStream(“C://out//test2.gif”); byte [] buf=new byte[1024]; int len; while((len=in.read(buf))!=-1){ out.write(buf, 0, len); } in.close(); out.close(); }catch(HibernateException e){ e.printStackTrace(); } }} 我们读取C盘目录下的test.gif并存储到数据库中，然后再取出来写入C:/out目录，此时你可以查看下数据表中photo显示为blob,表示已经成功存入．值的注意的代码片段就是： FileInputStream in=new FileInputStream(“C://test.gif”); Blob photo=Hibernate.createBlob(in);我们这里是从磁盘中读取图片，实际应用中你可以利用上传组件得到图片的２进制数据流，并利用Hibernate.createBlob方法来构造相应的Blob对象．而取图片则使用 InputStream in=photo.getBinaryStream(); 这只是个简单的测试类，如果我想从数据库中取出图片并现实在页面上该如何做呢？其实也很简单，我们先要写一个servlet，在它的service方法中取出图片，并＂画＂到指定页面上． package com.easyjf.asp.action;import java.io.InputStream;import java.io.OutputStream;import java.sql.Blob;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.hibernate.HibernateException;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;import com.denny)blue.hibernate.User;public class Test extends HttpServlet { /** * Destruction of the servlet. / private Session session; public void destroy() { try{ session.close(); }catch(HibernateException e){ e.printStackTrace(); } } /\* * Initialization of the servlet. * * @throws ServletException if an error occure */ public void init() throws ServletException { try{ Configuration config=new Configuration().configure(); SessionFactory sf=config.buildSessionFactory(); session=sf.openSession(); }catch(HibernateException e){ e.printStackTrace(); } } public void doGet(HttpServletRequest request,HttpServletResponse response) { try{ User user=(User)session.load(User.class, new Integer(1)); Blob photo=user.getPhoto(); InputStream in=photo.getBinaryStream(); OutputStream out=response.getOutputStream(); byte [] buf=new byte[1024]; int len; while((len=in.read(buf))!=-1){ out.write(buf, 0, len); } in.close(); out.close(); }catch(Exception e){ e.printStackTrace(); } }} 通过response.getOutputStream取得输出流，其他就与上段代码一致．servlet写好了，怎么在页面调用呢？那就更简单啦，直接在页面的img标签的src属性上调用该servlet即可，如： 简单的例子，希望对大家有帮助．]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Struts2：OGNL表达式，遍历List、Map集合；投影的使用]]></title>
    <url>%2Fpost%2F78312d06.html</url>
    <content type="text"><![CDATA[这里修改通过Servlet action传播到jsp。理解Servlet #。 理解Stack Context ，value stack 。username 传输不过来的原因—private了！ 对于标签中valuestack（值栈） 和 stack context（sc）：一些标签中的var=”0”只是当父类标签生命周期存的时候才放在值栈当中（即—放置在\[之间的这个地方\]）。 然而生命周期结束就会被放置在，JavaEE的OGNL自己的“银行”（sc）当中去！（有利于值栈资源的利用.） 阅读文章时理解难点是：值栈和sc 标签的使用 和 Servlet Request、ActionContext对于Servlet访问的理解，前者是jsp、Http提供的方法类，而后者是Struts2提供的访问Servlet的方法。 OGNL中$、%、#、{}、^、$ 标签的使用简介Struts2的ActionContext是来自于Ognl的上下文，是OGNL的一个增强，在Struts2的Context的根对象就是Action。因为只有根对象时可以直接访问的，不需要加任何标记，比如request,session,application这些对象在访问时都不需要加#号。 OGNL中$号的使用 1..在国际化资源文件中，引用OGNL表达式 2..在struts.xml文件中，引用OGNL表达式 OGNL中%号的使用 “%”符号的用途是在标签的属性值被理解为字符串类型时，告诉执行环境%{}里的是OGNL表达式。 这个类似js中的eval，很暴力。 1..使用%{}可以取出保存在值堆栈中的Action对象，直接调用它的方法 2..如果Action继承了ActionSupport，那么在页面标签中可以使用%{getText(‘key’)}获取国际化信息 OGNL中#号的使用 OGNL中的#号可以取出堆栈上下文中存放的对象 名称 作用 例子 attr 用于按request&gt;&gt;session&gt;&gt;application顺序访问其属性 attr.userName相当于按顺序从三个范围读取userName属性直到找到为止request 包含当前HttpServletRequest的属性的Map request.userName相当于request.getAttribute(“userName”)session 包含当前HttpSession的属性的Map session.userName相当于session.getAttribute(“userName”)application 包含当前应用的ServletContext的属性的Map application.userName相当于application.getAttribute(“userName”)parameters 包含当前HTTP请求参数的Map parameters.id[0]相当于request.getParameter(“id”) #符号的用途一般有三种： — 、访问非根对象属性，例如#session.msg表达式，由于Struts 2中值栈被视为根对象，所以访问其他非根对象时，需要加#前缀。实际上，#相当于ActionContext. getContext()；#session.msg表达式相当于ActionContext.getContext().getSession(). getAttribute(“msg”) 。 二、用于过滤和投影（projecting）集合，如persons.{?#this.age&gt;25}，persons.{?#this.name==’pla1’}.{age}[0]。 三、用来构造Map，例如示例中的#{‘foo1’:’bar1’, ‘foo2’:’bar2’}。 利用投影获取属性 利用投影获取List中对象的username属性时，其中{}表示的是一个集合 stus.{username}就表示将suts中所有的username属性取出组成一个新的列表 利用选择获取属性 OGNL表达式是很灵活的，可以同时使用选择技术与投影技术获取属性 使用选择技术时，#this代表当前元素，问号?是把所有满足条件的元素都取出来。 上箭头^是开始的意思，即取符合条件的数据索引中第一条数据，所以stus.{^#this.grade&gt;=60}.{username}输出的是[张三] 注意，此时输出文本中包含中括号，这表示它是一个列表。 而stus.{?#this.grade&gt;=60}.{username}[0]输出的是张三，是字符串，二者是不同的。 美元符号$是结束的意思，即取符合条件的数据索引中最后一条数据，所以stus.{$#this.grade&gt;=60}.{username}输出的是[王五] 这三个符号：问号、上箭头、美元符所返回的都是List 另符两语法： 使用Top语法获取值栈中的第二个对象的属性： 使用 N 语法获取值栈中的第二个对象的属性： OGNL是Object-Graph Navigation Language的缩写，它是一种功能强大的表达式语言（Expression Language，简称为EL），通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。 片头（ognl.jsp）&lt;% request.setAttribute(“para”, “request scope attribute”); request.getSession().setAttribute(“para”, “session scope attribute”); request.getSession().getServletContext().setAttribute(“para”, “aplication scope attribute”); List listStudent = new ArrayList(); listStudent.add(new Student(1, “张三”, new Date())); listStudent.add(new Student(2, “李四”, new Date())); listStudent.add(new Student(3, “赵五”, new Date())); listStudent.add(new Student(4, “孙六”, new Date())); listStudent.add(new Student(5, “钱七”, new Date())); pageContext.setAttribute(“listStudent”, listStudent);%&gt; 调用http://127.0.0.1:8080/st/ssh/demo6/ognl.jsp?para=hello 1. 通过OGNL表达式获取属性范围中的值&lt;br/&gt; HTTP parameters para = &lt;s:property value=&quot;#parameters.para&quot; /&gt; &lt;br/&gt; request attribute para = &lt;s:property value=&quot;#request.para&quot; /&gt; &lt;br/&gt; session attribute para = &lt;s:property value=&quot;#session.para&quot; /&gt; &lt;br/&gt; application attribute para = &lt;s:property value=&quot;#application.para&quot; /&gt; &lt;br/&gt; attr attribute para = &lt;s:property value=&quot;#attr.para&quot; /&gt; &lt;br/&gt; &lt;hr&gt; 输出：HTTP parameters para = hello request attribute para = request scope attribute session attribute para = session scope attribute application attribute para = aplication scope attribute attr attribute para = request scope attribute 2. 通过OGNL表达式创建list集合，并且遍历出集合中的值&lt;br&gt; &lt;s:set name=&quot;list&quot; value=&quot;{&#39;eeeee&#39;,&#39;ddddd&#39;,&#39;ccccc&#39;,&#39;bbbbb&#39;,&#39;aaaaa&#39;}&quot;&gt;&lt;/s:set&gt; &lt;s:iterator value=&quot;#list&quot; var=&quot;o&quot;&gt; ${o}&lt;br/&gt; &lt;!--&lt;s:property /&gt;--&gt; &lt;/s:iterator&gt; &lt;br/&gt; &lt;hr&gt; 输出： eeeee ddddd ccccc bbbbb aaaaa 3. 通过OGNL表达式创建Map集合，并且遍历出集合中的值&lt;br&gt; &lt;s:set name=&quot;map&quot; value=&quot;#{&#39;1&#39;:&#39;eeeee&#39;,&#39;2&#39;:&#39;ddddd&#39;,&#39;3&#39;:&#39;ccccc&#39;,&#39;4&#39;:&#39;bbbbb&#39;,&#39;5&#39;:&#39;aaaaa&#39;}&quot;&gt;&lt;/s:set&gt; &lt;s:iterator value=&quot;#map&quot; var=&quot;o&quot;&gt; ${o.key}-&gt;${o.value}&lt;br/&gt; &lt;!\-\- &lt;s:property value=&quot;#o.key&quot;/&gt;-&gt;&lt;s:property value=&quot;#o.value&quot;/&gt;&lt;br/&gt; --&gt; &lt;!\-\- &lt;s:property value=&quot;key&quot; /&gt;-&gt;&lt;s:property value=&quot;value&quot; /&gt; --&gt; &lt;/s:iterator&gt; &lt;br/&gt; &lt;hr&gt; 输出： 1-&gt;eeeee 2-&gt;ddddd 3-&gt;ccccc 4-&gt;bbbbb 5-&gt;aaaaa 4. 通过OGNL表达式，进行逻辑判断&lt;br&gt; &lt;s:if test=&quot;&#39;aaa&#39; in {&#39;aaa&#39;,&#39;bbb&#39;}&quot;&gt; aaa 在 集合{&#39;aaa&#39;,&#39;bbb&#39;}中； &lt;/s:if&gt; &lt;s:else&gt; aaa 不在 集合{&#39;aaa&#39;,&#39;bbb&#39;}中； &lt;/s:else&gt; &lt;br/&gt; &lt;s:if test=&quot;#request.req not in #list&quot;&gt; 不 在 集合list中； &lt;/s:if&gt; &lt;s:else&gt; 在 集合list中； &lt;/s:else&gt; &lt;br/&gt; &lt;hr&gt; 输出： aaa 在 集合{‘aaa’,’bbb’}中； 不 在 集合list中； 5. 通过OGNL表达式的投影功能进行数据筛选&lt;s:iterator value=&quot;#attr.listStudent.{?#this.id % 2 != 0}&quot; var=&quot;cur&quot;&gt; &lt;s:property value=&quot;#cur.username&quot;/&gt; &lt;/s:iterator&gt; &lt;br/&gt; &lt;s:iterator value=&quot;#attr.listStudent.{^#this.id % 2 != 0}&quot; var=&quot;cur&quot;&gt; &lt;s:property value=&quot;#cur.username&quot;/&gt; &lt;/s:iterator&gt; &lt;br/&gt; &lt;s:iterator value=&quot;#attr.listStudent.{$#this.id % 2 != 0}&quot; var=&quot;cur&quot;&gt; &lt;s:property value=&quot;#cur.username&quot;/&gt; &lt;/s:iterator&gt; &lt;br/&gt; &lt;s:property value=&quot;#attr.listStudent.{username}\[0\]&quot;/&gt; &lt;br/&gt; &lt;s:property value=&quot;#attr.listStudent.{$#this.id == 3}.{username}\[0\]&quot;/&gt; &lt;br/&gt; 输出： 张三 赵五 钱七 张三 钱七 张三 赵五 6. 通过OGNL表达式访问某个类的静态方法和值&lt;br&gt; &lt;s:property value=&quot;@java.lang.Maths@floor(32.56)&quot; /&gt; &lt;br/&gt; &lt;hr&gt; 输出： 32.0 7. OGNL表达式 迭代标签 详细&lt;br&gt; &lt;s:set name=&quot;list2&quot; value=&quot;{&#39;aa&#39;,&#39;bb&#39;,&#39;cc&#39;,&#39;dd&#39;,&#39;ee&#39;,&#39;ff&#39;,&#39;gg&#39;,&#39;hh&#39;,&#39;ii&#39;,&#39;jj&#39;}&quot;&gt;&lt;/s:set&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt; 索引 &lt;/td&gt; &lt;td&gt; 值 &lt;/td&gt; &lt;td&gt; 奇？ &lt;/td&gt; &lt;td&gt; 偶？ &lt;/td&gt; &lt;td&gt; 首？ &lt;/td&gt; &lt;td&gt; 尾？ &lt;/td&gt; &lt;td&gt; 当前迭代数量 &lt;/td&gt; &lt;/tr&gt; &lt;s:iterator value=&quot;#list2&quot; var=&quot;o&quot; status=&quot;s&quot;&gt; &lt;tr bgcolor=&quot;&lt;s:if test=&quot;#s.even&quot;&gt;pink&lt;/s:if&gt;&quot;&gt; &lt;td&gt; &lt;s:property value=&quot;#s.getIndex()&quot; /&gt; &lt;/td&gt; &lt;td&gt; &lt;s:property /&gt; &lt;/td&gt; &lt;td&gt; &lt;s:if test=&quot;#s.odd&quot;&gt;Y&lt;/s:if&gt; &lt;s:else&gt;N&lt;/s:else&gt; &lt;/td&gt; &lt;td&gt; &lt;s:if test=&quot;#s.even&quot;&gt;Y&lt;/s:if&gt; &lt;s:else&gt;N&lt;/s:else&gt; &lt;/td&gt; &lt;td&gt; &lt;s:if test=&quot;#s.first&quot;&gt;Y&lt;/s:if&gt; &lt;s:else&gt;N&lt;/s:else&gt; &lt;/td&gt; &lt;td&gt; &lt;s:if test=&quot;#s.isLast()&quot;&gt;Y&lt;/s:if&gt; &lt;s:else&gt;N&lt;/s:else&gt; &lt;/td&gt; &lt;td&gt; &lt;s:property value=&quot;#s.getCount()&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; 输出： 8. 完整代码（ognl.jsp）&lt;%@ page language=”java” import=”java.util.*,com.clzhang.ssh.demo6.Student” pageEncoding=”utf-8”%&gt;&lt;%@ taglib uri=”/struts-tags” prefix=”s”%&gt;&lt;% request.setAttribute(“para”, “request scope attribute”); request.getSession().setAttribute(“para”, “session scope attribute”); request.getSession().getServletContext().setAttribute(“para”, “aplication scope attribute”); List listStudent = new ArrayList(); listStudent.add(new Student(1, “张三”, new Date())); listStudent.add(new Student(2, “李四”, new Date())); listStudent.add(new Student(3, “赵五”, new Date())); listStudent.add(new Student(4, “孙六”, new Date())); listStudent.add(new Student(5, “钱七”, new Date())); pageContext.setAttribute(“listStudent”, listStudent);%&gt;&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”&gt; 1\. 通过OGNL表达式获取属性范围中的值 HTTP parameters para = request attribute para = session attribute para = application attribute para = attr attribute para = 2\. 通过OGNL表达式创建list集合，并且遍历出集合中的值 ${o} 3\. 通过OGNL表达式创建Map集合，并且遍历出集合中的值 ${o.key}->${o.value} --> --> 4\. 通过OGNL表达式，进行逻辑判断 aaa 在 集合{'aaa','bbb'}中； aaa 不在 集合{'aaa','bbb'}中； 不 在 集合list中； 在 集合list中； 5\. 通过OGNL表达式的投影功能进行数据筛选 6\. 通过OGNL表达式访问某个类的静态方法和值 7\. OGNL表达式 迭代标签 详细 索引 值 奇？ 偶？ 首？ 尾？ 当前迭代数量 Y N Y N Y N Y N Student.java（只用到部分方法） package com.clzhang.ssh.demo6;import java.util.*;public class Student { private int id; private String username; private int grade; private Date birthday; //只要是重写一个类的构造方法，就必须要为这个类保留空的构造方法 //因为框架默认的都会去调用无参的空的构造方法 public Student(){}; public Student(int id, String username, Date birthday) { this.id = id; this.username = username; this.birthday = birthday; } public Student(String username,int grade){ this.username = username; this.grade = grade; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getGrade() { return grade; } public void setGrade(int grade) { this.grade = grade; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } @Override public String toString() { //如果不重写它的toString()方法的话，默认调用toString()将输出【类型+@+内存地址的哈希值】 return “{学生姓名：” + username + “，成绩：” + grade + “}”; }} 更多阅读参考：struts2中的OGNL表达式（转） struts2：遍历自定义字符串数组，遍历Action实例所引用对象中的数组]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全科全程复习计划-考研]]></title>
    <url>%2Fpost%2Fe364ff6f.html</url>
    <content type="text"><![CDATA[“But why, some say, the moon? Why choose this as our goal? And they may well ask why climb the highest mountain? Why, 35 years ago, fly the Atlantic? Why does Rice play Texas?We choose to go to the moon We choose to go to the moon in this decade and do the other things, not because they are easy, but because they are hard. 你得考虑清楚你的人生与未来，你得挑战那些有点难度的事情，你得走出自己的舒适区而不要活得像条咸鱼。那些值得我们追逐和努力的，不是因为得到它们轻而易举，而是因为它们困难重重。 人生在世 俯仰之间 唯有追求卓越 但求尽其所能**. 回首这半年多的备考岁月，说平淡也平淡——每天图书馆、宿舍、食堂三点一线；但是说波澜却也确实有些波澜——有时一个人坐在宿舍情绪涌上心头便哭了。但是我敢保证，这篇文章绝对不是一篇煽情文，因为在整个备考过程中，我一直反反复复提醒和警惕自己的就是“不要随随便便自己感动自己”。你的努力和付出不是用来感动自己的，而是要把它变成一种再自然不过的习惯。全书、660题、概率论讲义、线代讲义、高数十八讲、30年真题、模拟题做个遍是应该的；不带手机去图书馆是应该的；反复研究英语真题是应该的；专业课课本翻了一遍又一遍是应该的……从来没有什么捷径可走，路就在那，一步一步往前走就好了。考研期间，从来没有所谓的五六点起床或者学到半夜十二点，重要的不是学习时间而是“有效学习时间”。凡事最怕认真**二字，是最简单不过的道理。“ 全科复习规划：专业课：武大计算机专硕目前考两门，数据结构与算法，计算机网络。 3月—4月+ 首先毫无疑问是看课本：李春葆主编的《数据结构教程》，其余三本是408的经典教材。有空可以把李春葆的那本数据结构对应的习题解析手册买回来刷一刷，也可以辅佐学长的视频。这个时间段也可以把武大17年的串讲班的课程看一下。结合武大课件。 计算机网络**-**谢希仁结合武大课件。 武大期末试题——明确方向。 5月—7月 王道两本单科书**-**反复的过程 有时间可以加天勤笔记刷下这两门 王道单科书最好看两遍，一遍以章节为序，做好摘抄的笔记，理解为主；一遍以专题为单位，做好套路的总结，辅以一定量的相关习题 (接下来王道四本单科书刷一遍。老老实实看，老老实实做题，不要说一看这个算法题我有思路就不写了，老老实实写在本子上，还有pv操作也是，实在不会写也可以在第二遍时写。) 8月—9月中旬 然后是计算机学科专业基础综合联考辅导教程，李春葆，张沪寅，曾平主编，可以直接淘宝二手购买此书籍。 接下来是408**真题，没什么好说的，全部刷完。这个很重要，今年计算机组成原理的一个大题就来自于14年408真题，只是稍微改动了一下。 接下来王道名校真题解析，可以去图书馆借13版本的，基本都没变过。继续查缺补漏。 最后可以刷武大真题，可以留两年到时候模拟，武大去年的真题不知道为什么没有，估计以后也不会有了，不过别怕，武大现在出题只会偶尔网络来一个偏题，还是选择题，我感觉武大真题这个时候反而参考性不大了 (王道名校真题解析或王道408联考知识点那本书（两本选一本就好），。最后做933往年真题，13年后题目质量比较高，尤其是15年的4套备考卷一定要每一题搞懂。还有余力可以做下王道模拟八套卷的选择题和算法题PV题。) 9月中旬—10月中旬 接下来王道单科书第二遍。第一次没写出来的题怎么着也要写了 王道单科书第二遍过完后，发现自己哪科复习的不好，可以再看一下综合联考指南后面封面上有四本书，哪科复习的不好去图书馆对应的借哪一本来看一下。（10月下旬） 11月 接下来王道单科书上的选择题再全部重做一遍，对了，王道单科书看的时候不要把答案写在上面，写在一个本子上，这样你可以看自己是那些题目错了，哪些题目反复错，这个时候可以直接去看课本对应的知识点。 接下来就是王道八套卷，这个八套卷就直接模拟，说实话，我实在没想到这个组成原理的第二个大题竟然就来自这个八套卷。 12月回归题目 所以，最后的时候408真题，王道八套卷，以及单科书的错题**都得好好看看。 最后再听一个串讲班，这个串加讲班我没听，不过听说网络出现原题了，不过也就一个选择题。至于具体的时间规划，你把书买回来，你看你自己要花多久时间看完。 数学二：得数学者得天下，复试的时候有一个问题就是你数学考了多少，选导师导师也直接问我数学考了多少，你要是数学考的太差，即使能上武大，导师也不是太愿意要你。 3月-4月中旬 高数**+**线性代数课本 数学首先看课本，辅导视频汤家凤讲课本的视频。 4月中旬—6月中旬 第二步：张宇高数18讲，李永乐线性代数讲义，辅导视频张宇的基础，李永乐基础。 7月 第三步：李永乐全书，辅导视频张宇强化，李永乐强化。这个时候其实也可以开始刷题了，比如张宇1000题或者汤家凤1800题，自己选一本，能刷多少刷多少，刷不完也不要紧。 8月 第四步：这个时候差不多8月了，8月这一个月你要一口气刷完31**年真题，使用书籍《张宇真题大全解》 9月 第五步：是时候看你的基础功底怎么样了，拿出李永乐的660，刷完它，同时看完冲刺视频。 10月-11月月 第六步：开启疯狂刷题模式，李永乐6+2，李正元400题，汤家凤8套卷，张宇8套卷，张宇4套卷，中途抽时间再把全书过一遍。 第七步：有空把最近十年真题再刷一遍，上面的模拟题刷不完就不刷了，当然你要是刷题刷上瘾了，推荐还有合工大数学二的题，也可以刷一刷。 12月 最后十二月看自己刷过的题目的错题**，看看自己还有哪些知识点掌握的不够牢固的，再回去看看对应的知识点（张宇18讲，李永乐线性代数讲义或者全书） 英语二：先说一下我的英语水平，四级第一次424，第二次440，六级第一次427，第二次450，考研英语二76分。 英语可以首先看一下王江涛的导学班，只看导学班，后面的视频后面再看。 3月—6月中旬 朱伟恋恋有词使劲背 毫无疑问记单词，红宝书每天在那里给我使劲背，背单词的方法是反复多遍，不一定要你这一次一定要把这个单词记住，太慢了，9月之前记单词这个行为是一直存在的，不管你背了几遍，我记得我当时背了两遍吧，也可以使用朱伟的恋恋有词，直接看视频就行，书你爱买不买，视频没看完也没问题。 接下来语法，推荐使用张满胜的三本语法书，把书看完，里面的题目老老实实刷完，我记得我看完这个语法书后基本考研的句子我都懂它的结构了。 接下来长难句，先看完何凯文的长难句视频，然后使用何凯文的长难句书籍，自己把里面的句子的主干找出来，能拆的尽量拆的详细点。 7月 然后就是刷真题了，张剑的黄皮书，对了，张剑的阅读80篇一定不要买，我怎么说这本书了，我记得当时阅读20个题目我经常只对4个，这本破书。当然张剑的真题解析还是很不错的。真题第一遍（7月）先只刷选择题，第二遍（8月—9月中旬，精读阅读）刷的时候加上翻译。第二遍刷真题的时候把每篇阅读自己翻译一遍，然后和张剑翻译的作对比，对了，你要是够恐怖，可以尝试把阅读背下来，晚上翻译一篇阅读，第二天早上背下来，这就是后期记单词的方法，在阅读中记单词，然后可以看王江涛的作文视频（9月开始），阅读背完了就可以开始背作文了，作文背个几篇后可以开始用王江涛的方法仿写作文，然后你觉得时间够的话把英语一（9月中旬开始刷英语一）的题买来刷，我记得我当时把张剑英语一的真题也刷了，只做英语一的完型，阅读，新题型。最后真题第三遍（差不多11月），这个时候基本要做到，没有一个句子不知道其结构，没有一个单词不认识，同时没有一个选项不知道其来源，就是说你要研究每个阅读题目给你挖的坑，怎么挖的，这样你在考试的时候，你才能知道它的套路，最后12月，把张剑的五套题买来模拟一下吧，掐时间。对了，英语也可以买字帖来练。作文的话要是你和我一样实在写不出来什么话的，十篇大作文，十篇小作文背的滚瓜烂熟，烂熟于心，随便给你一句话，你就知道是哪篇作文的，并且把整篇作文背出来，然后开始整理自己的模板，总结出一篇属于自己的模板，后面我会贴出自己总结的一篇模板，不过模板的话只能让你得一个平均分，我的英语选择题部分50，后面翻译加作文才26分，就一个平均分，也是没办法，本人作文实在不行，不过作文没成为我短板。对了，英语模板你要是自己总结出来了最好能找一个英语专业考研的人帮你看一下，差不多就是这些了。 以上三科的核心思想就是题海战术。 政治： 九月份开始**+结合报班-**节约时间 政治我选择题34，大题背肖四得了30，怎么说了，我基本都是实行的题海战术，后来考完了才知道政治不能用题海战术，我一直以为政治反复看，就能选对题，事实证明我错了，政治培养的是一种思维，一种爱党爱国爱人民的思维，资本主义丑陋龌龊，社会主义无比美好，算了，我说不下去了。但是我还是说几句吧，首先，下一个app，这个app叫学习中国，我发现那些政治考的比较高的，都是比较关心国家大事的，没事的时候可以看一看习大大的讲话，对你的政治只有好处，政治大概9月开始，使用视频肖秀荣的视频，先看肖秀荣的精讲简练，对了，马原第二章第三章的结构框图一定要会画，然后是看完大纲，然后背风中劲草，这本书是针对选择题的，同时刷肖秀荣的1000题，1000题有时间刷两遍，真题没必要刷了，这个时候再下一个app，叫考研政治，每次吃饭排队的时候刷一下选择题，然后是时政，直接用肖秀荣的时政，肖秀荣八套卷选择题刷完，有时间的话把米鹏的押题卷也刷一下，只刷选择题，这基本是用来猜选择题的，11月底看一下文都任燕翔的一个专门讲如何叫你答大题的视频，然后背肖四，给我使劲背，大家都是背的肖四，可以让你大题拿一个30分。 政治我的错就在以为政治也是一门考察知识点掌握怎么样的学科，所以我大纲看了两遍，刷了小草的选择题，刷了大纲解析1600题，模拟卷也是刷了蒋中庭的五套卷，石磊的模拟卷，后来发现这两货实在不行，吹牛皮倒是挺厉害的。考完当时我就觉得自己终于不用再看这些恶心巴拉的东西了。 — 933最新相关题型-经验贴从分值构成来说： 数据结构：24个选择题（每个2分），外用3个大题，第一个18分，第二个和第三个都是算法设计题，分值为12分每个； 计算机网络：12个选择题（每个2分），外加3个答题，第一个6分，第二个7分，第三个12分（记不太清楚了）； 从内容上面来说： 数据结构的选择题和往年重复率不高，但知识点还是考察往年那些知识点，把往年的知识点吃透就没问题了（二叉树，链表，队列，排序一类的），难度不难； 第一个数据结构大题考察结构体数组（几个班，几个学生，姓名，性别等属性），属于概念一类的题目，考察内容出处来源于武大平时的课后习题；第二个题目考察排序（把两个链表整合成一个，找到第k个大的值）；第三个题目考察哈夫曼编码（貌似是往年的408真题，这题我做的不好，望后来人多关注408里面的一些题目）大致上就这些了； 计算机网络的选择题依旧是比较偏，也就2到3个，其他的还是属于中规中矩的选择题（比较偏的题目有些是可以在武大ppt上找到的，多关注ppt上的内容会有好处），其他三个题目相对简单，第一个考察循环冗余码检验，第二个考察编码，也很简单的，第三个是平时常做的分配ip地址和子网掩码一类的题目，属于常规题目，试卷总体上难度适中。 调整以后的操作系统和计算机组成原理放到了复试的笔试里面，外加数据库原理，可能复试的比重会大一些，这也许是今后一个趋势，不过今年确实调整很多，注重基础性知识掌握是必要的，后续如果有什么心得我还会写出来，大家加油。 最后引用前辈的话作为后语： “**人生在世，俯仰之间，唯有追求卓越，但求尽其所能**”，与诸君共勉！ — 小周老师公共课高分规划K2&gt;K1 K2努力-学霸有完整完善且可执行的计划。执行力强 K1降低要求——看好自己专业课选择 9月份政治和专业课开始多起来时间 数学考高分：120+ 专业课：解决应试性，考高分 政治：学习目的节约时间 英语：过线！ 数学： 19年的数学大概率会简单——选拔性的考试 难度不是由题目决定的，而是由区分度决定的—— 做题要细心！！！ 1.过课本 9月份之前感受不到时间的紧张！ 上上策自己看课本：大量的要做题！ 做题——没有理由、直接做多的题目 就有感觉了！ 2.做全书 李永乐全书—-暑假过一遍！——应试性强！ 是最核心的阶段——整合体系、知道什么情况用啥 - 知识结合点 3.做真题 线性代数 概率论——1个半月 以作为主、看为辅！证明题目特别是！ 书不要买多了——买一套的 一套刷三遍刷精了就好！ 建议同学不看视频 就不看 效率有些低，自己过一遍 效率高点 多做 不会就问！ 结合个人情况-高效复习！！！ 政治： 9月份后花花咋时间（350/100h背诵） 单选题16-1 多选题17-2 主观题5-10 包含物大部分：1、马原（难且难理解！！！），其它四门课就是背 2、中国近现代史（屈辱史-目的：充分论证了歌颂和证明了只有中国共产党才能就中国 和奋斗史）——政治里面考历史-注意是在考政治！ 3、毛中特（毛泽东思想-100%是正确的因为去其糟粕而且 不等于毛泽东的思想是实事求是总结出来的、中国特色社会主义理论、）（马克思主义是具有持久生命力的——马克思主义不等于 马克思的主义！）——xidada思想 4、形势与政策 当今世界中发生的大事和要事。——新闻联播-主要考中国的事，看看习总去哪了。 中间十分钟——中国人民很幸福为什么中国人民很幸福——来考 为什么中国人民很幸福-党的好政策，外国人民生过载水深火热之中——但是我们这边风景正好 5、思想道德与法律修养——遵纪守法、道德高尚、爱国爱党 等九月份大纲出来进行复习。 考研前多干政治、真题 模拟题、每天两到三个小时-节约时间 英语： 过线就好 今年19届考试元年-今年应该难。 英语一难度在六级之上；60+高手、70+绝顶高手（研究生三年不学英语） 1.过线版本：过45分 一、题型：完形填空 20/0.5 传统阅读 4/10 新题型：1.）七个选出五个 2）选出五个来排顺序 翻译 ：五句/2 写作：小作文 十分、大作文二十分 二、有百分之六十的阅读 和 百分之四十的写作 阅读靠语感 三、写作主要靠这个：10 10 20 四、大于等于20分 靠小作文：1.单词 5500个（20%30%写作词汇，需要会写1600个，其它的见到了认识就行。） 2.不会写！：写作提高最快最有效的方法：多改！自己写的改，多改到自己可以驾驭的程度。 大作文： 2.高分版本： 词汇书+真题解析 真题走到极致！近十五年的！多写几轮——搞透为止！ 两件事真题：1.十五年内没有生词 2.所有的答案要知道正确和错误的原因&lt;为啥选，错在哪，命题的方向和点在哪？&gt; +学渣版本的写作来进行！！！]]></content>
      <categories>
        <category>日记之家</category>
        <category>考研</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Struts2相关应用]]></title>
    <url>%2Fpost%2Fe3c4992f.html</url>
    <content type="text"><![CDATA[要运用好struts等框架最好 将其背后的机理搞明白透彻。 回顾： ₪下载 ₪新建web工程 ₪添加lib ₪修改web.xml ₪添加jsp+action类 ₪配置struts.xml ₪部署运行 struts 工作流程 ₪1. Struts 2的工作流程■Struts 2框架中的配置文件struts.xml会起映射作用，它会根据“”来决定调用用户定义的哪个Action类。■例如在项目Struts 2中，请求为struts.action，前面“”的部分是“struts”，所以在struts.xml中有个Action类的name为“struts”，这表示该请求与这个Action来匹配，就会调用该Action中class属性指定的Action类。■但是在Struts 2中，用户定义的Action类并不是业务控制器，而是Action代理，其并没有和Servlet API耦合。所以Struts 2框架提供了一系列的拦截器，它负责将HttpServletRequest请求中的请求参数解析出来，传入到用户定义的Action类中。 ■（6）ActionSupport类 ActionSupport类为Action提供了一些默认实现，主要包括预定义常量、从资源文件中读取文本资源、接收验证错误信息和验证的默认实现。 下面是ActionSupport类所实现的接口： public class ActionSupport implements Action, Validateable, ValidationAware, TextProvider, LocaleProvider,Serializable {} Action接口同样位于com.opensymphony.xwork2包，定义了一些常量和一个execute()方法。 public interface Action { public static final String SUCCESS=”success”; public static final String NONE=”none”; public static final String ERROR=”error”; public static final String INPUT=”input”; public static final String LOGIN=”login”; public String execute() throws Exception;} ₪Struts 2数据验证有两种实现方式： ■Action类中validate方法 ■继承ActionSupport ■覆写validate方法（或者新建命名规则为validata*的方法） ■增加“input”的result ■JSP页面中用标签 ■验证框架（xml） ■位置：与Action类同一路径下 ■命名： X-validation.xml X--validation.xml 校验器：conversion validator 、date validator 、double validator 、email validator 、expression validator 、fieldexpression validator 、int validator 、regex validator 、required validator 、requiredstring validator 、stringlength validator 、url validator 、visitor validator]]></content>
      <categories>
        <category>JavaClass</category>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图书馆座位预约脚本]]></title>
    <url>%2Fpost%2F320e2620.html</url>
    <content type="text"><![CDATA[掌握技术者。需慎独。 抢座太耗精力，所以闲来无事，在服务器上搞了预约图书馆座位的脚本。 centOS下升级python版本，详细步骤 !注意我的目录是/usr/local/python3/1、可利用linux自带下载工具wget下载，如下所示：（笔者安装的是最小centos系统，所以使用编译命令前，必须安装wget服务，读者如果安装的是界面centos系统，或者使用过编译工具则可跳过安装wget，直接进行下边的编译步骤 ）wget http://www.python.org/ftp/python/3.3.0/Python-3.3.0.tgz2、下载完成后到下载目录下，解压tar -xzvf Python-3.3.0.tgz3、进入解压缩后的文件夹cd Python-3.3.0 4、在编译前先在/usr/local建一个文件夹python3（作为python的安装路径，以免覆盖老的版本）mkdir /usr/local/python3 （此处新建文件夹用mkdir，如果是新建文件则用touch） 5、开始编译安装（笔者安装的是最小centos系统，所以使用编译命令前，必须安装编译套件gcc，读者如果安装的是界面centos系统，或者使用过编译工具则可跳过安装gcc，直接进行下边的编译步骤）./configure —prefix=/usr/local/python3makemake install6、此时没有覆盖老版本，再将原来/usr/bin/python链接改为别的名字（笔者保留了两个版本的，一个python，一个python3，所以第6步笔者略过，把第7步的链接后名字改为python3，读者可按正常步骤，实现的效果相同）mv /usr/bin/python /usr/bin/python_old2 7、再建立新版本python的链接ln -s /usr/local/python3/bin/python3 /usr/bin/python 8、这个时候输入python -V 10、就会显示出python的新版本信息[idolaoxu@localhost home]# python -VPython 3.3.0PS：如果不建立新安装路径python3，而是直接默认安装，则安装后的新python应该会覆盖linux下自带的老版本，也有可能不覆盖，具体看安装过程了，这个大家可以自己试验下，当然如果还想保留原来的版本，那么这种方法最好不过了。 Install pip3 for python 3.x 要注意其实python3 文件夹-bin目录下已经有一个，pip3，pip3.6了！ 过程当中出现python requests环境错误——使得我不得不 /…/pip3 uninstall requests 然后重新 /…/pip3 install requests Python 日志输出 代码如下： # !/usr/bin/env python# coding=utf-8import requestsimport jsonimport timeimport sysimport logging# 配置文件作为参数传入预约第二天的座位# 座位转换# from ‘第一阅览室001’ to seat-id = 22558ROOM = “”” {“status”:”success”,”data”:[{“roomId”:41,”room”:”第一阅览室”,”floor”:2,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:136,”free”:136},{“roomId”:12,”room”:”第二阅览室中区”,”floor”:3,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:48,”free”:48},{“roomId”:11,”room”:”第二阅览室北区”,”floor”:3,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:196,”free”:196},{“roomId”:13,”room”:”第二阅览室南区”,”floor”:3,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:172,”free”:172},{“roomId”:15,”room”:”第十一阅览室中区”,”floor”:3,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:48,”free”:48},{“roomId”:14,”room”:”第十一阅览室北区”,”floor”:3,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:188,”free”:188},{“roomId”:16,”room”:”第十一阅览室南区”,”floor”:3,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:156,”free”:156},{“roomId”:18,”room”:”第三阅览室中区”,”floor”:4,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:48,”free”:48},{“roomId”:17,”room”:”第三阅览室北区”,”floor”:4,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:148,”free”:148},{“roomId”:19,”room”:”第三阅览室南区”,”floor”:4,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:120,”free”:120},{“roomId”:21,”room”:”第十阅览室中区”,”floor”:4,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:48,”free”:48},{“roomId”:22,”room”:”第十阅览室南区”,”floor”:4,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:164,”free”:164},{“roomId”:35,”room”:”第九阅览室中区”,”floor”:5,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:48,”free”:48},{“roomId”:34,”room”:”第九阅览室北区”,”floor”:5,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:195,”free”:195},{“roomId”:36,”room”:”第九阅览室南区”,”floor”:5,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:172,”free”:172},{“roomId”:32,”room”:”第四阅览室中区”,”floor”:5,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:48,”free”:48},{“roomId”:31,”room”:”第四阅览室北区”,”floor”:5,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:148,”free”:148},{“roomId”:33,”room”:”第四阅览室南区”,”floor”:5,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:164,”free”:164},{“roomId”:38,”room”:”第五阅览室中区”,”floor”:6,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:48,”free”:48},{“roomId”:8,”room”:”第五阅览室北区”,”floor”:6,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:59,”free”:59},{“roomId”:37,”room”:”第五阅览室南区”,”floor”:6,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:173,”free”:173},{“roomId”:47,”room”:”第八阅览室中区”,”floor”:6,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:48,”free”:48},{“roomId”:9,”room”:”第八阅览室北区”,”floor”:6,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:204,”free”:204},{“roomId”:40,”room”:”第八阅览室南区”,”floor”:6,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:176,”free”:176},{“roomId”:27,”room”:”第七阅览室中区”,”floor”:7,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:48,”free”:48},{“roomId”:46,”room”:”第七阅览室北区”,”floor”:7,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:132,”free”:132},{“roomId”:28,”room”:”第七阅览室南区”,”floor”:7,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:108,”free”:108},{“roomId”:24,”room”:”第六阅览室中区”,”floor”:7,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:48,”free”:48},{“roomId”:23,”room”:”第六阅览室北区”,”floor”:7,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:132,”free”:132},{“roomId”:25,”room”:”第六阅览室南区”,”floor”:7,”reserved”:0,”inUse”:0,”away”:0,”totalSeats”:108,”free”:108}],”message”:””,”code”:”0”}“””ROOM = json.loads(ROOM)ROOM = ROOM[‘data’]def get_seat_id(loc, token): local_room = loc[:-3] local_seat = loc[-3:] #for one room\_id = \[x for x in ROOM if x\[&#39;room&#39;\] == local\_room\]\[0\]\[&#39;roomId&#39;\] room\_layer\_url = &#39;http://seat.ujn.edu.cn/rest/v2/room/layoutByDate/&#39; + str(room_id) + &#39;/2018-03-0&#39; \ &#39;8?token=&#39; + token r = requests.get(room\_layer\_url) layer = json.loads(r.text) layer = layer\[&#39;data&#39;\]\[&#39;layout&#39;\] #for two seat\_id = \[x for x in layer if layer\[x\]\[&#39;type&#39;\] == &#39;seat&#39; and layer\[x\]\[&#39;name&#39;\] == local\_seat\] if seat\_id.\_\_len__() == 0: print(&#39;找不到&#39; + loc) return -1 else: seat\_id = layer\[seat\_id\[0\]\]\[&#39;id&#39;\] return seat_id ‘’’http://seat.ujn.edu.cn/rest/auth?username=220140421164&amp;password=220140421164获取token{“status”:”success”,”data”:{“token”:”T58UTCARF601204212”},”code”:”0”,”message”:””}{“status”:”fail”,”code”:”13”,”message”:”登录失败: 密码不正确”,”data”:null}‘’’def getToken(username, password): url = ‘http://seat.ujn.edu.cn/rest/auth‘ param = { ‘username’: username, ‘password’: password } r = requests.get(url, params=param) resp = json.loads(r.text) if resp[‘status’] == ‘fail’: print(username + ‘ ‘ + r.text) return -1 else: return resp[‘data’][‘token’]‘’’http://seat.ujn.edu.cn/rest/v2/freeBookPOST `token=HLIU9P4HYW01214703&amp;startTime=960&amp;endTime=1200&amp;seat=15343&amp;date=2018-01-21`‘’’def freeBook(token, startTime, endTime, seat): tomorrow = time.strftime(“%Y-%m-%d”, time.localtime(86400 + time.time())) url = ‘http://seat.ujn.edu.cn/rest/v2/freeBook‘ para = { ‘token’: token, ‘startTime’: startTime, ‘endTime’: endTime, ‘seat’: seat, ‘date’: tomorrow } r = requests.post(url, data=para) resp = json.loads(r.text) if resp[‘status’] == ‘fail’: #print(r.text) fileLogOut(&#39;seat_reason.log&#39;, r.text) return -1 else: fileLogOut(&#39;seat_reason.log&#39;, r.text) return 1 ‘’’ 调试并适用于在 凌晨进行预约时。输出日志文件进行确认。‘’’def fileLogOut(logFilename, logMessage): #创建logger实例 logger = logging.getLogger() logger.setLevel(logging.DEBUG) log_dir = &#39;/root/reservation/log/&#39; #创建handler #终端handler consoleHandler = logging.StreamHandler() consoleHandler.setLevel(logging.DEBUG) #文件Handler fileHandler = logging.FileHandler(log_dir + logFilename, mode=&#39;a&#39;, encoding=&#39;UTF-8&#39;) fileHandler.setLevel(logging.NOTSET) #Formatter formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;) consoleHandler.setFormatter(formatter) fileHandler.setFormatter(formatter) #添加 handler到对应的logger实例当中去 logger.addHandler(consoleHandler) logger.addHandler(fileHandler) #打印日志 logger.debug(logMessage) if __name__ == ‘__main__‘: if sys.argv.__len__() &lt;= 1: print(“请传入配置文件名称”) sys.exit() filename = sys.argv[1] now = time.strftime(“%Y-%m-%d %H:%M:%S”, time.localtime(time.time())) print(‘———————————‘ + now + ‘———————————-‘) f = open(sys.path[0] + ‘/‘ + filename, ‘r’, encoding=’utf8’) info = json.load(f) # print(info) # print(len(info\[&#39;stu&#39;\])) for i in info\[&#39;stu&#39;\]: token = getToken(i\[&#39;username&#39;\], i\[&#39;password&#39;\]) if token != -1: seat\_id = get\_seat_id(i\[&#39;seat&#39;\], token) if seat_id != -1: status = freeBook(token, i\[&#39;startTime&#39;\], i\[&#39;endTime&#39;\], seat_id) #print(&#39;test1&#39;) else: status = -1 #print(&#39;test2&#39;) if token != -1 and status != -1: response = i\[&#39;name&#39;\] + &#39; 成功预约 &#39; + i\[&#39;seat&#39;\] + &#39;\\n&#39; fileLogOut(&#39;seat_log.log&#39;, response) else: response = i\[&#39;name&#39;\] + &#39; 预约失败\\n&#39; #print(&#39;test3&#39;) fileLogOut(&#39;seat_log.log&#39;, response)]]></content>
      <categories>
        <category>Linux</category>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AClear]]></title>
    <url>%2Fpost%2F97945175.html</url>
    <content type="text"><![CDATA[考研 考研 考研 考研 这如许多的词汇，一旦成为叠词 即使这个词语有多么的少，重复多了，再小的东西也是力量无穷大的。 突然发现，如果我不去每日一记。写一写自己的计划，回顾下自己的往昔。 真的真的会忘记自己的初心。当初取下AClear这个名称——大概就是在大二下学期吧。当时自己还是有想要——永远相信梦想，永远相信年轻，永远相信努力的意义，相信失败比遗憾更可怕——相信不成功的人生，虽不完美，但是她完整啊！ 每个人都有每个人的艰辛。这不足以称道（灌鸡汤、学工为了技术为了大神、为了披荆斩棘收获更好的自己…这一切的一切难道不都是自己在大学里为之奋斗、为之努力的意义吗？） 有的时候你！张家豪！会不知道为什么而在努力，你会心里特别的焦虑、会特别的焦急（但是别怕，这个浮躁下的时代，我们只是缺少了计划、缺少了工匠精神和不为什么的坚持罢了…）。考研路上或者是未来的路上，我给你，亲爱的家豪，的希望是：期望你能在那样的时刻，能够AClear。能够放放松转化下，但是要快点转变回好的状态，或者只是在相信坚持住，多一点不为什么的坚持；勇敢一点、再勇敢点。 三观加强、目标强烈加强，加强自己对于目标的渴望。（你 还有，年轻，家人，还在奋斗的年级，还好好地在活着！）所以，努力 认真的AClear，做好坚持住自己的事情吧。Breave honest insist interest. 也是到了这个时候 才真正的意识到某些话语的意思，Less interests,More interest. A-acan 相信自己 C-clear 清晰目标 Lear-learn 学习坚持 家豪，祝你早日成为你想要的模样。与君共勉：D。wan an.]]></content>
      <categories>
        <category>日记之家</category>
      </categories>
      <tags>
        <tag>正能量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux定时任务Crontab命令速查与详解]]></title>
    <url>%2Fpost%2F2b879c1f.html</url>
    <content type="text"><![CDATA[速查基本格式 : command 分 时 日 月 周 命令 第1列表示分钟1～59 每分钟用或者 /1表示 第2列表示小时0～23（0表示0点） 第3列表示日期1～31 第4列表示月份1～12 第5列标识号星期0～6（0表示星期天） 第6列要运行的命令 crontab文件的一些例子： 30 21 /usr/local/etc/rc.d/lighttpd restart 上面的例子表示每晚的21:30重启apache。 45 4 1,10,22 /usr/local/etc/rc.d/lighttpd restart 上面的例子表示每月1、10、22日的4 : 45重启apache。 10 1 6,0 /usr/local/etc/rc.d/lighttpd restart 上面的例子表示每周六、周日的1 : 10重启apache。 0,30 18-23 /usr/local/etc/rc.d/lighttpd restart 上面的例子表示在每天18 : 00至23 : 00之间每隔30分钟重启apache。 0 23 6 /usr/local/etc/rc.d/lighttpd restart 上面的例子表示每星期六的11 : 00 pm重启apache。 /1 /usr/local/etc/rc.d/lighttpd restart 每一小时重启apache 23-7/1 /usr/local/etc/rc.d/lighttpd restart 晚上11点到早上7点之间，每隔一小时重启apache 0 11 4 mon-wed /usr/local/etc/rc.d/lighttpd restart 每月的4号与每周一到周三的11点重启apache 0 4 1 jan /usr/local/etc/rc.d/lighttpd restart 一月一号的4点重启apache 名称 : crontab 使用权限 : 所有使用者 使用方式 : crontab file [-u user]-用指定的文件替代目前的crontab。 crontab-[-u user]-用标准输入替代目前的crontab. crontab-1[user]-列出用户目前的crontab. crontab-e[user]-编辑用户目前的crontab. crontab-d[user]-删除用户目前的crontab. crontab-c dir- 指定crontab的目录。 crontab文件的格式：M H D m d cmd. M: 分钟（0-59）。 H：小时（0-23）。 D：天（1-31）。 m: 月（1-12）。 d: 一星期内的天（0~6，0为星期天）。 cmd要运行的程序，程序被送入sh执行，这个shell只有USER,HOME,SHELL这三个环境变量 说明 : crontab 是用来让使用者在固定时间或固定间隔执行程序之用，换句话说，也就是类似使用者的时程表。-u user 是指设定指定 user 的时程表，这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表。如果不使用 -u user 的话，就是表示设 定自己的时程表。 参数 : crontab -e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数 来指定使用那个文字编辑器(比如说 setenv VISUAL joe) crontab -r : 删除目前的时程表 crontab -l : 列出目前的时程表 crontab file [-u user]-用指定的文件替代目前的crontab。 时程表的格式如下 : f1 f2 f3 f4 f5 program 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执 行的程序。 当 f1 为 时表示每分钟都要执行 program，f2 为 时表示每小时都要执行程序，其余类推 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推 当 f1 为 /n 时表示每 n 分钟个时间间隔执行一次，f2 为 /n 表示每 n 小时个时间间隔执行一次，其馀类推 当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推 使用者也可以将所有的设定先存放在档案 file 中，用 crontab file 的方式来设定时程表。 例子 : #每天早上7点执行一次 /bin/ls : 0 7 /bin/ls 在 12 月内, 每天的早上 6 点到 12 点中，每隔3个小时执行一次 /usr/bin/backup : 0 6-12/3 12 /usr/bin/backup 周一到周五每天下午 5:00 寄一封信给 alex@domain.name : 0 17 1-5 mail -s “hi” alex@domain.name &lt; /tmp/maildata 每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha” 20 0-23/2 echo “haha” 注意 : 当程序在你所指定的时间执行后，系统会寄一封信给你，显示该程序执行的内容，若是你不希望收到这样的信，请在每一行空一格之 后加上 &gt; /dev/null 2&gt;&amp;1 即可 例子2 : #每天早上6点10分 10 6 date #每两个小时 0 /2 date #晚上11点到早上8点之间每两个小时，早上8点 0 23-7/2，8 date #每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点 0 11 4 mon-wed date #1月份日早上4点 0 4 1 jan date 范例 $crontab -l 列出用户目前的crontab. crontab语法1.crontab基本格式 {minute} {hour} {day-of-month} {month} {day-of-week} {full-path-to-shell-script} 2.crontab语法示例 1 #在 12:01a.m运行 2 1 0 /root/bin/backup.sh 3 #每个工作日11:59p.m运行 4 59 11 1,2,3,4,5 /root/bin/backup.sh 5 59 11 1-5 /root/bin/backup.sh 6 #每5分钟运行一次命令 7 /5 /root/bin/check-status.sh 8 #每个月的第一天1:10p.m运行 9 10 13 1 /root/bin/full-backup.sh10 #每个工作日11p.m运行11 0 23 1-5 /root/bin/incremental-backup.sh crontab实例1.crontab的启动和停止 1 service crond start/stop/restart 2.crontab -e方式添加crontab任务 1 crontab -e #添加任务2 crontab -l #查看所有任务3 crontab -r #删除任务 准备工作： vim /home/helloworld/helloworld.py vim /home/helloworld/helloworld.sh 1 #helloworld.py2 import time3 with open(‘test.txt’,’w+’) as f:4 f.write(str(time.time()))567 #helloworld.sh8 cd /home/helloworld/9 python /home/helloworld/helloworld.py step1：执行crontab -e命令之后进入编辑模式，添加要执行的任务。 /1 * bash /home/helloworld/helloworld.sh step2:启动crontab服务 step3:查看crontab日志 1 tail -f /var/log/cron 2 #查看log文件 3 May 12 19:11:01 localhost CROND[12824]: (root) CMD (bash /home/helloworld/helloworld.sh) 4 May 12 19:11:01 localhost CROND[12823]: (root) MAIL (mailed 14 bytes of output but got status 0x007f#012) 5 May 12 19:12:01 localhost CROND[12865]: (root) CMD (bash /home/helloworld/helloworld.sh) 6 May 12 19:12:01 localhost CROND[12864]: (root) MAIL (mailed 14 bytes of output but got status 0x007f#012) 7 May 12 19:13:01 localhost CROND[12880]: (root) CMD (bash /home/helloworld/helloworld.sh) 8 May 12 19:13:01 localhost CROND[12879]: (root) MAIL (mailed 14 bytes of output but got status 0x007f#012) 9 May 12 19:14:01 localhost CROND[12895]: (root) CMD (bash /home/helloworld/helloworld.sh)10 May 12 19:14:01 localhost CROND[12894]: (root) MAIL (mailed 13 bytes of output but got status 0x007f#012)1112 #同时查看helloworld文件夹13 ll -t14 #监测到15 [root@localhost helloworld]# ll -t16 总用量 1217 -rw-r—r— 1 root root 13 5月 12 19:11 test.txt18 -rw-r—r— 1 root root 59 5月 12 16:45 helloworld.sh19 -rw-r—r— 1 root root 94 5月 12 16:41 helloworld.py20 [root@localhost helloworld]# ll -t21 总用量 1222 -rw-r—r— 1 root root 13 5月 12 19:12 test.txt23 -rw-r—r— 1 root root 59 5月 12 16:45 helloworld.sh24 -rw-r—r— 1 root root 94 5月 12 16:41 helloworld.py25 [root@localhost helloworld]# ll -t26 总用量 1227 -rw-r—r— 1 root root 13 5月 12 19:13 test.txt28 -rw-r—r— 1 root root 59 5月 12 16:45 helloworld.sh29 -rw-r—r— 1 root root 94 5月 12 16:41 helloworld.py30 [root@localhost helloworld]# ll -t31 总用量 1232 -rw-r—r— 1 root root 12 5月 12 19:14 test.txt33 -rw-r—r— 1 root root 59 5月 12 16:45 helloworld.sh34 -rw-r—r— 1 root root 94 5月 12 16:41 helloworld.py35 [root@localhost helloworld]# 3.通过vim /etc/crontab方式添加任务 1 #查看/etc/crontab 2 vim /etc/crontab 3 4 #添加任务 5 SHELL=/bin/bash 6 PATH=/sbin:/bin:/usr/sbin:/usr/bin 7 MAILTO=”” 8 HOME=/ 910 # For details see man 4 crontabs11 # Example of job definition:12 # .———————— minute (0 - 59)13 # | .——————- hour (0 - 23)14 # | | .————— day of month (1 - 31)15 # | | | .———- month (1 - 12) OR jan,feb,mar,apr …16 # | | | | .—— day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,w ed,thu,fri,sat17 # | | | | |18 # user-name command to be executed19 /1 root bash /home/helloworld/helloworld.sh 4.可以通过同样的方式监测到任务在重复执行 详解前一天学习了 at 命令是针对仅运行一次的任务，循环运行的例行性计划任务，linux系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。 一、crond简介 crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。 Linux下的任务调度分为两类，系统任务调度和用户任务调度。 系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。 /etc/crontab文件包括下面几行： [root@localhost ~]# cat /etc/crontab SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=””HOME=/ # run-parts 51 root run-parts /etc/cron.hourly 24 7 root run-parts /etc/cron.daily 22 4 0 root run-parts /etc/cron.weekly 42 4 1 root run-parts /etc/cron.monthly [root@localhost ~]# 前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。 用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。 使用者权限文件： 文件： /etc/cron.deny 说明： 该文件中所列用户不允许使用crontab命令 文件： /etc/cron.allow 说明： 该文件中所列用户允许使用crontab命令 文件： /var/spool/cron/ 说明： 所有用户crontab文件存放的目录,以用户名命名 crontab**文件的含义：* 用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下： minute hour day month week command 其中： minute： 表示分钟，可以是从0到59之间的任何整数。 hour：表示小时，可以是从0到23之间的任何整数。 day：表示日期，可以是从1到31之间的任何整数。 month：表示月份，可以是从1到12之间的任何整数。 week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。 [caption id=”attachment_1189” align=”aligncenter” width=”542”] crontab 格式[/caption] 在以上各个字段中，还可以使用以下特殊字符： 星号（）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如/10，如果用在minute字段，表示每十分钟执行一次。 二、crond服务 安装crontab： yum install crontabs 服务操作说明： /sbin/service crond start //启动服务 /sbin/service crond stop //关闭服务 /sbin/service crond restart //重启服务 /sbin/service crond reload //重新载入配置 查看crontab服务状态： service crond status 手动启动crontab服务： service crond start 查看crontab服务是否已设置为开机启动，执行命令： ntsysv 加入开机自动启动： chkconfig –level 35 crond on 三、crontab命令详解 1**．**命令格式： crontab [-u user] file crontab [-u user] [ -e | -l | -r ] 2**．**命令功能： 通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。 3**．**命令参数： -u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。 file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。 -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。 -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。 -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。 -i：在删除用户的crontab文件时给确认提示。 4**．**常用方法： 1). **创建一个新的crontab文件 在考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的. profile文件，在其中加入这样一行： EDITOR=vi; export EDITOR 然后保存并退出。不妨创建一个名为 cron的文件，其中是用户名，例如， davecron。在该文件中加入如下的内容。 # (put your own initials here)echo the date to the console every # 15minutes between 6pm and 6am 0,15,30,45 18-06 * /bin/echo ‘date’ &gt; /dev/console 保存并退出。确信前面5个域用空格分隔。 在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数： $ crontab davecron 现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。 同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。 2). **列出crontab文件 为了列出crontab文件，可以用： $ crontab -l 0,15,30,45,18-06 /bin/echo `date` &gt; dev/tty1 你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对crontab文件做一备份： $ crontab -l &gt; $HOME/mycron 这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。 3). **编辑crontab文件** 如果希望添加、删除或编辑crontab文件中的条目，而E D I TO R环境变量又设置为v i，那么就可以用v i来编辑crontab文件，相应的命令为： $ crontab -e 可以像使用v i编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。 我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条： # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month 30 3 1,7,14,21,26 /bin/find -name “core’ -exec rm {} \\; 现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。 现在让我们使用前面讲过的crontab -l命令列出它的全部信息： $ crontab -l # (crondave installed on Tue May 4 13:07:43 1999) # DT:ech the date to the console every 30 minites 0,15,30,45 18-06 /bin/echo `date` &gt; /dev/tty1 # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month 30 3 1,7,14,21,26 /bin/find -name “core’ -exec rm {} \\; 4). **删除crontab文件 要删除crontab文件，可以用： $ crontab -r 5). **恢复丢失的crontab文件 如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/，其中是用户名。如果由于权限问题无法完成拷贝，可以用： $ crontab 其中，是你在$ H O M E目录中副本的文件名。 我建议你在自己的$ H O M E目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。 有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按，否则你将丢失crontab文件。 5**．**使用实例 实例1：每1分钟执行一次command 命令： command 实例2：每小时的第3和第15分钟执行 命令： 3,15 command 实例3：在上午8点到11点的第3和第15分钟执行 命令： 3,15 8-11 command 实例4：每隔两天的上午8点到11点的第3和第15分钟执行 命令： 3,15 8-11 /2 command 实例5：每个星期一的上午8点到11点的第3和第15分钟执行 命令： 3,15 8-11 1 command 实例6：每晚的21:30重启smb 命令： 30 21 /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb 命令： 45 4 1,10,22 /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb 命令： 10 1 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb 命令： 0,30 18-23 /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb 命令： 0 23 6 /etc/init.d/smb restart 实例11：每一小时重启smb 命令： /1 /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb 命令： 23-7/1 /etc/init.d/smb restart 实例13：每月的4号与每周一到周三的11点重启smb 命令： 0 11 4 mon-wed /etc/init.d/smb restart 实例14：一月一号的4点重启smb 命令： 0 4 1 jan /etc/init.d/smb restart 实例15：每小时执行/etc/cron.hourly目录内的脚本 命令： 01 root run-parts /etc/cron.hourly 说明： run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了 四、使用注意事项 注意环境变量问题 有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。 在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。 不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点： 1）脚本中涉及文件路径时写全局路径； 2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如： cat start_cbp.sh #!/bin/sh source /etc/profile export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf /usr/local/jboss-4.0.5/bin/run.sh -c mev &amp; 3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如： 0 . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh 注意清理系统用户的邮件日志 每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。 例如，可以在crontab文件中设置如下形式，忽略日志输出： 0 /3 /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1 “/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。 系统级任务调度与用户级任务调度 系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。 其他注意事项 新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。 当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。 千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。 在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义\\%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+\\%Y\\%m\\%d]]></content>
      <categories>
        <category>Big Data</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速入门——十分钟python]]></title>
    <url>%2Fpost%2F923c2edb.html</url>
    <content type="text"><![CDATA[初试牛刀假设你希望学习Python这门语言，却苦于找不到一个简短而全面的入门教程。那么本教程将花费十分钟的时间带你走入Python的大门。本文的内容介于教程(Toturial)和速查手册(CheatSheet)之间，因此只会包含一些基本概念。很显然，如果你希望真正学好一门语言，你还是需要亲自动手实践的。在此，我会假定你已经有了一定的编程基础，因此我会跳过大部分非Python语言的相关内容。本文将高亮显示重要的关键字，以便你可以很容易看到它们。另外需要注意的是，由于本教程篇幅有限，有很多内容我会直接使用代码来说明加以少许注释。 Python的语言特性Python是一门具有强类型(即变量类型是强制要求的)、动态性、隐式类型(不需要做变量声明)、大小写敏感(var和VAR代表了不同的变量)以及面向对象(一切皆为对象)等特点的编程语言。 获取帮助你可以很容易的通过Python解释器获取帮助。如果你想知道一个对象(object)是如何工作的，那么你所需要做的就是调用help()！另外还有一些有用的方法，dir()会显示该对象的所有方法，还有.__doc__会显示其文档： Python 1 2 3 4 5 6 7 8 9 10 11 help(5) Help on int object: (etc etc) dir(5) [‘__abs__‘, ‘__add__‘, …] abs.__doc__ ‘abs(number) -&gt; number Return the absolute value of the argument.’ 语法Python中没有强制的语句终止字符，且代码块是通过缩进来指示的。缩进表示一个代码块的开始，逆缩进则表示一个代码块的结束。声明以冒号(:)字符结束，并且开启一个缩进级别。单行注释以井号字符(#)开头，多行注释则以多行字符串的形式出现。赋值（事实上是将对象绑定到名字）通过等号(“=”)实现，双等号(“==”)用于相等判断，”+=”和”-=”用于增加/减少运算(由符号右边的值确定增加/减少的值)。这适用于许多数据类型，包括字符串。你也可以在一行上使用多个变量。例如： Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 myvar = 3 myvar += 2 myvar 5 myvar -= 1 myvar 4 “””This is a multiline comment. The following lines concatenate the two strings.””” mystring = “Hello” mystring += “ world.” print mystring Hello world. # This swaps the variables in one line(!). # It doesn’t violate strong typing because values aren’t # actually being assigned, but new objects are bound to # the old names. myvar, mystring = mystring, myvar 数据类型Python具有列表（list）、元组（tuple）和字典（dictionaries）三种基本的数据结构，而集合(sets)则包含在集合库中(但从Python2.5版本开始正式成为Python内建类型)。列表的特点跟一维数组类似（当然你也可以创建类似多维数组的“列表的列表”），字典则是具有关联关系的数组（通常也叫做哈希表），而元组则是不可变的一维数组（Python中“数组”可以包含任何类型的元素，这样你就可以使用混合元素，例如整数、字符串或是嵌套包含列表、字典或元组）。数组中第一个元素索引值(下标)为0，使用负数索引值能够从后向前访问数组元素，-1表示最后一个元素。数组元素还能指向函数。来看下面的用法： Python 1 2 3 4 5 6 7 8 9 10 sample = [1, [“another”, “list”], (“a”, “tuple”)] mylist = [“List item 1”, 2, 3.14] mylist[0] = “List item 1 again” # We’re changing the item. mylist[-1] = 3.21 # Here, we refer to the last item. mydict = {“Key 1”: “Value 1”, 2: 3, “pi”: 3.14} mydict[“pi”] = 3.15 # This is how you change dictionary values. mytuple = (1, 2, 3) myfunction = len print myfunction(mylist) 3 你可以使用:运算符访问数组中的某一段，如果:左边为空则表示从第一个元素开始，同理:右边为空则表示到最后一个元素结束。负数索引则表示从后向前数的位置（-1是最后一个项目），例如： Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mylist = [“List item 1”, 2, 3.14] print mylist[:] [‘List item 1’, 2, 3.1400000000000001] print mylist[0:2] [‘List item 1’, 2] print mylist[-3:-1] [‘List item 1’, 2] print mylist[1:] [2, 3.14] # Adding a third parameter, “step” will have Python step in # N item increments, rather than 1. # E.g., this will return the first item, then go to the third and # return that (so, items 0 and 2 in 0-indexing). print mylist[::2] [‘List item 1’, 3.14] 字符串Python中的字符串使用单引号(‘)或是双引号(“)来进行标示，并且你还能够在通过某一种标示的字符串中使用另外一种标示符(例如 “He said ‘hello’.”)。而多行字符串可以通过三个连续的单引号(”’)或是双引号(“””)来进行标示。Python可以通过u”This is a unicode string”这样的语法使用Unicode字符串。如果想通过变量来填充字符串，那么可以使用取模运算符(%)和一个元组。使用方式是在目标字符串中从左至右使用%s来指代变量的位置，或者使用字典来代替，示例如下： Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 print “Name: %s\ Number: %s\ String: %s” % (myclass.name, 3, 3 * “-“) Name: Poromenos Number: 3 String: —- strString = “””This is a multiline string.””” # WARNING: Watch out for the trailing s in “%(key)s”. print “This %(verb)s a %(noun)s.” % {“noun”: “test”, “verb”: “is”} This is a test. 流程控制Python中可以使用if、for和while来实现流程控制。Python中并没有select，取而代之使用if来实现。使用for来枚举列表中的元素。如果希望生成一个由数字组成的列表，则可以使用range()函数。以下是这些声明的语法示例： Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 rangelist = range(10) print rangelist [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] for number in rangelist: \# Check if number is one of \# the numbers in the tuple. if number in (3, 4, 7, 9): \# &quot;Break&quot; terminates a for without \# executing the &quot;else&quot; clause. break else: \# &quot;Continue&quot; starts the next iteration \# of the loop. It&#39;s rather useless here, \# as it&#39;s the last statement of the loop. continue else: \# The &quot;else&quot; clause is optional and is \# executed only if the loop didn&#39;t &quot;break&quot;. pass \# Do nothing if rangelist[1] == 2: print &quot;The second item (lists are 0-based) is 2&quot; elif rangelist[1] == 3: print &quot;The second item (lists are 0-based) is 3&quot; else: print &quot;Dunno&quot; while rangelist[1] == 1: pass 函数函数通过“def”关键字进行声明。可选参数以集合的方式出现在函数声明中并紧跟着必选参数，可选参数可以在函数声明中被赋予一个默认值。已命名的参数需要赋值。函数可以返回一个元组（使用元组拆包可以有效返回多个值）。Lambda函数是由一个单独的语句组成的特殊函数，参数通过引用进行传递，但对于不可变类型(例如元组，整数，字符串等)则不能够被改变。这是因为只传递了该变量的内存地址，并且只有丢弃了旧的对象后，变量才能绑定一个对象，所以不可变类型是被替换而不是改变（译者注：虽然Python传递的参数形式本质上是引用传递，但是会产生值传递的效果）。例如： Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 作用等同于 def funcvar(x): return x + 1 funcvar = lambda x: x + 1 print funcvar(1) 2 # an_int 和 a_string 是可选参数，它们有默认值 # 如果调用 passing_example 时只指定一个参数，那么 an_int 缺省为 2 ，a_string 缺省为 A default string。如果调用 passing_example 时指定了前面两个参数，a_string 仍缺省为 A default string。 # a_list 是必备参数，因为它没有指定缺省值。 def passing_example(a_list, an_int=2, a_string=”A default string”): a_list.append(&quot;A new item&quot;) an_int = 4 return a_list, an\_int, a\_string my_list = [1, 2, 3] my_int = 10 print passing_example(my_list, my_int) ([1, 2, 3, ‘A new item’], 4, “A default string”) my_list [1, 2, 3, ‘A new item’] my_int 10 类Python支持有限的多继承形式。私有变量和方法可以通过添加至少两个前导下划线和最多尾随一个下划线的形式进行声明（如“__spam”，这只是惯例，而不是Python的强制要求）。当然，我们也可以给类的实例取任意名称。例如： Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class MyClass(object): common = 10 def \_\_init\_\_(self): self.myvariable = 3 def myfunction(self, arg1, arg2): return self.myvariable \# This is the class instantiation classinstance = MyClass() classinstance.myfunction(1, 2) 3 # This variable is shared by all classes. classinstance2 = MyClass() classinstance.common 10 classinstance2.common 10 # Note how we use the class name # instead of the instance. MyClass.common = 30 classinstance.common 30 classinstance2.common 30 # This will not update the variable on the class, # instead it will bind a new object to the old # variable name. classinstance.common = 10 classinstance.common 10 classinstance2.common 30 MyClass.common = 50 # This has not changed, because “common” is # now an instance variable. classinstance.common 10 classinstance2.common 50 # This class inherits from MyClass. The example # class above inherits from “object”, which makes # it what’s called a “new-style class”. # Multiple inheritance is declared as: # class OtherClass(MyClass1, MyClass2, MyClassN) class OtherClass(MyClass): \# The &quot;self&quot; argument is passed automatically \# and refers to the class instance, so you can set \# instance variables as above, but from inside the class. def \_\_init\_\_(self, arg1): self.myvariable = 3 print arg1 classinstance = OtherClass(“hello”) hello classinstance.myfunction(1, 2) 3 # This class doesn’t have a .test member, but # we can add one to the instance anyway. Note # that this will only be a member of classinstance. classinstance.test = 10 classinstance.test 10 异常Python中的异常由 try-except [exceptionname] 块处理，例如： Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def some_function(): try: \# Division by zero raises an exception 10 / 0 except ZeroDivisionError: print &quot;Oops, invalid.&quot; else: \# Exception didn&#39;t occur, we&#39;re good. pass finally: \# This is executed after the code block is run \# and all exceptions have been handled, even \# if a new exception is raised while handling. print &quot;We&#39;re done with that.&quot; some_function() Oops, invalid. We’re done with that. 导入外部库可以使用 import [libname] 关键字来导入。同时，你还可以用 from [libname] import [funcname] 来导入所需要的函数。例如： Python 1 2 3 4 5 6 import random from time import clock randomint = random.randint(1, 100) print randomint 64 文件I / OPython针对文件的处理有很多内建的函数库可以调用。例如，这里演示了如何序列化文件(使用pickle库将数据结构转换为字符串)： Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import pickle mylist = [“This”, “is”, 4, 13327] # Open the file C:\\\binary.dat for writing. The letter r before the # filename string is used to prevent backslash escaping. myfile = open(r”C:\\\binary.dat”, “w”) pickle.dump(mylist, myfile) myfile.close() myfile = open(r”C:\\\text.txt”, “w”) myfile.write(“This is a sample string”) myfile.close() myfile = open(r”C:\\\text.txt”) print myfile.read() ‘This is a sample string’ myfile.close() # Open the file for reading. myfile = open(r”C:\\\binary.dat”) loadedlist = pickle.load(myfile) myfile.close() print loadedlist [‘This’, ‘is’, 4, 13327] 其它杂项 数值判断可以链接使用，例如 1&lt;a&lt;3 能够判断变量 a 是否在1和3之间。 可以使用 del 删除变量或删除数组中的元素。 列表推导式(List Comprehension)提供了一个创建和操作列表的有力工具。列表推导式由一个表达式以及紧跟着这个表达式的for语句构成，for语句还可以跟0个或多个if或for语句，来看下面的例子： Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 lst1 = [1, 2, 3] lst2 = [3, 4, 5] print [x * y for x in lst1 for y in lst2] [3, 4, 5, 6, 8, 10, 9, 12, 15] print [x for x in lst1 if 4 &gt; x &gt; 1] [2, 3] # Check if an item has a specific property. # “any” returns true if any item in the list is true. any([i % 3 for i in [3, 3, 4, 4, 3]]) True # This is because 4 % 3 = 1, and 1 is true, so any() # returns True. # Check how many items have this property. sum(1 for i in [3, 3, 4, 4, 3] if i == 4) 2 del lst1[0] print lst1 [2, 3] del lst1 全局变量在函数之外声明，并且可以不需要任何特殊的声明即能读取，但如果你想要修改全局变量的值，就必须在函数开始之处用global关键字进行声明，否则Python会将此变量按照新的局部变量处理（请注意，如果不注意很容易被坑）。例如： Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 number = 5 def myfunc(): \# This will print 5. print number def anotherfunc(): \# This raises an exception because the variable has not \# been bound before printing. Python knows that it an \# object will be bound to it later and creates a new, local \# object instead of accessing the global one. print number number = 3 def yetanotherfunc(): global number \# This will correctly change the global. number = 3 小结本教程并未涵盖Python语言的全部内容(甚至连一小部分都称不上)。Python有非常多的库以及很多的功能特点需要学习，所以要想学好Python你必须在此教程之外通过其它方式，例如阅读Dive into Python。我希望这个教程能给你一个很好的入门指导。如果你觉得本文还有什么地方值得改进或添加，或是你希望能够了解Python的哪方面内容，请留言。 转自http://blog.jobbole.com/43922/]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaEE当中关于MVC模式的若干理解]]></title>
    <url>%2Fpost%2Fb01d1e09.html</url>
    <content type="text"><![CDATA[记录自己上的JavaEE课堂的学习感悟，同时摘录博客进行自己想法的查漏补缺，提升个人开发技能。 解决：分层、功能单一 Ø模型：表示系统业务逻辑（可重用） Ø视图：实现系统的外观（界面，可重用） Ø控制器：接受用户请求，把数据传给业务逻辑模块，并调用业务逻辑模块处理，最后根据用户所需要的相应，调用相应的视图模块生成结果返回浏览器。 其中特别是登录界面当中，control-Servletmodel-UserBeanview-jsp、htmlutil-LoginFactory。相应需要进行辅助的类方法、工厂模式、新的设计模式。service-LoginService、ILoginService。逻辑处理。dao-进行数据库的修改、更新操作。db-进行数据库的链接、sql语句进行exe执行操作。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaEE面向对象的六原则一法则]]></title>
    <url>%2Fpost%2Ff3593d19.html</url>
    <content type="text"><![CDATA[面向对象的特征主要有抽象、继承、封装和多态四个方面，下面是我们来详细分析它们的含义： - 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 - 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 拓展：由于实际需要，某个类具有两个或两个以上的维度变化（例如我们去吃面：有拉面和板面两种选择，在这两中选择之上还有牛肉面和鸡蛋面两种选择，在这两层之上还有清淡、微辣、超辣等选择），如果仅仅使用继承实现这种需求，设计将会变得非常臃肿，这里我们可以引入桥接模式。桥接模式的做法就是把程序变化的部分抽象出来，让变化的部分与主类分离开来，从而将多个维度的变化彻底分离。最后提供一个管理类来组合不同维度上的变化，通过这个组合来满足业务需要。桥接模式在JavaEE应用中有非常广泛的应用。由于JavaEE应用需要实现跨数据库的功能，程序为了在不同的数据库之间迁移，系统需要在持久化技术这个维度上存在改变；另外，系统也需要在不同的业务逻辑之间迁移，因此也需要在业务逻辑这个维度迁移。因此，JavaEE应用都会推荐使用业务逻辑组件与DAO组件分离，让DAO组件负责持久化技术这个维度上的改变，让业务逻辑组件负责业务逻辑实现这个维度上的改变。JavaEE应用的DAO模式就是桥接模式的应用。从DAO组件的设计初衷来开，DAO组件是为了让应用在不同的持久化技术之间自由切换，也就是为了分离系统在持久化技术维度上的变化，从这个角度来看，JavaEE应用分离出DAO组件就是遵循桥接模式的。 - 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（ 拓展：可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情。 - 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。 运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事： 1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）； 2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 面向对象的“六原则一法则”：单一职责原则、开闭原则、依赖倒转原则、里氏替换原则、接口隔离原则、合成聚合复用原则和迪米特法则。 - 单一职责原则一个类只做它该做的事情。 单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。 - 开闭原则软件实体应当对扩展开放，对修改关闭。 在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。 要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。 - 依赖倒转原则面向接口编程。 该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。 -里氏替换原则任何时候都可以用子类型替换掉父类型。 关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。 - 接口隔离原则接口要小而专，绝不能大而全。 臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。 - 合成聚合复用原则优先使用聚合或合成关系复用代码。 通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。 - 迪米特法则迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。 迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。 拓展：对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。 如下图所示： 使用门面模式后： 迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。 版权声明：本文为博主原创文章，未经博主允许不得转载。 http://blog.csdn.net/sinat_26342009/article/details/46419873 LoadRunner 进行压力测试]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ACM基础篇-入门级问题]]></title>
    <url>%2Fpost%2F670454cc.html</url>
    <content type="text"><![CDATA[基本输入输出输入：1.Scanf函数返回值就是读出的变量个数，如：scanf( “%d %d”, &amp;a, &amp;b ); 如果只有一个整数输入，返回值是1，如果有两个整数输入，返回值是2，如果一个都没有，则返回值是-1。 2.EOF是一个预定义的常量，等于-1。 C语法： while(scanf(“%d %d”,&amp;a, &amp;b) != EOF) { …. }C++语法： while( cin &gt;&gt; a &gt;&gt; b ) { …. } 3.输入是一整行字符串时： C语法： char buf[20]; gets(buf);C++语法： 如果用string buf;来保存： getline( cin , buf ); 如果用char buf[ 255 ]; 来保存： cin.getline( buf, 255 );说明： 1.scanf(“%s%s”,str1,str2)，在多个字符串之间用一个或多个空格分隔； 2.若使用gets函数，应为gets(str1); gets(str2); 字符串之间用回车符作分隔。 3.通常情况下，接受短字符用scanf函数，接受长字符用gets函数。 4.而getchar函数每次只接受一个字符，经常c=getchar()这样来使用。 5.getline 是一个函数，它可以接受用户的输入的字符，直到已达指定个数，或者用户输入了特定的字符。它的函数声明形式（函数原型）如下： istream&amp; getline(char line[], int size, char endchar = ‘\\n’);不用管它的返回类型，来关心它的三个参数： char line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。 int size : 最多接受几个字符？用户超过size的输入都将不被接受。 char endchar :当用户输入endchar指定的字符时，自动结束。默认是回车符。即：n结合后两个参数，getline可以方便地实现： 用户最多输入指定个数的字符，如果超过，则仅指定个数的前面字符有效，如果没有超过，则用户可以通过回车来结束输入。 输出：]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day09_BigData渐进学习_aclear_fire]]></title>
    <url>%2Fpost%2F1808fdec.html</url>
    <content type="text"><![CDATA[目录 课程大纲（MAPREDUCE详解）…………………………………………………………………………….. 3 MAPREDUCE入门………………………………………………………………………………………… 4 1.1 为什么要MAPREDUCE…………………………………………………………………………….. 4 1.2 MAPREDUCE程序运行演示……………………………………………………………………….. 4 1.3 MAPREDUCE 示例编写及编程规范……………………………………………………………… 4 1.3.1 编程规范……………………………………………………………………………………… 4 1.3.2 wordcount示例编写………………………………………………………………………… 5 1.4 MAPREDUCE程序运行模式及debug方法…………………………………………………….. 7 1.4.1 本地运行模式……………………………………………………………………………….. 7 1.4.2 集群运行模式……………………………………………………………………………….. 7 Mapreduce程序的核心运行机制………………………………………………………………………… 8 2.1 概述…………………………………………………………………………………………………….. 8 2.2 mr程序运行流程…………………………………………………………………………………….. 8 2.2.1 流程示意图…………………………………………………………………………………… 8 2.2.2 流程解析……………………………………………………………………………………… 8 2.3 Maptask实例数的决定机制……………………………………………………………………… 10 2.3.1 maptask数量的决定机制………………………………………………………………… 10 2.3.2切片机制：………………………………………………………………………………….. 10 2.4 ReduceTask实例数的决定………………………………………………………………………… 11 MAPREDUCE中的Combiner……………………………………………………………………………… 12 MAPREDUCE中的序列化…………………………………………………………………………………. 12 4.1 概述…………………………………………………………………………………………………… 12 4.2 Jdk序列化和MR序列化之间的比较………………………………………………………….. 12 4.3 自定义对象实现MR中的序列化接口……………………………………………………….. 13 Mapreduce中的排序初步………………………………………………………………………………… 16 5.1 需求：……………………………………………………………………………………………….. 16 5.2 分析…………………………………………………………………………………………………… 16 5.3 实现…………………………………………………………………………………………………… 16 Mapreduce中的分区Partitioner……………………………………………………………………….. 20 6.1 需求：……………………………………………………………………………………………….. 20 6.2 分析…………………………………………………………………………………………………… 20 6.3 实现…………………………………………………………………………………………………… 20 mapreduce的shuffle机制……………………………………………………………………………….. 22 7.1 概述：……………………………………………………………………………………………….. 22 7.2 主要流程：…………………………………………………………………………………………. 22 7.3 详细流程…………………………………………………………………………………………….. 22 7.4 详细流程示意图…………………………………………………………………………………… 23 mapreduce数据压缩………………………………………………………………………………………. 24 8.1 概述…………………………………………………………………………………………………… 24 8.2 MR支持的压缩编码……………………………………………………………………………….. 24 8.3 Reducer输出压缩………………………………………………………………………………….. 24 8.4 Mapper输出压缩…………………………………………………………………………………… 25 8.5 压缩文件的读取…………………………………………………………………………………… 25 MapReduce与YARN……………………………………………………………………………………….. 27 9.1 YARN概述……………………………………………………………………………………………. 27 9.2 YARN的重要概念…………………………………………………………………………………… 27 9.3 Yarn中运行运算程序的示例…………………………………………………………………….. 27 MapReduce编程案例……………………………………………………………………………………. 28 10.1 reduce端join算法实现…………………………………………………………………… 28 10.2 map端join算法实现……………………………………………………………………… 29 10.3 web日志预处理………………………………………………………………………….. 32 附：Mapreduce参数优化…………………………………………………………………………………… 36 11.1 资源相关参数…………………………………………………………………………………….. 36 11.2 容错相关参数…………………………………………………………………………………….. 37 11.3 本地运行mapreduce 作业……………………………………………………………………. 37 11.4 效率和稳定性相关参数………………………………………………………………………… 37 课程大纲（MAPREDUCE详解）MapReduce快速入门 如何理解map、reduce计算模型 Mapreudce程序运行演示 Mapreduce编程规范及示例编写 Mapreduce程序运行模式及debug方法 MapReduce高级特性 Mapreduce程序的核心机制 MapReduce的序列化框架 MapReduce的排序实现 MapReduce的分区机制及自定义 Mapreduce的数据压缩 Mapreduce与yarn的结合 Mapreduce编程案例 Mapreduce 参数优化 目标： 掌握mapreduce分布式运算框架的编程思想 掌握mapreduce常用算法的编程套路 掌握mapreduce分布式运算框架的运行机制，具备一定自定义开发的能力 我们设置同一个对象&lt;是指定内存的一个地址中！&gt; ——如果注意交付给了：ArrayList是收集的对象的所指向的地址。是有意就算 add进去许多值进行。也最终只是指向了一块内存地址——即 最终ArrayList当中的数值是一样的！ 然而 我们Map方法中的context.write() 是不同的，这个是序列化 然后立即输出的！ 1. MAPREDUCE原理篇（1）_Mapreduce是一个分布式运算程序的编程框架，是用户开发“基于hadoop的数据分析应用”的核心框架；_ _Mapreduce__核心功能__是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个hadoop集群上；_ 1.1 为什么要MAPREDUCE（1）海量数据在单机上处理因为硬件资源限制，无法胜任 （2）而一旦将单机版程序扩展到集群来分布式运行，将极大增加程序的复杂度和开发难度 （3）引入mapreduce框架后，开发人员可以将绝大部分工作集中在业务逻辑的开发上，而将分布式计算中的复杂性交由框架来处理 _设想一个海量数据场景下的wordcount__需求：_ 单机版：内存受限，磁盘受限，运算能力受限 分布式： 1、文件分布式存储（HDFS） 2、运算逻辑需要至少分成2个阶段（一个阶段独立并发，一个阶段汇聚） 3、运算程序如何分发 4、程序如何分配运算任务（切片） 5、两阶段的程序如何启动？如何协调？ 6、整个程序运行过程中的监控？容错？重试？ 可见在程序由单机版扩成分布式时，会引入大量的复杂工作。为了提高开发效率，可以将分布式程序中的公共功能封装成框架，让开发人员可以将精力集中于业务逻辑。 而mapreduce就是这样一个分布式程序的通用框架，其应对以上问题的整体结构如下： 1、MRAppMaster(mapreduce application master) 2、MapTask 3、ReduceTask 1.2 MAPREDUCE框架结构及核心运行机制1.2.1 结构一个完整的mapreduce程序在分布式运行时有三类实例进程： 1、MRAppMaster：负责整个程序的过程调度及状态协调 2、mapTask：负责map阶段的整个数据处理流程 3、ReduceTask：负责reduce阶段的整个数据处理流程 1.2.2 MR程序运行流程1.2.2.1 流程示意图1.2.2.2 流程解析 一个mr程序启动的时候，最先启动的是MRAppMaster，MRAppMaster启动后根据本次job的描述信息，计算出需要的maptask实例数量，然后向集群申请机器启动相应数量的maptask进程 maptask进程启动之后，根据给定的数据切片范围进行数据处理，主体流程为： 利用客户指定的inputformat来获取RecordReader读取数据，形成输入KV对 将输入KV对传递给客户定义的map()方法，做逻辑运算，并将map()方法输出的KV对收集到缓存 将缓存中的KV对按照K分区排序后不断溢写到磁盘文件 MRAppMaster监控到所有maptask进程任务完成之后，会根据客户指定的参数启动相应数量的reducetask进程，并告知reducetask进程要处理的数据范围（数据分区） Reducetask进程启动之后，根据MRAppMaster告知的待处理数据所在位置，从若干台maptask运行所在机器上获取到若干个maptask输出结果文件，并在本地进行重新归并排序，然后按照相同key的KV为一个组，调用客户定义的reduce()方法进行逻辑运算，并收集运算输出的结果KV，然后调用客户指定的outputformat将结果数据输出到外部存储 1.3 MapTask并行度决定机制_maptask的并行度决定map阶段的任务处理并发度，进而影响到整个job的处理速度_ _那么，mapTask并行实例是否越多越好呢？其并行度又是如何决定呢？_ 1.3.1 mapTask并行度的决定机制一个job的map阶段并行度由客户端在提交job时决定 而客户端对map阶段并行度的规划的基本逻辑为： _将待处理数据执行逻辑切片（即按照一个特定切片大小，将待处理数据划分成逻辑上的多个split），然后每一个split分配一个mapTask__并行实例处理_ 这段逻辑及形成的切片规划描述文件，由FileInputFormat实现类的getSplits()方法完成，其过程如下图： 1.3.2 FileInputFormat切片机制1、切片定义在InputFormat类中的getSplit()方法2、FileInputFormat中默认的切片机制： 简单地按照文件的内容长度进行切片 切片大小，默认等于block大小 切片时不考虑数据集整体，而是逐个针对每一个文件单独切片 比如待处理数据有两个文件： file1.txt 320M file2.txt 10M 经过FileInputFormat的切片机制运算后，形成的切片信息如下： file1.txt.split1— 0~128 file1.txt.split2— 128~256 file1.txt.split3— 256~320 file2.txt.split1— 0~10M 3、FileInputFormat中切片的大小的参数配置通过分析源码，在FileInputFormat中，计算切片大小的逻辑：Math.max(minSize, Math.min(maxSize, blockSize)); 切片主要由这几个值来运算决定 minsize：默认值：1 配置参数： mapreduce.input.fileinputformat.split.minsize maxsize：默认值：Long.MAXValue 配置参数：mapreduce.input.fileinputformat.split.maxsize blocksize 因此，默认情况下，切片大小**=blocksize** maxsize（切片最大值）： 参数如果调得比blocksize小，则会让切片变小，而且就等于配置的这个参数的值 minsize （切片最小值）： 参数调的比blockSize大，则可以让切片变得比blocksize还大 选择并发数的影响因素： 运算节点的硬件配置 运算任务的类型：CPU密集型还是IO密集型 运算任务的数据量 1.4 map并行度的经验之谈如果硬件配置为212core + 64G，恰当的map并行度是大约每个节点20-100个map，最好每个**map**的执行时间至少一分钟。* 如果job的每个map或者 reduce task的运行时间都只有30-40秒钟，那么就减少该job的map或者reduce数，每一个task(map|reduce)的setup和加入到调度器中进行调度，这个中间的过程可能都要花费几秒钟，所以如果每个task都非常快就跑完了，就会在task的开始和结束的时候浪费太多的时间。 配置task的JVM 可以改善该问题： _（mapred.job.reuse.jvm.num.tasks，默认是1，表示一个JVM上最多可以顺序执行的task_ _数目（属于同一个Job）是1。也就是说一个task启一个JVM__）_ 如果input的文件非常的大，比如1TB，可以考虑将hdfs上的每个block size设大，比如设成256MB或者512MB 1.5 ReduceTask并行度的决定reducetask的并行度同样影响整个job的执行并发度和执行效率，但与maptask的并发数由切片数决定不同，Reducetask数量的决定是可以直接手动设置： //默认值是1，手动设置为4 job.setNumReduceTasks(4); 如果数据分布不均匀，就有可能在reduce阶段产生数据倾斜 _注意： reducetask数量并不是任意设置，还要考虑业务逻辑需求，有些情况下，需要计算全局汇总结果，就只能有1个reducetask_ _尽量不要运行太多的reduce task。对大多数job来说，最好rduce的个数最多和集群中的reduce持平，或者比集群的 reduce slots__小。这个对于小集群而言，尤其重要。_ 1.6 MAPREDUCE程序运行演示Hadoop的发布包中内置了一个hadoop-mapreduce-example-2.4.1.jar，这个jar包中有各种MR示例程序，可以通过以下步骤运行： 启动hdfs，yarn 然后在集群中的任意一台服务器上启动执行程序（比如运行wordcount）： hadoop jar hadoop-mapreduce-example-2.4.1.jar wordcount /wordcount/data /wordcount/out 2. MAPREDUCE实践篇（1）2.1 MAPREDUCE 示例编写及编程规范2.1.1 编程规范 用户编写的程序分成三个部分：Mapper，Reducer，Driver(提交运行mr程序的客户端) Mapper的输入数据是KV对的形式（KV的类型可自定义） Mapper的输出数据是KV对的形式（KV的类型可自定义） Mapper中的业务逻辑写在map()方法中 map()方法（maptask进程）对每一个调用一次 Reducer的输入数据类型对应Mapper的输出数据类型，也是KV Reducer的业务逻辑写在reduce()方法中 Reducetask进程对每一组相同k的组调用一次reduce()方法 用户自定义的Mapper和Reducer都要继承各自的父类 整个程序需要一个Drvier来进行提交，提交的是一个描述了各种必要信息的job对象 1.7.2 wordcount示例编写需求：在一堆给定的文本文件中统计输出每一个单词出现的总次数 (1)定义一个mapper类 //首先要定义四个泛型的类型 //keyin: LongWritable valuein: Text //keyout: Text valueout:IntWritable public class WordCountMapper extends Mapper{ //map方法的生命周期： 框架每传一行数据就被调用一次 //key : 这一行的起始点在文件中的偏移量 //value: 这一行的内容 @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { //拿到一行数据转换为string String line = value.toString(); //将这一行切分出各个单词 String[] words = line.split(“ “); //遍历数组，输出&lt;单词，1&gt; for(String word:words){ context.write(new Text(word), new IntWritable(1)); } } } (2)定义一个reducer类 //生命周期：框架每传递进来一个kv 组，reduce方法被调用一次 @Override protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException { //定义一个计数器 int count = 0; //遍历这一组kv的所有v，累加到count中 for(IntWritable value:values){ count += value.get(); } context.write(key, new IntWritable(count)); } } (3)定义一个主类，用来描述job并提交job public class WordCountRunner { //把业务逻辑相关的信息（哪个是mapper，哪个是reducer，要处理的数据在哪里，输出的结果放哪里……）描述成一个job对象 //把这个描述好的job提交给集群去运行 public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job wcjob = Job.getInstance(conf); //指定我这个job所在的jar包 // wcjob.setJar(“/home/hadoop/wordcount.jar”); wcjob.setJarByClass(WordCountRunner.class); wcjob.setMapperClass(WordCountMapper.class); wcjob.setReducerClass(WordCountReducer.class); //设置我们的业务逻辑Mapper类的输出key和value的数据类型 wcjob.setMapOutputKeyClass(Text.class); wcjob.setMapOutputValueClass(IntWritable.class); //设置我们的业务逻辑Reducer类的输出key和value的数据类型 wcjob.setOutputKeyClass(Text.class); wcjob.setOutputValueClass(IntWritable.class); //指定要处理的数据所在的位置 FileInputFormat.setInputPaths(wcjob, “hdfs://hdp-server01:9000/wordcount/data/big.txt”); //指定处理完成之后的结果所保存的位置 FileOutputFormat.setOutputPath(wcjob, new Path(“hdfs://hdp-server01:9000/wordcount/output/“)); //向yarn集群提交这个job boolean res = wcjob.waitForCompletion(true); System.exit(res?0:1); } 2.2 MAPREDUCE程序运行模式2.2.1 本地运行模式 mapreduce程序是被提交给LocalJobRunner在本地以单进程的形式运行 而处理的数据及输出结果可以在本地文件系统，也可以在hdfs上 怎样实现本地运行？写一个程序，不要带集群的配置文件（本质是你的mr程序的conf中是否有framework.name=local以及yarn.resourcemanager.hostname参数） _本地模式非常便于进行业务逻辑的debug，只要在eclipse中打断点即可_ _如果在windows下想运行本地模式来测试程序逻辑，需要在windows中配置环境变量：_ _％HADOOP_HOME％ = d:/hadoop-2.6.1_ _%PATH% =_ _％HADOOP_HOME％\\bin_ _并且要将d:/hadoop-2.6.1的lib和bin目录替换成windows平台编译的版本_ 2.2.2 集群运行模式 将mapreduce程序提交给yarn集群resourcemanager，分发到很多的节点上并发执行 处理的数据和输出结果应该位于hdfs文件系统 提交集群的实现步骤： A、将程序打成JAR包，然后在集群的任意一个节点上用hadoop命令启动 $ hadoop jar wordcount.jar cn.itcast.bigdata.mrsimple.WordCountDriver inputpath outputpath B、直接在linux的eclipse中运行main方法 （项目中要带参数：mapreduce.framework.name=yarn**以及yarn**的两个基本配置） C、如果要在windows的eclipse中提交job给集群，则要修改YarnRunner类 mapreduce程序在集群中运行时的大体流程： 附：在windows平台上访问hadoop时改变自身身份标识的方法之二： 3. MAPREDUCE中的Combiner combiner是MR程序中Mapper和Reducer之外的一种组件 combiner组件的父类就是Reducer combiner和reducer的区别在于运行的位置： Combiner是在每一个maptask所在的节点运行 Reducer是接收全局所有Mapper的输出结果； (4) combiner的意义就是对每一个maptask的输出进行局部汇总，以减小网络传输量 具体实现步骤： 自定义一个combiner继承Reducer，重写reduce方法 在job中设置： setCombinerClass(CustomCombiner.class) (5) combiner能够应用的前提是不能影响最终的业务逻辑 而且，combiner的输出kv应该跟reducer的输入kv类型要对应起来 3. MAPREDUCE原理篇（2）3.1 mapreduce的shuffle机制3.1.1 概述： mapreduce中，map阶段处理的数据如何传递给reduce阶段，是mapreduce框架中最关键的一个流程，这个流程就叫shuffle； shuffle: 洗牌、发牌——（核心机制：数据分区，排序，缓存）； 具体来说：就是将maptask输出的处理结果数据，分发给reducetask，并在分发的过程中，_对数据按key进行了分区和排序；_ 3.1.2 主要流程：Shuffle缓存流程： shuffle是MR处理流程中的一个过程，它的每一个处理步骤是分散在各个map task和reduce task节点上完成的，整体来看，分为3个操作： 分区partition Sort根据key排序 Combiner进行局部value的合并 3.1.3 详细流程 maptask收集我们的map()方法输出的kv对，放到内存缓冲区中 从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件 多个溢出文件会被合并成大的溢出文件 在溢出过程中，及合并的过程中，都要调用partitoner进行分组和针对key进行排序 reducetask根据自己的分区号，去各个maptask机器上取相应的结果分区数据 reducetask会取到同一个分区的来自不同maptask的结果文件，reducetask会将这些文件再进行合并（归并排序） 合并成大文件后，shuffle的过程也就结束了，后面进入reducetask的逻辑运算过程（从文件中取出一个一个的键值对group，调用用户自定义的reduce()方法） Shuffle中的缓冲区大小会影响到mapreduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快 缓冲区的大小可以通过参数调整, 参数：io.sort.mb 默认100M 3.1.4 详细流程示意图3.2. MAPREDUCE中的序列化3.2.1 概述Java的序列化是一个重量级序列化框架（Serializable），一个对象被序列化后，会附带很多额外的信息（各种校验信息，header，继承体系。。。。），不便于在网络中高效传输； 所以，hadoop自己开发了一套序列化机制（Writable），精简，高效 3.2.2 Jdk序列化和MR序列化之间的比较简单代码验证两种序列化机制的差别： _public class TestSeri {_ _ public static void main(String[] args) throws Exception {_ _ //定义两个ByteArrayOutputStream，用来接收不同序列化机制的序列化结果_ _ ByteArrayOutputStream ba = new ByteArrayOutputStream();_ _ ByteArrayOutputStream ba2 = new ByteArrayOutputStream();_ _ //定义两个DataOutputStream，用于将普通对象进行jdk标准序列化_ _ DataOutputStream dout = new DataOutputStream(ba);_ _ DataOutputStream dout2 = new DataOutputStream(ba2);_ _ ObjectOutputStream obout = new ObjectOutputStream(dout2);_ _ //定义两个bean，作为序列化的源对象_ _ ItemBeanSer itemBeanSer = new ItemBeanSer(1000L, 89.9f);_ _ ItemBean itemBean = new ItemBean(1000L, 89.9f);_ _ //用于比较String类型和Text类型的序列化差别_ _ Text atext = new Text(“a”);_ _ // atext.write(dout);_ _ itemBean.write(dout);_ _ byte[] byteArray = ba.toByteArray();_ _ //__比较序列化结果_ _ System.out.println(byteArray.length);_ _ for (byte b : byteArray) {_ _ System.out.print(b);_ _ System.out.print(“:”);_ _ }_ _ System.out.println(“———————————-“);_ _ String astr = “a”;_ _ // dout2.writeUTF(astr);_ _ obout.writeObject(itemBeanSer);_ _ byte[] byteArray2 = ba2.toByteArray();_ _ System.out.println(byteArray2.length);_ _ for (byte b : byteArray2) {_ _ System.out.print(b);_ _ System.out.print(“:”);_ _ }_ _ }_ _}_ 3.2.3 自定义对象实现MR中的序列化接口如果需要将自定义的bean放在key中传输，则还需要实现comparable接口，因为mapreduce框中的shuffle过程一定会对key进行排序,此时，自定义的bean实现的接口应该是： public class FlowBean implements WritableComparable 需要自己实现的方法是： /\*\* \* 反序列化的方法，反序列化时，从流中读取到的各个字段的顺序应该与序列化时写出去的顺序保持一致 */ @Override public void readFields(DataInput in) throws IOException { upflow = in.readLong(); dflow = in.readLong(); sumflow = in.readLong(); } /** * 序列化的方法 */ @Override public void write(DataOutput out) throws IOException { out.writeLong(upflow); out.writeLong(dflow); //可以考虑不序列化总流量，因为总流量是可以通过上行流量和下行流量计算出来的 out.writeLong(sumflow); } @Override public int compareTo(FlowBean o) { //实现按照sumflow的大小倒序排序 return sumflow&gt;o.getSumflow()?-1:1; } 3.3. MapReduce与YARN3.3.1 YARN概述Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而mapreduce等运算程序则相当于运行于操作系统之上的应用程序 3.3.2 YARN的重要概念 yarn并不清楚用户提交的程序的运行机制 yarn只提供运算资源的调度（用户程序向yarn申请资源，yarn就负责分配资源） yarn中的主管角色叫ResourceManager yarn中具体提供运算资源的角色叫NodeManager 这样一来，yarn其实就与运行的用户程序完全解耦，就意味着yarn上可以运行各种类型的分布式运算程序（mapreduce只是其中的一种），比如mapreduce、storm程序，spark程序，tez …… 所以，spark、storm等运算框架都可以整合在yarn上运行，只要他们各自的框架中有符合yarn规范的资源请求机制即可 Yarn就成为一个通用的资源调度平台，从此，企业中以前存在的各种运算集群都可以整合在一个物理集群上，提高资源利用率，方便数据共享 3.3.3 Yarn中运行运算程序的示例mapreduce程序的调度过程，如下图 4. MAPREDUCE实践篇（2）4.1. Mapreduce中的排序初步4.1.1 需求对日志数据中的上下行流量信息汇总，并输出按照总流量倒序排序的结果 数据如下： 1363157985066 13726230503 00-FD-07-A4-72-B8:CMCC 120.196.100.82 24 27 2481 24681 200 1363157995052 13826544101 5C-0E-8B-C7-F1-E0:CMCC 120.197.40.4 4 0 264 0 200 1363157991076 13926435656 20-10-7A-28-CC-0A:CMCC 120.196.100.99 2 4 132 1512 200 1363154400022 13926251106 5C-0E-8B-8B-B1-50:CMCC 120.197.40.4 4 0 240 0 200 4.1.2 分析基本思路：实现自定义的bean来封装流量信息，并将bean作为map输出的key来传输 MR程序在处理数据的过程中会对数据排序(map输出的kv对传输到reduce之前，会排序)，排序的依据是map输出的key 所以，我们如果要实现自己需要的排序规则，则可以考虑将排序因素放到key中，让key实现接口：WritableComparable 然后重写key的compareTo方法 4.1.3 实现 自定义的bean public class FlowBean implements WritableComparable{ long upflow; long downflow; long sumflow; //如果空参构造函数被覆盖，一定要显示定义一下，否则在反序列时会抛异常 public FlowBean(){} public FlowBean(long upflow, long downflow) { super(); this.upflow = upflow; this.downflow = downflow; this.sumflow = upflow + downflow; } public long getSumflow() { return sumflow; } public void setSumflow(long sumflow) { this.sumflow = sumflow; } public long getUpflow() { return upflow; } public void setUpflow(long upflow) { this.upflow = upflow; } public long getDownflow() { return downflow; } public void setDownflow(long downflow) { this.downflow = downflow; } //序列化，将对象的字段信息写入输出流 @Override public void write(DataOutput out) throws IOException { out.writeLong(upflow); out.writeLong(downflow); out.writeLong(sumflow); } //反序列化，从输入流中读取各个字段信息 @Override public void readFields(DataInput in) throws IOException { upflow = in.readLong(); downflow = in.readLong(); sumflow = in.readLong(); } @Override public String toString() { return upflow + “\\t” + downflow + “\\t” + sumflow; } @Override public int compareTo(FlowBean o) { //自定义倒序比较规则 return sumflow &gt; o.getSumflow() ? -1:1; } } mapper 和 reducer public class FlowCount { static class FlowCountMapper extends Mapper { @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String line = value.toString(); String[] fields = line.split(“\\t”); try { String phonenbr = fields[0]; long upflow = Long.parseLong(fields[1]); long dflow = Long.parseLong(fields[2]); FlowBean flowBean = new FlowBean(upflow, dflow); context.write(flowBean,new Text(phonenbr)); } catch (Exception e) { e.printStackTrace(); } } } static class FlowCountReducer extends Reducer { @Override protected void reduce(FlowBean bean, Iterable phonenbr, Context context) throws IOException, InterruptedException { Text phoneNbr = phonenbr.iterator().next(); context.write(phoneNbr, bean); } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(FlowCount.class); job.setMapperClass(FlowCountMapper.class); job.setReducerClass(FlowCountReducer.class); job.setMapOutputKeyClass(FlowBean.class); job.setMapOutputValueClass(Text.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(FlowBean.class); // job.setInputFormatClass(TextInputFormat.class); FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); job.waitForCompletion(true); } } 4.2. Mapreduce中的分区Partitioner4.2.1 需求根据归属地输出流量统计数据结果到不同文件，以便于在查询统计结果时可以定位到省级范围进行 4.2.2 分析Mapreduce中会将map输出的kv对，按照相同key分组，然后分发给不同的reducetask 默认的分发规则为：根据key的hashcode%reducetask数来分发 所以：如果要按照我们自己的需求进行分组，则需要改写数据分发（分组）组件Partitioner 自定义一个CustomPartitioner继承抽象类：Partitioner 然后在job对象中，设置自定义partitioner： job.setPartitionerClass(CustomPartitioner.class) 4.2.3 实现/** * 定义自己的从map到reduce之间的数据（分组）分发规则 按照手机号所属的省份来分发（分组）ProvincePartitioner 默认的分组组件是HashPartitioner @author */ public class ProvincePartitioner extends Partitioner { static HashMap provinceMap = new HashMap(); static { provinceMap.put(“135”, 0); provinceMap.put(“136”, 1); provinceMap.put(“137”, 2); provinceMap.put(“138”, 3); provinceMap.put(“139”, 4); } @Override public int getPartition(Text key, FlowBean value, int numPartitions) { Integer code = provinceMap.get(key.toString().substring(0, 3)); return code == null ? 5 : code; } } 4.3. mapreduce数据压缩4.3.1 概述这是mapreduce**的一种优化策略：通过压缩编码对mapper或者reducer的输出进行压缩，以减少磁盘IO，**提高MR程序运行速度（但相应增加了cpu运算负担） Mapreduce支持将map输出的结果或者reduce输出的结果进行压缩，以减少网络IO或最终输出数据的体积 压缩特性运用得当能提高性能，但运用不当也可能降低性能 基本原则： 运算密集型的job，少用压缩 IO密集型的job，多用压缩 4.3.2 MR支持的压缩编码4.3.3 Reducer输出压缩在配置参数或在代码中都可以设置reduce的输出压缩 1、在配置参数中设置 mapreduce.output.fileoutputformat.compress=false mapreduce.output.fileoutputformat.compress.codec=org.apache.hadoop.io.compress.DefaultCodec mapreduce.output.fileoutputformat.compress.type=RECORD 2、在代码中设置 Job job = Job.getInstance(conf); FileOutputFormat.setCompressOutput(job, true); FileOutputFormat.setOutputCompressorClass(job, (Class&lt;? extends CompressionCodec&gt;) Class.forName(&quot;&quot;)); 4.3.4 Mapper输出压缩在配置参数或在代码中都可以设置reduce的输出压缩 1、在配置参数中设置 mapreduce.map.output.compress=false mapreduce.map.output.compress.codec=org.apache.hadoop.io.compress.DefaultCodec 2、在代码中设置： conf.setBoolean(Job.MAP_OUTPUT_COMPRESS, true); conf.setClass(Job.MAP_OUTPUT_COMPRESS_CODEC, GzipCodec.class, CompressionCodec.class); 4.3.5 压缩文件的读取Hadoop自带的InputFormat类内置支持压缩文件的读取，比如TextInputformat类，在其initialize方法中： public void initialize(InputSplit genericSplit, TaskAttemptContext context) throws IOException { FileSplit split = (FileSplit) genericSplit; Configuration job = context.getConfiguration(); this.maxLineLength = job.getInt(MAX_LINE_LENGTH, Integer.MAX_VALUE); start = split.getStart(); end = start + split.getLength(); final Path file = split.getPath(); // open the file and seek to the start of the split final FileSystem fs = file.getFileSystem(job); fileIn = fs.open(file); //根据文件后缀名创建相应压缩编码的codec CompressionCodec codec = new CompressionCodecFactory(job).getCodec(file); if (null!=codec) { isCompressedInput = true; decompressor = CodecPool.getDecompressor(codec); //判断是否属于可切片压缩编码类型 if (codec instanceof SplittableCompressionCodec) { final SplitCompressionInputStream cIn = ((SplittableCompressionCodec)codec).createInputStream( fileIn, decompressor, start, end, SplittableCompressionCodec.READ_MODE.BYBLOCK); //如果是可切片压缩编码，则创建一个CompressedSplitLineReader读取压缩数据 in = new CompressedSplitLineReader(cIn, job, this.recordDelimiterBytes); start = cIn.getAdjustedStart(); end = cIn.getAdjustedEnd(); filePosition = cIn; } else { //如果是不可切片压缩编码，则创建一个SplitLineReader读取压缩数据，并将文件输入流转换成解压数据流传递给普通SplitLineReader读取 in = new SplitLineReader(codec.createInputStream(fileIn, decompressor), job, this.recordDelimiterBytes); filePosition = fileIn; } } else { fileIn.seek(start); //如果不是压缩文件，则创建普通SplitLineReader读取数据 in = new SplitLineReader(fileIn, job, this.recordDelimiterBytes); filePosition = fileIn; } 4.4. 更多MapReduce编程案例4.4.1 reduce端join算法实现1、需求： 订单数据表t_order： id date pid amount 1001 20150710 P0001 2 1002 20150710 P0001 3 1002 20150710 P0002 3 商品信息表t_product id pname category_id price P0001 小米5 1000 2 P0002 锤子T1 1000 3 假如数据量巨大，两表的数据是以文件的形式存储在HDFS中，需要用mapreduce程序来实现一下SQL查询运算： select a.id,a.date,b.name,b.category_id,b.price from t_order a join t_product b on a.pid = b.id 2、实现机制： 通过将关联的条件作为map输出的key，将两表满足join条件的数据并携带数据所来源的文件信息，发往同一个reduce task，在reduce中进行数据的串联 public class OrderJoin { static class OrderJoinMapper extends Mapper { @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { // 拿到一行数据，并且要分辨出这行数据所属的文件 String line = value.toString(); String[] fields = line.split(“\\t”); // 拿到itemid String itemid = fields[0]; // 获取到这一行所在的文件名（通过inpusplit） String name = “你拿到的文件名”; // 根据文件名，切分出各字段（如果是a，切分出两个字段，如果是b，切分出3个字段） OrderJoinBean bean = new OrderJoinBean(); bean.set(null, null, null, null, null); context.write(new Text(itemid), bean); } } static class OrderJoinReducer extends Reducer { @Override protected void reduce(Text key, Iterable beans, Context context) throws IOException, InterruptedException { //拿到的key是某一个itemid,比如1000 //拿到的beans是来自于两类文件的bean // {1000,amount} {1000,amount} {1000,amount} —- {1000,price,name} //将来自于b文件的bean里面的字段，跟来自于a的所有bean进行字段拼接并输出 } } } 缺点：这种方式中，join的操作是在reduce阶段完成，reduce端的处理压力太大，map节点的运算负载则很低，资源利用率不高，且在reduce阶段极易产生数据倾斜 解决方案： map端join实现方式 4.4.2 map端join算法实现1、原理阐述 适用于关联表中有小表的情形； 可以将小表分发到所有的map节点，这样，map节点就可以在本地对自己所读到的大表数据进行join并输出最终结果，可以大大提高join操作的并发度，加快处理速度 2、实现示例 —先在mapper类中预先定义好小表，进行join —引入实际场景中的解决方案：一次加载数据库或者用distributedcache public class TestDistributedCache { static class TestDistributedCacheMapper extends Mapper{ FileReader in = null; BufferedReader reader = null; HashMap b_tab = new HashMap(); String localpath =null; String uirpath = null; //是在map任务初始化的时候调用一次 @Override protected void setup(Context context) throws IOException, InterruptedException { //通过这几句代码可以获取到cache file的本地绝对路径，测试验证用 Path[] files = context.getLocalCacheFiles(); localpath = files[0].toString(); URI[] cacheFiles = context.getCacheFiles(); //缓存文件的用法——直接用本地IO来读取 //这里读的数据是map task所在机器本地工作目录中的一个小文件 in = new FileReader(“b.txt”); reader =new BufferedReader(in); String line =null; while(null!=(line=reader.readLine())){ String[] fields = line.split(“,”); b_tab.put(fields[0],fields[1]); } IOUtils.closeStream(reader); IOUtils.closeStream(in); } @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { //这里读的是这个map task所负责的那一个切片数据（在hdfs上） String[] fields = value.toString().split(“\\t”); String a_itemid = fields[0]; String a_amount = fields[1]; String b_name = b_tab.get(a_itemid); // 输出结果 1001 98.9 banan context.write(new Text(a_itemid), new Text(a_amount + “\\t” + “:” + localpath + “\\t” +b_name )); } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(TestDistributedCache.class); job.setMapperClass(TestDistributedCacheMapper.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(LongWritable.class); //这里是我们正常的需要处理的数据所在路径 FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); //不需要reducer job.setNumReduceTasks(0); //分发一个文件到task进程的工作目录 job.addCacheFile(new URI(“hdfs://hadoop-server01:9000/cachefile/b.txt”)); //分发一个归档文件到task进程的工作目录 // job.addArchiveToClassPath(archive); //分发jar包到task节点的classpath下 // job.addFileToClassPath(jarfile); job.waitForCompletion(true); } } 4.4.3 web日志预处理1、需求： 对web访问日志中的各字段识别切分 去除日志中不合法的记录 根据KPI统计需求，生成各类访问请求过滤数据 2、实现代码： a) 定义一个bean，用来记录日志数据中的各数据字段 public class WebLogBean { private String remote_addr;// 记录客户端的ip地址 private String remote_user;// 记录客户端用户名称,忽略属性”-“ private String time_local;// 记录访问时间与时区 private String request;// 记录请求的url与http协议 private String status;// 记录请求状态；成功是200 private String body_bytes_sent;// 记录发送给客户端文件主体内容大小 private String http_referer;// 用来记录从那个页面链接访问过来的 private String http_user_agent;// 记录客户浏览器的相关信息 private boolean valid = true;// 判断数据是否合法 public String getRemote_addr() { return remote_addr; } public void setRemote_addr(String remote_addr) { this.remote_addr = remote_addr; } public String getRemote_user() { return remote_user; } public void setRemote_user(String remote_user) { this.remote_user = remote_user; } public String getTime_local() { return time_local; } public void setTime_local(String time_local) { this.time_local = time_local; } public String getRequest() { return request; } public void setRequest(String request) { this.request = request; } public String getStatus() { return status; } public void setStatus(String status) { this.status = status; } public String getBody_bytes_sent() { return body_bytes_sent; } public void setBody_bytes_sent(String body_bytes_sent) { this.body_bytes_sent = body_bytes_sent; } public String getHttp_referer() { return http_referer; } public void setHttp_referer(String http_referer) { this.http_referer = http_referer; } public String getHttp_user_agent() { return http_user_agent; } public void setHttp_user_agent(String http_user_agent) { this.http_user_agent = http_user_agent; } public boolean isValid() { return valid; } public void setValid(boolean valid) { this.valid = valid; } @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(this.valid); sb.append(“\\001”).append(this.remote_addr); sb.append(“\\001”).append(this.remote_user); sb.append(“\\001”).append(this.time_local); sb.append(“\\001”).append(this.request); sb.append(“\\001”).append(this.status); sb.append(“\\001”).append(this.body_bytes_sent); sb.append(“\\001”).append(this.http_referer); sb.append(“\\001”).append(this.http_user_agent); return sb.toString(); } } b)定义一个parser用来解析过滤web访问日志原始记录 public class WebLogParser { public static WebLogBean parser(String line) { WebLogBean webLogBean = new WebLogBean(); String[] arr = line.split(“ “); if (arr.length &gt; 11) { webLogBean.setRemote_addr(arr[0]); webLogBean.setRemote_user(arr[1]); webLogBean.setTime_local(arr[3].substring(1)); webLogBean.setRequest(arr[6]); webLogBean.setStatus(arr[8]); webLogBean.setBody_bytes_sent(arr[9]); webLogBean.setHttp_referer(arr[10]); if (arr.length &gt; 12) { webLogBean.setHttp_user_agent(arr[11] + “ “ + arr[12]); } else { webLogBean.setHttp_user_agent(arr[11]); } if (Integer.parseInt(webLogBean.getStatus()) &gt;= 400) {// 大于400，HTTP错误 webLogBean.setValid(false); } } else { webLogBean.setValid(false); } return webLogBean; } public static String parserTime(String time) { time.replace(“/“, “-“); return time; } } c) mapreduce程序 public class WeblogPreProcess { static class WeblogPreProcessMapper extends Mapper { Text k = new Text(); NullWritable v = NullWritable.get(); @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String line = value.toString(); WebLogBean webLogBean = WebLogParser.parser(line); if (!webLogBean.isValid()) return; k.set(webLogBean.toString()); context.write(k, v); } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(WeblogPreProcess.class); job.setMapperClass(WeblogPreProcessMapper.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(NullWritable.class); FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); job.waitForCompletion(true); } }]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day08-02_BigData渐进学习_aclear_fire]]></title>
    <url>%2Fpost%2F4dcf08e3.html</url>
    <content type="text"><![CDATA[&lt;&lt;无图片版本&gt;&gt; 目录课程大纲（MAPREDUCE详解）… 1 流量统计相关需求… 2 社交粉丝数据分析… 3 倒排索引建立… 4 自定义inputFormat 5 1.1 需求… 5 1.2 分析… 5 1.3 实现… 5 自定义outputFormat 8 2.1 需求… 8 2.2 分析… 9 2.3 实现… 9 自定义GroupingComparator. 14 3.1 需求… 14 3.2 分析… 14 3.3 实现… 14 Mapreduce中的DistributedCache应用… 18 4.1 Map端join案例… 18 4.1.1 需求… 18 4.1.2 分析… 18 4.1.3 实现… 19 Mapreduce的其他补充… 21 5.1 计数器应用… 21 5.2 多job串联… 22 mapreduce参数优化… 23 11.1 资源相关参数… 23 11.2 容错相关参数… 23 11.3 本地运行mapreduce 作业… 24 11.4 效率和稳定性相关参数… 24 课程大纲（MAPREDUCE详解）MapReduce快速入门 如何理解map、reduce计算模型 Mapreudce程序运行演示 Mapreduce编程规范及示例编写 Mapreduce程序运行模式及debug方法 MapReduce高级特性 Mapreduce程序的核心机制 MapReduce的序列化框架 MapReduce的排序实现 MapReduce的分区机制及自定义 Mapreduce的数据压缩 Mapreduce与yarn的结合 Mapreduce编程案例 Mapreduce 参数优化 目标： 掌握mapreduce分布式运算框架的编程思想 掌握mapreduce常用算法的编程套路 掌握mapreduce分布式运算框架的运行机制，具备一定自定义开发的能力 流量统计相关需求 对流量日志中的用户统计总上、下行流量 技术点： 自定义javaBean用来在mapreduce中充当value 注意： javaBean要实现Writable接口，实现两个方法 //序列化，将对象的字段信息写入输出流 @Override public void write(DataOutput out) throws IOException { out.writeLong(upflow); out.writeLong(downflow); out.writeLong(sumflow); } //反序列化，从输入流中读取各个字段信息 @Override public void readFields(DataInput in) throws IOException { upflow = in.readLong(); downflow = in.readLong(); sumflow = in.readLong(); } 统计流量且按照流量大小倒序排序 技术点：这种需求，用一个mapreduce -job 不好实现，需要两个mapreduce -job 第一个job负责流量统计，跟上题相同 第二个job读入第一个job的输出，然后做排序 要将flowBean作为map的key输出，这样mapreduce就会自动排序 此时，flowBean要实现接口WritableComparable 要实现其中的compareTo()方法，方法中，我们可以定义倒序比较的逻辑 统计流量且按照手机号的归属地，将结果数据输出到不同的省份文件中 技术点：自定义Partitioner _ @Override_ _ public int getPartition(Text key, FlowBean value, int numPartitions) {_ _ String prefix = key.toString().substring(0,3);_ _ Integer partNum = pmap.get(prefix);_ _ return (partNum==null?4:partNum);_ _ }_ 自定义partition后，要根据自定义partitioner的逻辑设置相应数量的reduce task job.setNumReduceTasks(5); 注意：如果reduceTask的数量&gt;= _getPartition的结果数_ _，则会多产生几个空的输出文件part-r-000xx_ _如果 1&lt;reduceTask的数量&lt;getPartition的结果数_ _，则有一部分分区数据无处安放，会Exception！！！_ _如果_ reduceTask的数量=1，则不管mapTask端输出多少个分区文件，最终结果都交给这一个reduceTask，最终也就只会产生一个结果文件 part-r-00000 社交粉丝数据分析以下是qq的好友列表数据，冒号前是一个用，冒号后是该用户的所有好友（数据中的好友关系是单向的） A:B,C,D,F,E,O B:A,C,E,K C:F,A,D,I D:A,E,F,L E:B,C,D,M,L F:A,B,C,D,E,O,M G:A,C,D,E,F H:A,C,D,E,O I:A,O J:B,O K:A,C,D L:D,E,F M:E,F,G O:A,H,I,J 求出哪些人两两之间有共同好友，及他俩的共同好友都有谁？ 解题思路： 第一步 map 读一行 A:B,C,D,F,E,O 输出 在读一行 B:A,C,E,K 输出 REDUCE 拿到的数据比如…… 输出： ….. 第二步 map 读入一行 直接输出 reduce 读入数据 ……. 输出： A-B C,F,G,….. 扩展：求互粉的人！！！！ 倒排索引建立需求：有大量的文本（文档、网页），需要建立搜索索引 1. 自定义inputFormat1.1 需求无论hdfs还是mapreduce，对于小文件都有损效率，实践中，又难免面临处理大量小文件的场景，此时，就需要有相应解决方案 1.2 分析小文件的优化无非以下几种方式： 在数据采集的时候，就将小文件或小批数据合成大文件再上传HDFS 在业务处理之前，在HDFS上使用mapreduce程序对小文件进行合并 在mapreduce处理时，可采用combineInputFormat提高效率 1.3 实现本节实现的是上述第二种方式 程序的核心机制： 自定义一个InputFormat 改写RecordReader，实现一次读取一个完整文件封装为KV 在输出时使用SequenceFileOutPutFormat输出合并文件 代码如下： 自定义InputFromat public class WholeFileInputFormat extends FileInputFormat { //设置每个小文件不可分片,保证一个小文件生成一个key-value键值对 @Override protected boolean isSplitable(JobContext context, Path file) { return false; } @Override public RecordReader createRecordReader( InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException { WholeFileRecordReader reader = new WholeFileRecordReader(); reader.initialize(split, context); return reader; } } 自定义RecordReader class WholeFileRecordReader extends RecordReader { private FileSplit fileSplit; private Configuration conf; private BytesWritable value = new BytesWritable(); private boolean processed = false; @Override public void initialize(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException { this.fileSplit = (FileSplit) split; this.conf = context.getConfiguration(); } @Override public boolean nextKeyValue() throws IOException, InterruptedException { if (!processed) { byte[] contents = new byte[(int) fileSplit.getLength()]; Path file = fileSplit.getPath(); FileSystem fs = file.getFileSystem(conf); FSDataInputStream in = null; try { in = fs.open(file); IOUtils.readFully(in, contents, 0, contents.length); value.set(contents, 0, contents.length); } finally { IOUtils.closeStream(in); } processed = true; return true; } return false; } @Override public NullWritable getCurrentKey() throws IOException, InterruptedException { return NullWritable.get(); } @Override public BytesWritable getCurrentValue() throws IOException, InterruptedException { return value; } @Override public float getProgress() throws IOException { return processed ? 1.0f : 0.0f; } @Override public void close() throws IOException { // do nothing } } 定义mapreduce处理流程 public class SmallFilesToSequenceFileConverter extends Configured implements Tool { static class SequenceFileMapper extends Mapper { private Text filenameKey; @Override protected void setup(Context context) throws IOException, InterruptedException { InputSplit split = context.getInputSplit(); Path path = ((FileSplit) split).getPath(); filenameKey = new Text(path.toString()); } @Override protected void map(NullWritable key, BytesWritable value, Context context) throws IOException, InterruptedException { context.write(filenameKey, value); } } @Override public int run(String[] args) throws Exception { Configuration conf = new Configuration(); System.setProperty(“HADOOP_USER_NAME”, “hdfs”); String[] otherArgs = new GenericOptionsParser(conf, args) .getRemainingArgs(); if (otherArgs.length != 2) { System.err.println(“Usage: combinefiles “); System.exit(2); } Job job = Job.getInstance(conf,”combine small files to sequencefile”); // job.setInputFormatClass(WholeFileInputFormat.class); job.setOutputFormatClass(SequenceFileOutputFormat.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(BytesWritable.class); job.setMapperClass(SequenceFileMapper.class); return job.waitForCompletion(true) ? 0 : 1; } public static void main(String[] args) throws Exception { int exitCode = ToolRunner.run(new SmallFilesToSequenceFileConverter(), args); System.exit(exitCode); } } 2. 自定义outputFormat2.1 需求现有一些原始日志需要做增强解析处理，流程： 从原始日志文件中读取数据 根据日志中的一个URL字段到外部知识库中获取信息增强到原始日志 如果成功增强，则输出到增强结果目录；如果增强失败，则抽取原始数据中URL字段输出到待爬清单目录 2.2 分析程序的关键点是要在一个mapreduce程序中根据数据的不同输出两类结果到不同目录，这类灵活的输出需求可以通过自定义outputformat来实现 2.3 实现实现要点： 在mapreduce中访问外部资源 自定义outputformat，改写其中的recordwriter，改写具体输出数据的方法write() 代码实现如下： 数据库获取数据的工具 public class DBLoader { public static void dbLoader(HashMap ruleMap) { Connection conn = null; Statement st = null; ResultSet res = null; try { Class.forName(“com.mysql.jdbc.Driver”); conn = DriverManager.getConnection(“jdbc:mysql://hdp-node01:3306/urlknowledge”, “root”, “root”); st = conn.createStatement(); res = st.executeQuery(“select url,content from urlcontent”); while (res.next()) { ruleMap.put(res.getString(1), res.getString(2)); } } catch (Exception e) { e.printStackTrace(); } finally { try{ if(res!=null){ res.close(); } if(st!=null){ st.close(); } if(conn!=null){ conn.close(); } }catch(Exception e){ e.printStackTrace(); } } } public static void main(String[] args) { DBLoader db = new DBLoader(); HashMap map = new HashMap(); db.dbLoader(map); System.out.println(map.size()); } } 自定义一个outputformat public class LogEnhancerOutputFormat extends FileOutputFormat{ @Override public RecordWriter getRecordWriter(TaskAttemptContext context) throws IOException, InterruptedException { FileSystem fs = FileSystem.get(context.getConfiguration()); Path enhancePath = new Path(“hdfs://hdp-node01:9000/flow/enhancelog/enhanced.log”); Path toCrawlPath = new Path(“hdfs://hdp-node01:9000/flow/tocrawl/tocrawl.log”); FSDataOutputStream enhanceOut = fs.create(enhancePath); FSDataOutputStream toCrawlOut = fs.create(toCrawlPath); return new MyRecordWriter(enhanceOut,toCrawlOut); } static class MyRecordWriter extends RecordWriter{ FSDataOutputStream enhanceOut = null; FSDataOutputStream toCrawlOut = null; public MyRecordWriter(FSDataOutputStream enhanceOut, FSDataOutputStream toCrawlOut) { this.enhanceOut = enhanceOut; this.toCrawlOut = toCrawlOut; } @Override public void write(Text key, NullWritable value) throws IOException, InterruptedException { //有了数据，你来负责写到目的地 —— hdfs //判断，进来内容如果是带tocrawl的，就往待爬清单输出流中写 toCrawlOut if(key.toString().contains(“tocrawl”)){ toCrawlOut.write(key.toString().getBytes()); }else{ enhanceOut.write(key.toString().getBytes()); } } @Override public void close(TaskAttemptContext context) throws IOException, InterruptedException { if(toCrawlOut!=null){ toCrawlOut.close(); } if(enhanceOut!=null){ enhanceOut.close(); } } } } 开发mapreduce处理流程 /** * 这个程序是对每个小时不断产生的用户上网记录日志进行增强(将日志中的url所指向的网页内容分析结果信息追加到每一行原始日志后面) @author / public class LogEnhancer { static class LogEnhancerMapper extends Mapper { HashMap knowledgeMap = new HashMap(); /* maptask在初始化时会先调用setup方法一次 利用这个机制，将外部的知识库加载到maptask执行的机器内存中 */ @Override protected void setup(org.apache.hadoop.mapreduce.Mapper.Context context) throws IOException, InterruptedException { DBLoader.dbLoader(knowledgeMap); } @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String line = value.toString(); String[] fields = StringUtils.split(line, “\\t”); try { String url = fields[26]; // 对这一行日志中的url去知识库中查找内容分析信息 String content = knowledgeMap.get(url); // 根据内容信息匹配的结果，来构造两种输出结果 String result = “”; if (null == content) { // 输往待爬清单的内容 result = url + “\\t” + “tocrawl\\n”; } else { // 输往增强日志的内容 result = line + “\\t” + content + “\\n”; } context.write(new Text(result), NullWritable.get()); } catch (Exception e) { } } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(LogEnhancer.class); job.setMapperClass(LogEnhancerMapper.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(NullWritable.class); // 要将自定义的输出格式组件设置到job中 job.setOutputFormatClass(LogEnhancerOutputFormat.class); FileInputFormat.setInputPaths(job, new Path(args[0])); // 虽然我们自定义了outputformat，但是因为我们的outputformat继承自fileoutputformat // 而fileoutputformat要输出一个_SUCCESS文件，所以，在这还得指定一个输出目录 FileOutputFormat.setOutputPath(job, new Path(args[1])); job.waitForCompletion(true); System.exit(0); } } 3. 自定义GroupingComparator3.1 需求有如下订单数据 订单id 商品id 成交金额 Order_0000001 Pdt_01 222.8 Order_0000001 Pdt_05 25.8 Order_0000002 Pdt_03 522.8 Order_0000002 Pdt_04 122.4 Order_0000003 Pdt_01 222.8 现在需要求出每一个订单中成交金额最大的一笔交易 3.2 分析1、利用“订单id和成交金额”作为key，可以将map阶段读取到的所有订单数据按照id分区，按照金额排序，发送到reduce 2、在reduce端利用groupingcomparator将订单id相同的kv聚合成组，然后取第一个即是最大值 3.3 实现自定义groupingcomparator /** * 用于控制shuffle过程中reduce端对kv对的聚合逻辑 @author duanhaitao@itcast.cn */ public class ItemidGroupingComparator extends WritableComparator { protected ItemidGroupingComparator() { super(OrderBean.class, true); } @Override public int compare(WritableComparable a, WritableComparable b) { OrderBean abean = (OrderBean) a; OrderBean bbean = (OrderBean) b; //将item_id相同的bean都视为相同，从而聚合为一组 return abean.getItemid().compareTo(bbean.getItemid()); } } 定义订单信息bean /** * 订单信息bean，实现hadoop的序列化机制 @author duanhaitao@itcast.cn */ public class OrderBean implements WritableComparable{ private Text itemid; private DoubleWritable amount; public OrderBean() { } public OrderBean(Text itemid, DoubleWritable amount) { set(itemid, amount); } public void set(Text itemid, DoubleWritable amount) { this.itemid = itemid; this.amount = amount; } public Text getItemid() { return itemid; } public DoubleWritable getAmount() { return amount; } @Override public int compareTo(OrderBean o) { int cmp = this.itemid.compareTo(o.getItemid()); if (cmp == 0) { cmp = -this.amount.compareTo(o.getAmount()); } return cmp; } @Override public void write(DataOutput out) throws IOException { out.writeUTF(itemid.toString()); out.writeDouble(amount.get()); } @Override public void readFields(DataInput in) throws IOException { String readUTF = in.readUTF(); double readDouble = in.readDouble(); this.itemid = new Text(readUTF); this.amount= new DoubleWritable(readDouble); } @Override public String toString() { return itemid.toString() + “\\t” + amount.get(); } } 编写mapreduce处理流程 /** * 利用secondarysort机制输出每种item订单金额最大的记录 @author duanhaitao@itcast.cn */ public class SecondarySort { static class SecondarySortMapper extends Mapper{ OrderBean bean = new OrderBean(); @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String line = value.toString(); String[] fields = StringUtils.split(line, “\\t”); bean.set(new Text(fields[0]), new DoubleWritable(Double.parseDouble(fields[1]))); context.write(bean, NullWritable.get()); } } static class SecondarySortReducer extends Reducer{ //在设置了groupingcomparator以后，这里收到的kv数据 就是： ,null ,null …. //此时，reduce方法中的参数key就是上述kv组中的第一个kv的key： //要输出同一个item的所有订单中最大金额的那一个，就只要输出这个key @Override protected void reduce(OrderBean key, Iterable values, Context context) throws IOException, InterruptedException { context.write(key, NullWritable.get()); } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(SecondarySort.class); job.setMapperClass(SecondarySortMapper.class); job.setReducerClass(SecondarySortReducer.class); job.setOutputKeyClass(OrderBean.class); job.setOutputValueClass(NullWritable.class); FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); //指定shuffle所使用的GroupingComparator类 job.setGroupingComparatorClass(ItemidGroupingComparator.class); //指定shuffle所使用的partitioner类 job.setPartitionerClass(ItemIdPartitioner.class); job.setNumReduceTasks(3); job.waitForCompletion(true); } } 4. Mapreduce中的DistributedCache应用4.1 Map端join案例4.1.1 需求实现两个“表”的join操作，其中一个表数据量小，一个表很大，这种场景在实际中非常常见，比如“订单日志” join “产品信息” 4.1.2 分析—原理阐述 适用于关联表中有小表的情形； 可以将小表分发到所有的map节点，这样，map节点就可以在本地对自己所读到的大表数据进行join并输出最终结果 可以大大提高join操作的并发度，加快处理速度 —示例：先在mapper类中预先定义好小表，进行join —并用distributedcache机制将小表的数据分发到每一个maptask执行节点，从而每一个maptask节点可以从本地加载到小表的数据，进而在本地即可实现join 4.1.3 实现public class TestDistributedCache { static class TestDistributedCacheMapper extends Mapper{ FileReader in = null; BufferedReader reader = null; HashMap b_tab = new HashMap(); String localpath =null; String uirpath = null; //是在map任务初始化的时候调用一次 @Override protected void setup(Context context) throws IOException, InterruptedException { //通过这几句代码可以获取到cache file的本地绝对路径，测试验证用 Path[] files = context.getLocalCacheFiles(); localpath = files[0].toString(); URI[] cacheFiles = context.getCacheFiles(); //缓存文件的用法——直接用本地IO来读取 //这里读的数据是map task所在机器本地工作目录中的一个小文件 in = new FileReader(“b.txt”); reader =new BufferedReader(in); String line =null; while(null!=(line=reader.readLine())){ String[] fields = line.split(“,”); b_tab.put(fields[0],fields[1]); } IOUtils.closeStream(reader); IOUtils.closeStream(in); } @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { //这里读的是这个map task所负责的那一个切片数据（在hdfs上） String[] fields = value.toString().split(“\\t”); String a_itemid = fields[0]; String a_amount = fields[1]; String b_name = b_tab.get(a_itemid); // 输出结果 1001 98.9 banan context.write(new Text(a_itemid), new Text(a_amount + “\\t” + “:” + localpath + “\\t” +b_name )); } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(TestDistributedCache.class); job.setMapperClass(TestDistributedCacheMapper.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(LongWritable.class); //这里是我们正常的需要处理的数据所在路径 FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); //不需要reducer job.setNumReduceTasks(0); //分发一个文件到task进程的工作目录 job.addCacheFile(new URI(“hdfs://hadoop-server01:9000/cachefile/b.txt”)); //分发一个归档文件到task进程的工作目录 // job.addArchiveToClassPath(archive); //分发jar包到task节点的classpath下 // job.addFileToClassPath(jarfile); job.waitForCompletion(true); } } 5. Mapreduce的其他补充5.1 计数器应用在实际生产代码中，常常需要将数据处理过程中遇到的不合规数据行进行全局计数，类似这种需求可以借助mapreduce框架中提供的全局计数器来实现 示例代码如下： public class MultiOutputs { //通过枚举形式定义自定义计数器 enum MyCounter{MALFORORMED,NORMAL} static class CommaMapper extends Mapper { @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String[] words = value.toString().split(“,”); for (String word : words) { context.write(new Text(word), new LongWritable(1)); } //对枚举定义的自定义计数器加1 context.getCounter(MyCounter.MALFORORMED).increment(1); //通过动态设置自定义计数器加1 context.getCounter(“counterGroupa”, “countera”).increment(1); } } 5.2 多job串联一个稍复杂点的处理逻辑往往需要多个mapreduce程序串联处理，多job的串联可以借助mapreduce框架的JobControl实现 示例代码： ControlledJob cJob1 = new ControlledJob(job1.getConfiguration()); ControlledJob cJob2 = new ControlledJob(job2.getConfiguration()); ControlledJob cJob3 = new ControlledJob(job3.getConfiguration()); // 设置作业依赖关系 cJob2.addDependingJob(cJob1); cJob3.addDependingJob(cJob2); JobControl jobControl = new JobControl(&quot;RecommendationJob&quot;); jobControl.addJob(cJob1); jobControl.addJob(cJob2); jobControl.addJob(cJob3); cJob1.setJob(job1); cJob2.setJob(job2); cJob3.setJob(job3); // 新建一个线程来运行已加入JobControl中的作业，开始进程并等待结束 Thread jobControlThread = new Thread(jobControl); jobControlThread.start(); while (!jobControl.allFinished()) { Thread.sleep(500); } jobControl.stop(); return 0; 5.3 Configuration对象高级应用 6. mapreduce参数优化MapReduce重要配置参数 11.1 资源相关参数(1) mapreduce.map.memory.mb: 一个Map Task可使用的资源上限（单位:MB），默认为1024。如果Map Task实际使用的资源量超过该值，则会被强制杀死。 (2) mapreduce.reduce.memory.mb: 一个Reduce Task可使用的资源上限（单位:MB），默认为1024。如果Reduce Task实际使用的资源量超过该值，则会被强制杀死。 (3) mapreduce.map.java.opts: Map Task的JVM参数，你可以在此配置默认的java heap size等参数, e.g. “-Xmx1024m -verbose:gc -Xloggc:/tmp/@taskid@.gc” （@taskid@会被Hadoop框架自动换为相应的taskid）, 默认值: “” (4) mapreduce.reduce.java.opts: Reduce Task的JVM参数，你可以在此配置默认的java heap size等参数, e.g. “-Xmx1024m -verbose:gc -Xloggc:/tmp/@taskid@.gc”, 默认值: “” (5) mapreduce.map.cpu.vcores: 每个Map task可使用的最多cpu core数目, 默认值: 1 (6) mapreduce.map.cpu.vcores: 每个Reduce task可使用的最多cpu core数目, 默认值: 1 11.2 容错相关参数(1) mapreduce.map.maxattempts: 每个Map Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。 (2) mapreduce.reduce.maxattempts: 每个Reduce Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。 (3) mapreduce.map.failures.maxpercent: 当失败的Map Task失败比例超过该值为，整个作业则失败，默认值为0. 如果你的应用程序允许丢弃部分输入数据，则该该值设为一个大于0的值，比如5，表示如果有低于5%的Map Task失败（如果一个Map Task重试次数超过mapreduce.map.maxattempts，则认为这个Map Task失败，其对应的输入数据将不会产生任何结果），整个作业扔认为成功。 (4) mapreduce.reduce.failures.maxpercent: 当失败的Reduce Task失败比例超过该值为，整个作业则失败，默认值为0. (5) mapreduce.task.timeout: Task超时时间，经常需要设置的一个参数，该参数表达的意思为：如果一个task在一定时间内没有任何进入，即不会读取新的数据，也没有输出数据，则认为该task处于block状态，可能是卡住了，也许永远会卡主，为了防止因为用户程序永远block住不退出，则强制设置了一个该超时时间（单位毫秒），默认是300000。如果你的程序对每条输入数据的处理时间过长（比如会访问数据库，通过网络拉取数据等），建议将该参数调大，该参数过小常出现的错误提示是“AttemptID:attempt_14267829456721_123456_m_000224_0 Timed out after 300 secsContainer killed by the ApplicationMaster.”。 11.3 本地运行mapreduce 作业设置以下几个参数: mapreduce.framework.name=local mapreduce.jobtracker.address=local fs.defaultFS=local 11.4 效率和稳定性相关参数(1) mapreduce.map.speculative: 是否为Map Task打开推测执行机制，默认为false (2) mapreduce.reduce.speculative: 是否为Reduce Task打开推测执行机制，默认为false (3) mapreduce.job.user.classpath.first &amp; mapreduce.task.classpath.user.precedence：当同一个class同时出现在用户jar包和hadoop jar中时，优先使用哪个jar包中的class，默认为false，表示优先使用hadoop jar中的class。 (4) mapreduce.input.fileinputformat.split.minsize: 每个Map Task处理的数据量（仅针对基于文件的Inputformat有效，比如TextInputFormat，SequenceFileInputFormat），默认为一个block大小，即 134217728。]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[科目三Fighting总结]]></title>
    <url>%2Fpost%2F7338d3c.html</url>
    <content type="text"><![CDATA[人生不止于此！ ——每天要做不重样的事，在一个框框内，不断地挑战自己、突破自己！ 周五——五把加减档迅速提起速度 2把——15-20速度在掉头上坡地方换二档 打转向灯6s后动方向盘！ 提前打转向灯！ 死点！记住就好！ 周四——三把+两把纠正点三把—掉头回来一个小上坡，不要抢红绿灯9s也要注意刹车点踩上 刹车点再早一点：三个点：1、 路口右转红灯刹车起步（丁字路口树上） 2、三棵小树（要转弯时候踩踩刹车） +人行横道+公交汽车站 3、路口处是九州牌子！ 两把——全过程：注意任何时候 变道都要提前打开转向灯！5s转到另一个车道！ 刹车要慢慢的且较长点距离！ 1档之后一定换2档 转向灯要掰回来！ 就算前方有车，下一个点也不要忘记！ 起步—6字要诀—&gt;（模拟灯光前已经安全带、座椅、打火了） 踩 挂 点下手刹 看（左右看看来车） 左转向 起步半联动 十字路口就算有情况也要 1档之后换成2档走！ 掉头不要太靠近路沿石！ 掉头上坡：迅速挂到2档松开离合！有车先停停不要抢！或太慢！ 刹车点—&gt;最好在 感觉下降刹刹车、后轮子过去松开刹车！ 超车变道 超车听语音这个自己5s 然后自己变回来！ 变道变过去直线行驶、听语音是否变回去！！！再打转向灯 下坡 学校车头 不太到路口中央慢慢的！ 丁字路口 在树上！ 公交车站 有树叶的歪脖树上。 十字路口 红灯要先停停。 注意刹车点在电线杆！ 报点稍微等等再打右转向？ 直线加减档 迅速调整车身 (轰油门到20 好把方向盘！) 由远及近 迅速轰油门到2档，（25-&gt;）3档，（30-&gt;）-4档（40-20间跑10s？） 在过了坑 且 右转向地标处-&gt; 右转向灯 越级减档至2档 十字路口 要转弯前踩踩刹车（不要压线） 转过去时候看后方来车，可以就去中间车道，不行就行人车道 若要并到中间车道-&gt;提前5s打转向灯 看来车-&gt;打过去道！ 直线 人行横道 水泥缝快到的时候刹刹车 过去松开 公交车站 车子和第三棵小树！ 补加减档 前面合格的话这个地方-&gt;2档过去 补-&gt;3档30以上换，4档跑四十5s 到达向阳宾馆过去的路口的小树-&gt;刹刹车、越级减档2至2档 十字路口 右转向灯 九州挂牌处刹刹车 转弯打正了过去 靠边停车 左眼看！过去不要太过，可以先调整车身慢慢修！ 转向灯、档、手刹、安全带、熄火、看有无来车-&gt;再开开车门关上！等一会！ 周一——上午：模拟灯光：夜间路口直行改为-近光灯，不用双闪啦！ 下午：转圈：油门速度一定要控制好！ 速度：自己要有速度的感觉&lt;包括上下坡的速度！尽量少看速度表！> 10速 换2档，25-30换3档、30-40换4档！ 2档不超过30， 4档不超过50！ 直线行驶：-不要压线！ 小提示：提前预判-十字路口放慢下速度？刹刹车？刹车提前慢长点？ 注意： 4-2档，要先减速！ 全程是2档。加减档是2-3-4 然后立即减速到20-30换上(4-)2档！ 十字路口不要压线 转到 直线行驶时。 到加减档目视前方！不压线！不要转弯！！！！ 等待5s再超车！且车速放缓！ 掉头变道-也是正车身后-不！要！压！线！ 起步、停车要注意点！ ———MORE——— 1.三个容易忽略的细节 首先说几个容易被忽视的要点吧：转向灯、点刹车、回头观察，这三个细节做好，就可以~ 2.直线行驶秘籍： 视线一定要看远顾近，应握紧方向盘，并根据车速的变化调整，不要猛的一下子用力打，而是微调，做到早打、打多少回多少。 3.挂挡 练车时多熟练档位，这个很重要。档位熟悉加速踏板控制熟练以后，其他都不是问题。 另外在考试过程中低头挂档可是会挂的！ 汽车起步时 一定要稳，先打左转向灯，再踩离合器，挂一档，松手刹，左脚轻轻松开离合器的同时右脚逐渐踩油门（轻抬离合慢给油） 注意：很多人都会在起步时忘记打转向灯出错，或者没有松开手刹导致熄火而以失败告终！ 开车总感觉车开不直，有没有好的方法？ 感觉车开不直，也可能是视线放的太近了，教练经常对大家说“开车要看远处不要老看近处”，学员们把视线放到前方一百米以外，方向盘不要握的太紧就好啦~ 通过学校等特殊地点需要减速是不是必须减档？ 学校区域、人行横道、公交车站不超30km/h就好啦，路过学校区域二档只要踩刹车让感应器感应到就行，轻重这个看个人，主要是让系统感应到你减速了，不用换档哦！ 7.档位 新规后1档只用来起步、掉头，然后2档行走，加减档挂2档进入加到3档，再到4档跑5s即可，达到公里数后直接退回2档行走。 ??? 6. 语音提示超车后，先打左转向灯，观察后视镜有无来车。如果后方有来车，则等后车通过后，迅速超车，超车时速度不能低于30km/h。超车成功后，观察后车、打右转向灯，驶回中间路段。 注意：很多人在考试时，突然对面行来一辆大车，或者别的车辆跨越实线，逆向行来，这时候一定要减速停车，在不明白对方行驶意图时不要轻易改变行驶路段。 若遇到路口红灯，提前减速，换档，停车，拉手刹（可根据本地教练要求） 8. 直线行驶，直线行驶可以在怠速情况下踩点油门，保证车子不能跑偏，不能压双黄线，一边开一边通过两侧后视镜矫正方向。 —-】 科目三直线行驶走不直？那是因为方法不对2017-10-20 15:21 以前学车的时候，一听科目三考试项目中有直线行驶，心里还在想，那不是很简单吗？方向盘一动不动就好啦！然而，后来才发现，就算开车的时候，方向盘一动没动，车子也会跑偏。所以，其实科目三直线行驶并没有那么简单。 新规科目三直线行驶考核要求： 1、直线行驶要考生做到起步平稳，驾驶操作顺序基本不乱； 2、能正确把握方向盘（以左手为主操作方向盘），并能应用方向盘自由行程修正行驶方向； 3、能掌握变速换挡的时机和方法，善于在各种不同的车速下进行高低档互换（进行逐级加档、逐级减档或越级减档）； 4、以及能做到及时有效地运用制动器（预见性制动减速）； 5、能基本做到定点停车及路口调头的方法。 直线行驶技巧： 1、直线行驶时要目视前方注意两旁，必须选定好参照物，保持直线行驶，及时修正方向(微！调)，时刻注意前方各种交通情况，做到及时发现、及时处理。 2、要看远顾近，握正方向，视线看前方，适当要看得远一点，并用余光适时注意车辆周围的情况。 3、一定要用双手操作方向盘，用双手操纵转向盘时要平稳、自然，双手保持与肩同宽，用力不要太大。并且左手应放在方向盘9点位置，右手放在3点位置。 4、如果感觉车子跑偏，千万不要大幅度转方向盘，稍微修一修方向就可以。 5、直线行驶加减挡时左手轻搭在方向盘上，右手换挡的同时要注意左手不要晃动方向盘，保持直线行驶，如果感觉方向偏差，左手略微修正即可。(左手不放！！！稍微左调？) 6、考试时，一定要选择平整路面进行直线行驶！ 更多学车技巧可以关注微信“学车吧8”和“驾考宝典？”。 大家一定要记住这几个关键词：安全带、手刹、换档、转向灯、压线、熄火。这些都是基础的东西，千万不能掉以轻心。 考试过程中不要紧张，不要慌乱，心态一定要好，避免出现各种不该发生的事情。 周二——5s—超车变道、路边停车、加减档完成之后的红绿灯变道、——都需要等待5s之后再转道！接着摆正方向。 油门—是有缓冲的！除了直线行驶的加减档—其它时候的油门都不要一脚踩太大！ 4档10s —4档之前油门大一点！尽快到达4档10s但是！保持直线行驶！方向盘不要偏！ 刹车点之前—速度20-28迈；掉头回来的路口—速度稍微大一点！ 考试车上—记住自己错误的地方！ 2档不超过30！！！ 周三——左转向-掉头 直线行驶-马上开始做！加减档！ 4档-尽快达到！ 4-2档先减速！！！ 周四——]]></content>
      <categories>
        <category>日记之家</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day08_BigData渐进学习_aclear_fire]]></title>
    <url>%2Fpost%2F2efa6d1f.html</url>
    <content type="text"><![CDATA[今日内容梳理1、mapreduce框架的设计思想 2、mapreduce框架中的程序实体角色：maptask reducetask mrappmaster 3、mapreduce程序运行的整体流程 4、mapreduce程序中maptask任务切片规划的机制（掌握整体逻辑流程，看day03_word文档中的“maptask并行度”） 注意看图 5、mapreduce程序提交的整体流程（看图：一坨 “客户端提交mr程序job的流程”） 注意看图 6、编码： wordcount 流量汇总统计（hadoop的序列化实现） 流量汇总统计并按省份区分 作业：1/统计每一个用户（手机号）所耗费的总上行流量、下行流量，总流量 map 读一行，切分字段 抽取手机号，上行流量 下行流量 context.write(手机号,bean) reduce 2/得出上题结果的基础之上再加一个需求：将统计结果按照总流量倒序排序 3/将统计结果按照手机归属地不同省份输出到不同文件中 map 读一行，切分字段 抽取手机号，上行流量 下行流量 context.write(手机号,bean) map输出的数据要分成6个区 重写partitioner，让相同归属地的号码返回相同的分区号int 6省 跑6个reduce task reduce 拿到一个号码所有数据 遍历，累加 输出 What’s more, MapReduce，代码练习、理解增强。 目录课程大纲（MAPREDUCE详解）…………………………………………………………………………….. 3 MAPREDUCE入门………………………………………………………………………………………… 4 1.1 为什么要MAPREDUCE…………………………………………………………………………….. 4 1.2 MAPREDUCE程序运行演示……………………………………………………………………….. 4 1.3 MAPREDUCE 示例编写及编程规范……………………………………………………………… 4 1.3.1 编程规范……………………………………………………………………………………… 4 1.3.2 wordcount示例编写………………………………………………………………………… 5 1.4 MAPREDUCE程序运行模式及debug方法…………………………………………………….. 7 1.4.1 本地运行模式……………………………………………………………………………….. 7 1.4.2 集群运行模式……………………………………………………………………………….. 7 Mapreduce程序的核心运行机制………………………………………………………………………… 8 2.1 概述…………………………………………………………………………………………………….. 8 2.2 mr程序运行流程…………………………………………………………………………………….. 8 2.2.1 流程示意图…………………………………………………………………………………… 8 2.2.2 流程解析……………………………………………………………………………………… 8 2.3 Maptask实例数的决定机制……………………………………………………………………… 10 2.3.1 maptask数量的决定机制………………………………………………………………… 10 2.3.2切片机制：………………………………………………………………………………….. 10 2.4 ReduceTask实例数的决定………………………………………………………………………… 11 MAPREDUCE中的Combiner……………………………………………………………………………… 12 MAPREDUCE中的序列化…………………………………………………………………………………. 12 4.1 概述…………………………………………………………………………………………………… 12 4.2 Jdk序列化和MR序列化之间的比较………………………………………………………….. 12 4.3 自定义对象实现MR中的序列化接口……………………………………………………….. 13 Mapreduce中的排序初步………………………………………………………………………………… 16 5.1 需求：……………………………………………………………………………………………….. 16 5.2 分析…………………………………………………………………………………………………… 16 5.3 实现…………………………………………………………………………………………………… 16 Mapreduce中的分区Partitioner……………………………………………………………………….. 20 6.1 需求：……………………………………………………………………………………………….. 20 6.2 分析…………………………………………………………………………………………………… 20 6.3 实现…………………………………………………………………………………………………… 20 mapreduce的shuffle机制……………………………………………………………………………….. 22 7.1 概述：……………………………………………………………………………………………….. 22 7.2 主要流程：…………………………………………………………………………………………. 22 7.3 详细流程…………………………………………………………………………………………….. 22 7.4 详细流程示意图…………………………………………………………………………………… 23 mapreduce数据压缩………………………………………………………………………………………. 24 8.1 概述…………………………………………………………………………………………………… 24 8.2 MR支持的压缩编码……………………………………………………………………………….. 24 8.3 Reducer输出压缩………………………………………………………………………………….. 24 8.4 Mapper输出压缩…………………………………………………………………………………… 25 8.5 压缩文件的读取…………………………………………………………………………………… 25 MapReduce与YARN……………………………………………………………………………………….. 27 9.1 YARN概述……………………………………………………………………………………………. 27 9.2 YARN的重要概念…………………………………………………………………………………… 27 9.3 Yarn中运行运算程序的示例…………………………………………………………………….. 27 MapReduce编程案例……………………………………………………………………………………. 28 10.1 reduce端join算法实现…………………………………………………………………… 28 10.2 map端join算法实现……………………………………………………………………… 29 10.3 web日志预处理………………………………………………………………………….. 32 附：Mapreduce参数优化…………………………………………………………………………………… 36 11.1 资源相关参数…………………………………………………………………………………….. 36 11.2 容错相关参数…………………………………………………………………………………….. 37 11.3 本地运行mapreduce 作业……………………………………………………………………. 37 11.4 效率和稳定性相关参数………………………………………………………………………… 37 课程大纲（MAPREDUCE详解）MapReduce快速入门 如何理解map、reduce计算模型 Mapreudce程序运行演示 Mapreduce编程规范及示例编写 Mapreduce程序运行模式及debug方法 MapReduce高级特性 Mapreduce程序的核心机制 MapReduce的序列化框架 MapReduce的排序实现 MapReduce的分区机制及自定义 Mapreduce的数据压缩 Mapreduce与yarn的结合 Mapreduce编程案例 Mapreduce 参数优化 目标： 掌握mapreduce分布式运算框架的编程思想 掌握mapreduce常用算法的编程套路 掌握mapreduce分布式运算框架的运行机制，具备一定自定义开发的能力 回顾： hdfs的读取数据 hdfs的写入数据 HDFS注意 进行API操作的时候我们，并不能用客户端进行HDFS文件内容某一行的修改。只能进行 增删查进行HDFS操作。 Mr程序对hdfs的api的页数要求。Datanode进行并发实例，执行对应的指定的一部分进行读取——起始偏移量 到 终止偏移量之间的数值。（mr只是用hdfs执行对应的api，在对应的模块上进行操作。——所以我们说 mr将相当于 hdfs的客户端，mr不需要进行datanode深层的理解。）——以上四个回顾都是有 图片进行形象的回顾的！ 浏览器的&lt;浏览器当中 用户js&gt;行为 记录在我们的业务服务器上，注意对应的汇聚到对应的HDFS上. 2018/2/4 驾照考试完成 进行复习整理第一课： 大数据一般 统计的是用户的行为进行的。 关于日志的采集： 我们注意，日志的采集 MR实则是在HADOOP上的客户端似的。 Js 用户采集ftp传输到 我们服务器的本地磁盘当中；然后通过 java或者shell进行日志的采集和处理；并且利用hdfs api 从服务器的本地 上 传到我们自己的hdfs上进行数据的管理和 并发式的处理。 离线 和 spark一般都是写 sql和mapreduce&lt;但是由于 mapreduce 需要很多步才能达到sql的几步！&gt; &lt;项目可以一起串起来！&gt; 1. MAPREDUCE原理篇（1）_Mapreduce是一个分布式运算程序的编程框架，是用户开发“基于hadoop的数据分析应用”的核心框架；_ _Mapreduce__核心功能__是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个hadoop集群上；_ 1.1 为什么要MAPREDUCE（1）海量数据在单机上处理因为硬件资源限制，无法胜任 （2）而一旦将单机版程序扩展到集群来分布式运行，将极大增加程序的复杂度和开发难度 （3）引入mapreduce框架后，开发人员可以将绝大部分工作集中在业务逻辑的开发上，而将分布式计算中的复杂性交由框架来处理 _设想一个海量数据场景下的wordcount__需求：_ 单机版：内存受限，磁盘受限，运算能力受限 分布式： 1、文件分布式存储（HDFS） 2、运算逻辑需要至少分成2个阶段（一个阶段独立并发，一个阶段汇聚） 3、运算程序如何分发 4、程序如何分配运算任务（切片） 5、两阶段的程序如何启动？如何协调？ 6、整个程序运行过程中的监控？容错？重试？ 注意：图片下面若干复杂的问题 就行相应的解决的思想过程！ 可见在程序由单机版扩成分布式时，会引入大量的复杂工作。为了提高开发效率，可以将分布式程序中的公共功能封装成框架，让开发人员可以将精力集中于业务逻辑。 而mapreduce就是这样一个分布式程序的通用框架，其应对以上问题的整体结构如下： 1、MRAppMaster(mapreduce application master) 2、MapTask 3、ReduceTask 1.2 MAPREDUCE框架结构及核心运行机制1.2.1 结构一个完整的mapreduce程序在分布式运行时有三类实例进程： 1、MRAppMaster：负责整个程序的过程调度及状态协调 2、MapTask：负责map阶段的整个数据处理流程 3、ReduceTask：负责reduce阶段的整个数据处理流程 1.2.2 MR程序运行流程1.2.2.1 流程示意图1.2.2.2 流程解析 一个mr程序启动的时候，最先启动的是MRAppMaster，MRAppMaster启动后根据本次job的描述信息，计算出需要的maptask实例数量，然后向集群申请机器启动相应数量的maptask进程 maptask进程启动之后，根据给定的数据切片范围进行数据处理，主体流程为： 利用客户指定的inputformat来获取RecordReader读取数据，形成输入KV对 将输入KV对传递给客户定义的map()方法，做逻辑运算，并将map()方法输出的KV对收集到缓存 将缓存中的KV对按照K分区排序后不断溢写到磁盘文件 MRAppMaster监控到所有maptask进程任务完成之后，会根据客户指定的参数启动相应数量的reducetask进程，并告知reducetask进程要处理的数据范围（数据分区） Reducetask进程启动之后，根据MRAppMaster告知的待处理数据所在位置，从若干台maptask运行所在机器上获取到若干个maptask输出结果文件，并在本地进行重新归并排序，然后按照相同key的KV为一个组，调用客户定义的reduce()方法进行逻辑运算，并收集运算输出的结果KV，然后调用客户指定的outputformat将结果数据输出到外部存储 Eclipse 过程构建：注意进行user library的构建——添加 common hdfs yarn mapreduce 1.3 MapTask并行度决定机制_maptask的并行度决定map阶段的任务处理并发度，进而影响到整个job的处理速度_ _那么，mapTask并行实例是否越多越好呢？其并行度又是如何决定呢？_ 1.3.1 mapTask并行度的决定机制一个job的map阶段并行度由客户端在提交job时决定 而客户端对map阶段并行度的规划的基本逻辑为： _将待处理数据执行逻辑切片（即按照一个特定切片大小，将待处理数据划分成逻辑上的多个split），然后每一个split分配一个mapTask__并行实例处理_ 这段逻辑及形成的切片规划描述文件&lt;生成过程的逻辑 以及 文件写入生成、之后自动删除！&gt;，由FileInputFormat实现类的getSplits()方法完成，其过程如下图： &lt;加上要知道 下面的 三个参数，以及对应的一些方法！&gt; 上图代码错误，max(min()) 是对的。 注意 这个day08分析的切片对应的源码原理，不明白的时候可以再具体的看一下！ &gt;1.1倍，如果切片的大小不超过1.1倍。就把整个长度作为一个切片 给予一个 map去进行处理就行了！ 对应文件写入 job.split job.xml Shang shang shang 图中了解，切片的大体过程即可。 然而下面的两张图 是观看源码的东西！ 掌握 上方的红字 标红的就行！ 1.3.2 FileInputFormat切片机制1、切片定义在InputFormat类中的getSplit()方法2、FileInputFormat中默认的切片机制： 简单地按照文件的内容长度进行切片 切片大小，默认等于block大小 切片时不考虑数据集整体，而是逐个针对每一个文件单独切片 比如待处理数据有两个文件： file1.txt 320M file2.txt 10M 经过FileInputFormat的切片机制运算后，形成的切片信息如下： file1.txt.split1— 0~128 file1.txt.split2— 128~256 file1.txt.split3— 256~320 file2.txt.split1— 0~10M 3、FileInputFormat中切片的大小的参数配置通过分析源码，在FileInputFormat中，计算切片大小的逻辑：Math.max(minSize, Math.min(maxSize, blockSize)); 切片主要由这几个值来运算决定 minsize：默认值：1 配置参数： mapreduce.input.fileinputformat.split.minsize maxsize：默认值：Long.MAXValue 配置参数：mapreduce.input.fileinputformat.split.maxsize blocksize 因此，默认情况下，切片大小**=blocksize** maxsize（切片最大值）： 参数如果调得比blocksize小，则会让切片变小，而且就等于配置的这个参数的值 minsize （切片最小值）： 参数调的比blockSize大，则可以让切片变得比blocksize还大 选择并发数的影响因素： 运算节点的硬件配置 运算任务的类型：CPU密集型还是IO密集型 运算任务的数据量 Main()方法&lt;之前咱么配置的job参数&gt;去做 生成一个文件。 .xml 框架里面会给我们写！ Job – yarn -MR App Master -读文件 知道有几个文件 - 文件偏移量 以及相应的数据有多少 -Map Task 交给他 知道有几个切片！知道相应的医改分成几个切片！ 一个切片对应于 一个MapTask实例！ 客户端提交mr程序job的流程： 1.4 map并行度的经验之谈如果硬件配置为212core + 64G，恰当的map并行度是大约每个节点20-100个map，最好每个**map**的执行时间至少一分钟。* 如果job的每个map或者 reduce task的运行时间都只有30-40秒钟，那么就减少该job的map或者reduce数，每一个task(map|reduce)的setup和加入到调度器中进行调度，这个中间的过程可能都要花费几秒钟，所以如果每个task都非常快就跑完了，就会在task的开始和结束的时候浪费太多的时间。 配置task的JVM 可以改善该问题： _（mapred.job.reuse.jvm.num.tasks，默认是1，表示一个JVM上最多可以顺序执行的task_ _数目（属于同一个Job）是1。也就是说一个task启一个JVM__）_ 如果input的文件非常的大，比如1TB，可以考虑将hdfs上的每个block size设大，比如设成256MB或者512MB 1.5 ReduceTask并行度的决定reducetask的并行度同样影响整个job的执行并发度和执行效率，但与maptask的并发数由切片数决定不同，Reducetask数量的决定是可以直接手动设置： //默认值是1，手动设置为4 job.setNumReduceTasks(4); 如果数据分布不均匀，就有可能在reduce阶段产生数据倾斜 _注意： reducetask数量并不是任意设置，还要考虑业务逻辑需求，有些情况下，需要计算全局汇总结果，就只能有1个reducetask_ _尽量不要运行太多的reduce task。对大多数job来说，最好rduce的个数最多和集群中的reduce持平，或者比集群的 reduce slots__小。这个对于小集群而言，尤其重要。_ 1.6 MAPREDUCE程序运行演示Hadoop的发布包中内置了一个hadoop-mapreduce-example-2.4.1.jar，这个jar包中有各种MR示例程序，可以通过以下步骤运行： 启动hdfs，yarn 然后在集群中的任意一台服务器上启动执行程序（比如运行wordcount）： hadoop jar hadoop-mapreduce-example-2.4.1.jar wordcount /wordcount/data /wordcount/out 2. MAPREDUCE实践篇（1）2.1 MAPREDUCE 示例编写及编程规范2.1.1 编程规范 用户编写的程序分成三个部分：Mapper，Reducer，Driver(提交运行mr程序的客户端) Mapper的输入数据是KV对的形式（KV的类型可自定义） Mapper的输出数据是KV对的形式（KV的类型可自定义） Mapper中的业务逻辑写在map()方法中 map()方法（maptask进程）对每一个调用一次 &lt;处理文本的才有行概念,K是起始偏移量 每拿一行调用一次 KV对！&gt; Reducer的输入数据类型对应Mapper的输出数据类型，也是KV Reducer的业务逻辑写在reduce()方法中 Reducetask进程对每一组相同k的组调用一次reduce() 用户自定义的Mapper和Reducer都要继承各自的父类 整个程序需要一个Drvier来进行提交，提交的是一个描述了各种必要信息的job对象 —-在第三个、第六个当中 需要进行传输的细节处理&lt;序列化处理> —-但是我们有时需要进行特殊 对象的传输。所以需要自己封装一些特定的bean对象！ —-mapreduce类似于各种各样的 wordcount！ 1.7.2 wordcount示例编写需求：在一堆给定的文本文件中统计输出每一个单词出现的总次数 (1)定义一个mapper类 //首先要定义四个泛型的类型 //keyin: LongWritable valuein: Text //keyout: Text valueout:IntWritable / 会以 key value 传输进来！ KEYIN :默认情况下，是mr框架所读到的一行文本的起始偏移量，long &lt;注意 因为要进行网络传输-序列化long 最好用hadoop自己拥有的精简化的序列化接口，所以直接不用Long 而是利用LongWritable&gt; VALUEIN：默认情况下，是mr框架所读到的一行文本的内容 String，同上用 Text！对应import hadoop包当中的！ \ * * KEYOUT:是用户自定义 逻辑处理完成之后输出数据中的key，此处是单词 String VALUEOUT:用户逻辑处理完成之后的 value 此处map出来的value是数据，Integer @author* acanprince &amp; aclearzhang \ *业务逻辑类 * */ public class WordCountMapper extends Mapper{ //map方法的生命周期： 框架每传一行数据就被调用一次 //key : 这一行的起始点在文件中的偏移量 //value: 这一行的内容 @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { //拿到一行数据转换为string String line = value.toString(); //将这一行切分出各个单词 String[] words = line.split(“ “); //遍历数组，输出&lt;单词，1&gt; for(String word:words){ context.write(new Text(word), new IntWritable(1)); } } } (2)定义一个reducer类 //生命周期：框架每传递进来一个kv 组，reduce方法被调用一次 @Override protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException { //定义一个计数器 int count = 0; //遍历这一组kv的所有v，累加到count中 for(IntWritable value:values){ count += value.get(); } context.write(key, new IntWritable(count)); } } (3)定义一个主类，用来描述job并提交job public class WordCountRunner { //把业务逻辑相关的信息（哪个是mapper，哪个是reducer，要处理的数据在哪里，输出的结果放哪里……）描述成一个job对象 //把这个描述好的job提交给集群去运行 public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job wcjob = Job.getInstance(conf); //指定我这个job所在的jar包 // wcjob.setJar(“/home/hadoop/wordcount.jar”); wcjob.setJarByClass(WordCountRunner.class); wcjob.setMapperClass(WordCountMapper.class); wcjob.setReducerClass(WordCountReducer.class); //设置我们的业务逻辑Mapper类的输出key和value的数据类型 wcjob.setMapOutputKeyClass(Text.class); wcjob.setMapOutputValueClass(IntWritable.class); //设置我们的业务逻辑Reducer类的输出key和value的数据类型 wcjob.setOutputKeyClass(Text.class); wcjob.setOutputValueClass(IntWritable.class); //指定要处理的数据所在的位置 FileInputFormat.setInputPaths(wcjob, “hdfs://hdp-server01:9000/wordcount/data/big.txt”); //指定处理完成之后的结果所保存的位置 FileOutputFormat.setOutputPath(wcjob, new Path(“hdfs://hdp-server01:9000/wordcount/output/“)); //向yarn集群提交这个job boolean res = wcjob.waitForCompletion(true); System.exit(res?0:1); } 2.2 MAPREDUCE程序运行模式2.2.1 本地运行模式 mapreduce程序是被提交给LocalJobRunner在本地以单进程的形式运行 而处理的数据及输出结果可以在本地文件系统，也可以在hdfs上 怎样实现本地运行？写一个程序，不要带集群的配置文件（本质是你的mr程序的conf中是否有framework.name=local以及yarn.resourcemanager.hostname参数） _本地模式非常便于进行业务逻辑的debug，只要在eclipse中打断点即可_ _如果在windows下想运行本地模式来测试程序逻辑，需要在windows中配置环境变量：_ _％HADOOP_HOME％ = d:/hadoop-2.6.1_ _%PATH% =_ _％HADOOP_HOME％\\bin_ _并且要将d:/hadoop-2.6.1的lib和bin目录替换成windows平台编译的版本_ 2.2.2 集群运行模式 将mapreduce程序提交给yarn集群resourcemanager，分发到很多的节点上并发执行 处理的数据和输出结果应该位于hdfs文件系统 提交集群的实现步骤： 将程序打成JAR包&lt;暂时没有打成可运行的jar包&gt;，然后在集群的任意一个节点上用hadoop命令启动 //注意: $java -cp wordcount.jar cn.itcast.bigdata.mrsimple.WordCountDriver inputpath outputpath #会因为没有响应的export路径执行命令而不能运行：三个方法：1.在java -cp 后面带上全部的jar文件路径 2.打包jar的时候就全部打进去 3.下面这种hadoop命令进行执行——会自动导出export出命令！ $ hadoop jar wordcount.jar cn.itcast.bigdata.mrsimple.WordCountDriver inputpath outputpath B、直接在linux的eclipse中运行main方法 （项目中要带参数：mapreduce.framework.name=yarn**以及yarn**的两个基本配置） C、如果要在windows的eclipse中提交job给集群，则要修改YarnRunner类 http://aclear1:8088/cluster reduce默认是一个，所以会输出1个最终wordcount统计文件！ 注意 yarn给我们先启动，MRApp – Map – Reduce mapreduce程序在集群中运行时的大体流程： 附：在windows平台上访问hadoop时改变自身身份标识的方法之二： 3. MAPREDUCE中的Combiner combiner是MR程序中Mapper和Reducer之外的一种组件 combiner组件的父类就是Reducer combiner和reducer的区别在于运行的位置： Combiner是在每一个maptask所在的节点运行 Reducer是接收全局所有Mapper的输出结果； (4) combiner的意义就是对每一个maptask的输出进行局部汇总，以减小网络传输量 具体实现步骤： 自定义一个combiner继承Reducer，重写reduce方法 在job中设置： setCombinerClass(CustomCombiner.class) (5) combiner能够应用的前提是不能影响最终的业务逻辑 而且，combiner的输出kv应该跟reducer的输入kv类型要对应起来 整体之间一个大的流程：&lt;我们写的只是一个小片段，map reduce用我们的逻辑去做。其它的细节有很多——收集、处理、分区、任务分配.&gt; 图前三讲运行.wordcount运行过程的解析 Shuffle 机制-&gt;对应于上图的 map和reduce中间细节的处理：SHUFFLE //指定我们自定义的数据分区器 job.setPartitionerClass(ProvincePartitioner.class); //同时指定 响应分区数量的 reducetask的 数量进行 跑分区！ job.setNumReduceTasks(5); ProvincePatitioner.class ： package cn.itcast.bigdata.mr.province.flow; import java.util.HashMap; import org.apache.hadoop.classification.InterfaceAudience.Public; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapred.JobConf; import org.apache.hadoop.mapreduce.Partitioner; //新的api 是进行继承！ //import org.apache.hadoop.mapred.Partitioner;//这是老的api 是实现 /** * * K2 V2 对应的是map输出的KV类型 @author acanprince * / public class ProvincePartitioner extends Partitioner { public static HashMap _provinceDict_ = new HashMap(); static { _provinceDict_.put(“136”, 0); _provinceDict_.put(“137”, 1); _provinceDict_.put(“138”, 2); _provinceDict_.put(“139”, 3); } @Override public int getPartition(Text key, FlowBean value, int numPartitions) { // TODO Auto-generated method stub String prefix = key.toString().substring(0, 3); Integer provinceId = _provinceDict_.get(prefix); return provinceId == *null?4:provinceId; } } 接下来，如果我们想要传输 自己的对象&lt;而不是writable所以需要我们进行，重写writable&gt; 其实，感觉mapreduce程序就是各种各样的wordcount 打字的手法道义需不要要进行训练呢？ 我现在就是只是在利用除了小指等之外的手指进行代码的编程！ 虽然说这样也是挺快的了， 但是 还是有几个单词 英文状态下 打的并不是特别的好~—— 例如 p u o rb v 烦的一批~!Fighting! Fighting! 我还是需要进行单词的 寻找！ 盲打状态下 ，进行还是 比较好的！ 但是 这样子 就感觉不到小指头的存在了。很烦， 另外 之前打的字都是在中文状态下 进行拼写打字的，如果我们用英文打字，Let’s Go: Wordcount mapreduce test this my jiahaozhang’s ; .test in the last few years I asked my mom will I be handsome or will I be strong~ Number splite 注意切片的大小，既和文件的大小 又和文件的多少有关！ 思考：启动map task多少？ 图 切片示意图 注意切片 可以任意划分，其实其中的切片任务划分是 我们自由定的。 切片大小 ：一个切片对应一个maptask！ 默认是在 Driver当中（HDFS的客户端中自己设置的！ Job 切片大小！） 3. MAPREDUCE原理篇（2）3.1 mapreduce的shuffle机制3.1.1 概述： mapreduce中，map阶段处理的数据如何传递给reduce阶段，是mapreduce框架中最关键的一个流程，这个流程就叫shuffle； shuffle: 洗牌、发牌——（核心机制：数据分区，排序，缓存）； 具体来说：就是将maptask输出的处理结果数据，分发给reducetask，并在分发的过程中，_对数据按key进行了分区和排序；_ 3.1.2 主要流程：Shuffle缓存流程： shuffle是MR处理流程中的一个过程，它的每一个处理步骤是分散在各个map task和reduce task节点上完成的，整体来看，分为3个操作： 分区partition Sort根据key排序 Combiner进行局部value的合并 3.1.3 详细流程 maptask收集我们的map()方法输出的kv对，放到内存缓冲区中 从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件 多个溢出文件会被合并成大的溢出文件 在溢出过程中，及合并的过程中，都要调用partitoner进行分组和针对key进行排序 reducetask根据自己的分区号，去各个maptask机器上取相应的结果分区数据 reducetask会取到同一个分区的来自不同maptask的结果文件，reducetask会将这些文件再进行合并（归并排序） 合并成大文件后，shuffle的过程也就结束了，后面进入reducetask的逻辑运算过程（从文件中取出一个一个的键值对group，调用用户自定义的reduce()方法） Shuffle中的缓冲区大小会影响到mapreduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快 缓冲区的大小可以通过参数调整, 参数：io.sort.mb 默认100M 3.1.4 详细流程示意图3.2. MAPREDUCE中的序列化3.2.1 概述Java的序列化是一个重量级序列化框架（Serializable），一个对象被序列化后，会附带很多额外的信息（各种校验信息，header，继承体系。。。。），不便于在网络中高效传输； 所以，hadoop自己开发了一套序列化机制（Writable），精简，高效 3.2.2 Jdk序列化和MR序列化之间的比较简单代码验证两种序列化机制的差别： _public class TestSeri {_ _ public static void main(String[] args) throws Exception {_ _ //定义两个ByteArrayOutputStream，用来接收不同序列化机制的序列化结果_ _ ByteArrayOutputStream ba = new ByteArrayOutputStream();_ _ ByteArrayOutputStream ba2 = new ByteArrayOutputStream();_ _ //定义两个DataOutputStream，用于将普通对象进行jdk标准序列化_ _ DataOutputStream dout = new DataOutputStream(ba);_ _ DataOutputStream dout2 = new DataOutputStream(ba2);_ _ ObjectOutputStream obout = new ObjectOutputStream(dout2);_ _ //定义两个bean，作为序列化的源对象_ _ ItemBeanSer itemBeanSer = new ItemBeanSer(1000L, 89.9f);_ _ ItemBean itemBean = new ItemBean(1000L, 89.9f);_ _ //用于比较String类型和Text类型的序列化差别_ _ Text atext = new Text(“a”);_ _ // atext.write(dout);_ _ itemBean.write(dout);_ _ byte[] byteArray = ba.toByteArray();_ _ //__比较序列化结果_ _ System.out.println(byteArray.length);_ _ for (byte b : byteArray) {_ _ System.out.print(b);_ _ System.out.print(“:”);_ _ }_ _ System.out.println(“———————————-“);_ _ String astr = “a”;_ _ // dout2.writeUTF(astr);_ _ obout.writeObject(itemBeanSer);_ _ byte[] byteArray2 = ba2.toByteArray();_ _ System.out.println(byteArray2.length);_ _ for (byte b : byteArray2) {_ _ System.out.print(b);_ _ System.out.print(“:”);_ _ }_ _ }_ _}_ ---MORE--- - 测试数据记录 - 1363157985066 13726230503 00-FD-07-A4-72-B8:CMCC 120.196.100.82 i02.c.aliimg.com 24 27 2481 24681 200 1363157995052 13826544101 5C-0E-8B-C7-F1-E0:CMCC 120.197.40.4 4 0 264 0 200 1363157991076 13926435656 20-10-7A-28-CC-0A:CMCC 120.196.100.99 2 4 132 1512 200 1363154400022 13926251106 5C-0E-8B-8B-B1-50:CMCC 120.197.40.4 4 0 240 0 200 1363157993044 18211575961 94-71-AC-CD-E6-18:CMCC-EASY 120.196.100.99 iface.qiyi.com 视频网站 15 12 1527 2106 200 1363157995074 84138413 5C-0E-8B-8C-E8-20:7DaysInn 120.197.40.4 122.72.52.12 20 16 4116 1432 200 1363157993055 13560439658 C4-17-FE-BA-DE-D9:CMCC 120.196.100.99 18 15 1116 954 200 1363157995033 15920133257 5C-0E-8B-C7-BA-20:CMCC 120.197.40.4 sug.so.360.cn 信息安全 20 20 3156 2936 200 1363157983019 13719199419 68-A1-B7-03-07-B1:CMCC-EASY 120.196.100.82 4 0 240 0 200 1363157984041 13660577991 5C-0E-8B-92-5C-20:CMCC-EASY 120.197.40.4 s19.cnzz.com 站点统计 24 9 6960 690 200 1363157973098 15013685858 5C-0E-8B-C7-F7-90:CMCC 120.197.40.4 rank.ie.sogou.com 搜索引擎 28 27 3659 3538 200 1363157986029 15989002119 E8-99-C4-4E-93-E0:CMCC-EASY 120.196.100.99 www.umeng.com 站点统计 3 3 1938 180 200 1363157992093 13560439658 C4-17-FE-BA-DE-D9:CMCC 120.196.100.99 15 9 918 4938 200 1363157986041 13480253104 5C-0E-8B-C7-FC-80:CMCC-EASY 120.197.40.4 3 3 180 180 200 1363157984040 13602846565 5C-0E-8B-8B-B6-00:CMCC 120.197.40.4 2052.flash2-http.qq.com 综合门户 15 12 1938 2910 200 1363157995093 13922314466 00-FD-07-A2-EC-BA:CMCC 120.196.100.82 img.qfc.cn 12 12 3008 3720 200 1363157982040 13502468823 5C-0A-5B-6A-0B-D4:CMCC-EASY 120.196.100.99 y0.ifengimg.com 综合门户 57 102 7335 110349 200 1363157986072 18320173382 84-25-DB-4F-10-1A:CMCC-EASY 120.196.100.99 input.shouji.sogou.com 搜索引擎 21 18 9531 2412 200 1363157990043 13925057413 00-1F-64-E1-E6-9A:CMCC 120.196.100.55 t3.baidu.com 搜索引擎 69 63 11058 48243 200 1363157988072 13760778710 00-FD-07-A4-7B-08:CMCC 120.196.100.82 2 2 120 120 200 1363157985066 13726238888 00-FD-07-A4-72-B8:CMCC 120.196.100.82 i02.c.aliimg.com 24 27 2481 24681 200 1363157993055 13560436666 C4-17-FE-BA-DE-D9:CMCC 120.196.100.99 18 15 1116 954 200 3.2.3 自定义对象实现MR中的序列化接口如果需要将自定义的bean放在key中传输，则还需要实现comparable接口，因为mapreduce框中的shuffle过程一定会对key进行排序,此时，自定义的bean实现的接口应该是： public class FlowBean implements WritableComparable 需要自己实现的方法是： /\*\* \* 反序列化的方法，反序列化时，从流中读取到的各个字段的顺序应该与序列化时写出去的顺序保持一致 */ @Override public void readFields(DataInput in) throws IOException { upflow = in.readLong(); dflow = in.readLong(); sumflow = in.readLong(); } /** * 序列化的方法 */ @Override public void write(DataOutput out) throws IOException { out.writeLong(upflow); out.writeLong(dflow); //可以考虑不序列化总流量，因为总流量是可以通过上行流量和下行流量计算出来的 out.writeLong(sumflow); } @Override public int compareTo(FlowBean o) { //实现按照sumflow的大小倒序排序 return sumflow&gt;o.getSumflow()?-1:1; } 3.3. MapReduce与YARN3.3.1 YARN概述Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而mapreduce等运算程序则相当于运行于操作系统之上的应用程序 3.3.2 YARN的重要概念 yarn并不清楚用户提交的程序的运行机制 yarn只提供运算资源的调度（用户程序向yarn申请资源，yarn就负责分配资源） yarn中的主管角色叫ResourceManager yarn中具体提供运算资源的角色叫NodeManager 这样一来，yarn其实就与运行的用户程序完全解耦，就意味着yarn上可以运行各种类型的分布式运算程序（mapreduce只是其中的一种），比如mapreduce、storm程序，spark程序，tez …… 所以，spark、storm等运算框架都可以整合在yarn上运行，只要他们各自的框架中有符合yarn规范的资源请求机制即可 Yarn就成为一个通用的资源调度平台，从此，企业中以前存在的各种运算集群都可以整合在一个物理集群上，提高资源利用率，方便数据共享 3.3.3 Yarn中运行运算程序的示例mapreduce程序的调度过程，如下图 4. MAPREDUCE实践篇（2）4.1. Mapreduce中的排序初步4.1.1 需求对日志数据中的上下行流量信息汇总，并输出按照总流量倒序排序的结果 数据如下： 1363157985066 13726230503 00-FD-07-A4-72-B8:CMCC 120.196.100.82 24 27 2481 24681 200 1363157995052 13826544101 5C-0E-8B-C7-F1-E0:CMCC 120.197.40.4 4 0 264 0 200 1363157991076 13926435656 20-10-7A-28-CC-0A:CMCC 120.196.100.99 2 4 132 1512 200 1363154400022 13926251106 5C-0E-8B-8B-B1-50:CMCC 120.197.40.4 4 0 240 0 200 4.1.2 分析基本思路：实现自定义的bean来封装流量信息，并将bean作为map输出的key来传输 MR程序在处理数据的过程中会对数据排序(map输出的kv对传输到reduce之前，会排序)，排序的依据是map输出的key 所以，我们如果要实现自己需要的排序规则，则可以考虑将排序因素放到key中，让key实现接口：WritableComparable 然后重写key的compareTo方法 4.1.3 实现 自定义的bean public class FlowBean implements WritableComparable{ long upflow; long downflow; long sumflow; //如果空参构造函数被覆盖，一定要显示定义一下，否则在反序列时会抛异常 public FlowBean(){} public FlowBean(long upflow, long downflow) { super(); this.upflow = upflow; this.downflow = downflow; this.sumflow = upflow + downflow; } public long getSumflow() { return sumflow; } public void setSumflow(long sumflow) { this.sumflow = sumflow; } public long getUpflow() { return upflow; } public void setUpflow(long upflow) { this.upflow = upflow; } public long getDownflow() { return downflow; } public void setDownflow(long downflow) { this.downflow = downflow; } //序列化，将对象的字段信息写入输出流 @Override public void write(DataOutput out) throws IOException { out.writeLong(upflow); out.writeLong(downflow); out.writeLong(sumflow); } //反序列化，从输入流中读取各个字段信息 @Override public void readFields(DataInput in) throws IOException { upflow = in.readLong(); downflow = in.readLong(); sumflow = in.readLong(); } @Override public String toString() { return upflow + “\\t” + downflow + “\\t” + sumflow; } @Override public int compareTo(FlowBean o) { //自定义倒序比较规则 return sumflow &gt; o.getSumflow() ? -1:1; } } mapper 和 reducer public class FlowCount { static class FlowCountMapper extends Mapper { @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String line = value.toString(); String[] fields = line.split(“\\t”); try { String phonenbr = fields[0]; long upflow = Long.parseLong(fields[1]); long dflow = Long.parseLong(fields[2]); FlowBean flowBean = new FlowBean(upflow, dflow); context.write(flowBean,new Text(phonenbr)); } catch (Exception e) { e.printStackTrace(); } } } static class FlowCountReducer extends Reducer { @Override protected void reduce(FlowBean bean, Iterable phonenbr, Context context) throws IOException, InterruptedException { Text phoneNbr = phonenbr.iterator().next(); //注意context write出去的，FlowBean对象一定是，字符串。平时注意在输出到时候进行一行行的转化。 //注意此时 输出：toString()方法！ //又反序列化时： 反射运用空参数 构造！！！所以 FlowBean当中要 显示定义一个 显示构造的 FlowBean() 构造参数 context.write(phoneNbr, bean); } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(FlowCount.class); job.setMapperClass(FlowCountMapper.class); job.setReducerClass(FlowCountReducer.class); job.setMapOutputKeyClass(FlowBean.class); job.setMapOutputValueClass(Text.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(FlowBean.class); // job.setInputFormatClass(TextInputFormat.class); FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); job.waitForCompletion(true); } } 运行程序： hadoop jar flowcount.jar cn.itcast.bigdata.mr.flowsum.FlowCount /worcount/input/flowcount.dat /wordcount/output_flowcount //以上是打包成 jar文件 而不是可运行的jar包 4.2. Mapreduce中的分区Partitioner4.2.1 需求根据归属地输出流量统计数据结果到不同文件，以便于在查询统计结果时可以定位到省级范围进行 4.2.2 分析Mapreduce中会将map输出的kv对，按照相同key分组，然后分发给不同的reducetask 默认的分发规则为：根据key的hashcode%reducetask数来分发 所以：如果要按照我们自己的需求进行分组，则需要改写数据分发（分组）组件Partitioner 自定义一个CustomPartitioner继承抽象类：Partitioner 然后在job对象中，设置自定义partitioner： job.setPartitionerClass(CustomPartitioner.class) 4.2.3 实现/** * 定义自己的从map到reduce之间的数据（分组）分发规则 按照手机号所属的省份来分发（分组）ProvincePartitioner 默认的分组组件是HashPartitioner @author */ public class ProvincePartitioner extends Partitioner { static HashMap provinceMap = new HashMap(); static { provinceMap.put(“135”, 0); provinceMap.put(“136”, 1); provinceMap.put(“137”, 2); provinceMap.put(“138”, 3); provinceMap.put(“139”, 4); } @Override public int getPartition(Text key, FlowBean value, int numPartitions) { Integer code = provinceMap.get(key.toString().substring(0, 3)); return code == null ? 5 : code; } } 4.3. mapreduce数据压缩4.3.1 概述这是mapreduce**的一种优化策略：通过压缩编码对mapper或者reducer的输出进行压缩，以减少磁盘IO，**提高MR程序运行速度（但相应增加了cpu运算负担） Mapreduce支持将map输出的结果或者reduce输出的结果进行压缩，以减少网络IO或最终输出数据的体积 压缩特性运用得当能提高性能，但运用不当也可能降低性能 基本原则： 运算密集型的job，少用压缩 IO密集型的job，多用压缩 4.3.2 MR支持的压缩编码4.3.3 Reducer输出压缩在配置参数或在代码中都可以设置reduce的输出压缩 1、在配置参数中设置 mapreduce.output.fileoutputformat.compress=false mapreduce.output.fileoutputformat.compress.codec=org.apache.hadoop.io.compress.DefaultCodec mapreduce.output.fileoutputformat.compress.type=RECORD 2、在代码中设置 Job job = Job.getInstance(conf); FileOutputFormat.setCompressOutput(job, true); FileOutputFormat.setOutputCompressorClass(job, (Class&lt;? extends CompressionCodec&gt;) Class.forName(&quot;&quot;)); 4.3.4 Mapper输出压缩在配置参数或在代码中都可以设置reduce的输出压缩 1、在配置参数中设置 mapreduce.map.output.compress=false mapreduce.map.output.compress.codec=org.apache.hadoop.io.compress.DefaultCodec 2、在代码中设置： conf.setBoolean(Job.MAP_OUTPUT_COMPRESS, true); conf.setClass(Job.MAP_OUTPUT_COMPRESS_CODEC, GzipCodec.class, CompressionCodec.class); 4.3.5 压缩文件的读取Hadoop自带的InputFormat类内置支持压缩文件的读取，比如TextInputformat类，在其initialize方法中： public void initialize(InputSplit genericSplit, TaskAttemptContext context) throws IOException { FileSplit split = (FileSplit) genericSplit; Configuration job = context.getConfiguration(); this.maxLineLength = job.getInt(MAX_LINE_LENGTH, Integer.MAX_VALUE); start = split.getStart(); end = start + split.getLength(); final Path file = split.getPath(); // open the file and seek to the start of the split final FileSystem fs = file.getFileSystem(job); fileIn = fs.open(file); //根据文件后缀名创建相应压缩编码的codec CompressionCodec codec = new CompressionCodecFactory(job).getCodec(file); if (null!=codec) { isCompressedInput = true; decompressor = CodecPool.getDecompressor(codec); //判断是否属于可切片压缩编码类型 if (codec instanceof SplittableCompressionCodec) { final SplitCompressionInputStream cIn = ((SplittableCompressionCodec)codec).createInputStream( fileIn, decompressor, start, end, SplittableCompressionCodec.READ_MODE.BYBLOCK); //如果是可切片压缩编码，则创建一个CompressedSplitLineReader读取压缩数据 in = new CompressedSplitLineReader(cIn, job, this.recordDelimiterBytes); start = cIn.getAdjustedStart(); end = cIn.getAdjustedEnd(); filePosition = cIn; } else { //如果是不可切片压缩编码，则创建一个SplitLineReader读取压缩数据，并将文件输入流转换成解压数据流传递给普通SplitLineReader读取 in = new SplitLineReader(codec.createInputStream(fileIn, decompressor), job, this.recordDelimiterBytes); filePosition = fileIn; } } else { fileIn.seek(start); //如果不是压缩文件，则创建普通SplitLineReader读取数据 in = new SplitLineReader(fileIn, job, this.recordDelimiterBytes); filePosition = fileIn; } 4.4. 更多MapReduce编程案例4.4.1 reduce端join算法实现1、需求： 订单数据表t_order： id date pid amount 1001 20150710 P0001 2 1002 20150710 P0001 3 1002 20150710 P0002 3 商品信息表t_product id name category_id price P0001 小米5 C01 2 P0002 锤子T1 C01 3 假如数据量巨大，两表的数据是以文件的形式存储在HDFS中，需要用mapreduce程序来实现一下SQL查询运算： select a.id,a.date,b.name,b.category_id,b.price from t_order a join t_product b on a.pid = b.id 2、实现机制： 通过将关联的条件作为map输出的key，将两表满足join条件的数据并携带数据所来源的文件信息，发往同一个reduce task，在reduce中进行数据的串联 public class OrderJoin { static class OrderJoinMapper extends Mapper { @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { // 拿到一行数据，并且要分辨出这行数据所属的文件 String line = value.toString(); String[] fields = line.split(“\\t”); // 拿到itemid String itemid = fields[0]; // 获取到这一行所在的文件名（通过inpusplit） String name = “你拿到的文件名”; // 根据文件名，切分出各字段（如果是a，切分出两个字段，如果是b，切分出3个字段） OrderJoinBean bean = new OrderJoinBean(); bean.set(null, null, null, null, null); context.write(new Text(itemid), bean); } } static class OrderJoinReducer extends Reducer { @Override protected void reduce(Text key, Iterable beans, Context context) throws IOException, InterruptedException { //拿到的key是某一个itemid,比如1000 //拿到的beans是来自于两类文件的bean // {1000,amount} {1000,amount} {1000,amount} —- {1000,price,name} //将来自于b文件的bean里面的字段，跟来自于a的所有bean进行字段拼接并输出 } } } 缺点：这种方式中，join的操作是在reduce阶段完成，reduce端的处理压力太大，map节点的运算负载则很低，资源利用率不高，且在reduce阶段极易产生数据倾斜 解决方案： map端join实现方式 4.4.2 map端join算法实现1、原理阐述 适用于关联表中有小表的情形； 可以将小表分发到所有的map节点，这样，map节点就可以在本地对自己所读到的大表数据进行join并输出最终结果，可以大大提高join操作的并发度，加快处理速度 2、实现示例 —先在mapper类中预先定义好小表，进行join —引入实际场景中的解决方案：一次加载数据库或者用distributedcache public class TestDistributedCache { static class TestDistributedCacheMapper extends Mapper{ FileReader in = null; BufferedReader reader = null; HashMap b_tab = new HashMap(); String localpath =null; String uirpath = null; //是在map任务初始化的时候调用一次 @Override protected void setup(Context context) throws IOException, InterruptedException { //通过这几句代码可以获取到cache file的本地绝对路径，测试验证用 Path[] files = context.getLocalCacheFiles(); localpath = files[0].toString(); URI[] cacheFiles = context.getCacheFiles(); //缓存文件的用法——直接用本地IO来读取 //这里读的数据是map task所在机器本地工作目录中的一个小文件 in = new FileReader(“b.txt”); reader =new BufferedReader(in); String line =null; while(null!=(line=reader.readLine())){ String[] fields = line.split(“,”); b_tab.put(fields[0],fields[1]); } IOUtils.closeStream(reader); IOUtils.closeStream(in); } @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { //这里读的是这个map task所负责的那一个切片数据（在hdfs上） String[] fields = value.toString().split(“\\t”); String a_itemid = fields[0]; String a_amount = fields[1]; String b_name = b_tab.get(a_itemid); // 输出结果 1001 98.9 banan context.write(new Text(a_itemid), new Text(a_amount + “\\t” + “:” + localpath + “\\t” +b_name )); } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(TestDistributedCache.class); job.setMapperClass(TestDistributedCacheMapper.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(LongWritable.class); //这里是我们正常的需要处理的数据所在路径 FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); //不需要reducer job.setNumReduceTasks(0); //分发一个文件到task进程的工作目录 job.addCacheFile(new URI(“hdfs://hadoop-server01:9000/cachefile/b.txt”)); //分发一个归档文件到task进程的工作目录 // job.addArchiveToClassPath(archive); //分发jar包到task节点的classpath下 // job.addFileToClassPath(jarfile); job.waitForCompletion(true); } } 4.4.3 web日志预处理1、需求： 对web访问日志中的各字段识别切分 去除日志中不合法的记录 根据KPI统计需求，生成各类访问请求过滤数据 2、实现代码： a) 定义一个bean，用来记录日志数据中的各数据字段 public class WebLogBean { private String remote_addr;// 记录客户端的ip地址 private String remote_user;// 记录客户端用户名称,忽略属性”-“ private String time_local;// 记录访问时间与时区 private String request;// 记录请求的url与http协议 private String status;// 记录请求状态；成功是200 private String body_bytes_sent;// 记录发送给客户端文件主体内容大小 private String http_referer;// 用来记录从那个页面链接访问过来的 private String http_user_agent;// 记录客户浏览器的相关信息 private boolean valid = true;// 判断数据是否合法 public String getRemote_addr() { return remote_addr; } public void setRemote_addr(String remote_addr) { this.remote_addr = remote_addr; } public String getRemote_user() { return remote_user; } public void setRemote_user(String remote_user) { this.remote_user = remote_user; } public String getTime_local() { return time_local; } public void setTime_local(String time_local) { this.time_local = time_local; } public String getRequest() { return request; } public void setRequest(String request) { this.request = request; } public String getStatus() { return status; } public void setStatus(String status) { this.status = status; } public String getBody_bytes_sent() { return body_bytes_sent; } public void setBody_bytes_sent(String body_bytes_sent) { this.body_bytes_sent = body_bytes_sent; } public String getHttp_referer() { return http_referer; } public void setHttp_referer(String http_referer) { this.http_referer = http_referer; } public String getHttp_user_agent() { return http_user_agent; } public void setHttp_user_agent(String http_user_agent) { this.http_user_agent = http_user_agent; } public boolean isValid() { return valid; } public void setValid(boolean valid) { this.valid = valid; } @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(this.valid); sb.append(“\\001”).append(this.remote_addr); sb.append(“\\001”).append(this.remote_user); sb.append(“\\001”).append(this.time_local); sb.append(“\\001”).append(this.request); sb.append(“\\001”).append(this.status); sb.append(“\\001”).append(this.body_bytes_sent); sb.append(“\\001”).append(this.http_referer); sb.append(“\\001”).append(this.http_user_agent); return sb.toString(); } } b)定义一个parser用来解析过滤web访问日志原始记录 public class WebLogParser { public static WebLogBean parser(String line) { WebLogBean webLogBean = new WebLogBean(); String[] arr = line.split(“ “); if (arr.length &gt; 11) { webLogBean.setRemote_addr(arr[0]); webLogBean.setRemote_user(arr[1]); webLogBean.setTime_local(arr[3].substring(1)); webLogBean.setRequest(arr[6]); webLogBean.setStatus(arr[8]); webLogBean.setBody_bytes_sent(arr[9]); webLogBean.setHttp_referer(arr[10]); if (arr.length &gt; 12) { webLogBean.setHttp_user_agent(arr[11] + “ “ + arr[12]); } else { webLogBean.setHttp_user_agent(arr[11]); } if (Integer.parseInt(webLogBean.getStatus()) &gt;= 400) {// 大于400，HTTP错误 webLogBean.setValid(false); } } else { webLogBean.setValid(false); } return webLogBean; } public static String parserTime(String time) { time.replace(“/“, “-“); return time; } } c) mapreduce程序 public class WeblogPreProcess { static class WeblogPreProcessMapper extends Mapper { Text k = new Text(); NullWritable v = NullWritable.get(); @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String line = value.toString(); WebLogBean webLogBean = WebLogParser.parser(line); if (!webLogBean.isValid()) return; k.set(webLogBean.toString()); context.write(k, v); } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(WeblogPreProcess.class); job.setMapperClass(WeblogPreProcessMapper.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(NullWritable.class); FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); job.waitForCompletion(true); } }]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hadoop之路中所有的问题小结]]></title>
    <url>%2Fpost%2Fa23cf390.html</url>
    <content type="text"><![CDATA[·org.apache.hadoop.security.AccessControlException: Permission denied: user=acanprince, access=WRITE, inode=”/“:hadoop:supergroup:drwxr-xr-x at org.apache.hadoop.hdfs.server.namenode.FSPermissionChecker.checkFsPermission(FSPermissionChecker.java:271) at 解决： 方法一： -DHADOOP_USER_NAME=hadoop //因为开始运行VM虚拟机当中会寻找 VM当中的hadoop_user)name这一个参数！ 方法二-直接通过代码： FileSystem fs = null;Configuration conf = null;@Beforepublic void init() throws Exception{conf = new Configuration();conf.set(“fs.defaultFS”,”hdfs://aclear1:9000”);//这个是本地的对象fs = FileSystem.get(conf);// fs = FileSystem.get(new URI(“hdfs://aclear1:9000”), conf,”hadoop”);//拿到一个文件系统操作的客户端实例对象/*fs = FileSystem.get(conf);*///可以直接传入 uri和用户身份} 现象： 注意：如果是从eclipse1上传上去的就是去的eclipse当中hdfs-core.xml配置的副本个数的数量！（所以第一个有三个副本）-&gt;否则若是从 shell里面上传的，首先参考的参数是从，hadoop-2.6.4当中配置的参数起作用还是有两个副本！———————为angelababy打印的分割线———————angelababy.love134217728rw-r—r—76块的起始偏移量：0块的长度：76当前主机：aclear3当前主机：aclear2当前主机：aclear4———————为angelababy打印的分割线———————cenos-6.5-hadoop-2.6.4.tar.gz134217728rw-r—r—180813065块的起始偏移量：0块的长度：134217728当前主机：aclear4当前主机：aclear3块的起始偏移量：134217728块的长度：46595337当前主机：aclear4当前主机：aclear3]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hadoop 2.4.1集群搭建手册]]></title>
    <url>%2Fpost%2F8416728a.html</url>
    <content type="text"><![CDATA[hadoop 2.4.1集群搭建手册&lt;相应的可以改变为自己，相应版本hadoop.&gt; 1.准备Linux环境 1.0先将虚拟机的网络模式选为NAT 1.1修改主机名 vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=itcast ### 1.2修改IP 两种方式： 第一种：通过Linux图形界面进行修改（强烈推荐） 进入Linux图形界面 -&gt; 右键点击右上方的两个小电脑 -&gt; 点击Edit connections -&gt; 选中当前网络System eth0 -&gt; 点击edit按钮 -&gt; 选择IPv4 -&gt; method选择为manual -&gt; 点击add按钮 -&gt; 添加IP：192.168.1.101 子网掩码：255.255.255.0 网关：192.168.1.1 -&gt; apply 第二种：修改配置文件方式（屌丝程序猿专用） vim /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=”eth0” BOOTPROTO=”static” ### HWADDR=”00:0C:29:3C:BF:E7” IPV6INIT=”yes” NM_CONTROLLED=”yes” ONBOOT=”yes” TYPE=”Ethernet” UUID=”ce22eeca-ecde-4536-8cc2-ef0dc36d4a8c” IPADDR=”192.168.1.101” ### NETMASK=”255.255.255.0” ### GATEWAY=”192.168.1.1” ### 1.3修改主机名和IP的映射关系 vim /etc/hosts 192.168.1.101 itcast 1.4关闭防火墙 #查看防火墙状态 service iptables status #关闭防火墙 service iptables stop #查看防火墙开机启动状态 chkconfig iptables —list #关闭防火墙开机启动 chkconfig iptables off 1.5 修改sudo su root vim /etc/sudoers 给hadoop用户添加执行的权限 关闭linux服务器的图形界面： vi /etc/inittab 1.5重启Linux reboot 2.安装JDK 2.1上传alt+p 后出现sftp窗口，然后put d:\\xxx\\yy\\ll\\jdk-7u_65-i585.tar.gz 2.2解压jdk #创建文件夹 mkdir /home/hadoop/app #解压 tar -zxvf jdk-7u55-linux-i586.tar.gz -C /home/hadoop/app 2.3将java添加到环境变量中 vim /etc/profile #在文件最后添加 export JAVA_HOME=/home/hadoop/app/jdk-7u_65-i585 export PATH=$PATH:$JAVA_HOME/bin #刷新配置 source /etc/profile 3.安装hadoop2.4.1 先上传hadoop的安装包到服务器上去/home/hadoop/ 注意：hadoop2.x的配置文件$HADOOP_HOME/etc/hadoop 伪分布式需要修改5个配置文件 3.1配置hadoop 第一个：hadoop-env.sh vim hadoop-env.sh #第27行 export JAVA_HOME=/usr/java/jdk1.7.0_65 第二个：core-site.xml fs.defaultFS hdfs://weekend-1206-01:9000 hadoop.tmp.dir /home/hadoop/hadoop-2.4.1/tmp 第三个：hdfs-site.xml dfs.replication 1 dfs.secondary.http.address 192.168.1.152:50090 第四个：mapred-site.xml (mv mapred-site.xml.template mapred-site.xml) mv mapred-site.xml.template mapred-site.xml vim mapred-site.xml mapreduce.framework.name yarn 第五个：yarn-site.xml yarn.resourcemanager.hostname weekend-1206-01 yarn.nodemanager.aux-services mapreduce_shuffle 3.2将hadoop添加到环境变量 vim /etc/proflie export JAVA_HOME=/usr/java/jdk1.7.0_65 export HADOOP_HOME=/itcast/hadoop-2.4.1 export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin source /etc/profile 3.3格式化namenode（是对namenode进行初始化） hdfs namenode -format (hadoop namenode -format) 3.4启动hadoop 先启动HDFS sbin/start-dfs.sh 再启动YARN sbin/start-yarn.sh 3.5验证是否启动成功 使用jps命令验证 27408 NameNode 28218 Jps 27643 SecondaryNameNode 28066 NodeManager 27803 ResourceManager 27512 DataNode http://192.168.1.101:50070 （HDFS管理界面） http://192.168.1.101:8088 （MR管理界面） 4.配置ssh免登陆 #生成ssh免登陆密钥 #进入到我的home目录 cd ~/.ssh ssh-keygen -t rsa （四个回车） 执行完这个命令后，会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥） 将公钥拷贝到要免密登陆的目标机器上 ssh-copy-id localhost —————————————- ssh免登陆： 生成key: ssh-keygen 复制从A复制到B上: ssh-copy-id B 验证： ssh localhost/exit，ps -e|grep ssh ssh A #在B中执行]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day07_BigData渐进学习_aclear_fire]]></title>
    <url>%2Fpost%2Fc2c21e1f.html</url>
    <content type="text"><![CDATA[基本配置: http://www.cnblogs.com/huligong1234/p/4136331.html https://www.cnblogs.com/huligong1234/p/4137133.html 浏览器查看 浏览器打开 http://ubuntu-V01:50070/，会看到hdfs管理页面 浏览器打开 http://ubuntu-V01:8088/，会看到hadoop进程管理页面 浏览器打开 http://ubuntu-v01:8088/cluster 查看cluster情况 day06问题总结： 1/运行mr程序出错 connecting to resoucemanager retrying …. retrying ….. 原因是没有启动yarn或者启动失败 sudo date -s “2018-1-21 09:00:00” 2/初始化工作目录结构 hdfs namenode -format 只是初始化了namenode的工作目录 而datanode的工作目录是在datanode启动后自己初始化的 3/datanode不被namenode识别的问题 namenode在format初始化的时候会形成两个标识： blockPoolId： clusterId： 新的datanode加入时，会获取这两个标识作为自己工作目录中的标识 一旦namenode重新format后，namenode的身份标识已变，而datanode如果依然 持有原来的id，就不会被namenode识别 4/datanode下线后多久看到效果 datanode不是一下线就会被namenode认定为下线的，有一个超时时间 5/关于副本数量的问题 副本数由客户端的参数dfs.replication决定（优先级： conf.set &gt; 自定义配置文件 &gt; jar包中的hdfs-default.xml） _hadoop-dfs.jar &gt; hdfs-site.xml &gt; 代码中的 configuration（执行顺序，后来执行的会覆盖后面执行的。）_ Day07开始我们开始 4.1关于服务器HDFS内部的工作原理开始进行 研究 探讨。 离线计算机系统-目录 [课程大纲（HDFS详解）.................................................................................................... 2](#_Toc439077207) HDFS前言…………………………………………………………………………………………………….. 3 HDFS的概念和特性…………………………………………………………………………………………. 3 HDFS的shell(命令行客户端)操作……………………………………………………………………….. 4 3.1 HDFS命令行客户端使用…………………………………………………………………………… 4 3.2命令行客户端支持的命令参数…………………………………………………………………… 4 3.2 常用命令参数介绍………………………………………………………………………………….. 5 hdfs的工作机制……………………………………………………………………………………………… 8 4.1 概述：…………………………………………………………………………………………………. 8 4.2 HDFS写数据流程…………………………………………………………………………………….. 9 4.2.1 概述……………………………………………………………………………………………. 9 4.2.2 详细步骤图…………………………………………………………………………………… 9 4.2.3 详细步骤解析……………………………………………………………………………….. 9 4.3. HDFS读数据流程………………………………………………………………………………….. 10 4.3.1 概述………………………………………………………………………………………….. 10 4.3.2 详细步骤图：……………………………………………………………………………… 10 4.3.3 详细步骤解析……………………………………………………………………………… 10 NAMENODE工作机制…………………………………………………………………………………….. 11 5.1 概述…………………………………………………………………………………………………… 11 5.2元数据管理………………………………………………………………………………………….. 11 5.2.1 元数据存储机制…………………………………………………………………………… 11 5.2.2 元数据手动查看…………………………………………………………………………… 11 5.2.3 元数据的checkpoint……………………………………………………………………… 12 DATANODE的工作机制……………………………………………………………………………………. 13 6.1 概述…………………………………………………………………………………………………… 13 6.2 观察验证DATANODE功能………………………………………………………………………. 13 HDFS的java操作………………………………………………………………………………………….. 13 7.1 搭建开发环境………………………………………………………………………………………. 13 7.2 获取api中的客户端对象……………………………………………………………………….. 14 7.3 DistributedFileSystem实例对象所具备的方法………………………………………………. 14 7.4 HDFS客户端操作数据代码示例：……………………………………………………………… 15 7.4.1 文件的增删改查…………………………………………………………………………… 15 7.4.2 通过流的方式访问hdfs…………………………………………………………………. 18 课程大纲（HDFS详解）Hadoop HDFS 分布式文件系统DFS简介 HDFS的系统组成介绍 HDFS的组成部分详解 副本存放策略及路由规则 命令行接口 Java接口 客户端与HDFS的数据流讲解 学习目标： 掌握hdfs的shell操作 掌握hdfs的java api操作 理解hdfs的工作原理 ******HDFS基本概念篇******1. HDFS前言 设计思想 分而治之：将大文件、大批量文件，分布式存放在大量服务器上，以便于采取分而治之的方式对海量数据进行运算分析； 在大数据系统中作用： 为各类分布式运算框架（如：mapreduce，spark，tez，……）提供数据存储服务 重点概念：文件切块，副本存放，元数据 2. HDFS的概念和特性首先，它是一个文件系统，用于存储文件，通过统一的命名空间——目录树来定位文件 其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务器有各自的角色； 重要特性如下： HDFS中的文件在物理上是分块存储（**block**），块的大小可以通过配置参数( dfs.blocksize)来规定，默认大小在x版本中是128M，老版本中是64M HDFS文件系统会给客户端提供一个统一的抽象目录树，客户端通过路径来访问文件，形如：hdfs://namenode:port/dir-a/dir-b/dir-c/file.data 目录结构及文件分块信息(**元数据)**的管理由namenode节点承担 ——namenode是HDFS集群主节点，负责维护整个hdfs文件系统的目录树，以及每一个路径（文件）所对应的block块信息（block的id，及所在的datanode服务器） 文件的各个block的存储管理由datanode节点承担 ---- datanode是HDFS集群从节点，每一个block都可以在多个datanode上存储多个副本（副本数量也可以通过参数设置dfs.replication） HDFS是设计成适应一次写入，多次读出的场景，且不支持文件的修改 _(__注：适合用来做数据分析，并不适合用来做网盘应用，因为，不便修改，延迟大，网络开销大，成本太高)_ ******HDFS基本操作篇******3. HDFS的shell(命令行客户端)操作3.1 HDFS命令行客户端使用HDFS提供shell命令行客户端，使用方法如下： 3.2 命令行客户端支持的命令参数 \[-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;\] \[-cat \[-ignoreCrc\] &lt;src&gt; ...\] \[-checksum &lt;src&gt; ...\] \[-chgrp \[-R\] GROUP PATH...\] \[-chmod \[-R\] &lt;MODE\[,MODE\]... | OCTALMODE&gt; PATH...\] \[-chown \[-R\] \[OWNER\]\[:\[GROUP\]\] PATH...\] \[-copyFromLocal \[-f\] \[-p\] &lt;localsrc&gt; ... &lt;dst&gt;\] \[-copyToLocal \[-p\] \[-ignoreCrc\] \[-crc\] &lt;src&gt; ... &lt;localdst&gt;\] \[-count \[-q\] &lt;path&gt; ...\] \[-cp \[-f\] \[-p\] &lt;src&gt; ... &lt;dst&gt;\] \[-createSnapshot &lt;snapshotDir&gt; \[&lt;snapshotName&gt;\]\] \[-deleteSnapshot &lt;snapshotDir&gt; &lt;snapshotName&gt;\] \[-df \[-h\] \[&lt;path&gt; ...\]\] \[-du \[-s\] \[-h\] &lt;path&gt; ...\] \[-expunge\] \[-get \[-p\] \[-ignoreCrc\] \[-crc\] &lt;src&gt; ... &lt;localdst&gt;\] \[-getfacl \[-R\] &lt;path&gt;\] \[-getmerge \[-nl\] &lt;src&gt; &lt;localdst&gt;\] \[-help \[cmd ...\]\] \[-ls \[-d\] \[-h\] \[-R\] \[&lt;path&gt; ...\]\] \[-mkdir \[-p\] &lt;path&gt; ...\] \[-moveFromLocal &lt;localsrc&gt; ... &lt;dst&gt;\] \[-moveToLocal &lt;src&gt; &lt;localdst&gt;\] \[-mv &lt;src&gt; ... &lt;dst&gt;\] \[-put \[-f\] \[-p\] &lt;localsrc&gt; ... &lt;dst&gt;\] \[-renameSnapshot &lt;snapshotDir&gt; &lt;oldName&gt; &lt;newName&gt;\] \[-rm \[-f\] \[-r|-R\] \[-skipTrash\] &lt;src&gt; ...\] \[-rmdir \[--ignore-fail-on-non-empty\] &lt;dir&gt; ...\] \[-setfacl \[-R\] \[{-b|-k} {-m|-x &lt;acl\_spec&gt;} &lt;path&gt;\]|\[--set &lt;acl\_spec&gt; &lt;path&gt;\]\] \[-setrep \[-R\] \[-w\] &lt;rep&gt; &lt;path&gt; ...\] \[-stat \[format\] &lt;path&gt; ...\] \[-tail \[-f\] &lt;file&gt;\] \[-test -\[defsz\] &lt;path&gt;\] \[-text \[-ignoreCrc\] &lt;src&gt; ...\] \[-touchz &lt;path&gt; ...\] \[-usage \[cmd ...\]\] 3.2 常用命令参数介绍注意： hdfs fs -du -s -h hdfs://aclear1:9000/* //是从这里面uri去访问的资源！全称是这样的！ -help 功能：输出这个命令参数手册 -ls 功能：显示目录信息 _示例： hadoop fs -ls hdfs://hadoop-server01:9000/_ _备注：这些参数中，所有的hdfs__路径都可以简写_ _—&gt;hadoop fs -ls /_ _等同于上一条命令的效果_ -mkdir 功能：在hdfs**上创建目录** _示例：hadoop fs -mkdir -p /aaa/bbb/cc/dd_ -moveFromLocal 功能：从本地剪切粘贴到hdfs _示例：hadoop fs - moveFromLocal /home/hadoop/a.txt /aaa/bbb/cc/dd_ -moveToLocal 功能：从hdfs**剪切粘贴到本地** _示例：hadoop fs - moveToLocal /aaa/bbb/cc/dd /home/hadoop/a.txt_ —appendToFile 功能：追加一个文件到已经存在的文件末尾 _示例：hadoop fs -appendToFile ./hello.txt hdfs://hadoop-server01:9000/hello.txt_ _可以简写为：_ _Hadoop fs -appendToFile ./hello.txt /hello.txt_ -cat 功能：显示文件内容 _示例：hadoop fs -cat /hello.txt_ //Hadoop fs -cat /hello.txt | more //就会出现可以翻页的more. -tail 功能：显示一个文件的末尾 _示例：hadoop fs -tail /weblog/access_log.1_ -text 功能：以字符形式打印一个文件的内容 _示例：hadoop fs -text /weblog/access_log.1_ -chgrp //**改组 -chmod //**该权限 -chown //**改组 和 该用户！ 功能：linux**文件系统中的用法一样，对文件所属权限 _示例：_ _hadoop fs -chmod 666 /hello.txt_ _hadoop fs -chown someuser:somegrp /hello.txt //someuser用户(但是不回去检查是否存在！) somegrp__组_ -copyFromLocal 功能：从本地文件系统中拷贝文件到hdfs**路径去 _示例：hadoop fs -copyFromLocal ./jdk.tar.gz /aaa/_ -copyToLocal 功能：从hdfs**拷贝到本地 _示例：hadoop fs -copyToLocal /aaa/jdk.tar.gz_ -cp 功能：从hdfs**的一个路径拷贝hdfs**的另一个路径 _示例： hadoop fs -cp /aaa/jdk.tar.gz /bbb/jdk.tar.gz.2_ -mv 功能：在hdfs**目录中移动文件** _示例： hadoop fs -mv /aaa/jdk.tar.gz /_ -get 功能：等同于copyToLocal**，就是从hdfs**下载文件到本地 示例：hadoop fs -get /aaa/jdk.tar.gz -getmerge 功能：合并下载多个文件 //**注意是合并成一个文件了，txt 等* _示例：比如hdfs的目录 /aaa/__下有多个文件:log.1, log.2,log.3,…_ hadoop fs -getmerge /aaa/log. ./log.sum -put 功能：等同于copyFromLocal _示例：hadoop fs -put /aaa/jdk.tar.gz /bbb/jdk.tar.gz.2_ -rm 功能：删除文件或文件夹 _示例：hadoop fs -rm -r /aaa/bbb/_ -rmdir 功能：删除空目录 _示例：hadoop fs -rmdir /aaa/bbb/ccc_ -df 功能：统计文件系统的可用空间信息 _示例：hadoop fs -df -h /_ -du 功能：统计文件夹的大小信息 _示例：_ _hadoop fs -du -s -h /aaa/*_ -count 功能：统计一个指定目录下的文件节点数量 _示例：hadoop fs -count /aaa/_ -setrep 功能：设置hdfs**中文件的副本数量** _示例：hadoop fs -setrep 3 /aaa/jdk.tar.gz_ 但是注意： 中间只开启了DataNode三个机器——__ ******HDFS原理篇******4. hdfs的工作机制_（工作机制的学习主要是为加深对分布式系统的理解，以及增强遇到各种问题时的分析解决能力，形成一定的集群运维能力）_ _注：很多不是真正理解hadoop技术体系的人会常常觉得HDFS可用于网盘类应用，但实际并非如此。要想将技术准确用在恰当的地方，必须对技术有深刻的理解_ 4.1 概述 HDFS集群分为两大角色：NameNode、DataNode NameNode负责管理整个文件系统的元数据 DataNode 负责管理用户的文件数据块 文件会按照固定的大小（blocksize）切成若干块后分布式存储在若干台datanode上 每一个文件块可以有多个副本，并存放在不同的datanode上 Datanode会定期向Namenode汇报自身所保存的文件block信息，而namenode则会负责保持文件的副本数量 HDFS的内部工作机制对客户端保持透明，客户端请求访问HDFS都是通过向namenode申请来进行 4.2 HDFS写数据流程4.2.1 概述客户端要向HDFS写数据，首先要跟namenode通信以确认可以写文件并获得接收文件block的datanode，然后，客户端按顺序将文件逐个block传递给相应datanode，并由接收到block的datanode负责向其他datanode复制block的副本 4.2.2 详细步骤图4.2.3 详细步骤解析1、根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在 2、namenode返回是否可以上传 3、client请求第一个 block该传输到哪些datanode服务器上 4、namenode返回3个datanode服务器ABC 5、client请求3台dn中的一台A上传数据（本质上是一个RPC调用，建立pipeline），A收到请求会继续调用B，然后B调用C，将真个pipeline建立完成，逐级返回客户端 6、client开始往A上传第一个block（先从磁盘读取数据放到一个本地内存缓存），以packet为单位，A收到一个packet就会传给B，B传给C；A每传一个packet会放入一个应答队列等待应答 7、当一个block传输完成之后，client再次请求namenode上传第二个block的服务器。 4.3. HDFS读数据流程4.3.1 概述客户端将要读取的文件路径发送给namenode，namenode获取文件的元信息（主要是block的存放位置信息）返回给客户端，客户端根据返回的信息找到相应datanode逐个获取文件的block并在客户端本地进行数据追加合并从而获得整个文件 4.3.2 详细步骤图4.3.3 详细步骤解析1、跟namenode通信查询元数据，找到文件块所在的datanode服务器 2、挑选一台datanode（就近原则，然后随机）服务器，请求建立socket流 3、datanode开始发送数据（从磁盘里面读取数据放入流，以packet为单位来做校验） 4、客户端以packet为单位接收，现在本地缓存，然后写入目标文件 5. NAMENODE工作机制学习目标：理解namenode的工作机制尤其是元数据管理机制，以增强对HDFS工作原理的理解，及培养hadoop集群运营中“性能调优”、“namenode”故障问题的分析解决能力 _问题场景：_ _1、集群启动后，可以查看文件，但是上传文件时报错，打开web页面可看到namenode正处于safemode状态，怎么处理？_ _2、Namenode服务器的磁盘故障导致namenode宕机，如何挽救集群及数据？_ _3、Namenode是否可以有多个？namenode内存要配置多大？namenode跟集群数据存储能力有关系吗？_ _4、文件的blocksize究竟调大好还是调小好？_ _……_ _诸如此类问题的回答，都需要基于对namenode自身的工作原理的深刻理解_ 5.1 NAMENODE职责NAMENODE职责： 负责客户端请求的响应 元数据的管理（查询，修改） 5.2 元数据管理namenode对数据的管理采用了三种存储形式： 内存元数据(NameSystem) 磁盘元数据镜像文件 数据操作日志文件（可通过日志运算出元数据） 5.2.1 元数据存储机制A、内存中有一份完整的元数据(内存meta data) B、磁盘有一个“准完整”的元数据镜像（fsimage）文件(在namenode的工作目录中) C、用于衔接内存metadata和持久化元数据镜像fsimage之间的操作日志（edits**文件**）_注：当客户端对hdfs中的文件进行新增或者修改操作，操作记录首先被记入edits日志文件中，当客户端操作成功后，相应的元数据会更新到内存meta.data中_ 5.2.2 元数据手动查看可以通过hdfs的一个工具来查看edits中的信息 bin/hdfs oev -i edits -o edits.xmlbin/hdfs oiv -i fsimage_0000000000000000087 -p XML -o fsimage.xml 5.2.3 元数据的checkpoint每隔一段时间，会由secondary namenode将namenode上积累的所有edits和一个最新的fsimage下载到本地，并加载到内存进行merge（这个过程称为checkpoint） checkpoint的详细过程checkpoint操作的触发条件配置参数dfs.namenode.checkpoint.check.period=60 #检查触发条件是否满足的频率，60秒 dfs.namenode.checkpoint.dir=file://${hadoop.tmp.dir}/dfs/namesecondary #以上两个参数做checkpoint操作时，secondary namenode的本地工作目录 dfs.namenode.checkpoint.edits.dir=${dfs.namenode.checkpoint.dir} dfs.namenode.checkpoint.max-retries=3 #最大重试次数 dfs.namenode.checkpoint.period=3600 #两次checkpoint之间的时间间隔3600秒 dfs.namenode.checkpoint.txns=1000000 #两次checkpoint之间最大的操作记录 checkpoint的附带作用namenode和secondary namenode的工作目录存储结构完全相同，所以，当namenode故障退出需要重新恢复时，可以从secondary namenode的工作目录中将fsimage拷贝到namenode的工作目录，以恢复namenode的元数据 6. DATANODE的工作机制_问题场景：_ _1、集群容量不够，怎么扩容？_ _2、如果有一些datanode宕机，该怎么办？_ _3、datanode明明已启动，但是集群中的可用datanode列表中就是没有，怎么办？_ _以上这类问题的解答，有赖于对datanode__工作机制的深刻理解_ 6.1 概述1、Datanode工作职责： 存储管理用户的文件块数据 定期向namenode汇报自身所持有的block信息（通过心跳信息上报） （这点很重要，因为，当集群中发生某些block副本失效时，集群如何恢复block初始副本数量的问题） dfs.blockreport.intervalMsec 3600000 Determines block reporting interval in milliseconds. 2、Datanode掉线判断时限参数 datanode进程死亡或者网络故障造成datanode无法与namenode通信，namenode不会立即把该节点判定为死亡，要经过一段时间，这段时间暂称作超时时长。HDFS默认的超时时长为10分钟+30秒。如果定义超时时间为timeout，则超时时长的计算公式为： timeout = 2 heartbeat.recheck.interval + 10 dfs.heartbeat.interval。 而默认的heartbeat.recheck.interval 大小为5分钟，dfs.heartbeat.interval默认为3秒。 需要注意的是hdfs-site.xml 配置文件中的heartbeat.recheck.interval的单位为毫秒，dfs.heartbeat.interval的单位为秒。所以，举个例子，如果heartbeat.recheck.interval设置为5000（毫秒），dfs.heartbeat.interval设置为3（秒，默认），则总的超时时间为40秒。 heartbeat.recheck.interval 2000 dfs.heartbeat.interval 1 6.2 观察验证DATANODE功能上传一个文件，观察文件的block具体的物理存放情况： 在每一台datanode机器上的这个目录中能找到文件的切块： /home/hadoop/app/hadoop-2.4.1/tmp/dfs/data/current/BP-193442119-192.168.2.120-1432457733977/current/finalized 更新当前目录为： /home/hadoop/hdpdata/dfs/data/current/BP-1525464751-192.168.78.201-1515703290610/current/finalized/subdir0/subdir0 ******HDFS应用开发篇******hdfs dfsadmin -report //注意这里进行shell中的集群状态的打印。 大数据list hashmap&lt;不常用&gt;；常常是在 iterator当中 进行迭代取值（或者在hashmap的数据池当中进行获取），这样大数据 方便拿到数据！ HDFS加上MR在上层跑应用程序的框架来说，我们需要进行MR在HDFS中调用一小片的数据！ 7. HDFS的java操作_hdfs在生产应用中主要是客户端的开发，其核心步骤是从hdfs提供的api中构造一个HDFS的访问客户端对象，然后通过该客户端对象操作（增删改查）HDFS__上的文件_ 7.1 搭建开发环境1、引入依赖 org.apache.hadoop hadoop-client 2.6.1 _注：如需手动引入jar包，hdfs的jar包——hadoop的安装目录的share__下_ 2、window下开发的说明 建议在linux下进行hadoop应用的开发，不会存在兼容性问题。如在window上做客户端应用开发，需要设置以下环境： 在windows的某个目录下解压一个hadoop的安装包 将安装包下的lib和bin目录用对应windows版本平台编译的本地库替换 在window系统中配置HADOOP_HOME指向你解压的安装包 在windows系统的path变量中加入hadoop的bin目录 7.2 获取api中的客户端对象在java中操作hdfs，首先要获得一个客户端实例 Configuration conf = new Configuration() FileSystem fs = FileSystem.get(conf) 而我们的操作目标是HDFS，所以获取到的fs对象应该是DistributedFileSystem的实例； get方法是从何处判断具体实例化那种客户端类呢？ ——从conf**中的一个参数 fs.defaultFS**的配置值判断； 如果我们的代码中没有指定fs.defaultFS，并且工程classpath下也没有给定相应的配置，conf中的默认值就来自于hadoop的jar包中的core-default.xml，默认值为： file:///，则获取的将不是一个DistributedFileSystem的实例，而是一个本地文件系统的客户端对象 7.3 DistributedFileSystem实例对象所具备的方法7.4 HDFS客户端操作数据代码示例：7.4.1 文件的增删改查public class HdfsClient { FileSystem fs = null; @Before public void init() throws Exception { // 构造一个配置参数对象，设置一个参数：我们要访问的hdfs的URI // 从而FileSystem.get()方法就知道应该是去构造一个访问hdfs文件系统的客户端，以及hdfs的访问地址 // new Configuration();的时候，它就会去加载jar包中的hdfs-default.xml // 然后再加载classpath下的hdfs-site.xml Configuration conf = new Configuration(); conf.set(“fs.defaultFS”, “hdfs://hdp-node01:9000”); / 参数优先级： 1、客户端代码中设置的值 2、classpath下的用户自定义配置文件 3、然后是服务器的默认配置 / conf.set(“dfs.replication”, “3”); // 获取一个hdfs的访问客户端，根据参数，这个实例应该是DistributedFileSystem的实例 // fs = FileSystem.get(conf); // 如果这样去获取，那conf里面就可以不要配”fs.defaultFS”参数，而且，这个客户端的身份标识已经是hadoop用户 fs = FileSystem.get(new URI(“hdfs://hdp-node01:9000”), conf, “hadoop”); } / 往hdfs上传文件 @throws Exception / @Test public void testAddFileToHdfs() throws Exception { // 要上传的文件所在的本地路径 Path src = new Path(“g:/redis-recommend.zip”); // 要上传到hdfs的目标路径 Path dst = new Path(“/aaa”); fs.copyFromLocalFile(src, dst); fs.close(); } / 从hdfs中复制文件到本地文件系统 @throws IOException @throws IllegalArgumentException */ @Test public void testDownloadFileToLocal() throws IllegalArgumentException, IOException { fs.copyToLocalFile(new Path(“/jdk-7u65-linux-i586.tar.gz”), new Path(“d:/“)); fs.close(); } @Test public void testMkdirAndDeleteAndRename() throws IllegalArgumentException, IOException { // 创建目录 fs.mkdirs(new Path(“/a1/b1/c1”)); // 删除文件夹 ，如果是非空文件夹，参数2必须给值true fs.delete(new Path(“/aaa”), true); // 重命名文件或文件夹 fs.rename(new Path(“/a1”), new Path(“/a2”)); } / 查看目录信息，只显示文件 @throws IOException @throws IllegalArgumentException @throws FileNotFoundException / @Test public void testListFiles() throws FileNotFoundException, IllegalArgumentException, IOException { // 思考：为什么返回迭代器，而不是List之类的容器 RemoteIterator listFiles = fs.listFiles(new Path(“/“), true); while (listFiles.hasNext()) { LocatedFileStatus fileStatus = listFiles.next(); System.out.println(fileStatus.getPath().getName()); System.out.println(fileStatus.getBlockSize()); System.out.println(fileStatus.getPermission()); System.out.println(fileStatus.getLen()); BlockLocation[] blockLocations = fileStatus.getBlockLocations(); for (BlockLocation bl : blockLocations) { System.out.println(“block-length:” + bl.getLength() + “—“ + “block-offset:” + bl.getOffset()); String[] hosts = bl.getHosts(); for (String host : hosts) { System.out.println(host); } } System.out.println(“———————为angelababy打印的分割线———————“); } } /* 查看文件及文件夹信息 @throws IOException @throws IllegalArgumentException @throws FileNotFoundException */ @Test public void testListAll() throws FileNotFoundException, IllegalArgumentException, IOException { FileStatus[] listStatus = fs.listStatus(new Path(“/“)); String flag = “d— “; for (FileStatus fstatus : listStatus) { if (fstatus.isFile()) flag = “f— “; System.out.println(flag + fstatus.getPath().getName()); } } } 7.4.2 通过流的方式访问hdfs_/_ _*_ _相对那些封装好的方法而言的更底层一些的操作方式_ _*_ _上层那些mapreduce spark等运算框架，去hdfs中获取数据的时候，就是调的这种底层的__api_ _ * @author_ _ _ _ /_ _public class StreamAccess {_ _ FileSystem fs = null;_ _ @Before_ _ public void init() throws Exception {_ _ Configuration conf = new Configuration();_ _ fs = FileSystem.get(new URI(“hdfs://hdp-node01:9000”), conf, “hadoop”);_ _ }_ _ /_ _*_ _通过流的方式上传文件到hdfs_ _ * @throws Exception_ _ */_ _ @Test_ _ public void testUpload() throws Exception {_ _ FSDataOutputStream outputStream = fs.create(new Path(“/angelababy.love”), true);_ _ FileInputStream inputStream = new FileInputStream(“c:/angelababy.love”);_ _ IOUtils.copy(inputStream, outputStream);_ _ }_ _ @Test_ _ public void testDownLoadFileToLocal() throws IllegalArgumentException, IOException{_ _ //先获取一个文件的输入流----针对hdfs上的_ _ FSDataInputStream in = fs.open(new Path(“/jdk-7u65-linux-i586.tar.gz”));_ _ //再构造一个文件的输出流----针对本地的_ _ FileOutputStream out = new FileOutputStream(new File(“c:/jdk.tar.gz”));_ _ //再将输入流中数据传输到输出流_ _ IOUtils.copyBytes(in, out, 4096);_ _ }_ _ /_ _ * hdfs支持随机定位进行文件读取，而且可以方便地读取指定长度_ _*_ _用于上层分布式运算框架并发处理数据_ _ * @throws IllegalArgumentException_ _ * @throws IOException_ _ */_ _ @Test_ _ public void testRandomAccess() throws IllegalArgumentException, IOException{_ _ //先获取一个文件的输入流----针对hdfs上的_ _ FSDataInputStream in = fs.open(new Path(“/iloveyou.txt”));_ _ //可以将流的起始偏移量进行自定义_ _ in.seek(22);_ _ //再构造一个文件的输出流----针对本地的_ _ FileOutputStream out = new FileOutputStream(new File(“c:/iloveyou.line.2.txt”));_ _ IOUtils.copyBytes(in,out,19L,true);_ _ }_ _ /_ _*_ _显示hdfs上文件的内容_ _* @throws IOException_ _* @throws IllegalArgumentException_ _ */_ _ @Test_ _ public void testCat() throws IllegalArgumentException, IOException{_ _ FSDataInputStream in = fs.open(new Path(“/iloveyou.txt”));_ _ IOUtils.copyBytes(in, System.out, 1024);_ _ }_ _}_ 7.4.3 场景编程在mapreduce 、spark等运算框架中，有一个核心思想就是将运算移往数据，或者说，就是要在并发计算中尽可能让运算本地化，这就需要获取数据所在位置的信息并进行相应范围读取 以下模拟实现：获取一个文件的所有block位置信息，然后读取指定block中的内容 _ @Test_ _ public void testCat() throws IllegalArgumentException, IOException{_ _ FSDataInputStream in = fs.open(new Path(“/weblog/input/access.log.10”));_ _ //拿到文件信息_ _ FileStatus[] listStatus = fs.listStatus(new Path(“/weblog/input/access.log.10”));_ _ //获取这个文件的所有block的信息_ _ BlockLocation[] fileBlockLocations = fs.getFileBlockLocations(listStatus[0], 0L, listStatus[0].getLen());_ _ //第一个block的长度_ _ long length = fileBlockLocations[0].getLength();_ _ //第一个block的起始偏移量_ _ long offset = fileBlockLocations[0].getOffset();_ _ System.out.println(length);_ _ System.out.println(offset);_ _ //获取第一个block__写入输出流_ _// IOUtils.copyBytes(in, System.out, (int)length);_ _ byte[] b = new byte[4096];_ _ FileOutputStream os = new FileOutputStream(new File(“d:/block0”));_ _ while(in.read(offset, b, 0, 4096)!=-1){_ _ os.write(b);_ _ offset += 4096;_ _ if(offset&gt;=length) return;_ _ };_ _ os.flush();_ _ os.close();_ _ in.close();_ _ }_ //注意：其实在client //只需要导入 hadooop-common.jar //还有对应的 Hadoopjars-common-lib对应上方 jar包的依赖也是需要的！ //《Hadoop 技术内幕》可以看一下，研究源代码！-自己打断点这样学习源码更加省力一点。 //注意 源码调试可以看一下：视频day07-06 第一个视频！已经跳过 原理：1.写一个java定时收集数据的程序，进行shell脚本的定时数据的手机、 Timer、线程池、scheduler、code？进行java定时 或者利用服务器进行定时启动-à天 小时 时间段，每隔多少小时，linux文档当中启动服务器进行采集数据—&gt; 2.然后 copyFromLocal() 放入hdfs当中，每一个小时进行一次的数据分析！ 有需求/挑战 就是有市场—&gt;数据的采集也是有相应的api文档进行开发的！ 首先过滤（上传到一个地方检查是否合法），然后 上传hdfs ！要进行改名！ 脚本因为没有对应的代码规范、编译检错。所以需要我们自己对于这种开发进行 代码模板规范 看懂老师相应的代码就好！慢慢的一点点看 去开发！ 模板：先export 再定义一些 固定文件目录常量 编写代码 8. 案例1：开发shell采集脚本8.1需求说明点击流日志每天都10T，在业务应用服务器上，需要准实时上传至数据仓库（Hadoop HDFS）上 8.2需求分析一般上传文件都是在凌晨24点操作，由于很多种类的业务数据都要在晚上进行传输，为了减轻服务器的压力，避开高峰期。 如果需要伪实时的上传，则采用定时上传的方式 8.3技术分析HDFS SHELL: hadoop fs –put xxxx.tar /data 还可以使用 Java Api 满足上传一个文件，不能满足定时、周期性传入。 定时调度器： Linux crontab crontab -e /5 * $home/bin/command.sh //五分钟执行一次 系统会自动执行脚本，每5分钟一次，执行时判断文件是否符合上传规则，符合则上传 8.4实现流程8.4.1日志产生程序日志产生程序将日志生成后，产生一个一个的文件，使用滚动模式创建文件名。 日志生成的逻辑由业务系统决定，比如在log4j配置文件中配置生成规则，如：当xxxx.log 等于10G时，滚动生成新日志 _log4j.logger.msg=info,msg_ _log4j.appender.msg=cn.maoxiangyi.MyRollingFileAppender_ _log4j.appender.msg.layout=org.apache.log4j.PatternLayout_ _log4j.appender.msg.layout.ConversionPattern=%m%n_ _log4j.appender.msg.datePattern=’.’yyyy-MM-dd_ _log4j.appender.msg.Threshold=info_ _log4j.appender.msg.append=true_ _log4j.appender.msg.encoding=UTF-8_ _log4j.appender.msg.MaxBackupIndex=100_ _log4j.appender.msg.MaxFileSize=10GB_ _log4j.appender.msg.File=/home/hadoop/logs/log/access.log_ 细节： 如果日志文件后缀是1\\2\\3等数字，该文件满足需求可以上传的话。把该文件移动到准备上传的工作区间。 工作区间有文件之后，可以使用hadoop put命令将文件上传。 阶段问题： 待上传文件的工作区间的文件，在上传完成之后，是否需要删除掉。 8.4.2伪代码使用ls命令读取指定路径下的所有文件信息， ls | while read line //判断line这个文件名称是否符合规则 if line=access.log. ( 将文件移动到待上传的工作区间 ) //批量上传工作区间的文件 hadoop fs –put xxx *脚本写完之后，配置linux定时任务，每5分钟运行一次。 8.5代码实现代码第一版本，实现基本的上传功能和定时调度功能 代码第二版本：增强版V2(基本能用，还是不够健全) 8.6效果展示及操作步骤1、日志收集文件收集数据，并将数据保存起来，效果如下： 2、上传程序通过crontab定时调度 3、程序运行时产生的临时文件 4、Hadoo hdfs上的效果 作业：第七节都要自己敲一遍！ 然而第八节 这个是企业里面实实在在就是这样写的！所以自己最好实实在在敲一遍！ 9. 案例2：开发JAVA采集程序9.1 需求从外部购买数据，数据提供方会实时将数据推送到6台FTP服务器上，我方部署6台接口采集机来对接采集数据，并上传到HDFS中 提供商在FTP上生成数据的规则是以小时为单位建立文件夹(2016-03-11-10)，每分钟生成一个文件（00.dat,01.data,02.dat,……..） 提供方不提供数据备份，推送到FTP服务器的数据如果丢失，不再重新提供，且FTP服务器磁盘空间有限，最多存储最近10小时内的数据 由于每一个文件比较小，只有150M左右，因此，我方在上传到HDFS过程中，需要将15分钟时段的数据合并成一个文件上传到HDFS 为了区分数据丢失的责任，我方在下载数据时最好进行校验 9.2 设计分析Kotlin]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VMWare中CentOS 6.7_x64mini版本安装(NAT方式)]]></title>
    <url>%2Fpost%2Fb7a2b11.html</url>
    <content type="text"><![CDATA[点击典型安装 稍后安装操作系统 centos 64位 Linux 自定义硬件： 内存 2G， CD/DVD 使用ISO映像文件：选择对应的mini iso镜像， 网络适配器：自定义：（NAT模式）， 移除声卡和打印机。 创建虚拟机啊开机过程： skip， ok， 中文，英文键盘，上海时间。 分盘——选择对应的最后一个自定义布局： /boot ext4 200M或380M(15G硬盘) swap 选择对应主存的两倍 / ext4 注意选择第三个——选择最下面的——利用所有剩余空间。 完成（剩余默认） 默认回车就好（不用怕全部清除） ，最后重新引导即可。 配置网络的NAT模式见day01或印象笔记的安装目录。 已经配置完成NAT，接下来进行基础的mini软件、网络的配置： 修改网卡\\网络掩码\\网关\\dns—-vi /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0HWADDR=00:0C:29:22:EC:2DTYPE=EthernetUUID=4012149b-6643-45cb-8612-a3e287135f52ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=noneIPADDR=192.168.78.202NETMASK=255.255.255.0GATEWAY=192.168.78.2DNS1=192.168.78.2—-service network restart 修改DNS，修改主机名：CentOS修改主机名(hostname)需要修改两处：一处是/etc/sysconfig/network，另一处是/etc/hosts，只修改任一处会导致系统启动异常。首先切换到root用户。/etc/sysconfig/network用任一款你喜爱的编辑器打开该文件，里面有一行 HOSTNAME=localhost.localdomain(如果是默认的话），修改 localhost.localdomain 为你的主机名。/etc/hosts（选择修改，不修改好像也没问题）打开该文件，会有一行 127.0.0.1 localhost.localdomain localhost 。其中 127.0.0.1 是本地环路地址， localhost.localdomain 是主机名(hostname)，也就是你待修改的。localhost 是主机名的别名（alias），它会出现在Konsole的提示符下。将第二项修改为你的主机名，第三项可选。将上面两个文件修改完后，并不能立刻生效。如果要立刻生效的话，可以用 hostname your-hostname 作临时修改，它只是临时地修改主机名，系统重启后会恢复原样的。但修改上面两个文件是永久的，重启系统会得到新的主机名。最后，重启后查看主机名 uname -n 。 CentOS修改IP地址# ifconfig eth0 192.168.1.80这样就把IP地址修改为192.168.1.80(如果发现上不了网了，那么你可能需要把网关和DNS也改一下，后面会提到)，但是当你重新启动系统或网卡之后，还是会变回原来的地址，这种修改方式只适用于需要临时做IP修改。要想永久性修改，就要修改/etc/sysconfig/network-scripts/ifcfg-eth0这个文件，这个文件的主要内容如下（你的文件中没有的项，你可以手动添加）：# vi /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0 #描述网卡对应的设备别名BOOTPROTO=static #设置网卡获得ip地址的方式，选项可以为为static，dhcp或bootpBROADCAST=192.168.1.255 #对应的子网广播地址HWADDR=00:07:E9:05:E8:B4 #对应的网卡物理地址IPADDR=12.168.1.80 #只有网卡设置成static时，才需要此字段NETMASK=255.255.255.0 #网卡对应的网络掩码NETWORK=192.168.1.0 #网卡对应的网络地址，也就是所属的网段ONBOOT=yes #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备CentOS修改网关# route add default gw 192.168.1.1 dev eth0这样就把网关修改为192.168.1.1了，这种修改只是临时的，当你重新启动系统或网卡之后，还是会变回原来的网关。要想永久性修改，就要修改/etc/sysconfig/network 这个文件，这个文件的主要内容如下（你的文件中没有的项，你可以手动添加）：# vi /etc/sysconfig/networkNETWORKING=yes #表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络。HOSTNAME=centos #设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应GATEWAY=192.168.1.1 #设置本机连接的网关的IP地址。**上面的文件修改完要重新启动一下网卡才会生效：# service network restart **CentOS修改DNS上面的都修改完之后，当你ping一个域名是肯能不通，但ping对应的IP地址是同的，这时我们需要修改一下DNS。修改DNS要通过修改/etc/resolv.conf这个文件：# vi /etc/resolv.confnameserver 8.8.8.8 #google域名服务器 nameserver 8.8.4.4 #google域名服务器通过上面的所有设置，系统应该可以上网了。如果centos系统建立在虚拟机之上，那么在设置虚拟机的网络时请选择‘网桥适配器’连接。 完成]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强大的vi快捷键大全——编辑快捷键概览+方便查找]]></title>
    <url>%2Fpost%2Fc53a2ec6.html</url>
    <content type="text"><![CDATA[1、vim ~/.vimrc 进入配置文件如果不知道vimrc文件在哪，可使用 :scriptnames 来查看 set nu #行号 set tabstop=4 #一个tab为4个空格长度 set ai #设置自动缩进 syntax on #高亮 2、基本空格键 向右移动一格 x 删除后面的字符 X 删除前一个字符 删除3个字符就是3x dd:删除一行 D 删除到行尾 caw:改写单词 c 相当于 d 变为编辑模式 J:删除换行符，使下一行并上来。 nJ:连接后面的n行 u:撤销上一次操作 U:撤销当前行的所有修改 ctrl+r:对撤消的撤消 i 在光标前插入 I 在行首插入 a 在光标后插入 A 在行末插入 o:在当前行的下面另起一行，并变为插入模式 O：在当前行上面另起一行，变为插入模式 Ctrl+o:临时变成命令模式（一次而已） ：e!:放弃更改，然后相当于重新打开 ：help:帮助，可用ZZ退出帮助窗口 vim中Nyy可以复制光标后的N行。有时我们不容易得出行数，这时可以用做标记的方法来制定复制范围： 1. 在开始行上输入ma作一个标记a 2. 移动到结束行，输入y’a会复制当前行到标记a之间的文本。d’a会删除。 或者是v进入可视模式，再13G跳转到相应行，y即可。 :10,20y 回车即可，相应的删除也是如此 :10,20d （此方法比上面两种方法更简单） :10,20 m 30 把10行到20行的内容，剪切到30行之后 :10,20 co 30 把10行到20行的内容，复制到30行之后 将光标放在 { 处，然后输入v%就可以把大括号中内容选定 如果光标放在第一个s上，想删除到“(”为止，则输入dt(就可以了，t(的作用是跳到下一个”(“前。 ctrl +n 自动补全 ctrl + p 也一样 :ab hw hello world 用一个缩写字符串代替一个长的字符串，此处用 hw 代替 hello world %: 移动到与制匹配的括号上去（），{}，[]，&lt;&gt;等 ‘ 移动到上一次的修改行 fx 向右跳到本行字符x处（x可以是任何字符） Fx 向左跳到本行字符x处（x可以是任何字符） tx 和fx相同，区别是跳到字符x前 Tx 和Fx相同，区别是跳到字符x后 # 到与当前单词相同的上一个单词上， * 到与当前单词相同的下一个单词上 如果你要重复键入一个短语或一个句子, 也有一种快捷的方法。Vim有一种记录宏的机制。你键入”qa”开始把一段宏记录入寄存器变量’a’中。 按下来你可以象平常一样键入你要的操作, 只是这些操作都会被Vim记录进它命名为’a’的宏中, 再次再下”q”键, 就结束了宏’a’的录制。当你要重复执行你刚才记录的那些操作时只要使用”@a”命令。共有26个可用的寄存器供你记录宏。 使用宏你可以重复多个不同的操作。而不仅仅是插入文本了。如果你要进行某种重复的操作, 记着要用这一招呀。 :abbr hte the :abbr hw Hello World 输入先面的单词时，自动用后面的替换。 3、移动：b、3b、w、3w:向前\\后移动几个单词，标点也算一个单词。相应的大写状态为不含标点，即只把空格和换行符作为单词间隔符。 $：移动到行尾 3$：移动到3行后的行尾 ^:移动到行首，0也是 +：移到下一行的行首 -： 移到上一行的行首 f:搜索命令，小写时向后搜索（用来定位）如 fx：定位到下一个x上。 Fx：定位到上一个x上，重复时，可用;或, 不过 , 表示反方向 %：跳到相对应的括号上，编程时常用 33G：跳转到33行 此时按可以返回到原来行 gg:文件头 G： 文件尾 30%：跳转到文件的30%处 &quot;H&quot;意为Home, &quot;M&quot;为Middle, &quot;L&quot;为Last. 当前屏幕的上中下位置，大小写皆可 Ctrl+G:显示当前位置 set number:设置显示行号，set nonumber:关闭显示 :set ruler 设置在窗口右下角显示行号，与上面的好处是，节省空间 ctrl+u\\d 向上\\下滚动半屏 ctrl+e\\y 向上\\下滚动一行 ctrl+b\\f 向上\\下滚动一屏 这个比较实用，记住。 zz:将当前行滚动于屏幕中间，方便查看上下文 zt置顶，zb置尾 /string 查找string，回车后，按n键可以跳到下一个，N上一个，另外按/键后，按上下键可以找到以前查找的记录，同样的 ：也有记录 ?/string 同上，默认向上查找 :set ignorecase 大小写无关 :set noignorecase 大小写敏感 * ：查找下一个光标所在单词 #是查找上一个 :set hlsearch 高亮显示查找结果 :set nohlsearch 取消高亮 :nohlsearch 去掉当前显示的高完（一次性） 上次光标停靠的行 % 匹配到相应括号处 &gt;&gt; 向右移动本行一段距离 &lt;&lt; 向左移动本行一段距离 3&lt;&lt; 把下面3行（包括本行），向左移动一段距离 :20,30&gt;&gt; 把20行到30行向右移动一段距离 4、小幅改动：:%s/str1/str2/g 替换每一行的 str1为 str2 :10,20s/str1/str2/g 替换从行10到行20之间的 str1为 str2 :10,$s/str1/str2/g 替换从行10到最后一行之间的 str1为 str2 :s/str1/str2/g 替换当前行的 str1为 str2 . 重复执行命令 :10,$ w test2.cpp 取行10到最后一行内容，保存到test2.cpp :r class/User.hpp 读取文件中的内容，插入到当前行的后面 dw:删除一个单词（光标后部分） 不如：daw实用 d4w：删除4个单词 d$:删除当前光标到行尾 d^：删除当前光标至行首 d换成c效果是一样的，只是操作完会变成insert模式 dnw： 删除N个单词 dnj: 向下删除n行 dnk: 向上删除n行 X：删除左边的字符，相当于&lt;-键，x删除当前字符 D:相当于d$ C:相当于c$ s:相当于c1 S:相当于cc r:替换当前字符，但不会进入insert模式 3r:把后面3个字符替换掉 R：替换模式 .:重复上一次操作 v：进入Visual模式 V:进入可视行模式，比如 Vjjd 删除3行 Ctrl+v：可视块模式 P：粘贴至光标前 p：粘贴至光标后 3P：粘贴3次 “2p 粘贴最后第二次的删除的内容 yy:复制一行 yaw： 复制一个单词,光标在单词任意位置 ynw： 复制N个单词 ynj: 向下复制n行 ynk: 向上复制n行 自动缩进： :set cindent(所有的set都可以简写为se,虽然只节省了一个字符, 译者注) 需要注意的是cindent控制缩进量是通过shiftwidth选项的值, 而不是通过tabstop 的值, shiftwidth的默认值是8(也就是说, 一个缩进为8个空格, 译者注), 要改变默认的设置, 可以使用”:set shiftwidth=x”命令, 其中x是你希望一个缩进量代表的空格的数目. { = 到前一个空行上 } = 到下一个空行上 5、VIM的一些插件：c.vim :如果是用root账号的，把文件复制到/usr/share/vim/vim70中解压没有用的，不存在 $HOME/.vim 这个目录，没办法，只能新建个目录，然后把压缩包cp到这个目录，再unzip即可。在 ~/.vimrc 中 写入 filetype plugin on :e! 返回上次保存后的状态 Ctrl+z:暂停vi,回到Unix提示符，再输入fg即可回到vi。 ^回到行首，光标位于行首字母处；0回到行首，光标位于行首字母前。$回到行尾，光标位于行尾字母处。 nb:向前移动n个单词，nw：向后移动n个单词。光标位于单词的第一个字母处。 nw这个操作很慢，不知何故。 以空格、标点符号与单词的分界为分隔符。（几个连续的标点视为一个单词） 同样的，也可以使用nB,nW，只是这里只使用空格做为分隔符。 相换两个相邻字母的位置：x、p s:删除一个字符，并进入编辑模式。 S：删除一整行，进入编辑模式，相当于cc。 ns:删除后面n个字符，并进入编辑模式。 ~:更改字母的大小写，同时光标进入到下一个字符。 n~:把后面n个字母的大小写状态改变。 dw:删除单词后面部分 db：删除单词前面部分。 如果要删除整个单词(光标位于单词中间的话)，可以 dbw\\wdb de:类似于dw,删除单词后面的部分（只删除到本单词结尾，dw会删除掉单词后面的空格） dE:删除的范围包括标号在内的单词结尾。 e:相当于w，向后移动一个单词。不同的是，w移动到单词第一个字符上，e移动到单词最后一个字符上。 所以ea,可以给本单词追加内容。 D：d$ 的简写，同样的，C：c$的简写。 U：会恢复一整行原先的面貌，即最原始的样子。 Y：相当于yy，不同于D与C的操作方法。 .：重复上一个命令。 除了O/o，插入命令(A,a,I,i)接受数值参数，如：5Ihello，然后按ESE键。会在行首输入5个连接的hello nr:替换后面n个字符。 nJ:合并下面的n行（从本行算起）。 ynl:向后复制n个字符。 e/E:到单词的结尾。 滚动整屏： ^f：向前（下）一整屏 ^b：向后（上）一整屏 ^d：向前（下）一半屏 ^u：向后（上）一半屏 z,Enter：将光标所在行移动到屏幕顶部（同于zz) z.：将光标所在行移动到屏幕中间 z-：将光标所在行移动到屏幕尾部 nz,Enter：将第n行移动到屏幕顶部，同样的，z. 与 z- 前也可以加数字。 在屏幕中移动： H、M、L分别移动到屏幕的顶部、中间和尾部。 nH、nL 移动到距离屏幕顶部和顶部n行的位置。 Enter：到下一行的第一个字符。 +：到下一行的第一个字符。 -：到上一行的第一个字符。 n|：移动到当前行的第n列 e：移到单词的结尾 E：移到单词的结尾（忽略标点符号） ( ) { } [[ ]] 这几个对编程作用不大，可忽略。 d/it：向后删除到it之前的位置（不删it）。 d?it：向前删除到it之前的位置（删除it）。 fx:本行中向右搜索x，光标置于x上。 Fx:向左搜索。; 重复上一个搜索命令，方向相同。 ,重复上一个搜索命令，方向相反。 tx:同fx，只是光标置于x之前。 Tx类似。 dfi：向右删除第一个i的位置（包括i) dti：同dfi，只是不包括i Ctrl+G 查看当前行信息 nG跳转后，可使用``回到上一次的位置，’’功能一样，不过只是回到前次位置所在行的开头，而不是确定的位置上。 删除包含keyword字符串的行： :g/keyword/d 删除空行：:%s/^\\n$//g i a/A o/O r + ?替换 0:文件当前行的开头 $:文件当前行的末尾 G:文件的最后一行开头 1 + G到第一行 9 + G到第九行 = :9 dd:删除一行 3dd：删除3行 yy:复制一行 3yy:复制3行 p:粘贴 u:undo ctrl + r:redo “a剪切板a “b剪切板b “ap粘贴剪切板a的内容 每次进入vi就有行号 vi ~/.vimrc set nu :w a.txt另存为 :w &gt;&gt; a.txt内容追加到a.txt :e!恢复到最初状态 :1,$s/hadoop/root/g 将第一行到追后一行的hadoop替换为root :1,$s/hadoop/root/c 将第一行到追后一行的hadoop替换为root(有提示)]]></content>
      <categories>
        <category>Big Data</category>
        <category>CentOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强大的vim快捷键大全]]></title>
    <url>%2Fpost%2Fa9a3267.html</url>
    <content type="text"><![CDATA[1、vim ~/.vimrc 进入配置文件如果不知道vimrc文件在哪，可使用 :scriptnames 来查看set nu #行号set tabstop=4 #一个tab为4个空格长度set ai #设置自动缩进syntax on #高亮 2、基本空格键 向右移动一格x 删除后面的字符 X 删除前一个字符 删除3个字符就是3xdd:删除一行 D 删除到行尾caw:改写单词 c 相当于 d 变为编辑模式J:删除换行符，使下一行并上来。 nJ:连接后面的n行u:撤销上一次操作 U:撤销当前行的所有修改ctrl+r:对撤消的撤消i 在光标前插入I 在行首插入a 在光标后插入A 在行末插入o:在当前行的下面另起一行，并变为插入模式O：在当前行上面另起一行，变为插入模式Ctrl+o:临时变成命令模式（一次而已）：e!:放弃更改，然后相当于重新打开：help:帮助，可用ZZ退出帮助窗口vim中Nyy可以复制光标后的N行。有时我们不容易得出行数，这时可以用做标记的方法来制定复制范围： 在开始行上输入ma作一个标记a 移动到结束行，输入y’a会复制当前行到标记a之间的文本。d’a会删除。或者是v进入可视模式，再13G跳转到相应行，y即可。:10,20y 回车即可，相应的删除也是如此 :10,20d （此方法比上面两种方法更简单）:10,20 m 30 把10行到20行的内容，剪切到30行之后:10,20 co 30 把10行到20行的内容，复制到30行之后将光标放在 { 处，然后输入v%就可以把大括号中内容选定如果光标放在第一个s上，想删除到“(”为止，则输入dt(就可以了，t(的作用是跳到下一个”(“前。ctrl +n 自动补全 ctrl + p 也一样:ab hw hello world 用一个缩写字符串代替一个长的字符串，此处用 hw 代替 hello world%: 移动到与制匹配的括号上去（），{}，[]，&lt;&gt;等‘ 移动到上一次的修改行fx 向右跳到本行字符x处（x可以是任何字符）Fx 向左跳到本行字符x处（x可以是任何字符）tx 和fx相同，区别是跳到字符x前Tx 和Fx相同，区别是跳到字符x后 到与当前单词相同的上一个单词上， 到与当前单词相同的下一个单词上如果你要重复键入一个短语或一个句子, 也有一种快捷的方法。Vim有一种记录宏的机制。你键入”qa”开始把一段宏记录入寄存器变量’a’中。按下来你可以象平常一样键入你要的操作, 只是这些操作都会被Vim记录进它命名为’a’的宏中, 再次再下”q”键, 就结束了宏’a’的录制。当你要重复执行你刚才记录的那些操作时只要使用”@a”命令。共有26个可用的寄存器供你记录宏。 使用宏你可以重复多个不同的操作。而不仅仅是插入文本了。如果你要进行某种重复的操作, 记着要用这一招呀。:abbr hte the:abbr hw Hello World输入先面的单词时，自动用后面的替换。 3、移动：b、3b、w、3w:向前\后移动几个单词，标点也算一个单词。相应的大写状态为不含标点，即只把空格和换行符作为单词间隔符。$：移动到行尾 3$：移动到3行后的行尾^:移动到行首，0也是+：移到下一行的行首-： 移到上一行的行首f:搜索命令，小写时向后搜索（用来定位）如 fx：定位到下一个x上。 Fx：定位到上一个x上，重复时，可用;或, 不过 , 表示反方向%：跳到相对应的括号上，编程时常用33G：跳转到33行 此时按``可以返回到原来行gg:文件头 G： 文件尾30%：跳转到文件的30%处“H”意为Home, “M”为Middle, “L”为Last. 当前屏幕的上中下位置，大小写皆可Ctrl+G:显示当前位置set number:设置显示行号，set nonumber:关闭显示:set ruler 设置在窗口右下角显示行号，与上面的好处是，节省空间ctrl+u\d 向上\下滚动半屏ctrl+e\y 向上\下滚动一行ctrl+b\f 向上\下滚动一屏 这个比较实用，记住。zz:将当前行滚动于屏幕中间，方便查看上下文 zt置顶，zb置尾/string 查找string，回车后，按n键可以跳到下一个，N上一个，另外按/键后，按上下键可以找到以前查找的记录，同样的 ：也有记录?/string 同上，默认向上查找:set ignorecase 大小写无关:set noignorecase 大小写敏感 ：查找下一个光标所在单词 #是查找上一个:set hlsearch 高亮显示查找结果:set nohlsearch 取消高亮:nohlsearch 去掉当前显示的高完（一次性）`` 上次光标停靠的行% 匹配到相应括号处 向右移动本行一段距离 &lt;&lt; 向左移动本行一段距离 3&lt;&lt; 把下面3行（包括本行），向左移动一段距离 :20,30&gt;&gt; 把20行到30行向右移动一段距离 4、小幅改动：:%s/str1/str2/g 替换每一行的 str1为 str2:10,20s/str1/str2/g 替换从行10到行20之间的 str1为 str2:10,$s/str1/str2/g 替换从行10到最后一行之间的 str1为 str2:s/str1/str2/g 替换当前行的 str1为 str2. 重复执行命令:10,$ w test2.cpp 取行10到最后一行内容，保存到test2.cpp:r class/User.hpp 读取文件中的内容，插入到当前行的后面dw:删除一个单词（光标后部分） 不如：daw实用 d4w：删除4个单词 d$:删除当前光标到行尾 d^：删除当前光标至行首 d换成c效果是一样的，只是操作完会变成insert模式 dnw： 删除N个单词 dnj: 向下删除n行 dnk: 向上删除n行X：删除左边的字符，相当于&lt;-键，x删除当前字符 D:相当于d$ C:相当于c$ s:相当于c1 S:相当于ccr:替换当前字符，但不会进入insert模式 3r:把后面3个字符替换掉 R：替换模式.:重复上一次操作v：进入Visual模式 V:进入可视行模式，比如 Vjjd 删除3行 Ctrl+v：可视块模式P：粘贴至光标前 p：粘贴至光标后 3P：粘贴3次 “2p 粘贴最后第二次的删除的内容yy:复制一行 yaw： 复制一个单词,光标在单词任意位置 ynw： 复制N个单词 ynj: 向下复制n行 ynk: 向上复制n行自动缩进：:set cindent(所有的set都可以简写为se,虽然只节省了一个字符, 译者注) 需要注意的是cindent控制缩进量是通过shiftwidth选项的值, 而不是通过tabstop 的值, shiftwidth的默认值是8(也就是说, 一个缩进为8个空格, 译者注), 要改变默认的设置, 可以使用”:set shiftwidth=x”命令, 其中x是你希望一个缩进量代表的空格的数目.{ = 到前一个空行上} = 到下一个空行上 5、VIM的一些插件：c.vim :如果是用root账号的，把文件复制到/usr/share/vim/vim70中解压没有用的，不存在 $HOME/.vim 这个目录，没办法，只能新建个目录，然后把压缩包cp到这个目录，再unzip即可。在 ~/.vimrc 中 写入 filetype plugin on :e! 返回上次保存后的状态Ctrl+z:暂停vi,回到Unix提示符，再输入fg即可回到vi。^回到行首，光标位于行首字母处；0回到行首，光标位于行首字母前。$回到行尾，光标位于行尾字母处。nb:向前移动n个单词，nw：向后移动n个单词。光标位于单词的第一个字母处。 nw这个操作很慢，不知何故。 以空格、标点符号与单词的分界为分隔符。（几个连续的标点视为一个单词）同样的，也可以使用nB,nW，只是这里只使用空格做为分隔符。相换两个相邻字母的位置：x、ps:删除一个字符，并进入编辑模式。 S：删除一整行，进入编辑模式，相当于cc。 ns:删除后面n个字符，并进入编辑模式。~:更改字母的大小写，同时光标进入到下一个字符。 n~:把后面n个字母的大小写状态改变。dw:删除单词后面部分 db：删除单词前面部分。 如果要删除整个单词(光标位于单词中间的话)，可以 dbw\wdbde:类似于dw,删除单词后面的部分（只删除到本单词结尾，dw会删除掉单词后面的空格） dE:删除的范围包括标号在内的单词结尾。e:相当于w，向后移动一个单词。不同的是，w移动到单词第一个字符上，e移动到单词最后一个字符上。 所以ea,可以给本单词追加内容。D：d$ 的简写，同样的，C：c$的简写。U：会恢复一整行原先的面貌，即最原始的样子。Y：相当于yy，不同于D与C的操作方法。.：重复上一个命令。除了O/o，插入命令(A,a,I,i)接受数值参数，如：5Ihello，然后按ESE键。会在行首输入5个连接的hellonr:替换后面n个字符。nJ:合并下面的n行（从本行算起）。ynl:向后复制n个字符。e/E:到单词的结尾。 滚动整屏：^f：向前（下）一整屏^b：向后（上）一整屏^d：向前（下）一半屏^u：向后（上）一半屏z,Enter：将光标所在行移动到屏幕顶部（同于zz)z.：将光标所在行移动到屏幕中间z-：将光标所在行移动到屏幕尾部nz,Enter：将第n行移动到屏幕顶部，同样的，z. 与 z- 前也可以加数字。 在屏幕中移动：H、M、L分别移动到屏幕的顶部、中间和尾部。nH、nL 移动到距离屏幕顶部和顶部n行的位置。 Enter：到下一行的第一个字符。+：到下一行的第一个字符。-：到上一行的第一个字符。n|：移动到当前行的第n列e：移到单词的结尾E：移到单词的结尾（忽略标点符号）( ) { } [[ ]] 这几个对编程作用不大，可忽略。d/it：向后删除到it之前的位置（不删it）。 d?it：向前删除到it之前的位置（删除it）。 fx:本行中向右搜索x，光标置于x上。 Fx:向左搜索。; 重复上一个搜索命令，方向相同。 ,重复上一个搜索命令，方向相反。tx:同fx，只是光标置于x之前。 Tx类似。dfi：向右删除第一个i的位置（包括i) dti：同dfi，只是不包括iCtrl+G 查看当前行信息nG跳转后，可使用``回到上一次的位置，’’功能一样，不过只是回到前次位置所在行的开头，而不是确定的位置上。 删除包含keyword字符串的行： :g/keyword/d删除空行：:%s/^\n$//g ia/Ao/Or + ?替换0:文件当前行的开头$:文件当前行的末尾G:文件的最后一行开头1 + G到第一行9 + G到第九行 = :9dd:删除一行3dd：删除3行yy:复制一行3yy:复制3行p:粘贴u:undoctrl + r:redo“a剪切板a“b剪切板b“ap粘贴剪切板a的内容每次进入vi就有行号vi ~/.vimrcset nu:w a.txt另存为:w &gt;&gt; a.txt内容追加到a.txt:e!恢复到最初状态:1,$s/hadoop/root/g 将第一行到追后一行的hadoop替换为root:1,$s/hadoop/root/c 将第一行到追后一行的hadoop替换为root(有提示)]]></content>
      <categories>
        <category>Big Data</category>
        <category>CentOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day06_BigData渐进学习_aclear_fire]]></title>
    <url>%2Fpost%2Ff4308eec.html</url>
    <content type="text"><![CDATA[—-关于hadoop.apache.org 官方事务的使用分析： common一般是放置一些公共可供使用和下载的框架等。 Ambari 图形化的hadoop安装版本。商业化做一下cdh 一个商业化、方便操作的hadoop版本。 Spark 广义 hadoop.apache.org 2.2.0 是在2015-2016年比较多人用的。 开发的时候，数据分析 只需要我们进行嵌入的一部分用户的API即可。所以官网的API http://hadoop.apache.org/docs/r2.6.5/api/index.html 接口是很多doc但建起来的 知道用户接口，把需要的业务逻辑嵌入进去就好。 但是底部的 configuration——表示里面的配置参数，因为数据分析一点API加许多的配置参数进行处理的。但是好在 大部分的值用默认的惨呼就好，用的过程中会说，但是参数配置大全——用的的时候再拿来用即可。 —-典型的推荐系统架构，应用的实时计算——看下当时讲的架构图即可 添加一：kafka？ 进行实时处理统计当前的最新动态. 添加二：&lt;有些东西只是sql统计不出来，所以要用 深度学习，mahout&lt;根据算法得到的结果，也是得到一些协同过滤算法得到的结果&gt;&gt;sql-&gt;HIVE仓库； 另一个通过mahout-&gt;协同算法得推荐数据。 综上 都要到，推荐原料中，成立为一个表。 [caption id=”attachment_1107” align=”aligncenter” width=”1422”] 推荐系统架构+实时操作[/caption] —-Hadoop集群框架搭建 hdfs:name nodename datanode datanode datanode … yarn: resourcenode nodemanager nodemanage15r nodemanager …. —-注意hadoop编译，由于hadoop包&lt;原本应该是跨平台的&gt;下载下来之后还需要，利用对应平台的解压缩命令还有maven tar c java编译库都要和操作系统的存在形式是一样的。 注意：如果只是小小的想要使用 servlet，给hadoop一个内置的netty即可。 PS.:file:// hdfs:// 注意哦统一资源定位符，对应的协议。 —-关于官网下载的hadoop源码包，因为官网下载下来的都是源码包。 然而hadoop是maven的项目，所以需要在maven上进行下载相应的包、并编译， 利用ant进行打包。 注意：官网上面有：hadoop.src.tar.gz① hadoop.tar.gz② 其中①是源码包用于进行图片中“hadoop编译.docx”进行tar.gz编译 share/hadoop/hdfs share下方是jar包 ---eclipse上面导入jar包需要导入：share/hadoop/hdfs common、hdfs下面的：jar+lib当中的jar到一个新建的eclipse项目中去。——完成就是hdfs的jar包了。 1.以上hdfs的一些在eclipse上通过hdfs api运行的类似于客户端的操作——称之为HDFS应用开发篇。 _hdfs在生产应用中主要是客户端的开发，其核心步骤是从hdfs提供的api中构造一个HDFS的访问客户端对象，然后通过该客户端对象操作（增删改查）HDFS__上的文件_ 详情见：7.HDFS的java操作。 以上是通过centos当做服务器（所以你会看到，有protobuf当做序列化工具）； windows上eclipse做为客户端调用api学习使用的客户端。（我们当前就是使用的这样一种开发学习方式。） 2.window下开发的说明建议在linux下进行hadoop应用的开发，不会存在兼容性问题。如在window上做客户端应用开发，需要设置以下环境：·在windows的某个目录下解压一个hadoop的安装包·将安装包下的lib和bin目录用对应windows版本平台编译的本地库替换·在window系统中配置HADOOP_HOME指向你解压的安装包·在windows系统的path变量中加入hadoop的bin目录（注意，也就是最近一张图片中windows7编译出来的zip包中bin/lib替换安装包中的bin/lib即可！） （注意：我们设置HADOOP_HOME+path + windows10编译出来的 bin+lib 替换掉挂网的东西） /** * * 客户端去操作hdfs时，是有一个用户身份的 * 默认情况下，hdfs客户端api会从jvm中获取一个参数来作为自己的用户身份：-DHADOOP_USER_NAME=hadoop * * 也可以在构造客户端fs对象时，通过参数传递进去 * @author /public class HdfsClientDemo { FileSystem fs = null; Configuration conf = null; @Before public void init() throws Exception{ conf = new Configuration(); conf.set(“fs.defaultFS”,”hdfs://aclear1:9000”); //这个是本地的对象 fs = FileSystem.get(conf);// fs = FileSystem.get(new URI(“hdfs://aclear1:9000”), conf,”hadoop”); //拿到一个文件系统操作的客户端实例对象 /*fs = FileSystem.get(conf);*/ //可以直接传入 uri和用户身份 } @Test public void testUpload() throws Exception { fs.copyFromLocalFile(new Path(“H:/access.log”), new Path(“/accessFromLocal.log.copy”)); fs.close();// Thread.sleep(2000);// fs.copyFromLocalFile(new Path(“G:/access.log”), new Path(“/access.log.copy”));// fs.close(); } @Test public void testDownload() throws Exception { fs.copyToLocalFile(new Path(“/access.log.copy”), new Path(“d:/“)); fs.close(); }//注意环境问题是主要出在 bin的上面！！！//1.配置好 HADOOP_HOME//2.搞好 bin lib就好了。（即平台相关性的替换，用在windows上的相关库！相关exe！）//综上所述：解决空格问题一共有两种办法，一个是想办法在环境变量设置的时候用特殊字符给他替换掉，另外一个就//是在写代码的时候 用双引号给有空格的路径给它引起来就OK了 //目录”program files”同时还拥有一个8.3规范的”PROGRA~1”短名称； 目录 课程大纲（HADOOP快速入门）…………………………………………………………………………… 2 HADOOP 快速入门………………………………………………………………………………………….. 3 什么是HADOOP…………………………………………………………………………………………… 3 HADOOP产生背景……………………………………………………………………………………….. 3 HADOOP在大数据、云计算中的位置和关系……………………………………………………… 3 国内外HADOOP应用案例介绍……………………………………………………………………….. 4 国内HADOOP的就业情况分析……………………………………………………………………….. 5 HADOOP生态圈以及各组成部分的简介……………………………………………………………. 6 分布式系统概述………………………………………………………………………………………….. 6 HIVE快速入门………………………………………………………………………………………………… 7 2.1 Hive基本介绍…………………………………………………………………………………………. 7 2.2 Hive的基本使用……………………………………………………………………………………… 8 2.3 数据仓库基本知识………………………………………………………………………………….. 9 数据分析案列演示………………………………………………………………………………………… 10 3.1 需求分析…………………………………………………………………………………………….. 10 3.1.1案例名称…………………………………………………………………………………….. 10 3.1.2 案例需求描述……………………………………………………………………………… 10 3.1.3 web点击流日志的数据格式……………………………………………………………. 10 3.1.4 分析指标……………………………………………………………………………………. 11 3.1.5 统计结果数据可视化…………………………………………………………………….. 11 3.2 数据来源分析………………………………………………………………………………………. 12 3.2.1 企业中获取数据的几种方式…………………………………………………………… 12 3.2.2 数据采集……………………………………………………………………………………. 12 3.3 数据处理流程………………………………………………………………………………………. 13 数据预处理/加载入库…………………………………………………………………………… 13 使用Hive做数据ETL…………………………………………………………………………….. 14 使用Hive运算业务指标………………………………………………………………………… 16 将结果数据导出到mysql（sqoop）…………………………………………………………. 17 结果展现——数据可视化………………………………………………………………………. 17 集群搭建…………………………………………………………………………………………………….. 18 4.1 HADOOP集群搭建…………………………………………………………………………………. 18 4.1.1集群简介：………………………………………………………………………………….. 18 4.1.2服务器准备………………………………………………………………………………….. 18 4.1.3网络环境准备………………………………………………………………………………. 18 4.1.4服务器系统设置……………………………………………………………………………. 18 4.1.5 Jdk环境安装………………………………………………………………………………… 19 4.1.6 HADOOP安装部署…………………………………………………………………………. 19 4.1.7 启动集群……………………………………………………………………………………. 21 4.1.8 测试………………………………………………………………………………………….. 21 4.2 Hive搭建……………………………………………………………………………………………… 22 Hive的配置安装………………………………………………………………………………….. 22 Hive的使用………………………………………………………………………………………… 23 Hive运行测试……………………………………………………………………………………… 23 课程大纲（HADOOP快速入门）HADOOP快速入门 HADOOP快速入门 HADOOP产生背景 HADOOP在大数据、云计算中的位置和关系 国内外HADOOP应用案例介绍 国内HADOOP的就业情况分析及课程大纲介绍 分布式系统概述 HADOOP生态圈以及各组成部分的简介 Hive快速入门 Hive快速入门 Hive基本介绍 Hive的使用 数据仓库基本知识 数据分析案例演示 需求分析 案列：定义需求、介绍数据格式 数据获取 企业中获取数据的几种方式 将文件直接导入到数据仓库 将数据库的数据导入到数据仓库（sqoop） 数据处理 使用Hive对数进行清洗（ETL的过程） 数据计算 使用Hive对数据进行计算 数据展现 将结果数据导出到mysql（sqoop） 学习目标： 第一天接触具体的大数据框架，总目标是让学习者建立起大数据和分布式的宏观概念 1、理解hadoop是什么，用于做什么，大体上怎么用 2、理解hive是什么，用于做什么，大体上怎么用 3、通过一个案例的演示说明，理解数据挖掘系统的基本流程和结构 1. HADOOP背景介绍1.1 什么是HADOOP HADOOP是apache旗下的一套开源软件平台 HADOOP提供的功能：利用服务器集群，根据用户的自定义业务逻辑，对海量数据进行分布式处理 HADOOP的核心组件有 HDFS（分布式文件系统） YARN（运算资源调度系统） MAPREDUCE（分布式运算编程框架） 广义上来说，HADOOP通常是指一个更广泛的概念——HADOOP生态圈 1.2 HADOOP产生背景 HADOOP最早起源于Nutch。Nutch的设计目标是构建一个大型的全网搜索引擎，包括网页抓取、索引、查询等功能，但随着抓取网页数量的增加，遇到了严重的可扩展性问题——如何解决数十亿网页的存储和索引问题。 2003年、2004年谷歌发表的两篇论文为该问题提供了可行的解决方案。 ——分布式文件系统（GFS），可用于处理海量网页的存储 ——分布式计算框架MAPREDUCE，可用于处理海量网页的索引计算问题。 Nutch的开发人员完成了相应的开源实现**HDFS**和MAPREDUCE，并从Nutch中剥离成为独立项目HADOOP，到2008年1月，HADOOP成为Apache顶级项目，迎来了它的快速发展期。 1.3 HADOOP在大数据、云计算中的位置和关系 云计算是分布式计算、并行计算、网格计算、多核计算、网络存储、虚拟化、负载均衡等传统计算机技术和互联网技术融合发展的产物。借助IaaS(基础设施即服务)、PaaS(平台即服务)、SaaS（软件即服务）等业务模式，把强大的计算能力提供给终端用户。 现阶段，云计算的两大底层支撑技术为“虚拟化”和“大数据技术” 而HADOOP则是云计算的PaaS层的解决方案之一，并不等同于PaaS，更不等同于云计算本身。 1.4 国内外HADOOP应用案例介绍1**、HADOOP**应用于数据服务基础平台建设 2/HADOOP**用于用户画像 3、HADOOP用于网站点击流日志数据挖掘** 1.5 国内HADOOP的就业情况分析 HADOOP就业整体情况 大数据产业已纳入国家十三五规划 各大城市都在进行智慧城市项目建设，而智慧城市的根基就是大数据综合平台 互联网时代数据的种类，增长都呈现爆发式增长，各行业对数据的价值日益重视 相对于传统JAVAEE技术领域来说，大数据领域的人才相对稀缺 随着现代社会的发展，数据处理和数据挖掘的重要性只会增不会减，因此，大数据技术是一个尚在蓬勃发展且具有长远前景的领域 HADOOP就业职位要求 大数据是个复合专业，包括应用开发、软件平台、算法、数据挖掘等，因此，大数据技术领域的就业选择是多样的，但就HADOOP而言，通常都需要具备以下技能或知识： HADOOP分布式集群的平台搭建 HADOOP分布式文件系统HDFS的原理理解及使用 HADOOP分布式运算框架MAPREDUCE的原理理解及编程 Hive数据仓库工具的熟练应用 Flume、sqoop、oozie等辅助工具的熟练使用 Shell/python等脚本语言的开发能力 HADOOP相关职位的薪资水平 大数据技术或具体到HADOOP的就业需求目前主要集中在北上广深一线城市，薪资待遇普遍高于传统**JAVAEE**开发人员，以北京为例： 1.6 HADOOP生态圈以及各组成部分的简介各组件简介 重点组件： HDFS：分布式文件系统 MAPREDUCE：分布式运算程序开发框架 HIVE：基于大数据技术（文件系统+运算框架）的SQL数据仓库工具 HBASE：基于HADOOP的分布式海量数据库 ZOOKEEPER**：分布式协调服务基础组件** Mahout：基于mapreduce/spark/flink等分布式运算框架的机器学习算法库 Oozie：工作流调度框架 Sqoop：数据导入导出工具 Flume：日志数据采集框架 2 分布式系统概述_注：由于大数据技术领域的各类技术框架基本上都是分布式系统，因此，理解hadoop、storm、spark__等技术框架，都需要具备基本的分布式系统概念_ 2.1 分布式软件系统(Distributed Software Systems) 该软件系统会划分成多个子系统或模块，各自运行在不同的机器上，子系统或模块之间通过网络通信进行协作，实现最终的整体功能 比如分布式操作系统、分布式程序设计语言及其编译(解释)系统、分布式文件系统和分布式数据库系统等。 2.2 分布式软件系统举例：solrcloud 一个solrcloud集群通常有多台solr服务器 每一个solr服务器节点负责存储整个索引库的若干个shard（数据分片） 每一个shard又有多台服务器存放若干个副本互为主备用 索引的建立和查询会在整个集群的各个节点上并发执行 solrcloud集群作为整体对外服务，而其内部细节可对客户端透明 总结：利用多个节点共同协作完成一项或多项具体业务功能的系统就是分布式系统。 2.3 分布式应用系统模拟开发需求：可以实现由主节点将运算任务发往从节点，并将各从节点上的任务启动； 程序清单： AppMaster AppSlave/APPSlaveThread Task 程序运行逻辑流程： 3. 离线数据分析流程介绍_注：本环节主要感受数据分析系统的宏观概念及处理流程，初步理解hadoop__等框架在其中的应用环节，不用过于关注代码细节_ 一个应用广泛的数据分析系统：“web日志数据挖掘” 3.1 需求分析3.1.1 案例名称“网站或。 3.1.2 案例需求描述“Web点击流日志”包含着网站运营很重要的信息，通过日志分析，我们可以知道网站的访问量，哪个网页访问人数最多，哪个网页最有价值，广告转化率、访客的来源信息，访客的终端信息等。 3.1.3 数据来源本案例的数据主要由用户的点击行为记录 获取方式：在页面预埋一段js程序，为页面上想要监听的标签绑定事件，只要用户点击或移动到标签，即可触发ajax请求到后台servlet程序，用log4j记录下事件信息，从而在web服务器（nginx、tomcat等）上形成不断增长的日志文件。 形如： 58.215.204.118 - - [18/Sep/2013:06:51:35 +0000] “GET /wp-includes/js/jquery/jquery.js?ver=1.10.2 HTTP/1.1” 304 0 “http://blog.fens.me/nodejs-socketio-chat/“ “Mozilla/5.0 (Windows NT 5.1; rv:23.0) Gecko/20100101 Firefox/23.0” 3.2 数据处理流程3.2.1 流程图解析本案例跟典型的BI系统极其类似，整体流程如下： 但是，由于本案例的前提是处理海量数据，因而，流程中各环节所使用的技术则跟传统BI完全不同，后续课程都会一一讲解： 数据采集：定制开发采集程序，或使用开源框架FLUME 数据预处理：定制开发mapreduce程序运行于hadoop集群 数据仓库技术：基于hadoop之上的Hive 数据导出：基于hadoop的sqoop数据导入导出工具 数据可视化：定制开发web程序或使用kettle等产品 整个过程的流程调度：hadoop生态圈中的oozie工具或其他类似开源产品 3.2.2 项目技术架构图3.2.3 项目相关截图（感性认识，欣赏即可） Mapreudce程序运行 在Hive中查询数据 将统计结果导入mysql ./sqoop export —connect jdbc:mysql://localhost:3306/weblogdb —username root —password root —table t_display_xx —export-dir /user/hive/warehouse/uv/dt=2014-08-03 3.3 项目最终效果经过完整的数据处理流程后，会周期性输出各类统计指标的报表，在生产实践中，最终需要将这些报表数据以可视化的形式展现出来，本案例采用web程序来实现数据可视化 效果如下所示： 4. 集群搭建4.1 HADOOP集群搭建4.1.1集群简介HADOOP集群具体来说包含两个集群：HDFS集群和YARN集群，两者逻辑上分离，但物理上常在一起 HDFS集群： 负责海量数据的存储，集群中的角色主要有 NameNode / DataNode YARN集群： 负责海量数据运算时的资源调度，集群中的角色主要有 ResourceManager /NodeManager _(那mapreduce是什么呢？它其实是一个应用程序开发包)_ 本集群搭建案例，以5节点为例进行搭建，角色分配如下： hdp-node-01 NameNode SecondaryNameNode hdp-node-02 ResourceManager hdp-node-03 DataNode NodeManager hdp-node-04 DataNode NodeManager hdp-node-05 DataNode NodeManager 部署图如下： 4.1.2服务器准备本案例使用虚拟机服务器来搭建HADOOP集群，所用软件及版本： Vmware 11.0 Centos 5 64bit 4.1.3网络环境准备 采用NAT方式联网 网关地址：168.33.1 3个服务器节点IP地址：168.33.101、192.168.33.102、192.168.33.103 子网掩码：255.255.0 4.1.4服务器系统设置 添加HADOOP用户 为HADOOP用户分配sudoer权限 同步时间 设置主机名 hdp-node-01 hdp-node-02 hdp-node-03 配置内网域名映射： 168.33.101 hdp-node-01 168.33.102 hdp-node-02 168.33.103 hdp-node-03 配置ssh免密登陆 配置防火墙 4.1.5 Jdk环境安装 上传jdk安装包 规划安装目录 /home/hadoop/apps/jdk_1.7.65 解压安装包 配置环境变量 /etc/profile 4.1.6 HADOOP安装部署 上传HADOOP安装包 规划安装目录 /home/hadoop/apps/hadoop-2.6.1 解压安装包 修改配置文件 $HADOOP_HOME/etc/hadoop/ 1最简化配置如下： vi hadoop-env.sh # The java implementation to use. export JAVA_HOME=/home/hadoop/apps/jdk1.7.0_51 vi core-site.xml fs.defaultFS hdfs://aclear1:9000 hadoop.tmp.dir /home/Hadoop/hdpdata vi hdfs-site.xml dfs.replication 2 dfs.secondary.http.address hdp-node-01:50090 &lt;/configuration&gt; vi mapred-site.xml mapreduce.framework.name yarn vi yarn-site.xml yarn.resourcemanager.hostname aclear1 yarn.nodemanager.aux-services mapreduce_shuffle 对应放置在 2 3 4上 所以我们 由以上的配置得出一个问题&lt;在此之前先配置下面的东西&gt;： Namenode 以及 resourcemanager 都已经出现了。对应的集群子服务器并没有出现：所以 其实aclear1 我们已经写死。其它的子服务器会按照目前启动的服务器自行装载： Aclear1通过： Hadoop-daemon.sh start namenode //启动namenode服务器 //注意 jetty是在 50070&lt;端口有个网页可以看到对应服务器配合的 情况有多少可用东西。&gt; JPS Aclear2通过： Hadoop-daemon.sh start datanode //启动当做datanode //原理： 因为hadoop的配置文件已经配置的完全一致了，所以可以相互握手 —-2HDFS进行格式化—- &lt;因为这个是建立在 Linux物理目录之上的，也就是说 HDFS是格式化建立一个逻辑文件层，分块 进行大型数据、文件集的处理&gt; Source /etc/profile 人机交互&lt;脚本执行进行实现&gt; 必须注意：学会使用.log日志 查找、发现错误： 问题：下面 vi /etc/Hadoop/salves //纯粹是给自动化启动脚本用的！——apps/Hadoop/../start-all.sh 注意这个是 aclear2 都必须是主机名称！ Aclear2 Aclear3 Aclear4 Start-dfs.sh //只在一个namenode 服务器去做即可 //别忘了配置hadoop用户的免密登录—— ssh-keygen -t rsa Ssh-copy-id aclear2 … P.S.：start-all.sh == start-dfs.sh &amp;&amp; start-yarn.sh //配置 secondary namenode //在hdfs— 注意： 深入理解，查看对应的 启动方式得知： Ssh aclear1 Hadoop-daemon.sh start namenode 对比：yarn-daemon.sh start resourcemanager 这样启动 //动态上线 动态下限：一台机器 三个副本：上方副本是：2 所以每个数据都是有2个副本！ //我们安装集群最常见问题： 权限不统一问题！——所以最好用sudo来进行权限的获取！！！ //配置文件少 或 写错文字 //日志文件会看到！ 对了 //ssh 免密登录没配好，然后连接超时 —— 没启动起来！ Unknown host——统统用主机名！不用IP！ 4.1.7 启动集群初始化HDFS 生成namenode初始目录，对应的账本、自己需要的框架结构 hadoop namenode -format 启动HDFS sbin/start-dfs.sh 启动YARN sbin/start-yarn.sh 测试：http://192.168.78.201:50090/status.html 这个放置在 hdfs-site里面可以自定义端口！ 4.1.8 测试1、上传文件到HDFS从本地上传一个文本文件到hdfs的/wordcount/input目录下 [HADOOP@hdp-node-01 ~]$ HADOOP fs -mkdir -p /wordcount/input //父类也可以创建出来 [HADOOP@hdp-node-01 ~]$ HADOOP fs -put /home/HADOOP/somewords.txt /wordcount/input 2、运行一个mapreduce程序在HADOOP安装目录下，运行一个示例mr程序 cd $HADOOP_HOME/share/hadoop/mapreduce/ hadoop jar mapredcue-example-2.6.1.jar wordcount /wordcount/input /wordcount/output //注意 第一个：hadoop jar 启动share文件夹当中，mapreduce的jar包的wordcount函数：两个参数：第一个是需要同级的文件夹在哪 第二个：需要输出结果到那里去并且不能存在 5 集群使用初步5.1 HDFS使用1、查看集群状态 命令： hdfs dfs admin –report 可以看出，集群共有3个datanode可用 也可打开web控制台查看HDFS集群信息，在浏览器打开http://hdp-node-01:50070/ 2、上传文件到HDFS 查看HDFS中的目录信息 命令： hadoop fs –ls / 上传文件 命令： hadoop fs -put ./ scala-2.10.6.tgz to / 从HDFS下载文件 命令： hadoop fs -get /yarn-site.xml //注意！：1.在环境变量中配置HADOOP_HOME 2.bin .和lib 替换为已经在win10用c编译好的bin 和 lib 5.2 MAPREDUCE使用mapreduce是hadoop中的分布式运算编程框架，只要按照其编程规范，只需要编写少量的业务逻辑代码即可实现一个强大的海量数据并发处理程序 5.2.1 Demo开发——wordcount1、需求 从大量（比如T级别）文本文件中，统计出每一个单词出现的总次数 2、mapreduce实现思路 Map阶段： 从HDFS的源数据文件中逐行读取数据 将每一行数据切分出单词 为每一个单词构造一个键值对(单词，1) 将键值对发送给reduce Reduce阶段： 接收map阶段输出的单词键值对 将相同单词的键值对汇聚成一组 对每一组，遍历组中的所有“值”，累加求和，即得到每一个单词的总次数 将(单词，总次数)输出到HDFS的文件中 具体编码实现 (1)定义一个mapper类 //首先要定义四个泛型的类型 //keyin: LongWritable valuein: Text //keyout: Text valueout:IntWritable public class WordCountMapper extends Mapper{ //map方法的生命周期： 框架每传一行数据就被调用一次 //key : 这一行的起始点在文件中的偏移量 //value: 这一行的内容 @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { //拿到一行数据转换为string String line = value.toString(); //将这一行切分出各个单词 String[] words = line.split(“ “); //遍历数组，输出&lt;单词，1&gt; for(String word:words){ context.write(new Text(word), new IntWritable(1)); } } } (2)定义一个reducer类 //生命周期：框架每传递进来一个kv 组，reduce方法被调用一次 @Override protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException { //定义一个计数器 int count = 0; //遍历这一组kv的所有v，累加到count中 for(IntWritable value:values){ count += value.get(); } context.write(key, new IntWritable(count)); } } (3)定义一个主类，用来描述job并提交job public class WordCountRunner { //把业务逻辑相关的信息（哪个是mapper，哪个是reducer，要处理的数据在哪里，输出的结果放哪里。。。。。。）描述成一个job对象 //把这个描述好的job提交给集群去运行 public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job wcjob = Job.getInstance(conf); //指定我这个job所在的jar包 // wcjob.setJar(“/home/hadoop/wordcount.jar”); wcjob.setJarByClass(WordCountRunner.class); wcjob.setMapperClass(WordCountMapper.class); wcjob.setReducerClass(WordCountReducer.class); //设置我们的业务逻辑Mapper类的输出key和value的数据类型 wcjob.setMapOutputKeyClass(Text.class); wcjob.setMapOutputValueClass(IntWritable.class); //设置我们的业务逻辑Reducer类的输出key和value的数据类型 wcjob.setOutputKeyClass(Text.class); wcjob.setOutputValueClass(IntWritable.class); //指定要处理的数据所在的位置 FileInputFormat.setInputPaths(wcjob, “hdfs://hdp-server01:9000/wordcount/data/big.txt”); //指定处理完成之后的结果所保存的位置 FileOutputFormat.setOutputPath(wcjob, new Path(“hdfs://hdp-server01:9000/wordcount/output/“)); //向yarn集群提交这个job boolean res = wcjob.waitForCompletion(true); System.exit(res?0:1); } 5.2.2 程序打包运行 将程序打包 准备输入数据 vi /home/hadoop/test.txt Hello tom Hello jim Hello ketty Hello world Ketty tom 在hdfs上创建输入数据文件夹： hadoop fs mkdir -p /wordcount/input 将words.txt上传到hdfs上 hadoop fs –put /home/hadoop/words.txt /wordcount/input 将程序jar包上传到集群的任意一台服务器上 使用命令启动执行wordcount程序jar包 $ hadoop jar wordcount.jar cn.itcast.bigdata.mrsimple.WordCountDriver /wordcount/input /wordcount/out 查看执行结果 $ hadoop fs –cat /wordcount/out/part-r-00000 HADOOP（hdfs、MAPREDUCE、yarn） 元老级大数据处理技术框架，擅长离线数据分析 Zookeeper 分布式协调服务基础组件 Hbase 分布式海量数据库，离线分析和在线业务通吃 Hive sql 数据仓库工具，使用方便，功能丰富，基于MR延迟大 Sqoop数据导入导出工具 Flume数据采集框架 一般中型的网站(10W的PV以上)，每天会产生1G以上Web日志文件。大型或超大型的网站，可能每小时就会产生10G的数据量。 具体来说，比如某电子商务网站，在线团购业务。每日PV数100w，独立IP数5w。用户通常在工作日上午10:00-12:00和下午15:00-18:00访问量最大。日间主要是通过PC端浏览器访问，休息日及夜间通过移动设备访问较多。网站搜索浏量占整个网站的80%，PC用户不足1%的用户会消费，移动用户有5%会消费。 对于日志的这种规模的数据，用HADOOP进行日志分析，是最适合不过的了。]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day05_BigData渐进学习_aclear_fire]]></title>
    <url>%2Fpost%2Faf273ff9.html</url>
    <content type="text"></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day04_BigData渐进学习_aclear_fire]]></title>
    <url>%2Fpost%2F99d5af0a.html</url>
    <content type="text"><![CDATA[JAVA多线程 JAVA并发包(java.util.concurrent) 并发编程总结 JAVA JMS技术&lt;这是一种规范.消息队列&gt; &lt;实现：ActiceMQ&gt; JAVA动态代理和反射 JVM技术——堆栈、垃圾回收 J2EE是种规范，Tomcat是种实现。 JAVA并发编程实践-cn.pdf 深入理解Java虚拟机—JVM高级特性与最佳实践（第2版）.pdf word详情笔记请见——印象笔记-BigData-Day’s NoteBook 第**4**天 java**高级特性增强** 今天内容安排： 1、掌握多线程 2、掌握并发包下的队列 3、了解JMS 4、掌握JVM技术 5、掌握反射和动态代理 java**多线程增强** java**多线程基本知识** 进程介绍 不管是我们开发的应用程序，还是我们运行的其他的应用程序，都需要先把程序安装在本地的硬盘上。然后找到这个程序的启动文件，启动程序的时候，其实是电脑把当前的这个程序加载到内存中，在内存中需要给当前的程序分配一段独立的运行空间。这片空间就专门负责当前这个程序的运行。 不同的应用程序运行的过程中都需要在内存中分配自己独立的运行空间，彼此之间不会相互的影响。我们把每个独立应用程序在内存的独立空间称为当前应用程序运行的一个进程。 进程：它是内存中的一段独立的空间，可以负责当前应用程序的运行。当前这个进程负责调度当前程序中的所有运行细节。 线程介绍 启动的QQ聊天软件，需要和多个人进行聊天。这时多个人之间是不能相互影响，但是它们都位于当前QQ这个软件运行时所分配的内存的独立空间中。 在一个进程中，每个独立的功能都需要独立的去运行，这时又需要把当前这个进程划分成多个运行区域，每个独立的小区域（小单元）称为一个线程。 线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。 进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。一个进程中至少应该有一个线程。 多线程介绍 现在的操作系统基本都是多用户，多任务的操作系统。每个任务就是一个进程。而在这个进程中就会有线程。 真正可以完成程序运行和功能的实现靠的是进程中的线程。 多线程：在一个进程中，我们同时开启多个线程，让多个线程同时去完成某些任务（功能）。 (比如后台服务系统，就可以用多个线程同时响应多个客户的请求) 多线程的目的：提高程序的运行效率。 多线程运行的原理 cpu在线程中做时间片的切换。 其实真正电脑中的程序的运行不是同时在运行的。CPU负责程序的运行，而CPU在运行程序的过程中某个时刻点上，它其实只能运行一个程序。而不是多个程序。而CPU它可以在多个程序之间进行高速的切换。而切换频率和速度太快，导致人的肉眼看不到。 每个程序就是进程， 而每个进程中会有多个线程，而CPU是在这些线程之间进行切换。 了解了CPU对一个任务的执行过程，我们就必须知道，多线程可以提高程序的运行效率，但不能无限制的开线程。 实现线程的两种方式 1、继承Thread的方式 见代码MyThreadWithExtends 2、声明实现 Runnable 接口的方式 见代码MyThreadWithImpliment java**同步关键词解释** synchronized 加同步格式： synchronized( 需要一个任意的对象（锁） ){ &lt;注意直接 写一个任意的对象即可.> 代码块中放操作共享数据的代码。 } 见代码MySynchronized synchronized的缺陷 synchronized是java中的一个关键字，也就是说是Java语言内置的特性。 如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况： 1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有； 2）线程执行发生异常，此时JVM会让线程自动释放锁。 &lt;注意 线程是让JVM管理的.&gt; 例子1： 如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。 因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。 &lt;注意这是一个对象，就不是一个JAVA内置的 关键字特性了&gt; 例子2： 当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。 但是采用synchronized关键字来实现同步的话，就会导致一个问题： 如果多个线程都只是进行读操作，当一个线程在进行读操作时，其他线程只能等待无法进行读操作。 因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。 另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。 总的来说，也就是说Lock提供了比synchronized更多的功能。 2.2 lock lock和synchronized的区别 1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问； 2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。 util.concurrent.locks包下常用的类 Lock 首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口： public interface Lock { void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); } Lock接口中每个方法的使用： lock()、tryLock()、tryLock(long time, TimeUnit unit)、lockInterruptibly()是用来获取锁的。 unLock()方法是用来释放锁的。 四个获取锁方法的区别： lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。 由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。 tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。 tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。 lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。&lt;等待的人可以被中断&gt; 注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。 因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。 而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。 ReentrantLock 直接使用lock接口的话，我们需要实现很多方法，不太方便，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，ReentrantLock，意思是“可重入锁”。 以下是ReentrantLock的使用案例： 例子1，lock()的正确使用方法 见代码MyLockTest 例子2，tryLock()的使用方法 见代码MyTryLock 例子3，lockInterruptibly()响应中断的使用方法： 见代码MyInterruptibly ReadWriteLock ReadWriteLock也是一个接口，在它里面只定义了两个方法： public interface ReadWriteLock { / Returns the lock used for reading. @return the lock used for reading. / Lock readLock(); / Returns the lock used for writing. @return the lock used for writing. / Lock writeLock(); } 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。 如果拿到了writeLock的锁，其他人都不能操作了。 拿到了readLock的锁，其他人还可以进行read的操作。 ReentrantReadWriteLock ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。//这个就是一点具体实现 下面通过几个例子来看一下ReentrantReadWriteLock具体用法。 例子1：假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果 见代码MySynchronizedReadWrite 例子2：改成用读写锁的话： 见代码MyReentrantReadWriteLock 注意： 不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 Lock和synchronized的选择 1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； 2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）Lock可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 平常使用不能无限制的 添加线程——一上来就new 一个Thread() 只是runnable对象不一样。直接从线程池中找线程 添加上去Runnable即可。 java**并发包** java**并发包介绍** JDK5.0 以后的版本都引入了高级并发特性，大多数的特性在java.util.concurrent 包中，是专门用于多线程发编程的，充分利用了现代多处理器和多核心系统的功能以编写大规模并发应用程序。主要包含原子量**&lt;不优化，每次都拿真实地方&gt;**、并发集合、同步器、可重入锁，并对线程池的构造提供 保证构造的线程是同一个视图。 了强力的支持。 线程池 线程池的5中创建方式： Single Thread Executor : 只有一个线程的线程池，因此所有提交的任务是顺序执行， 代码： Executors.newSingleThreadExecutor() Cached Thread Pool : 线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，如果线程超过60秒内没执行，那么将被终止并从池中删除， 代码：Executors.newCachedThreadPool() //有一定的回收60s 会和搜房党阀。 Fixed Thread Pool : 拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待， 代码： Executors.newFixedThreadPool(4) 在构造函数中的参数4是线程池的大小，你可以随意设置，也可以和cpu的核数量保持一致，获取cpu的核数量int cpuNums = Runtime.getRuntime().availableProcessors(); Scheduled Thread Pool : 用来调度即将执行的任务的线程池，可能是 不是直接执行, 每隔多久执行一次… 策略型的 代码：Executors.newScheduledThreadPool() Single Thread Scheduled Pool : 只有一个线程，用来调度任务在指定时间执行，代码：newSingleThreadScheduledExecutor() 线程池的使用 提交 Runnable ，任务完成后 Future 对象返回 null 调用excute,提交任务, 匿名Runable重写run方法, run方法里是业务逻辑 见代码：ThreadPoolWithRunable 提交 Callable，该方法返回一个 Future 实例表示任务的状态 调用submit提交任务, 匿名Callable,重写call方法, 有返回值, 获取返回值会阻塞,一直要等到线程任务返回结果 见代码：ThreadPoolWithcallable /** * callable 跟runnable的区别： runnable的run方法不会有任何返回结果，所以主线程无法获得任务线程的返回值 callable的call方法可以返回结果，但是主线程在获取时是被阻塞，需要等待任务线程返回才能拿到结果 @author acanprince / public class ThreadPoolWithcallable { public static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService pool = Executors.newFixedThreadPool(4); for(int i = 0; i &lt; 10; i++){ Future submit = pool.submit(new Callable(){ @Override public String call() throws Exception { //System.out.println(“a”); Thread.sleep(5000); return “b—“+Thread.currentThread().getName(); } }); //从Future中get结果，这个方法是会被阻塞的，一直要等到线程任务返回结果 注意所以也会有一定的危险！反回不回来就 卡死！ System.out.println(submit.get()); } pool.shutdown(); } } 学习电商的 服务器并发性 就是需要进行以上的学习 理解！！！综合所学的这些部分！ java**并发包消息队列及在开源软件中的应用** BlockingQueue也是java.util.concurrent下的主要用来控制线程同步的工具。 主要的方法是：put、take一对阻塞存取；add、poll一对非阻塞存取。 插入: 1)add(anObject):把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则抛出异常,不好 2)offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false. 3)put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续, 有阻塞, 放不进去就等待 读取： 4)poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null; 取不到返回null 5)take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止; 阻塞, 取不到就一直等 其他 int remainingCapacity();返回队列剩余的容量，在队列插入和获取的时候，不要瞎搞，数 据可能不准, 不能保证数据的准确性 boolean remove(Object o); 从队列移除元素，如果存在，即移除一个或者更多，队列改 变了返回true public boolean contains(Object o); 查看队列是否存在这个元素，存在返回true int drainTo(Collection&lt;? super E&gt; c); //移除此队列中所有可用的元素,并将它们添加到给定 collection 中。取出放到集合中 int drainTo(Collection&lt;? super E&gt; c, int maxElements); 和上面方法的区别在于，指定了移 动的数量; 取出指定个数放到集合 BlockingQueue有四个具体的实现类,常用的两种实现类为： 1、ArrayBlockingQueue：一个由数组支持的有界阻塞队列，规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的。 2、LinkedBlockingQueue：大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的。 LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE,其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。 //即上面的也是有空间大小的。只是空间比较大 LinkedBlockingQueue和ArrayBlockingQueue区别： LinkedBlockingQueue和ArrayBlockingQueue比较起来,它们背后所用的数据结构不一样,导致LinkedBlockingQueue的数据吞吐量要大于ArrayBlockingQueue,但在线程数量很大时其性能的可预见性低于ArrayBlockingQueue. 当我们用流式的 storm框架的时候——会用到很多BlockingQueue！ 生产者消费者的示例代码： 见代码 java**并发编程的一些总结** 不应用线程池的缺点 有些开发者图省事，遇到需要多线程处理的地方，直接new Thread(…).start()，对于一般场景是没问题的，但如果是在并发请求很高的情况下，就会有些隐患： 新建线程的开销。线程虽然比进程要轻量许多，但对于JVM来说，新建一个线程的代价还是挺大的，决不同于新建一个对象 资源消耗量。没有一个池来限制线程的数量，会导致线程的数量直接取决于应用的并发量，这样有潜在的线程数据巨大的可能，那么资源消耗量将是巨大的 稳定性。当线程数量超过系统资源所能承受的程度，稳定性就会成问题 制定执行策略 在每个需要多线程处理的地方，不管并发量有多大，需要考虑线程的执行策略 任务以什么顺序执行 可以有多少个任务并发执行 可以有多少个任务进入等待执行队列 系统过载的时候，应该放弃哪些任务？如何通知到应用程序？ 一个任务的执行前后应该做什么处理 线程池的类型 不管是通过Executors创建线程池，还是通过Spring来管理，都得清楚知道有哪几种线程池： FixedThreadPool：定长线程池，提交任务时创建线程，直到池的最大容量，如果有线程非预期结束，会补充新线程 CachedThreadPool：可变线程池，它犹如一个弹簧，如果没有任务需求时，它回收空闲线程，如果需求增加，则按需增加线程，不对池的大小做限制 SingleThreadExecutor：单线程。处理不过来的任务会进入FIFO队列等待执行 SecheduledThreadPool：周期性线程池。支持执行周期性线程任务 其实，这些不同类型的线程池都是通过构建一个ThreadPoolExecutor来完成的，所不同的是corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory这么几个参数。具体可以参见JDK DOC。 线程池饱和策略 由以上线程池类型可知，除了CachedThreadPool其他线程池都有饱和的可能，当饱和以后就需要相应的策略处理请求线程的任务，比如，达到上限时通过ThreadPoolExecutor.setRejectedExecutionHandler方法设置一个拒绝任务的策略，JDK提供了AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy几种策略，具体差异可见JDK DOC 线程无依赖性 多线程任务设计上尽量使得各任务是独立无依赖的，所谓依赖性可两个方面： 线程之间的依赖性。如果线程有依赖可能会造成死锁或饥饿 调用者与线程的依赖性。调用者得监视线程的完成情况，影响可并发量 当然，在有些业务里确实需要一定的依赖性，比如调用者需要得到线程完成后结果，传统的Thread是不便完成的，因为run方法无返回值，只能通过一些共享的变量来传递结果，但在Executor框架里可以通过Future和Callable实现需要有返回值的任务，当然线程的异步性导致需要有相应机制来保证调用者能等待任务完成，关于Future和Callable的用法前文已讲解； java JMS**技术** 什么是**JMS** JMS即Java消息服务（Java Message Service）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。 JMS是一种与厂商无关的 API，用来访问消息收发系统消息。它类似于JDBC(Java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ，这只是几个例子。 JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JMS客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。根据有效负载的类型来划分，可以将消息分为几种类型，它们分别携带：简单文本(TextMessage)、可序列化的对象 (ObjectMessage)、属性集合 (MapMessage)、字节流 (BytesMessage)、原始值流 (StreamMessage)，还有无有效负载的消息 (Message)。 JMS**规范** 专业技术规范 JMS（Java Messaging Service）是Java平台上有关面向消息中间件(MOM)的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发，翻译为Java消息服务。 体系架构 JMS由以下元素组成。 JMS提供者provider：连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。 JMS客户：生产或消费基于消息的Java的应用程序或对象。 JMS生产者：创建并发送消息的JMS客户。 JMS消费者：接收消息的JMS客户。 JMS消息：包括可以在JMS客户之间传递的数据的对象 JMS队列：一个容纳那些被发送的等待阅读的消息的区域。与队列名字所暗示的意思不同，消息的接受顺序并不一定要与消息的发送顺序相同。一旦一个消息被阅读，该消息将被从队列中移走。 JMS主题：一种支持发送消息给多个订阅者的机制。 Java**消息服务应用程序结构支持两种模型** 点对点或队列模型 在点对点或队列模型下，一个生产者向一个特定的队列发布消息，一个消费者从该队列中读取消息。这里，生产者知道消费者的队列，并直接将消息发送到消费者的队列。 这种模式被概括为： 只有一个消费者将获得消息 生产者不需要在接收者消费该消息期间处于运行状态，接收者也同样不需要在消息发送时处于运行状态。 每一个成功处理的消息都由接收者签收 2、发布者/订阅者模型 发布者/订阅者模型支持向一个特定的消息主题发布消息。0或多个订阅者可能对接收来自特定消息主题的消息感兴趣。在这种模型下，发布者和订阅者彼此不知道对方。这种模式好比是匿名公告板。 这种模式被概括为： 多个消费者可以获得消息 在发布者和订阅者之间存在时间依赖性。发布者需要建立一个订阅（subscription），以便客户能够订阅。订阅者必须保持持续的活动状态以接收消息，除非订阅者建立了持久的订阅。在那种情况下，在订阅者未连接时发布的消息将在订阅者重新连接时重新发布。 ActiveMQ 应付下J2EE还是可以的。但是 如果我们需要 进行大数据开发，需要进行卡发卡使用。 代码演示 1.下载ActiveMQ 去官方网站下载：http://activemq.apache.org/ 2.运行ActiveMQ 解压缩apache-activemq-5.5.1-bin.zip， 修改配置文件activeMQ.xml，将0.0.0.0修改为localhost //注释 当前配置是，当前支持的通用协议的配置 然后双击apache-activemq-5.5.1\\bin\\activemq.bat运行ActiveMQ程序。 启动ActiveMQ以后，登陆：http://localhost:8161/admin/，创建一个Queue，命名为FirstQueue。 3.运行代码 常用的**JMS**实现 要使用Java消息服务，你必须要有一个JMS提供者，管理会话和队列。既有开源的提供者也有专有的提供者。 开源的提供者包括： Apache ActiveMQ JBoss 社区所研发的 HornetQ Joram Coridan的MantaRay The OpenJMS Group的OpenJMS 专有的提供者包括： BEA的BEA WebLogic Server JMS TIBCO Software的EMS GigaSpaces Technologies的GigaSpaces Softwired 2006的iBus IONA Technologies的IONA JMS SeeBeyond的IQManager（2005年8月被Sun Microsystems并购） webMethods的JMS+ - my-channels的Nirvana Sonic Software的SonicMQ SwiftMQ的SwiftMQ IBM的WebSphere MQ 生产者生产者把消息放到 消息池盒子当中&lt;一堆大数据出来的需要分析的数据&gt;，然后经由kafak消息中间件 进行消息存储： 消费者通过 提取kafak中的信息进行 处理&lt;1. 方便提取 方便 后者转赶上前者， 进行速度的缓冲， 也方便进行统一管理与 处理。 其它池子好进行提取。&gt; java**动态代理、反射** 反射 通过反射的方式可以获取class对象中的属性、方法、构造函数等，一下是实例： 类似于 通过对应包或类的字符串进行 响应对象中的class对象的提取。 package cn.itcast_04_reflect; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.List; import org.junit.Before; import org.junit.Test; public class MyReflect { public String className = null; @SuppressWarnings(“rawtypes”) public Class personClass = null; /** * 反射Person类 @throws Exception / @Before public void init() throws Exception { className = “cn.itcast_04_reflect.Person”; personClass = Class._forName_(className); } / 获取某个class文件对象 通过 class类名获取对应的 class文件对象. */ @Test public void getClassName() throws Exception { System._out_.println(personClass); } / 获取某个class文件对象的另一种方式 直接获取 package 当中已经有的，文件对象. / @Test public void getClassName2() throws Exception { System._out_.println(Person.class); } /** 创建一个class文件表示的实例对象，底层会调用空参数的构造方法 / @Test public void getNewInstance() throws Exception { System._out_.println(personClass.newInstance()); } / 获取非私有的构造函数 获取唯一的 构造函数,进行唯一的方法调用.也可以获得实例. */ @SuppressWarnings({ “rawtypes”, “unchecked” }) @Test public void getPublicConstructor() throws Exception { Constructor constructor = personClass.getConstructor(Long.class,String.class); Person person = (Person)constructor.newInstance(100L,”zhangsan”); System._out_.println(person.getId()); System._out_.println(person.getName()); } / 获得私有的构造函数 / @SuppressWarnings({ “rawtypes”, “unchecked” }) @Test public void getPrivateConstructor() throws Exception { Constructor con = personClass.getDeclaredConstructor(String.class); //暴力获取 私有权限的 链接。 con.setAccessible(true);//强制取消Java的权限检测 Person person2 = (Person)con.newInstance(“zhangsan”); System._out_.println(““+person2.getName()); } / 访问非私有的成员变量 / @SuppressWarnings({ “rawtypes”, “unchecked” }) @Test public void getNotPrivateField() throws Exception { Constructor constructor = personClass.getConstructor(Long.class,String.class); Object obj = constructor.newInstance(100L,”zhangsan”); Field field = personClass.getField(“name”); field.set(obj, “lisi”); System._out_.println(field.get(obj)); } / 访问私有的成员变量 / @SuppressWarnings({ “rawtypes”, “unchecked” }) @Test public void getPrivateField() throws Exception { // Constructor constructor2 = personClass.getConstructor(Long,class); // Object newInstance = constructor2.newInstance(100L); // // // personClass.getDeclaredFields(“name”); Constructor constructor = personClass.getConstructor(Long.class); Object obj = constructor.newInstance(100L); Field field2 = personClass.getDeclaredField(“id”); field2.setAccessible(true);//强制取消Java的权限检测 field2.set(obj,10000L); System._out_.println(field2.get(obj)); } / 获取非私有的成员函数 / @SuppressWarnings({ “unchecked” }) @Test public void getNotPrivateMethod() throws Exception { System._out_.println(personClass.getMethod(“toString”)); Object obj = personClass.newInstance();//获取空参的构造函数 Method toStringMethod = personClass.getMethod(“toString”); //指定代理对象 执行对应的方法. 当我们发过来的都是字符串 并不知道我们应该执行的方法是什么，只能通过·发送给我们的字符串货值用的什么具体方法. Object object = toStringMethod.invoke(obj); System._out_.println(object); } / 获取私有的成员函数 / @SuppressWarnings(“unchecked”) @Test public void getPrivateMethod() throws Exception { Object obj = personClass.newInstance();//获取空参的构造函数 Method method = personClass.getDeclaredMethod(“getSomeThing”); method.setAccessible(true); Object value = method.invoke(obj); System._out_.println(value); } / / @Test public void otherMethod() throws Exception { //当前加载这个class文件的那个类加载器对象 System._out_.println(personClass.getClassLoader()); //获取某个类实现的所有接口 Class[] interfaces = personClass.getInterfaces(); for (Class class1 : interfaces) { System._out_.println(class1); } //反射当前这个类的直接父类 extends没有.就是Object的孩子 System._out_.println(personClass.getGenericSuperclass()); / getResourceAsStream这个方法可以获取到一个输入流，这个输入流会关联到name所表示的那个文件上。 / //path 不以’/‘开头时默认是从此类所在的包下取资源&lt;更小&gt;，以’/‘开头则是从ClassPath根下获取。其只是通过path构造一个绝对路径，最终还是由ClassLoader获取资源。 System._out_.println(personClass.getResourceAsStream(“/log4j.properties”)); System._out_.println(personClass.getResourceAsStream(“log4j.properties”)); //判断当前的Class对象表示是否是数组 System._out_.println(personClass.isArray()); System._out_.println(new String[3].getClass().isArray()); //判断当前的Class对象表示是否是枚举类 System._out_.println(personClass.isEnum()); System._out_.println(Class._forName_(“cn.itcast_04_reflect.City”).isEnum()); //判断当前的Class对象表示是否是接口 System._out_.println(personClass.isInterface()); System._out_**.println(Class._forName_(“cn.itcast_04_reflect.TestInterface”).isInterface()); } } 动态代理 在之前的代码调用阶段，我们用action调用service的方法实现业务即可。 由于之前在service中实现的业务可能不能够满足当先客户的要求，需要我们重新修改service中的方法，但是service的方法不只在我们这个模块使用，在其他模块也在调用，其他模块调用的时候，现有的service方法已经能够满足业务需求，所以我们不能只为了我们的业务而修改service，导致其他模块授影响。 那怎么办呢？ 可以通过动态代理的方式，扩展我们的service中的方法实现，使得在原有的方法中增加更多的业务，而不是实际修改service中的方法，这种实现技术就叫做动态代理。 动态代理：在不修改原业务的基础上，基于原业务方法，进行重新的扩展，实现新的业务。 例如下面的例子： 旧业务 买家调用action，购买衣服，衣服在数据库的标价为50元，购买流程就是简单的调用。 新业务 在原先的价格上可以使用优惠券，但是这个功能在以前没有实现过，我们通过代理类，代理了原先的接口方法，在这个方法的基础上，修改了返回值。 代理实现流程： 书写代理类和代理方法，在代理方法中实现代理newProxyInstance 代理中需要的参数分别为：被代理的类的类加载器getClassLoader()，被代理类的所有实现接口new Class[] { Interface.class }，句柄方法new InvocationHandler() 在句柄方法中复写invoke&lt;调用&gt;方法，invoke方法的输入有3个参数Object proxy（代理类对象）, Method method（被代理类的方法）,Object[] args（被代理类方法的传入参数），在这个方法中，我们可以定制化的开发新的业务。 获取代理类，强转成被代理的接口 最后，我们可以像没被代理一样，调用接口的认可方法，方法被调用后，方法名和参数列表将被传入代理类的invoke方法中，进行新业务的逻辑流程。 原业务接口IBoss public interface IBoss {//接口 int yifu(String size); } 原业务实现类 public class Boss implements IBoss{ public int yifu(String size){ System.err.println(“天猫小强旗舰店，老板给客户发快递——衣服型号：”+size); //这件衣服的价钱，从数据库读取 return 50; } public void kuzi(){ System.err.println(“天猫小强旗舰店，老板给客户发快递——裤子”); } } 原业务调用 public class SaleAction { @Test public void saleByBossSelf() throws Exception { IBoss boss = new Boss(); System.out.println(“老板自营！”); int money = boss.yifu(“xxl”); System.out.println(“衣服成交价：” + money); } } 代理类 public static IBoss getProxyBoss(final int discountCoupon) throws Exception { Object proxedObj = Proxy.newProxyInstance(Boss.class.getClassLoader(), new Class[] { IBoss.class }, new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Integer returnValue = (Integer) method.invoke(new Boss(), args);// 调用原始对象以后返回的值 return returnValue - discountCoupon; } }); return (IBoss)proxedObj; } } 新业务调用 public class ProxySaleAction { @Test public void saleByProxy() throws Exception { IBoss boss = ProxyBoss.getProxyBoss(20);// 将代理的方法实例化成接口 System.out.println(“代理经营！”); int money = boss.yifu(“xxl”);// 调用接口的方法，实际上调用方式没有变 System.out.println(“衣服成交价：” + money); } } 动态代理的模板： Socket**编程模板：** ——利用socket来进行远程远程过程调用 服务器&lt;类方法 最好用反射方法，这样灵活——根据发过来的类来进行 灵活的调用请求。&gt; WebService 封装http协议等等. 服务器利用代码 托管封装到—Tomcat容器当中。然后 Tomcat封装的http协议action然后 client就可以通过http直接调用服务器了。 &lt;以上方法 太冗余。所以我们进行了 简化的socket通信&gt; ServiceServer &lt;服务器端&gt;package cn.itcast.bigdata.socket; import java.io.IOException; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; public class ServiceServer { public static void main(String[] args) { ServerSocket server; try { //创建 一个serversocket 绑定到本机的 8899 端口上. server = new ServerSocket(); server.bind(new InetSocketAddress(“localhost”, 8899)); //监听并接受客户端的李连杰请求，accept是祖册方法 会一直等待。客户端有请求连接才返回 // 创建一个serversocket，绑定到本机的8899端口上 // 接受客户端的连接请求;accept是一个阻塞方法，会一直等待，到有客户端请求连接才返回 while (true) { Socket socket = server.accept(); //业务逻辑 抛出业务类进行处理. new Thread(new ServiceServerTask(socket)).start(); } } catch (IOException e1) { // TODO 自动生成的 catch 块 e1.printStackTrace(); } } } ServiceServerTask&lt;服务器端 线程 socket实现类&gt;package cn.itcast.bigdata.socket; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.PrintWriter; import java.lang.reflect.Parameter; import java.net.Socket; public class ServiceServerTask implements Runnable{ Socket socket; InputStream in; OutputStream out; public ServiceServerTask(Socket socket) { // TODO 自动生成的构造函数存根 this.socket = socket; } @Override public void run() { // TODO 自动生成的方法存根 //从socket 连接中获取到与client之间的网络罗通信输入流 try { in = socket.getInputStream(); out = socket.getOutputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(in)); //用 此方法读取一行 客户端传输过来的数据 // String line = “”; // String param = “”; // while( (line = br.readLine())!=null ) { // param += line; // } // 多行就用上方的方法。 //从网络通信输入流中读取客户端发送过来的数据 //注意：socketinputstream的读数据的方法都是阻塞的 String param = br.readLine(); System.out.println(Thread.currentThread().getName()+”线程在服务器中，获取到参数为:” + param); /* 作业： 将以下业务调用逻辑写成更加通用的：可以根据客户端发过来的调用类名、调用方法名、调用该参数来灵活调用 《反射》 即进行动态代理！！！！！！ 未完成！！！ */ GetDataServiceImpl getDataServiceImpl = new GetDataServiceImpl(); String result = getDataServiceImpl.getData(param); //将调用结果写到sokect的输出流中，以发送给客户端 注意服务器。先收到 客户端发来的，然后自己再发出带回车符的 PW！！！ //注意28行—输出也是输出到 socket通信到中去！！ PrintWriter pw = new PrintWriter(out); pw.println(result); pw.flush(); } catch (IOException e) { e.printStackTrace(); }finally{ try { in.close(); out.close(); socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } ServiceClient&lt;客户端&gt;package cn.itcast.bigdata.socket; import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.PrintWriter; import java.net.Socket; public class ServiceClient { public static void main(String[] args) throws Exception { /*ServiceIterface service = ProxyUtils.getProxy(ServiceIterface.class,”methodA”,hostname,port); Result = service.methodA(parameters);*/ // 向服务器发出请求建立连接 Socket socket = new Socket(“localhost”, 8899); // 从socket中获取输入输出流 InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); PrintWriter pw = new PrintWriter(outputStream); pw.println(“hello”); pw.flush(); BufferedReader br = new BufferedReader(new InputStreamReader(inputStream)); String result = br.readLine(); System.out.println(result); inputStream.close(); outputStream.close(); socket.close(); } } GetDataServiceImpl/** * &lt;实现方法,最好在 ServiceServerTask当中进行 反射的通用书写方法.&gt; * */ package cn.itcast.bigdata.socket; public class GetDataServiceImpl { public String getData(String param){ return “ok-“+param; } } java JVM**技术** java**监控工具使用** jconsole jconsole是一种集成了上面所有命令功能的可视化工具，可以分析jvm的内存使用情况和线程等信息。 启动**jconsole 通过JDK/bin目录下的“jconsole.exe”启动Jconsole后，将自动搜索出本机运行的所有JVM进程，不需要用户使用jps来查询了，双击其中一个进程即可开始监控。也可以“远程连接服务器，进行远程虚拟机的监控。” 概览页面** 概述页面显示的是整个虚拟机主要运行数据的概览。 jvisualvm 提供了和jconsole的功能类似，提供了一大堆的插件。 插件中，Visual GC（可视化GC）还是比较好用的，可视化GC可以看到内存的具体使用情况。 java**内存模型** 内存模型图解 Java虚拟机在执行Java程序的过程中，会把它所管理的内存划分为若干个不同的数据区。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而建立和销毁，我们可以将这些区域统称为Java运行时数据区域。 如下图是一个内存模型的关系图（详情见图：内存划分.png）： 如上图所示，Java虚拟机运行时数据区域被分为五个区域：堆(Heap)、栈(Stack)、本地方法栈(Native Stack)、方法区(Method Area)、程序计数器(Program Count Register)。 堆（**Heap**） 对于大多数应用来说，Java Heap是Java虚拟机管理的内存的最大一块，这块区域随着虚拟机的启动而创建。在实际的运用中，我们创建的对象和数组就是存放在堆里面。如果你听说线程安全的问题，就会很明确的知道Java Heap是一块共享的区域，操作共享区域的成员就有了锁和同步。 与Java Heap相关的还有Java的垃圾回收机制（GC）,Java Heap是垃圾回收器管理的主要区域。程序猿所熟悉的新生代、老生代、永久代的概念就是在堆里面，现在大多数的GC基本都采用了分代收集算法。如果再细致一点，Java Heap还有Eden空间，From Survivor空间,To Survivor空间等。 Java Heap可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。 栈（**Stack**） 相对于Java Heap来讲，Java Stack是线程私有的，她的生命周期与线程相同。Java Stack描述的是Java方法执行时的内存模型，每个方法执行时都会创建一个栈帧（Stack Frame）用语存储局部变量表、操作数栈、动态链接、方法出口等信息。从下图从可以看到，每个线程在执行一个方法时，都意味着有一个栈帧在当前线程对应的栈帧中入栈和出栈。 图中可以看到每一个栈帧中都有局部变量表。局部变量表存放了编译期间的各种基本数据类型，对象引用等信息。 本地方法栈（**Native Stack**） 本地方法栈（Native Stack）与Java虚拟机站（Java Stack）所发挥的作用非常相似，他们之间的区别在于虚拟机栈为虚拟机栈执行java方法（也就是字节码）服务，而本地方法栈则为使用到Native方法服务。 方法区（**Method Area**） 方法区（Method Area）与堆（Java Heap）一样，是各个线程共享的内存区域，它用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是她却有一个别名叫做非堆（Non-Heap）。分析下Java虚拟机规范，之所以把方法区描述为堆的一个逻辑部分，应该觉得她们都是存储数据的角度出发的。一个存储对象数据（堆），一个存储静态信息(方法区)。 在上文中，我们看到堆中有新生代、老生代、永久代的描述。为什么我们将新生代、老生代、永久代三个概念一起说，那是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。这样HotSpot的垃圾收集器就能想管理Java堆一样管理这部分内存。简单点说就是HotSpot虚拟机中内存模型的分代，其中新生代和老生代在堆中，永久代使用方法区实现。根据官方发布的路线图信息，现在也有放弃永久代并逐步采用Native Memory来实现方法区的规划，在JDK1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。 总结 线程私有的数据区域有： Java虚拟机栈（Java Stack） 本地方法栈（Native Stack） 线程共有的数据区域有： 堆（Java Heap） 方法区 JVM**参数列表** java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0 -Xmx3550m：最大堆内存为3550M。 -Xms3550m：初始堆内存为3550m。 此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn2g：设置年轻代大小为2G。 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 -Xss128k：设置每个线程的堆栈大小。 JDK5.0以后每个线程堆栈大小为1M，在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000左右。 -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。 设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 -XX:MaxPermSize=16m:设置持久代大小为16m。 -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。 如果设置为0的话，则年轻代对象不经过Survivor区，直 接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象 再年轻代的存活时间，增加在年轻代即被回收的概论。 收集器设置 -XX:+UseSerialGC:设置串行收集器 -XX:+UseParallelGC:设置并行收集器 -XX:+UseParalledlOldGC:设置并行年老代收集器 -XX:+UseConcMarkSweepGC:设置并发收集器 垃圾回收统计信息 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:filename 并行收集器设置 -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。 -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n) 并发收集器设置 -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。 -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 jvm**案例演示** 内存： Jconsole的内存标签相当于可视化的jstat命令，用于监视收集器管理的虚拟机内存（java堆和永久代）的变化趋势。 我们通过下面的一段代码体验一下它的监视功能。运行时设置的虚拟机参数为：-Xms100m -Xmx100m -XX:+UseSerialGC，这段代码的作用是以64kb/50毫秒的速度往java堆内存中填充数据。 public class TestMemory { static class OOMObject { public byte[] placeholder = new byte[64 * 1024]; } public static void fillHeap(int num) throws Exception { ArrayList list = new ArrayList(); for (int i = 0; i &lt; num; i++) { Thread.sleep(50); list.add(new OOMObject()); } System.gc(); } public static void main(String[] args) throws Exception { fillHeap(1000); Thread.sleep(500000); } } 从图中可以看出，运行轨迹成曲线增长，循环1000次后，虽然整个新生代Eden和Survivor区都基本上被清空了，但是老年代仍然保持峰值状态，这说明，填充的数据在GC后仍然存活，因为list的作用域没有结束。如果把System.gc();移到fillHeap(1000);后，就可以全部回收掉。 线程： jconsole线程标签相当于可视化了jstack命令，遇到线程停顿时，可以使用这个也签进行监控分析。线程长时间停顿的主要原因有：等待外部资源（数据库连接等），死循环、锁等待。下面的代码将演示这几种情况： package cn.java.jvm; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class TestThread { / 死循环演示 @param args / public static void createBusyThread() { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(“createBusyThread”); while (true) ; } }, “testBusyThread”); thread.start(); } / 线程锁等待 @param args / public static void createLockThread(final Object lock) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(“createLockThread”); synchronized (lock) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } }, “testLockThread”); thread.start(); } public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); br.readLine(); createBusyThread(); br.readLine(); Object object = new Object(); createLockThread(object); } } main线程：追踪到需要键盘录入 testBusyThread线程：线程阻塞在18行的while（true），直到线程切换，很耗性能 testLockThread线程：出于waitting状态，等待notify 死锁： package cn.java.jvm; public class TestDeadThread implements Runnable { int a, b; public TestDeadThread(int a, int b) { this.a = a; this.b = b; } @Override public void run() { System.out.println(“createDeadThread”); synchronized (Integer.valueOf(a)) { synchronized (Integer.valueOf(b)) { System.out.println(a + b); } } } public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { new Thread(new TestDeadThread(1, 2)).start(); new Thread(new TestDeadThread(2, 1)).start(); } } } 点击检查死锁，会出现死锁的详情。 thread-5的锁被thread-10持有，相反亦是，造成死锁。]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Eclipse中10个最有用的快捷键组合]]></title>
    <url>%2Fpost%2Fc0928cfc.html</url>
    <content type="text"><![CDATA[一个Eclipse骨灰级开发者总结了他认为最有用但又不太为人所知的快捷键组合。通过这些组合可以更加容易的浏览源代码，使得整体的开发效率和质量得到提升。 1. ctrl+shift+r：打开资源 这可能是所有快捷键组合中最省时间的了。这组快捷键可以让你打开你的工作区中任何一个文件，而你只需要按下文件名或mask名中的前几个字母，比如applic.xml。美中不足的是这组快捷键并非在所有视图下都能用。 2. ctrl+o：快速outline 如果想要查看当前类的方法或某个特定方法，但又不想把代码拉上拉下，也不想使用查找功能的话，就用ctrl+o吧。它可以列出当前类中的所有方法及属性，你只需输入你想要查询的方法名，点击enter就能够直接跳转至你想去的位置。 3. ctrl+e：快速转换编辑器 这组快捷键将帮助你在打开的编辑器之间浏览。使用ctrl+page down或ctrl+page up可以浏览前后的选项卡，但是在很多文件打开的状态下，ctrl+e会更加有效率。 4. ctrl+2，L：为本地变量赋值 开发过程中，我常常先编写方法，如Calendar.getInstance()，然后通过ctrl+2快捷键将方法的计算结果赋值于一个本地变量之上。 这样我节省了输入类名，变量名以及导入声明的时间。Ctrl+F的效果类似，不过效果是把方法的计算结果赋值于类中的域。 5. alt+shift+r：重命名 重命名属性及方法在几年前还是个很麻烦的事，需要大量使用搜索及替换，以至于代码变得零零散散的。今天的Java IDE提供源码处理功能，Eclipse也是一样。现在，变量和方法的重命名变得十分简单，你会习惯于在每次出现更好替代名称的时候都做一次重命名。要使 用这个功能，将鼠标移动至属性名或方法名上，按下alt+shift+r，输入新名称并点击回车。就此完成。如果你重命名的是类中的一个属性，你可以点击alt+shift+r两次，这会呼叫出源码处理对话框，可以实现get及set方法的自动重命名。 6. alt+shift+l以及alt+shift+m：提取本地变量及方法 源码处理还包括从大块的代码中提取变量和方法的功能。比如，要从一个string创建一个常量，那么就选定文本并按下alt+shift+l即可。如果同 一个string在同一类中的别处出现，它会被自动替换。方法提取也是个非常方便的功能。将大方法分解成较小的、充分定义的方法会极大的减少复杂度，并提 升代码的可测试性。 7. shift+enter及ctrl+shift+enter Shift+enter在当前行之下创建一个空白行，与光标是否在行末无关。Ctrl+shift+enter则在当前行之前插入空白行。 8. Alt+方向键 这也是个节省时间的法宝。这个组合将当前行的内容往上或下移动。在try/catch部分，这个快捷方式尤其好使。 9. ctrl+m 大显示屏幕能够提高工作效率是大家都知道的。Ctrl+m是编辑器窗口最大化的快捷键。 * 10. ctrl+.及ctrl+1：下一个错误及快速修改 ctrl+.将光标移动至当前文件中的下一个报错处或警告处。这组快捷键我一般与ctrl+1一并使用，即修改建议的快捷键。新版Eclipse的修改建 议做的很不错，可以帮你解决很多问题，如方法中的缺失参数，throw/catch exception，未执行的方法等等。 更多快捷键组合可在Eclipse按下ctrl+shift+L查看 或者查看本篇博文。]]></content>
      <categories>
        <category>Eclipse</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Tomcat和Netty]]></title>
    <url>%2Fpost%2F2a629e2e.html</url>
    <content type="text"><![CDATA[tomcat像是一个web server容器 相对于Tomcat这种Web Server（顾名思义主要是提供Web协议相关的服务的），Netty是一个Network Server，是处于Web Server更下层的网络框架，也就是说你可以使用Netty模仿Tomcat做一个提供HTTP服务的Web容器。 简而言之，Netty通过使用NIO的很多新特性，对TCP/UDP编程进行了简化和封装，提供了更容易使用的网络编程接口，让你可以根据自己的需要封装独特的HTTP Server活着FTP Server等. Netty是什么？ 1）本质：JBoss做的一个Jar包 2）目的：快速开发高性能、高可靠性的网络服务器和客户端程序 3）优点：提供异步的、事件驱动的网络应用程序框架和工具 通俗的说：一个好使的处理Socket的东东]]></content>
      <categories>
        <category>Big Data</category>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day03_BigData渐进学习_aclear_fire]]></title>
    <url>%2Fpost%2F19085dd3.html</url>
    <content type="text"><![CDATA[1. 1. yum源配置补充2. [自动化部署脚本](#sh) ============== 3. [自动化部署脚本](#installZk) ===================== 4. [Zookeeper结构化和命令](#zkDS) ======================== 1.yum源配置补充P.S. centos关机命令： 1、本地yum仓库的安装配置 两种方式： a、每一台机器都配一个本地文件系统上的yum仓库 file:///packege/path/ b、在局域网内部配置一台节点(server-base)的本地文件系统yum仓库，然后将其发布到web服务器中，其他节点就可以通过http://server-base/pagekege/path/ 制作流程： 先挑选一台机器mini4，挂载一个系统光盘到本地目录/mnt/cdrom，然后启动一个httpd服务器，将/mnt/cdrom 软连接到httpd服务器的/var/www/html目录中 (cd /var/www/html; ln -s /mnt/cdrom ./centos ) 然后通过网页访问测试一下： http://mini4/centos 会看到光盘的目录内容 至此：网络版yum私有仓库已经建立完毕 剩下就是去各台yum的客户端配置这个http地址到repo配置文件中 无论哪种配置，都需要先将光盘挂在到本地文件目录中 mount -t iso9660 /dev/cdrom /mnt/cdrom 为了避免每次重启后都要手动mount，可以在/etc/fstab中加入一行挂载配置，即可自动挂载 vi /etc/fstab /dev/cdrom /mnt/cdrom iso9660 defaults 0 0 #这样每次开始 都会自动挂载光驱到 /mnt/cdrom 下面！ 2、minimal安装的系统出现的问题：缺各种命令，安装软件时缺各种依赖 scp命令都没有：yum install -y openssh-clients #每台机器上都要安装才行，作用 在两台机器之间传递文件 #注意不一定都是 命令对应于依赖包名！ #yum erase openssh-clients #卸载openssh-clients包 2.实现自动部署tomcat脚本思路： //首先hadoop要进行免密登录！-&gt; 安装wget 再解压 再安装. yum install -y wget #我们就不用进行输入 yes了！ !/bin/bashSERVERS=”node-3.itcast.cn node-4.itcast.cn” #服务器名称PASSWORD=123456BASE_SERVER=172.16.203.100auto_ssh_copy_id() { expect -c “set timeout -1; spawn ssh-copy-id $1; expect { (yes/no) {send — yes\\r;exp_continue;} *assword:* {send — $2\\r;exp_continue;} eof {exit 0;} }”; #用户输入的交互过程， }ssh_copy_id_to_all() { for SERVER in $SERVERS do auto_ssh_copy_id $SERVER $PASSWORD done}ssh_copy_id_to_allfor SERVER in $SERVERSdo scp install.sh root@$SERVER:/root ssh root@$SERVER /root/install.shdone install_everyone.sh !/bin/bashBASE_SERVER=mini4 #可以下载软件的服务器在哪里yum install -y wgetwget $BASE_SERVER/soft/jdk-7u45-linux-x64.tar.gztar -zxvf jdk-7u45-linux-x64.tar.gz -C /usr/localcat &gt;&gt; /etc/profile &lt;&lt; EOFexport JAVA_HOME=/usr/local/jdk1.7.0_45export PATH=\$PATH:\$JAVA_HOME/binEOF 标准化输入 cat profile文件 追加export 两行到profile里面去。原本cat 2.txt &gt;&gt; 1.txt现在 输出追加到1.txt; &lt;&lt; EOF “中间当做文件内容输入到 追加到 1.txt当中！” EOF-- 对于高可用的客户端 寻找服务器端。 IPC(心跳程序，每秒钟进行检查，查看 当前是否宕机；还要记录宕机的状态信息-&gt;最好记录在数据库当中) 于是，我们希望有个这样的第三方进行解耦： 图一： 另一种工作场景: 保管数据(进行注册) 提供监听 图二： 替我们保管数据、提供监听：这样对于我们复杂的分布式就很简单(所以第三方自己就要很高的可靠性，zookeeper只要有半数以上结点存货即可 正常运行.) 图三： 注意：只是状态信息(描述性的信息放置在zk上面(但是如果读取的状态数据特别大的时候 上万个集群？阿里可能会有些问题。)) Zookeeper是一个分布式协调服务；就是为用户的分布式应用程序提供协调服务 zookeeper是为别的分布式程序服务的 Zookeeper本身就是一个分布式程序（只要有半数以上节点存活，zk就能正常服务） Zookeeper所提供的服务涵盖：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统一名称服务…… 虽然说可以提供各种服务，但是zookeeper在底层其实只提供了两个功能： 管理(存储，读取)用户程序提交的数据； #注意只是状态存取和读取在zk，数据实际在自己 分布式服务期当中 并为用户程序提供数据节点监听服务； #监听 请求，返回；类似于一个中转站 图四：(hadoop集群很多协调服务的 感知，协调 storm框架也是用的zk) 自动化配置Zookeeper1.注意在一开始的 Zk并没有主从之分，只是之后自己配置或者自己进行投票的逻辑进行配置的 PAXOS版本 -&gt;Zab算法. (当发现没有主从的时候，开始投票;注意算法既看版本号也看id) 图一： [caption id=”attachment_1066” align=”aligncenter” width=”1008”] zookeeper集群结构[/caption] 开始启动了两台机器： mini1 mini2 ：投票：1投票投自己。2也投票投自己。 两个人统计都读出一共投出两张票；没有人当选 leader；所以等到下一轮继续投票，发现leader没有，并且2的ID是大的。1投票就给了2,2投的票也给了2-》所以最后2 就得到两票-》当选leader 当然第三个服务器启动后：发现 有了leader所以 3就自动变成了follower 注意：1.对于大型的集群来说，最好不用这个，因为他们的主从是由投票来的，每次数据修改之后 还需要进行通知，每个机器还需要进行信息的更新。 一个leader要让所有的集群进行数据更新的话，延迟还是很大的。数据要求频繁不适合。 2.图一当中红色的部分 是我们需要给服务器配置的。 然而leader 和 follow是投票算法出来的。 ——-开始搭建——-简而言之配置 apps/conf/zoo.cfg 然后apps/zookeeper 拷贝过去 各个机器，进行编辑 /root/zkdata/myid 注意前提是 service iptables stop 2181 端口，关闭防火墙 rm -rf src/ .txt .xml dist-maven/ docs 因为 这个是源码包 工程java+jar进行的程序；所以吧源码包删除即可。 因为 c语言（make &amp;&amp; make install）是与平台相关的 编译。然而 javca 不是，他是运行在虚拟机啊上的。只要里面的 jdk是一直的即可。 注意：这是个集群 每个机器有自己的数据目录。然而给用户看的是一些状态描述。 spark storm hadoop zookeeper集群 都是在内网之中进行工作的。所以防火墙我们是统统关闭的。 server.1=aclear2:2888:3888 leader和follow的，3888是投票的端口。#.1 代表投票服务器编号。 myid还需要记录到 数据文件夹当中。 ——还有如果 service connect error 说明链接错误，没有奇数个服务器，进行链接了！失败了。 3、添加内容： dataDir=/root/zkdata server.1=aclear2:2888:3888 server.2=aclear3:2888:3888 server.3=aclear5:2888:3888 4 启动（每台机器）zkServer.sh start 5 查看集群状态 jps（查看进程） sh status（查看集群状态，主从信息） — ZK结构和命令4. zookeeper结构和命令 4.1. zookeeper特性 1、Zookeeper：一个leader，多个follower组成的集群 2、全局数据一致：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的 3、分布式读写，更新请求转发，由leader实施 4、更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行 5、数据更新原子性，一次数据更新要么成功，要么失败 6、实时性，在一定时间范围内，client能读到最新数据 4.2. zookeeper数据结构 1、层次化的目录结构，命名符合常规文件系统规范(见下图) 2、每个节点在zookeeper中叫做znode,并且其有一个唯一的路径标识 3、节点Znode可以包含数据和子节点（但是EPHEMERAL类型的节点不能有子节点，下一页详细讲解）；；注意：暂时性的结点是 不让新建其子节点的！！！ 4、客户端应用可以在节点上设置监视器（后续详细讲解） 4.3. 数据结构的图 4.4. 节点类型 1、Znode有两种类型： 短暂（ephemeral）（断开连接自己删除） 持久（persistent）（断开连接不删除） 2、Znode有四种形式的目录节点（默认是persistent ） PERSISTENT PERSISTENT_SEQUENTIAL（持久序列/test0000000019 ） EPHEMERAL EPHEMERAL_SEQUENTIAL 3、创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护 4、在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序 —day03_07区别 export b (只能在本进程和相应的子进程之中b 变量是有效的。) source 1.sh 于是这样我们就能进行响应父进程中使用b变量的！ 因为在一开始执行启动ssh是不会source 环境变量的。只能进行手动： 之前配置免密登录ssh-keygenssh-copy-id!/bin/shecho “Start ZkServer…”for i in 2 3 5do ssh aclear$i “source /etc/profile;/root/apps/zookeeper/bin/zkServer.sh start”done —day03_08 Zookeeper客户端1.1. zookeeper命令行操作运行 zkCli.sh –server 进入命令行工具 1、使用 ls 命令来查看当前 ZooKeeper 中所包含的内容： [zk: 202.115.36.251:2181(CONNECTED) 1] ls / 2、创建一个新的 znode ，使用 create /zk myData 。这个命令创建了一个新的 znode 节点“ zk ”以及与它关联的字符串： [zk: 202.115.36.251:2181(CONNECTED) 2] create /zk “myData“ 3、我们运行 get 命令来确认 znode 是否包含我们所创建的字符串： [zk: 202.115.36.251:2181(CONNECTED) 3] get /zk #监听这个节点的变化,当另外一个客户端改变/zk时,它会打出下面的 #WATCHER:: #WatchedEvent state:SyncConnected type:NodeDataChanged path:/zk [zk: localhost:2181(CONNECTED) 4] get /zk watch 4、下面我们通过 set 命令来对 zk 所关联的字符串进行设置： [zk: 202.115.36.251:2181(CONNECTED) 4] set /zk “zsl“ 5、下面我们将刚才创建的 znode 删除： [zk: 202.115.36.251:2181(CONNECTED) 5] delete /zk 6、删除节点：rmr #注意这个是删除 文件夹下的所有节点。 [zk: 202.115.36.251:2181(CONNECTED) 5] rmr /zk 1.2. zookeeper-api应用1.2.1. 基本使用org.apache.zookeeper.Zookeeper是客户端入口主类，负责建立与server的会话 它提供了表 1 所示几类主要方法 ： 功能 描述 create 在本地目录树中创建一个节点 delete 删除一个节点 exists 测试本地是否存在目标节点 get/set data 从目标节点上读取 / 写数据 get/set ACL 获取 / 设置目标节点访问控制列表信息 getchildren 检索一个子节点上的列表 sync 等待要被传送的数据 表 1 ： ZooKeeper API 描述 —-search.maven.org 注意：目前是结合 eclipse进行开发，学习。 代码测试：/** * * @author acanprince method: 进行ZooKeeper 客户端的增删改查。监听存数据 因为咱们在j2ee上编写的是客户端 /public class SimpleZkClient { //注意在这个里面 , 才是正规的分隔符 然而 ； 不是分隔符！ 这样就认成一个整体了 //zoo.cfg 配置是绑定在主机名上的。 不是绑定在IP上的。 所以 这里必须是 主机名称！IP会连接失败！ private static final String connectString = “aclear2:2181,aclear3:2181,aclear5:2181”; private static final int sessionTimeout = 2000; ZooKeeper zkClient = null; //JUnit 库添加到路径中来。 然后就能分步测试 @Before public void init() throws IOException { zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() { @Override public void process(WatchedEvent event) { // TODO 自动生成的方法存根 // 收到事件后的回调函数 System.out.println(event.getType() + “—-“ + event.getPath()); try { //不加这个 h就只能监听一次的 根节点变化。 zkClient.getChildren(“/“, true); } catch (KeeperException | InterruptedException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } }); } /\* * 数据的增删改查 * 返回创建节点的路径 * 参数：路径 数据 权限 类型 * @throws InterruptedException * @throws KeeperException */ public void testCreated() throws KeeperException, InterruptedException { String nodeCreated = zkClient.create(“/eclipse”, “helloZk”.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); //此处的数据 如果上传文件的数据 也需要上传 byte数组的数据。 } //判断是否存在 @Test public void testExit() throws KeeperException, InterruptedException { // TODO 自动生成的方法存根 Stat stat = zkClient.exists(“/eclipse”, false); System.out.println(stat==null?”not exit”:”exit”); } //获取子节点 监听”/“ 结点变化，就会watch内部类被调用。 @Test public void getChildren() throws KeeperException, InterruptedException { //注意第二个参数 是watcher，置成true就是默认使用上方设置了的匿名内部类。 List children = zkClient.getChildren(“/“, true); for (String child : children) { System.out.println(“当前孩子节点是：” + child); } //注意图片 在mian主线程 有两个子线程： connect，egtchildren ； 一个listen() Thread.sleep(Long.MAX_VALUE); } //获取znode的数据 @Test public void getData() throws KeeperException, InterruptedException { //如果集群很大 可能集群上的版本，和老的版本是不一致的。 但是我们现在是 小集群或者每次拿到都是最新的就行。 byte[] data = zkClient.getData(“/eclipse”, false, null); System.out.println(new String(data)); } //删除 znode；第二个参数：指定要删除的版本，-1表示删除所有版本！ @Test public void deleteZnode() throws Exception { zkClient.delete(“/eclipse”, -1); } @Test public void setZnode() throws KeeperException, InterruptedException { zkClient.setData(“/eclipse”, “Hello Znode”.getBytes(), -1); byte[] data = zkClient.getData(“/eclipse”, false, null); System.out.println(“当前数据是：” + new String(data)); }} ——10客户端要知道 服务器到底有几台在线上和下线了。 —-服务端添加： 有序号的临时性的结点 注意：Listen 上方是守护线程——即主线程退出子线程(listen也关闭了！) public static void main(String args[]) { System.out.println(“主线程开始了!”); new Thread(new Runnable() { @Override public void run() { // TODO 自动生成的方法存根 System.out.println(“子线程开始了”); for (int i = 0; i &lt; 10000; i++) { } System.out.println(“子线程执行结束…”); } }).start(); System.out.println(“主线程结束执行退出。”); } public static void main(String args[]) { System.out.println(“主线程开始了!”); Threa thread = new Thread(new Runnable() { @Override public void run() { // TODO 自动生成的方法存根 System.out.println(“子线程开始了”); for (int i = 0; i &lt; 10000; i++) { } System.out.println(“子线程执行结束…”); } }); thread.setDaemon(true); //添加使 其为守护线程 thread.start(); //线程启动. } 客户端：获取列表+监听。get父目录的children 这样能知道那些机器在线；负载均衡：感知获取当前连接的机器数 代码练习： 服务器端： public class DistributedServer { private static final String connectString = “aclear2:2181,aclear3:2181,aclear5:2181”; private static final int sessionTimeout = 2000; private static final String parentNode = “/servers/“; private ZooKeeper zooKeeper = null; /** * 创建到zk的客户端连接 * @throws IOException / public void getConnect() throws IOException { zooKeeper = new ZooKeeper(connectString, sessionTimeout, new Watcher() { @Override public void process(WatchedEvent event) { // TODO 自动生成的方法存根 // 收到事件后的回调函数 System.out.println(event.getType() + “—-“ + event.getPath()); try { //不加这个 h就只能监听一次的 根节点变化。 zooKeeper.getChildren(“/“, true); } catch (KeeperException | InterruptedException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } }); } /\* * 注册服务器；上线连接 * @param hostname * @throws KeeperException * @throws InterruptedException / public void registerServer(String hostname) throws KeeperException, InterruptedException { String create = zooKeeper.create(parentNode + “server”, hostname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); System.out.println(hostname + “ is online..” + create); } /\* * 业务功能 * @throws InterruptedException */ public void handleBusiness(String hostname) throws InterruptedException { System.out.println(hostname + “start working…”); Thread.sleep(Long.MAX_VALUE); } public static void main(String args[]) throws IOException, KeeperException, InterruptedException { //获取zk连接 DistributedServer server = new DistributedServer(); server.getConnect(); //利用Zk链接注册服务器信息 server.registerServer(args[0]); //启动业务功能 因为ipc等要封装成一个 通用的业务服务器 //new Thread 执行业务线程。 server.handleBusiness(args[0]); }} 客户端： 学习：多线程的 volatile b 我们新建的对象的是放置在 堆内存当中的。当我们进行多线程的应用时：是有自己的线程栈控件，有些读 堆内存、有些写堆内存。 怕就怕 他们把b变量拷贝一份拿去进行，自行处理。修改时才返回修改堆内存物理地址上真正的b变流量。为了真正的每个线程每次都是 拿 真正的变量，就这样进行的。 注意以为是临时变量所以： 关闭服务器，结点就会消失————所以就实现了 宕机监听啦！ ---- 监听器是一个接口，我们的代码中可以实现Wather这个接口，实现其中的process方法，方法中即我们自己的业务逻辑 监听器的注册是在获取数据的操作中实现： getData(path,watch?)监听的事件是：节点数据变化事件 getChildren(path,watch?)监听的事件是：节点下的子节点增减变化事件 1.1. zookeeper应用案例（分布式应用HA||分布式锁）3.7.1 实现分布式应用的(主节点HA)及客户端动态更新主节点状态某分布式系统中，主节点可以有多台，可以动态上下线 任意一台客户端都能实时感知到主节点服务器的上下线 A、客户端实现 public class AppClient { private String groupNode = “sgroup”; private ZooKeeper zk; private Stat stat = new Stat(); private volatile List serverList; / 连接zookeeper / public void connectZookeeper() throws Exception { zk = new ZooKeeper(“localhost:4180,localhost:4181,localhost:4182”, 5000, new Watcher() { public void process(WatchedEvent event) { // 如果发生了”/sgroup”节点下的子节点变化事件, 更新server列表, 并重新注册监听 if (event.getType() == EventType.NodeChildrenChanged &amp;&amp; (“/“ + groupNode).equals(event.getPath())) { try { updateServerList(); } catch (Exception e) { e.printStackTrace(); } } } }); updateServerList(); } / 更新server列表 / private void updateServerList() throws Exception { List newServerList = new ArrayList(); // 获取并监听groupNode的子节点变化 // watch参数为true, 表示监听子节点变化事件. // 每次都需要重新注册监听, 因为一次注册, 只能监听一次事件, 如果还想继续保持监听, 必须重新注册 List subList = zk.getChildren(“/“ + groupNode, true); for (String subNode : subList) { // 获取每个子节点下关联的server地址 byte[] data = zk.getData(“/“ + groupNode + “/“ + subNode, false, stat); newServerList.add(new String(data, “utf-8”)); } // 替换server列表 serverList = newServerList; System.out.println(“server list updated: “ + serverList); } /* client的工作逻辑写在这个方法中 此处不做任何处理, 只让client sleep / public void handle() throws InterruptedException { Thread.sleep(Long.MAX_VALUE); } public static void main(String[] args) throws Exception { AppClient ac = new AppClient(); ac.connectZookeeper(); ac.handle(); } } B、服务器端实现 public class AppServer { private String groupNode = “sgroup”; private String subNode = “sub”; / 连接zookeeper @param address server的地址 */ public void connectZookeeper(String address) throws Exception { ZooKeeper zk = new ZooKeeper( “localhost:4180,localhost:4181,localhost:4182”, 5000, new Watcher() { public void process(WatchedEvent event) { // 不做处理 } }); // 在”/sgroup”下创建子节点 // 子节点的类型设置为EPHEMERAL_SEQUENTIAL, 表明这是一个临时节点, 且在子节点的名称后面加上一串数字后缀 // 将server的地址数据关联到新创建的子节点上 String createdPath = zk.create(“/“ + groupNode + “/“ + subNode, address.getBytes(“utf-8”), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); System.out.println(“create: “ + createdPath); } / server的工作逻辑写在这个方法中 此处不做任何处理, 只让server sleep */ public void handle() throws InterruptedException { Thread.sleep(Long.MAX_VALUE); } public static void main(String[] args) throws Exception { // 在参数中指定server的地址 if (args.length == 0) { System.err.println(“The first argument must be server address”); System.exit(1); } AppServer as = new AppServer(); as.connectZookeeper(args[0]); as.handle(); } } 3.7.2分布式共享锁的简单实现 客户端A public class DistributedClient { // 超时时间 private static final int SESSION_TIMEOUT = 5000; // zookeeper server列表 private String hosts = “localhost:4180,localhost:4181,localhost:4182”; private String groupNode = “locks”; private String subNode = “sub”; private ZooKeeper zk; // 当前client创建的子节点 private String thisPath; // 当前client等待的子节点 private String waitPath; private CountDownLatch latch = new CountDownLatch(1); /* 连接zookeeper */ public void connectZookeeper() throws Exception { zk = new ZooKeeper(hosts, SESSION_TIMEOUT, new Watcher() { public void process(WatchedEvent event) { try { // 连接建立时, 打开latch, 唤醒wait在该latch上的线程 if (event.getState() == KeeperState.SyncConnected) { latch.countDown(); } // 发生了waitPath的删除事件 if (event.getType() == EventType.NodeDeleted &amp;&amp; event.getPath().equals(waitPath)) { doSomething(); } } catch (Exception e) { e.printStackTrace(); } } }); // 等待连接建立 latch.await(); // 创建子节点 thisPath = zk.create(“/“ + groupNode + “/“ + subNode, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); // wait一小会, 让结果更清晰一些 Thread.sleep(10); // 注意, 没有必要监听”/locks”的子节点的变化情况 List childrenNodes = zk.getChildren(“/“ + groupNode, false); // 列表中只有一个子节点, 那肯定就是thisPath, 说明client获得锁 if (childrenNodes.size() == 1) { doSomething(); } else { String thisNode = thisPath.substring((“/“ + groupNode + “/“).length()); // 排序 Collections.sort(childrenNodes); int index = childrenNodes.indexOf(thisNode); if (index == -1) { // never happened } else if (index == 0) { // inddx == 0, 说明thisNode在列表中最小, 当前client获得锁 doSomething(); } else { // 获得排名比thisPath前1位的节点 this.waitPath = “/“ + groupNode + “/“ + childrenNodes.get(index - 1); // 在waitPath上注册监听器, 当waitPath被删除时, zookeeper会回调监听器的process方法 zk.getData(waitPath, true, new Stat()); } } } private void doSomething() throws Exception { try { System.out.println(“gain lock: “ + thisPath); Thread.sleep(2000); // do something } finally { System.out.println(“finished: “ + thisPath); // 将thisPath删除, 监听thisPath的client将获得通知 // 相当于释放锁 zk.delete(this.thisPath, -1); } } public static void main(String[] args) throws Exception { for (int i = 0; i &lt; 10; i++) { new Thread() { public void run() { try { DistributedClient dl = new DistributedClient(); dl.connectZookeeper(); } catch (Exception e) { e.printStackTrace(); } } }.start(); } Thread.sleep(Long.MAX_VALUE); } } 分布式多进程模式实现： public class DistributedClientMy { // 超时时间 private static final int SESSION_TIMEOUT = 5000; // zookeeper server列表 private String hosts = “spark01:2181,spark02:2181,spark03:2181”; private String groupNode = “locks”; private String subNode = “sub”; private boolean haveLock = false; private ZooKeeper zk; // 当前client创建的子节点 private volatile String thisPath; / 连接zookeeper / public void connectZookeeper() throws Exception { zk = new ZooKeeper(“spark01:2181”, SESSION_TIMEOUT, new Watcher() { public void process(WatchedEvent event) { try { // 子节点发生变化 if (event.getType() == EventType.NodeChildrenChanged &amp;&amp; event.getPath().equals(“/“ + groupNode)) { // thisPath是否是列表中的最小节点 List childrenNodes = zk.getChildren(“/“ + groupNode, true); String thisNode = thisPath.substring((“/“ + groupNode + “/“).length()); // 排序 Collections.sort(childrenNodes); if (childrenNodes.indexOf(thisNode) == 0) { doSomething(); thisPath = zk.create(“/“ + groupNode + “/“ + subNode, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); } } } catch (Exception e) { e.printStackTrace(); } } }); // 创建子节点 thisPath = zk.create(“/“ + groupNode + “/“ + subNode, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); // wait一小会, 让结果更清晰一些 Thread.sleep(new Random().nextInt(1000)); // 监听子节点的变化 List childrenNodes = zk.getChildren(“/“ + groupNode, true); // 列表中只有一个子节点, 那肯定就是thisPath, 说明client获得锁 if (childrenNodes.size() == 1) { doSomething(); thisPath = zk.create(“/“ + groupNode + “/“ + subNode, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); } } / 共享资源的访问逻辑写在这个方法中 / private void doSomething() throws Exception { try { System.out.println(“gain lock: “ + thisPath); Thread.sleep(2000); // do something } finally { System.out.println(“finished: “ + thisPath); // 将thisPath删除, 监听thisPath的client将获得通知 // 相当于释放锁 zk.delete(this.thisPath, -1); } } public static void main(String[] args) throws Exception { DistributedClientMy dl = new DistributedClientMy(); dl.connectZookeeper(); Thread.sleep(Long.MAX_VALUE); } }]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx和keepalived教程]]></title>
    <url>%2Fpost%2F54e297a4.html</url>
    <content type="text"><![CDATA[1. 目标1.1. 了解反向代理和负载均衡的概念1.2. 掌握Nginx的安装和使用1.3. 利用Nginx实现负载均衡2. Nginx相关概念2.1. 反向代理反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 2.2. 负载均衡负载均衡，英文名称为Load Balance，是指建立在现有网络结构之上，并提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。其原理就是数据流量分摊到多个服务器上执行，减轻每台服务器的压力，多台服务器共同完成工作任务，从而提高了数据的吞吐量。 3. Nginx的安装3.1. 下载nginx官网：http://nginx.org/ 3.2. 上传并解压nginx //注意因为上传的是源码需编译tar -zxvf nginx-1.8.1.tar.gz -C /usr/local/src 3.3. 编译nginx进入到nginx源码目录 cd /usr/local/src/nginx-1.8.1 #检查安装环境,并指定将来要安装的路径 //prefix 指定路径 ./configure —prefix=/usr/local/nginx #缺包报错 ./configure: error: C compiler cc is not found #使用YUM安装缺少的包 yum -y install gcc pcre-devel openssl openssl-devel #编译安装 //make进行编译； make install:可执行文件，库放荡相应的安装目录去 make &amp;&amp; make install 安装完后测试是否正常： /usr/loca/nginx/sbin/nginx 查看端口是否有ngnix进程监听 netstat -ntlp | grep 80 // || netstat -nltp4. 配置nginx4.1. 配置反向代理 修改nginx配置文件 server { listen 80; server_name nginx-01.itcast.cn; #nginx所在服务器的主机名 #反向代理的配置 location / { #拦截所有请求 / 这个请求（即所以URL请求） root html; proxy_pass http://192.168.0.21:8080; #这里是代理走向的目标服务器：tomcat } } 启动tomcat-01上的tomcat 3.启动nginx-01上的nginx ./nginx 重启: kill -HUP `cat /usr/local/nginx/logs/nginx.pid ` 参考网址:http://www.cnblogs.com/jianxie/p/3990377.html 4.2. 动静分离(/ )动态资源 index.jsp (nignx当中 根据后缀名进行代理返回。 删除上方的代理所有的’/’ ！)location ~ .*\.(jsp|do|action)$ { proxy_pass http://tomcat-01.itcast.cn:8080; } 静态资源location ~ .*\.(html|js|css|gif|jpg|jpeg|png)$ { expires 3d; } 4.3. 负载均衡在http这个节下面配置一个叫upstream的，后面的名字可以随意取，但是要和location下的proxy_pass http://后的保持一致。 http { 是在http里面的, 已有http, 不是在server里,在server外面 upstream tomcats { server shizhan02:8080 weight=1;#weight表示多少个 server shizhan03:8080 weight=1; server shizhan04:8080 weight=1; } #卸载server里 ~.\. 是正则表达式 location ~ .\.(jsp|do|action) { proxy_pass http://tomcats; #tomcats是后面的tomcat服务器组的逻辑组号 } } 5. 利用keepalived实现高可靠（HA）5.1. 高可靠概念HA(High Available), 高可用性集群，是保证业务连续性的有效解决方案，一般有两个或两个以上的节点，且分为活动节点及备用节点。 5.2. 高可靠软件keepalivedkeepalive是一款可以实现高可靠的软件，通常部署在2台服务器上，分为一主一备。Keepalived可以对本机上的进程进行检测，一旦Master检测出某个进程出现问题，将自己切换成Backup状态，然后通知另外一个节点切换成Master状态。 5.3. keepalived安装下载keepalived官网:http://keepalived.org 将keepalived解压到/usr/local/src目录下 tar -zxvf keepalived-1.2.19.tar.gz -C /usr/local/src 进入到/usr/local/src/keepalived-1.2.19目录 cd /usr/local/src/keepalived-1.2.19 开始configure ./configure —prefix=/usr/local/keepalived #编译并安装 make &amp;&amp; make install 5.4. 将keepalived添加到系统服务中(service 就可以启动了)拷贝执行文件 cp /usr/local/keepalived/sbin/keepalived /usr/sbin/ 将init.d文件拷贝到etc下,加入开机启动项 cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived 将keepalived文件拷贝到etc下 cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/ 创建keepalived文件夹 mkdir -p /etc/keepalived 将keepalived配置文件拷贝到etc下 cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf 添加可执行权限 chmod +x /etc/init.d/keepalived ##以上所有命令一次性执行： cp /usr/local/keepalived/sbin/keepalived /usr/sbin/ cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/ mkdir -p /etc/keepalived cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf chmod +x /etc/init.d/keepalived chkconfig —add keepalived chkconfig keepalived on 添加keepalived到开机启动 chkconfig —add keepalived chkconfig keepalived on 5.5. 配置keepalived虚拟IP修改配置文件： /etc/keepalived/keepalived.conf #MASTER节点 global_defs { } vrrp_instance VI_1 { state MASTER #指定A节点为主节点 备用节点上设置为BACKUP即可 interface eth0 #绑定虚拟IP的网络接口 virtual_router_id 51 #VRRP组名，两个节点的设置必须一样，以指明各个节点属于同一VRRP组 priority 100 #主节点的优先级（1-254之间），备用节点必须比主节点优先级低 advert_int 1 #组播信息发送间隔，两个节点设置必须一样 authentication { #设置验证信息，两个节点必须一致《传输加密的密文》 auth_type PASS auth_pass 1111 } virtual_ipaddress { #指定虚拟IP, 两个节点设置必须一样 192.168.33.60/24 #如果两个nginx的ip分别是192.168.33.61,,…62，则此处的虚拟ip跟它俩同一个网段即可 } } BACKUP节点global_defs { } vrrp_instance VI_1 { state BACKUP interface eth0 virtual_router_id 51 priority 99 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.33.60/24 } } 分别启动两台机器上的keepalived service keepalived start 测试： 杀掉master上的keepalived进程，你会发现，在slave机器上的eth0网卡多了一个ip地址 查看ip地址的命令： ip addr //注意 eth0多了一个ip地址就是。虚拟的那个IP地址。就是这样实现的把虚拟ip切换给对应的 master 或者 backup的那台机器。5.6. 配置keepalived心跳检查原理： Keepalived并不跟nginx耦合，它俩完全不是一家人 但是keepalived提供一个机制：让用户自定义一个shell脚本去检测用户自己的程序，返回状态给keepalived就可以了 #MASTER节点 global_defs { } #注意： vrrp_script chk_health { script “[[ `ps -ef | grep nginx | grep -v grep | wc -l` -ge 2 ]] &amp;&amp; exit 0 || exit 1 #发生异常调用脚本最下面看色 interval 1 #每隔1秒执行上述的脚本，去检查用户的程序ngnix,老师dang机weight权重减减 weight -2 } vrrp_instance VI_1 { state MASTER interface eth0 virtual_router_id 1 priority 100 advert_int 2 authentication { auth_type PASS auth_pass 1111 } #跟踪用户程序的脚本 track_script { chk_health } virtual_ipaddress { 10.0.0.10/24 } #给我们的对应的接口，传去需要进行调用的脚本文件 notify_master “/usr/local/keepalived/sbin/notify.sh master” notify_backup “/usr/local/keepalived/sbin/notify.sh backup” notify_fault “/usr/local/keepalived/sbin/notify.sh fault” # } 添加切换通知脚本 vi /usr/local/keepalived/sbin/notify.sh!/bin/bash case “$1” in master) /usr/local/nginx/sbin/nginx exit 0 ;; backup) /usr/local/nginx/sbin/nginx -s stop /usr/local/nginx/sbin/nginx exit 0 ;; fault) /usr/local/nginx/sbin/nginx -s stop exit 0 ;; *) echo ‘Usage: notify.sh {master|backup|fault}’ exit 1 ;; esac添加执行权限 chmod +x /usr/local/keepalived/sbin/notify.shglobal_defs { } vrrp_script chk_health { script “[[ `ps -ef | grep nginx | grep -v grep | wc -l` -ge 2 ]] &amp;&amp; exit 0 || exit 1” interval 1 weight -2 } vrrp_instance VI_1 { state BACKUP interface eth0 virtual_router_id 1 priority 99 advert_int 1 authentication { auth_type PASS auth_pass 1111 } track_script { chk_health } virtual_ipaddress { 10.0.0.10/24 } notify_master “/usr/local/keepalived/sbin/notify.sh master” notify_backup “/usr/local/keepalived/sbin/notify.sh backup” notify_fault “/usr/local/keepalived/sbin/notify.sh fault” } 在第二台机器上添加notify.sh脚本 #分别在两台机器上启动keepalived service keepalived start chkconfig keepalived on]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux shell编程]]></title>
    <url>%2Fpost%2F52de762d.html</url>
    <content type="text"><![CDATA[1. shell编程2. sed命令3. awk命令4. crontab定时器5. 高级文本文件处理sort cut wc6. sed详解(会使用,有些东西可能一辈子也不会去使用的)7. awk详解目标：因为shell编程有时候不和我们的java类似。是一种固定的语法类型。 这样来说，就是我们基本能看懂一些shell编程的文件，拿过来懂得怎么去用、怎么去改，就可以了。 在进行编程如果看不懂，就可以一点一点的 什么是SHELL Shell是用户与内核进行交互操作的一种接口，目前最流行的Shell称为bash Shell Shell也是一门编程语言&lt;解释型的编程语言&gt;，即shell脚本 一个系统可以存在多个shell，可以通过cat /etc/shells命令查看系统中安装的shell，不同的shell可能支持的命令语法是不相同的 注意：A=`wc -c` 反引号. 引用上一个变量的输出结果！！！（即，运行里面的命令并把结果返回给变量A）——将命令的返回值赋值给结果。 （注意等价于： A=$(wc -c)） Shell脚本的执行方式Shell脚本的执行方式①第一种：输入脚本的绝对路径或相对路径 首先要赋予+x权限 /root/helloWorld.sh ./helloWorld.sh 或者，不用赋予+x权限，而用解释器解释执行 sh helloworld.sh ②第二种：bash或sh +脚本 sh /root/helloWorld.sh sh helloWorld.sh ③第三种：在脚本的路径前再加”. “ . /root/helloWorld.sh . ./helloWorld.sh 注意：区别：第一种和第二种会新开一个bash，不同bash中的变量无法共享 Shell中的变量 Linux Shell中的变量分为“系统变量”和“用户自定义变量”，可以通过set命令查看那系统变量 系统变量：$HOME、$PWD、$SHELL、$USER等等 显示当前shell中所有变量 : set 定义变量 变量＝值 （例如STR=abc） 等号两侧不能有空格 变量名称一般习惯为大写 双引号和单引号有区别，双引号仅将空格脱意，单引号会将所有特殊字符脱意 STR=”hello world”A=9unset A 撤销变量 Areadonly B=2 声明静态的变量 B=2 ，不能 unsetexport 变量名 可把变量提升为全局环境变量，可供其他shell程序使用soource /etc/profile 就是将profiile文件夹里面的，export 全局变量全部输出一遍，获取最新的全局变量。 将命令的返回值赋给变量•A=`ls -la` 反引号，运行里面的命令，并把结果返回给变量A •A=$(ls -la) 等价于反引号 Shell中的特殊变量(前面都要加上echo $)•$? 表示上一个命令退出的状态 //echo $? 返回 表示上次命令执行的返回值。或说状态。0 表示返回正确 •$$ 表示当前进程编号 •$0 表示当前脚本名称 •$n 表示n位置的输入参数（n代表数字，n&gt;=1） •$# 表示参数的个数，常用于循环 •$*和$@ 都表示参数列表 $*与$@区别•$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号” “包含时，都以$1 $2 … $n 的形式输出所有参数 •当它们被双引号” “包含时，”$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；”$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数 运算符l格式 :expr m + n 或$((m+n)) 注意expr运算符间要有空格 l例如计算（2 ＋3 ）×4 的值 1 .分步计算 S=`expr 2 + 3` expr $S \* 4 2.一步完成计算 expr `expr 2 + 3 ` \* 4 echo `expr \\`expr 2 + 3\` \* 4` 或 $(((2+3)*4)) for循环第一种：for N in 1 2 3do echo $Ndone或for N in 1 2 3; do echo $N; done或for N in {1..3}; do echo $N; done第二种：for ((i = 0; i &lt;= 5; i++))do echo “welcome $i times”done或for ((i = 0; i &lt;= 5; i++)); do echo “welcome $i times”; done while循环第一种while expressiondocommand…done//注意 [ 2 -gt 1 ] 这是一个表达式，然而 while 1 就是不对的！第二种i=1while ((i&lt;=3))do echo $i let i++done case语句格式case $1 instart) echo “starting” ;;stop) echo “stoping” ;;*) echo “Usage: {start|stop} “esac//脚本语言当中，Python还是比shell规范一些的~ 大概就没有一些shell中这些恶心的语法了。 read命令 read -p(提示语句)-n(字符个数) -t(等待时间) read -p “please input your name: “ NAME使用示例： read -p “please input your name: “ c-&gt;please input your name: name echo $c-&gt;name if判断&amp;例子语法if conditionthen statements[elif condition then statements. ..][else statements ]fi语法、单词 掌握学号。 例子： #!/bin/bash read -p “please input your name:” NAME #printf ‘%s\\n’ $NAME if [ $NAME = root ] then echo “hello ${NAME}, welcome !” elif [ $NAME = itcast ] then echo “hello ${NAME}, welcome !” else echo “SB, get out here !” fi 判断语句：[ condition ] (注意condition前后要有空格) 非空返回true，可使用$?验证（0为true，&gt;1为false）[ itcast ] 空返回false[ ][ condition ] &amp;&amp; echo OK || echo notok 条件满足，执行后面的语句 常用判断条件= 字符串比较-lt 小于-le 小于等于-eq 等于-gt 大于-ge 大于等于-ne 不等于-r 有读的权限-w 有写的权限-x 有执行的权限-f 文件存在并且是一个常规的文件-s 文件存在且不为空-d 文件存在并是一个目录-b文件存在并且是一个块设备-L 文件存在并且是一个链接 Shell自定义函数语法 [ function ] funname [()]{ action; [return int;] //注意返回的值只能是int 而且是0-255 $?可以得到.}function start() / function start / start() 注意：1.必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先预编译2.函数返回值，只能通过$? 系统变量获得，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255) 脚本调试：•sh -vx helloWorld.sh •或者在脚本中增加set -x [hadoop@aclear shell]$ sh -vx if_console.sh //例子 !/bin/bashread -p “please input your name:” NAME+ read -p ‘please input your name:’ NAMEplease input your name:root printf ‘%s\\n’ $NAMEif [ $NAME = root ] then echo “hello ${NAME}, welcome !”elif [ $NAME = itcast ] then echo “hello ${NAME}, welcome !”else echo “SB, get out here !”fi+ ‘[‘ root = root ‘]‘+ echo ‘hello root, welcome !’hello root, welcome ! 高级文本文件命令 处理：sed命令•sed全称是：Stream EDitor即流编辑器，是一个很好的文本处理工具，本身是一个管道命令，处理时，把当前处理的行存储在临时缓冲区中，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行。它是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作。 sed选项•-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。 •-e ：直接在命令列模式上进行 sed 的动作编辑； •-i ：直接修改读取的文件内容，而不是输出到终端。 sed function•a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行) •d ：删除，因为是删除啊，所以 d 后面通常不接任何内容 •i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行) •p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行 •s ：取代，可以直接进行取代的工作！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g awk命令•AWK是一种优良的文本处理工具。其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母，AWK 提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。实际上 AWK 的确拥有自己的语言：AWK 程序设计语言， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。 注意格式为： awk ‘pattern1 {action1} pattern2 {action2} …’ filename sort sort 命令对 File 参数指定的文件中的行排序，并将结果写到标准输出。如果 File 参数指定多个文件，那么 sort 命令将这些文件连接起来，并当作一个文件进行排序。 sort语法 [root@www ~]# sort [-fbMnrtuk] [file or stdin] 选项与参数： -f ：忽略大小写的差异，例如 A 与 a 视为编码相同； -b ：忽略最前面的空格符部分； -M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法； -n ：使用『纯数字』进行排序(默认是以文字型态来排序的)； -r ：反向排序； -u ：就是 uniq ，相同的数据中，仅出现一行代表； -t ：分隔符，默认是用 [tab] 键来分隔； -k ：以那个区间 (field) 来进行排序的意思 对/etc/passwd 的账号进行排序 [root@www ~]# cat /etc/passwd | sort adm:x:3:4:adm:/var/adm:/sbin/nologin apache:x:48:48:Apache:/var/www:/sbin/nologin bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin sort 是默认以第一个数据来排序，而且默认是以字符串形式来排序,所以由字母 a 开始升序排序。 /etc/passwd 内容是以 : 来分隔的，我想以第三栏(按照用户id来进行排序,但是按照字典来的0 10来进行排序)来排序，该如何 [root@www ~]# cat /etc/passwd | sort -t ‘:’ -k 3 //用户名:密码占位符:用户id:所属主要组:代号:家目录:默认 用到的shell解释器 在/bin/bash 里面. root:x:0:0:root:/root:/bin/bash //id 从500开始的是普通用户。小于500是特殊用户。 uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin operator:x:11:0:operator:/root:/sbin/nologin bin:x:1:1:bin:/bin:/sbin/nologin games:x:12:100:games:/usr/games:/sbin/nologin 默认是以字符串来排序的，如果想要使用数字排序： cat /etc/passwd | sort -t ‘:’ -k 3n root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/bin/sh bin:x:2:2:bin:/bin:/bin/sh 默认是升序排序，如果要倒序排序，如下 cat /etc/passwd | sort -t ‘:’ -k 3nr nobody:x:65534:65534:nobody:/nonexistent:/bin/sh ntp:x:106:113::/home/ntp:/bin/false messagebus:x:105:109::/var/run/dbus:/bin/false sshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin 如果要对/etc/passwd,先以第六个域的第2个字符到第4个字符进行正向排序，再基于第一个域进行反向排序。 cat /etc/passwd | sort -t’:’ -k 6.2,6.4 -k 1r sync:x:4:65534:sync:/bin:/bin/sync proxy:x:13:13:proxy:/bin:/bin/sh bin:x:2:2:bin:/bin:/bin/sh sys:x:3:3:sys:/dev:/bin/sh 查看/etc/passwd有多少个shell:对/etc/passwd的第七个域进行排序，然后去重: cat /etc/passwd | sort -t’:’ -k 7 -u root:x:0:0:root:/root:/bin/bash syslog:x:101:102::/home/syslog:/bin/false daemon:x:1:1:daemon:/usr/sbin:/bin/sh sync:x:4:65534:sync:/bin:/bin/sync sshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin uniq uniq命令可以去除排序过的文件中的重复行，因此uniq经常和sort合用。也就是说，为了使uniq起作用，所有的重复行必须是相邻的。 即： # cat /etc/passwd | sort | uniq -c uniq语法 [root@www ~]# uniq [-icu] 选项与参数： -i ：忽略大小写字符的不同； -c ：进行计数 -u ：只显示唯一的行 testfile的内容如下 cat testfile hello world friend hello world hello 直接删除未经排序的文件，将会发现没有任何行被删除 #uniq testfile hello world friend hello world hello 排序文件，默认是去重 #cat testfile | sort |uniq friend hello world 排序之后删除了重复行，同时在行首位置输出该行重复的次数 #sort testfile | uniq -c 1 friend 3 hello 2 world 仅显示存在重复的行，并在行首显示该行重复的次数 #sort testfile | uniq -dc 3 hello 2 world 仅显示不重复的行 sort testfile | uniq -u friend cut cut命令可以从一个文本文件或者文本流中提取文本列。 cut语法 [root@www ~]# cut -d’分隔字符’ -f fields &lt;==用于有特定分隔字符 [root@www ~]# cut -c 字符区间 &lt;==用于排列整齐的信息 选项与参数： -d ：后面接分隔字符。与 -f 一起使用； -f ：依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思； -c ：以字符 (characters) 的单位取出固定字符区间； PATH 变量如下 [root@www ~]# echo $PATH /bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games # 1 | 2 | 3 | 4 | 5 | 6 | 7 将 PATH 变量取出，我要找出第五个路径。 #echo $PATH | cut -d ‘:’ -f 5 /usr/local/bin 将 PATH 变量取出，我要找出第三和第五个路径。 #echo $PATH | cut -d ‘:’ -f 3,5 /sbin:/usr/local/bin 将 PATH 变量取出，我要找出第三到最后一个路径。 echo $PATH | cut -d ‘:’ -f 3- /sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games 将 PATH 变量取出，我要找出第一到第三个路径。 #echo $PATH | cut -d ‘:’ -f 1-3 /bin:/usr/bin:/sbin: 将 PATH 变量取出，我要找出第一到第三，还有第五个路径。 echo $PATH | cut -d ‘:’ -f 1-3,5 /bin:/usr/bin:/sbin:/usr/local/bin 实用例子:只显示/etc/passwd的用户和shell #cat /etc/passwd | cut -d ‘:’ -f 1,7 root:/bin/bash daemon:/bin/sh bin:/bin/sh wc 统计文件里面有多少单词，多少行，多少字符。 wc语法 [root@www ~]# wc [-lwm] 选项与参数： -l ：仅列出行； -w ：仅列出多少字(英文单字)； -m ：多少字符； 默认使用wc统计/etc/passwd #wc /etc/passwd 40 45 1719 /etc/passwd 40是行数，45是单词数，1719是字节数w wc的命令比较简单使用，每个参数使用如下： #wc -l /etc/passwd #统计行数，在对记录数时，很常用 40 /etc/passwd #表示系统有40个账户 #wc -w /etc/passwd #统计单词出现次数 45 /etc/passwd #wc -m /etc/passwd #统计文件的字符数 1719 参考 http://vbird.dic.ksu.edu.tw/linux\_basic/0320bash\_6.php#pipe_2 http://www.cnblogs.com/stephen-liu74/archive/2011/11/10/2240461.html sed详解1. Sed简介 sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。以下介绍的是Gnu版本的Sed 3.02。 2. 定址 可以通过定址来定位你所希望编辑的行，该地址用数字构成，用逗号分隔的两个行数表示以这两行为起止的行的范围（包括行数表示的那两行）。如1，3表示1，2，3行，美元符号($)表示最后一行。范围可以通过数据，正则表达式或者二者结合的方式确定 。 3. Sed命令 调用sed命令有两种形式： sed [options] ‘command’ file(s) sed [options] -f scriptfile file(s) a\ 在当前行后面加入一行文本。 b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 c\ 用新的文本改变本行的文本。 d 从模板块（Pattern space）位置删除行。 D 删除模板块的第一行。 i\ 在当前行上面插入文本。 h 拷贝模板块的内容到内存中的缓冲区。 H 追加模板块的内容到内存中的缓冲区 g 获得内存缓冲区的内容，并替代当前模板块中的文本。 G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 l 列表不能打印字符的清单。 n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 p 打印模板块的行。 P（大写） 打印模板块的第一行。 q 退出Sed。 r file 从file中读行。 t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 w file 写并追加模板块到file末尾。 W file 写并追加模板块的第一行到file末尾。 ! 表示后面的命令对所有没有被选定的行发生作用。 s/re/string 用string替换正则表达式re。 = 打印当前行号码。 # 把注释扩展到下一个换行符以前。 以下的是替换标记 g表示行内全面替换。 p表示打印行。 w表示把行写入一个文件。 x表示互换模板块中的文本和缓冲区中的文本。 y表示把一个字符翻译为另外的字符（但是不用于正则表达式） 4. 选项 -e command, —expression=command 允许多台编辑。 -h, —help 打印帮助，并显示bug列表的地址。 -n, —quiet, —silent 取消默认输出。 -f, —filer=script-file 引导sed脚本文件名。 -V, —version 打印版本和版权信息。 5. 元字符集^ 锚定行的开始 如：/^sed/匹配所有以sed开头的行。 $ 锚定行的结束 如：/sed$/匹配所有以sed结尾的行。 . 匹配一个非换行符的字符 如：/s.d/匹配s后接一个任意字符，然后是d。 匹配零或多个字符 如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 [] 匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。 [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。 \(..\) 保存匹配的字符，如s/\(love\)able/\\1rs，loveable被替换成lovers。 &amp; 保存搜索字符用来替换其他字符，如s/love/**&amp;*/，love这成\*love**。 \\&lt; 锚定单词的开始，如:/\\ 锚定单词的结束，如/love\>/匹配包含以love结尾的单词的行。 x\\{m\\} 重复字符x，m次，如：/o\\{5\\}/匹配包含5个o的行。 x\\{m,\\} 重复字符x,至少m次，如：/o\\{5,\\}/匹配至少有5个o的行。 x\\{m,n\\} 重复字符x，至少m次，不多于n次，如：/o\\{5,10\\}/匹配5—10个o的行。 6. 实例(其实就是类似于 正则表达式的思想) 删除：d命令 $ sed ‘2d’ example——-删除example文件的第二行。 $ sed ‘2,$d’ example——-删除example文件的第二行到末尾所有行。 * $ sed ‘$d’ example——-删除example文件的最后一行。 $ sed ‘/test/‘d example——-删除example文件所有包含test的行。 替换：s命令 $ sed ‘s/test/mytest/g’ example——-在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。 $ sed -n ‘s/^test/mytest/p’ example——-(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。 $ sed ‘s/^192.168.0.1/&amp;localhost/‘ example——-&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhost。 $ sed -n ‘s/\(love\)able/\\1rs/p’ example——-love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。 \ $ sed ‘s#10#100#g’ example——-不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。 选定行的范围：逗号 $ sed -n ‘/test/,/check/p’ example——-所有在模板test和check所确定的范围内的行都被打印。 $ sed -n ‘5,/^test/p’ example——-打印从第五行开始到第一个包含以test开始的行之间的所有行。 $ sed ‘/test/,/check/s/$/sed test/‘ example——-对于模板test和west之间的行，每行的末尾用字符串sed test替换。 多点编辑：e命令 $ sed -e ‘1,5d’ -e ‘s/test/check/‘ example——-(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执 行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。 $ sed —expression=’s/test/check/‘ —expression=’/love/d’ example——-一个比-e更好的命令是—expression。它能给sed表达式赋值。 从文件读入：r命令 $ sed ‘/test/r file’ example——-file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。 写入文件：w命令 $ sed -n ‘/test/w file’ example——-在example中所有包含test的行都被写入file里。 追加命令：a命令 $ sed ‘/^test/a\\-—&gt;this is a example’ example ‘——-&gt;this is a example’被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。 插入：i命令 $ sed ‘/test/i\\\ new line ————————————-‘ example 如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。 下一个：n命令 $ sed ‘/test/{ n; s/aa/bb/; }’ example——-如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。 变形：y命令 $ sed ‘1,10y/abcde/ABCDE/‘ example——-把1—10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。 退出：q命令 $ sed ‘10q’ example——-打印完第10行后，退出sed。 保持和获取：h命令和G命令 $ sed -e ‘/test/h’ -e ‘$G example——-在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保 持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中 的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。 保持和互换：h命令和x命令 * $ sed -e ‘/test/h’ -e ‘/check/x’ example ——-互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。 7. 脚本 Sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。 awk详解简介 awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。 awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。 使用方法 awk ‘{pattern + action}’ {filenames} 尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。 awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。 通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。 调用awk 有三种方式调用awk 1.命令行方式 awk [-F field-separator] ‘commands’ input-file(s) 其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。 在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。 2.shell脚本方式 将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。 相当于shell脚本首行的：#!/bin/sh 可以换成：#!/bin/awk 3.将所有的awk命令插入一个单独文件，然后调用： awk -f awk-script-file input-file(s) 其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。 本章重点介绍命令行方式。 入门实例 假设last -n 5的输出如下 [root@www ~]# last -n 5 &lt;==仅取出前五行 root pts/1 192.168.1.100 Tue Feb 10 11:21 still logged in root pts/1 192.168.1.100 Tue Feb 10 00:46 - 02:28 (01:41) root pts/1 192.168.1.100 Mon Feb 9 11:41 - 18:30 (06:48) dmtsai pts/1 192.168.1.100 Mon Feb 9 11:41 - 11:41 (00:00) root tty1 Fri Sep 5 14:09 - 14:10 (00:01) 如果只是显示最近登录的5个帐号 #last -n 5 | awk ‘{print $1}’ //注意默认是以 空格和tab作为分隔符的 root root root dmtsai root awk工作流程是这样的：读入有’\\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推。 如果只是显示/etc/passwd的账户 #cat /etc/passwd |awk -F ‘:’ ‘{print $1}’ root daemon bin sys 这种是awk+action的示例，每行都会执行action{print $1}。 -F指定域分隔符为’:’。 如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割 #cat /etc/passwd |awk -F ‘:’ ‘{print $1”\\t”$7}’ root /bin/bash daemon /bin/sh bin /bin/sh sys /bin/sh 如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加”blue,/bin/nosh”。 cat /etc/passwd |awk -F ‘:’ ‘BEGIN {print “name,shell”} {print $1”,”$7} END {print “blue,/bin/nosh”}’ name,shell root,/bin/bash daemon,/bin/sh bin,/bin/sh sys,/bin/sh …. blue,/bin/nosh awk工作流程是这样的：先执行BEGING，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录······直到所有的记录都读完，最后执行END操作。 搜索/etc/passwd有root关键字的所有行 #awk -F: ‘/root/‘ /etc/passwd root:x:0:0:root:/root:/bin/bash 这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。 搜索支持正则，例如找root开头的: awk -F: ‘/^root/‘ /etc/passwd 搜索/etc/passwd有root关键字的所有行，并显示对应的shell # awk -F: ‘/root/{print $7}’ /etc/passwd /bin/bash 这里指定了action{print $7} awk内置变量 awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量。 ARGC 命令行参数个数 ARGV 命令行参数排列 ENVIRON 支持队列中系统环境变量的使用 FILENAME awk浏览的文件名 FNR 浏览文件的记录数 FS 设置输入域分隔符，等价于命令行 -F选项 NF 浏览记录的域的个数 NR 已读的记录数 OFS 输出域分隔符 ORS 输出记录分隔符 RS 控制记录分隔符 此外,$0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,……以此类推。 统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容: #awk -F ‘:’ ‘{print “filename:” FILENAME “,linenumber:” NR “,columns:” NF “,linecontent:”$0}’ /etc/passwd filename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/bash filename:/etc/passwd,linenumber:2,columns:7,linecontent:daemon:x:1:1:daemon:/usr/sbin:/bin/sh filename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/sh filename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh 使用printf替代print,可以让代码更加简洁，易读 awk -F ‘:’ ‘{printf(“filename:%s,linenumber:%s,columns:%s,linecontent:%s\\n”,FILENAME,NR,NF,$0)}’ /etc/passwd print和printf awk中同时提供了print和printf两种打印输出的函数。 其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。 printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。 %%%%%%%%%%%%%%%%%%%%%%%%%%%下面的没事就不用看了,用到用不到的时候再看、再说%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% awk编程 变量和赋值 除了awk的内置变量，awk还可以自定义变量。 下面统计/etc/passwd的账户人数 awk ‘{count++;print $0;} END{print “user count is “, count}’ /etc/passwd root:x:0:0:root:/root:/bin/bash …… user count is 40 count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。 这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0: awk ‘BEGIN {count=0;print “[start]user count is “, count} {count=count+1;print $0;} END{print “[end]user count is “, count}’ /etc/passwd [start]user count is 0 root:x:0:0:root:/root:/bin/bash … [end]user count is 40 统计某个文件夹下的文件占用的字节数 ls -l |awk ‘BEGIN {size=0;} {size=size+$5;} END{print “[end]size is “, size}’ [end]size is 8657198 如果以M为单位显示: ls -l |awk ‘BEGIN {size=0;} {size=size+$5;} END{print “[end]size is “, size/1024/1024,”M”}’ [end]size is 8.25889 M 注意，统计不包括文件夹的子目录。 条件语句 awk中的条件语句是从C语言中借鉴来的，见如下声明方式： if (expression) { statement; statement; … … } if (expression) { statement; } else { statement2; } if (expression) { statement1; } else if (expression1) { statement2; } else { statement3; } 统计某个文件夹下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹): ls -l |awk ‘BEGIN {size=0;print “[start]size is “, size} {if($5!=4096){size=size+$5;}} END{print “[end]size is “, size/1024/1024,”M”}’ [end]size is 8.22339 M 循环语句 awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。 数组 因为awk中数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。 显示/etc/passwd的账户 awk -F ‘:’ ‘BEGIN {count=0;} {name[count] = $1;count++;}; END{for (i = 0; i &lt; NR; i++) print i, name[i]}’ /etc/passwd 0 root 1 daemon 2 bin 3 sys 4 sync 5 games …… 这里使用for循环遍历数组 awk编程的内容极多，这里只罗列简单常用的用法，更多请参考 http://www.gnu.org/software/gawk/manual/gawk.html]]></content>
      <categories>
        <category>Big Data</category>
        <category>CentOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Iptables教程]]></title>
    <url>%2Fpost%2Fb1d268a8.html</url>
    <content type="text"><![CDATA[1. iptables防火墙简介Iptables也叫netfilter是Linux下自带的一款免费且优秀的基于包过滤的防火墙工具，它的功能十分强大，使用非常灵活，可以对流入、流出、流经服务器的数据包进行精细的控制。iptables是Linux2.4及2.6内核中集成的模块。 2. Iptables服务相关命令(重点记忆) 查看iptables状态 service iptables status 开启/关闭iptables service iptables start service iptables stop 查看iptables是否开机启动 chkconfig iptables —list 设置iptables开机启动/不启动 chkconfig iptables on chkconfig iptables off 3. iptables原理简介(拓展记忆)3.1. iptables的结构在iptables中有四张表，分别是filter、nat、mangle和raw每一个表中都包含了各自不同的链，最常用的是filter表。 filter**表：** filter是iptables默认使用的表，负责对流入、流出本机的数据包进行过滤，该表中定义了3个链： INPOUT 负责过滤所有目标地址是本机地址的数据包，就是过滤进入主机的数据包。 FORWARD 负责转发流经本机但不进入本机的数据包，起到转发的作用。 OUTPUT 负责处理所有源地址是本机地址的数据包，就是处理从主机发出去的数据包。 查看帮助iptables -hman iptables列出iptables规则iptables -L -n列出iptables规则并显示规则编号iptables -L -n —line-numbers列出iptables nat表规则（默认是filter表）iptables -L -n -t nat清除默认规则（注意默认是filter表，如果对nat表操作要加-t nat） 清楚所有规则iptables -F 重启iptables发现规则依然存在，因为没有保存service iptables restart 保存配置service iptables save 禁止ssh登陆（若果服务器在机房，一定要小心）iptables -A INPUT -p tcp —dport 22 -j DROP 删除规则iptables -D INPUT -p tcp —dport 22 -j DROP-A, —append chain 追加到规则的最后一条-D, —delete chain [rulenum] Delete rule rulenum (1 = first) from chain-I, —insert chain [rulenum] Insert in chain as rulenum (default 1=first) 添加到规则的第一条-p, —proto proto protocol: by number or name, eg. ‘tcp’,常用协议有tcp、udp、icmp、all-j, —jump target 常见的行为有ACCEPT、DROP和REJECT三种，但一般不用REJECT，会带来安全隐患//ping 不同是因为 icmp给DROP掉了，一点消息也不会返回。 然而在REJECT时，还是有信息返回，告知被拒绝了！注意：INPUT和DROP这样的关键字需要大写 同时注意相当于：/etc/sysconfig/iptables 直接修改这个目录下的文件里面的配置了。 禁止192.168.33.0网段从eth0网卡接入iptables -A INPUT -p tcp -i eth0 -s 192.168.33.0 -j DROPiptables -A INPUT -p tcp —dport 22 -i eth0 -s 192.168.33.61 -j ACCEPT 禁止ip地址非192.168.10.10的所有类型数据接入iptables -A INPUT ! -s 192.168.10.10 -j DROP 禁止ip地址非192.168.10.10的ping请求iptables -I INPUT -p icmp —icmp-type 8 -s 192.168.50.100 -j DROP 扩展匹配：1.隐式扩展 2.显示扩展#隐式扩展 -p tcp --sport PORT 源端口 --dport PORT 目标端口 #显示扩展：使用额外的匹配规则 -m EXTENSTION --SUB-OPT -p tcp --dport 22 与 -p tcp -m tcp --dport 22功能相同 state：状态扩展，接口ip_contrack追踪会话状态 NEW：新的连接请求 ESTABLISHED：已建立的连接请求 INVALID：非法连接 RELATED：相关联的连接 匹配端口范围iptables -I INPUT -p tcp —dport 22:80 -j DROP 匹配多个端口iptables -I INPUT -p tcp -m multiport —dport 22,80,3306 -j ACCEPT 不允许源端口为80的数据流出iptables -I OUTPUT -p tcp —sport 80 -j DROP%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%]]></content>
      <categories>
        <category>Big Data</category>
        <category>CentOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WinSocket简单编程实验]]></title>
    <url>%2Fpost%2Fcbcc82af.html</url>
    <content type="text"><![CDATA[1.主要实现2.c++实现3.主要函数1.主要简单的实现 这一节是计算机网络作业，windows socket编程，老师电脑上开一个服务器程序，公开ip地址和端口号，我们同学自己编写一个客户端，能与老师的服务器建立联系，两者能收发即可。这样的代码网上很多，而是就采用了孙鑫VC++第14讲的代码，下面是添加的一点简单注释。 其实socket完成连接功能很简单，依葫芦画瓢即可。首先来看面向连接的TCP流程图。 ![](http://pic002.cnblogs.com/images/2012/381513/2012041116485219.png) 面向无连接的UDP流程更加简单，如下所示： ![](http://pic002.cnblogs.com/images/2012/381513/2012041116492745.png) 现在用TCP协议来完成任务，下面是孙鑫老师的代码，由于我们要提前测试自己的代码，所以也用了服务器端的代码，服务器端端server代码如下： 1 #include 2 #include 3 4 void main() 5 { 6 // 以下的几句都是固定的 7 WORD wVersionRequested; 8 WSADATA wsaData; 9 int err;1011 wVersionRequested = MAKEWORD( 1, 1 );1213 err = WSAStartup( wVersionRequested, &amp;wsaData );//该函数的功能是加载一个Winsocket库版本14 if ( err != 0 ) {15 return;16 }171819 if ( LOBYTE( wsaData.wVersion ) != 1 ||20 HIBYTE( wsaData.wVersion ) != 1 ) {21 WSACleanup( );22 return;23 }242526 //真正socket编程部分27 SOCKET sockSrv=socket(AF_INET,SOCK_STREAM,0);//面向连接的可靠性服务SOCK_STRAM2829 SOCKADDR_IN addrSrv;//存放本地地址信息的30 addrSrv.sin_addr.S_un.S_addr=htonl(INADDR_ANY);//htol将主机字节序long型转换为网络字节序31 addrSrv.sin_family=AF_INET;32 addrSrv.sin_port=htons(6001);//htos用来将端口转换成字符，1024以上的数字即可3334 bind(sockSrv,(SOCKADDR)&amp;addrSrv,sizeof(SOCKADDR));//将socket绑定到相应地址和端口上3536 listen(sockSrv,5);//等待队列中的最大长度为53738 SOCKADDR_IN addrClient;39 int len=sizeof(SOCKADDR);4041 while(1)42 {43 SOCKET sockConn=accept(sockSrv,(SOCKADDR)&amp;addrClient,&amp;len);//建立一个新的套接字用于通信，不是前面的监听套接字44 char sendBuf[100];45 sprintf(sendBuf,”Server IP is:%s”,46 inet_ntoa(addrClient.sin_addr));//inet_nota函数是将字符转换成ip地址47 send(sockConn,sendBuf,strlen(sendBuf)+1,0);//服务器向客户端发送数据4849 char recvBuf[100];50 recv(sockConn,recvBuf,100,0);//服务器从客户端接受数据51 printf(“%s\\n”,recvBuf);52 closesocket(sockConn);//关闭socket53 }54 } 客户端client的代码如下： 1 #include 2 #include 3 4 void main() 5 { 6 //固定格式 7 WORD wVersionRequested; 8 WSADATA wsaData; 9 int err;1011 wVersionRequested = MAKEWORD( 1, 1 );1213 err = WSAStartup( wVersionRequested, &amp;wsaData );14 if ( err != 0 ) {15 return;16 }171819 if ( LOBYTE( wsaData.wVersion ) != 1 ||20 HIBYTE( wsaData.wVersion ) != 1 ) {21 WSACleanup( );22 return;23 }2425 //建立通讯socket26 SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0);2728 SOCKADDR_IN addrSrv;29 addrSrv.sin_addr.S_un.S_addr=inet_addr(“192.168.1.24”);//设定需要连接的服务器的ip地址30 addrSrv.sin_family=AF_INET;31 addrSrv.sin_port=htons(6001);//设定需要连接的服务器的端口地址32 connect(sockClient,(SOCKADDR*)&amp;addrSrv,sizeof(SOCKADDR));//与服务器进行连接3334 //接受来自老师的信息35 char recvBuf[100];36 recv(sockClient,recvBuf,100,0);37 printf(“来自老师的信息：\\n%s\\n”,recvBuf);3839 //发送信息给老师40 send(sockClient,”姓名：小明 学号：123456789，IP地址：192.168.1.14!”,strlen(“姓名：小明 学号：123456789，IP地址：192.168.1.14!”)+1,0);4142 closesocket(sockClient);43 WSACleanup();44 } 模拟运行结果如下： 作者：tornadomeet 出处：http://www.cnblogs.com/tornadomeet 2.C++实现//服务器 includeinclude // socket 所需要的头文件pragma comment(lib,”WS2_32.lib”)// link socket 库define PORT 9999define BUFLEN 1024using namespace std;int main(){ WSADATA wsaData; // 1 启动并初始化winsock(WSAStarup) if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData))//成功返回0 { return FALSE; } //2 创建套接字(socket) SOCKET sServer = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(INVALID_SOCKET == sServer) { WSACleanup(); return FALSE; } //3 准备通信地址 SOCKADDR_IN addrServer; addrServer.sin_family = AF_INET; addrServer.sin_port = htons(PORT); addrServer.sin_addr.s_addr = INADDR_ANY;//任意可用地址 //4 绑定地址与socket（bind） if (SOCKET_ERROR==bind(sServer, (const sockaddr)&amp;addrServer, sizeof(SOCKADDR_IN))) { closesocket(sServer); WSACleanup(); return FALSE; } //5 监听 （listen) if (SOCKET_ERROR == listen(sServer, SOMAXCONN)) { closesocket(sServer); WSACleanup(); } // 6 等待客户端连接（accpet） sockaddr_in addrClient; int addrClientLen = sizeof(addrClient); cout &lt;&lt; “服务器启动成功，等待客户端连接中。。。。” &lt;&lt; endl; SOCKET sClient = accept(sServer, (sockaddr )&amp;addrClient, &amp;addrClientLen); if (INVALID_SOCKET == sClient) { cout &lt;&lt; WSAGetLastError() &lt;&lt; endl; closesocket(sServer); closesocket(sClient); WSACleanup(); return FALSE; } //7 接收数据（recv） char recvBuf[BUFLEN]; ZeroMemory(recvBuf, sizeof(recvBuf)); if (SOCKET_ERROR == recv(sClient, recvBuf, sizeof(recvBuf), 0)) { closesocket(sServer); closesocket(sClient); WSACleanup(); return FALSE; } cout &lt;&lt; “客户端(“ &lt;&lt; inet_ntoa(addrClient.sin_addr) &lt;&lt; “:” &lt;&lt; addrClient.sin_port &lt;&lt; “):” &lt;&lt; recvBuf &lt;&lt; endl; //8 发送数据 char sendBuf[BUFLEN] = “你好客户端！”; if (SOCKET_ERROR==send(sClient, sendBuf, sizeof(sendBuf), 0)) { closesocket(sServer); closesocket(sClient); WSACleanup(); return FALSE; } system(“pause”); system(“pause”); return TRUE;}/注：1：MAKEWORD把参数组成一个WORD（双字节）类型数据并返回这个WORD类型数值，高位代表(修订本)号,低位字节指定主版本号（其代表）2：socket(AF_INET,//The Internet Protocol version 4 (IPv4) address familySOCK_STREAM,//, two-way,This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).IPPROTO_TCP//The Transmission Control Protocol (TCP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type parameter is SOCK_STREAM.) / //客户端 includeincludepragma comment(lib,”WS2_32.lib”)using namespace std; define BUFLEN 1024define PORT 9999void getIP(charszHostaddress);int main(){ WSADATA wsaData; // 1 启动并初始化winsock(WSAStarup) if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData))//成功返回0 { return FALSE; } //2 创建套接字(socket) SOCKET sHost = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (INVALID_SOCKET == sHost) { closesocket(sHost); WSACleanup(); return FALSE; } //3 准备通信地址 char szHostaddress[200]; getIP(szHostaddress); SOCKADDR_IN addrServer; addrServer.sin_family = AF_INET; addrServer.sin_port = htons(PORT); addrServer.sin_addr.s_addr = inet_addr(szHostaddress); //4 连接服务器（connect) if (SOCKET_ERROR == connect(sHost, (const sockaddr)&amp;addrServer, sizeof(addrServer))) { closesocket(sHost); WSACleanup(); return FALSE; } //5 发送数据 (send) char sendBuf[BUFLEN] = “你好服务器!”; if (SOCKET_ERROR == send(sHost, sendBuf, sizeof(sendBuf), 0)) { closesocket(sHost); WSACleanup(); return FALSE; } cout &lt;&lt; “客户端发送消息成功！” &lt;&lt; endl; //7 接收数据（recv） char recvBuf[BUFLEN]; ZeroMemory(recvBuf, sizeof(recvBuf)); if (SOCKET_ERROR == recv(sHost, recvBuf, sizeof(recvBuf), 0)) { closesocket(sHost); WSACleanup(); return FALSE; } cout &lt;&lt; “服务器发来的消息：” &lt;]]></content>
      <categories>
        <category>socket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day02_BigData渐进学习，aclear，fire~]]></title>
    <url>%2Fpost%2F7662e85e.html</url>
    <content type="text"><![CDATA[1.mini_centos的配置2.软件安装3.本地YUM源制作1.网络配置文件一起day01杂记_解决克隆虚拟机失败情况网络配置文件/etc/sysconfig/network 主机名/etc/sysconfig/network-scripts/ifcfg-eth0 网卡配置文件/etc/udev/rules.d/70-persistent-net.rules/etc/resolv.conf DNS服务/etc/hosts 修改hosts文件.***批量自动删除rpm包：rpm -qa | grep mysql | while read c; do rpm -e $c —nodeps; doneminimal最小化安装eth0默认没有自启用修改配置文件onboot=true修改静态地址后发现无法ping外网需要设置网关route add default gw 192.168.33.1添加nameservervi /etc/resolv.confnameserver 192.168.33.1 挂载光盘mkdir /mnt/cdrommount -t iso9660 -o ro /dev/cdrom/ /mnt/cdrom *解决克隆后eth0不见的问题(day02 1)直接修改 /etc/sysconfig/network-script/ifcfg-eth0 删掉UUID HWADDR 配置静态地址 然后： rm -rf /etc/udev/rules.d/70-persistent-net.rules或者修改这个文件： 将其中的eth1的物理地址赋值给eth0，然后删掉eth1的配置 然后 reboot —————-2.软件安装————sftp 192.168.78.200JDK ：wget http:// 进行对应网址下载到linux服务器上！软件安装1、如何上传安装包到服务器 可以使用图形化工具，如： filezilla,xftp可以使用sftp工具： alt+p 调出后，用put命令上传上传（如果不cd指定目录，则上传到当前用户的主目录）：sftp&gt; cd /home/sftp&gt; put C:\\Users\\Administrator\\Desktop\\day02\\soft\\jdk-7u45-linux-x64.tar.gz下载（lcd指定下载到本地的目标路径）sftp&gt; lcd d:/sftp&gt; get /home/jdk-7u45-linux-x64.tar.gz lrzsz//软件安装用 上传接受2、安装jdk压缩解压缩的相关命令**%%压缩解压缩%%root@mini1 ~]# gzip access.log[root@mini1 ~]# ll总用量 134892-rw-r—r—. 1 root root 68 4月 3 17:37 access.log.gz解压gz文件： gzip -d access.log.gz%%打包解包%% 将后方的 文件夹全部压缩成前方名字的压缩包。[root@mini1 ~]# tar -cvf myfirsttarball.tar aaa/aaa/aaa/2.txtaaa/3.txtaaa/1.txt解包：[root@mini1 ~]# tar -xvf myfirsttarball.taraaa/aaa/2.txtaaa/3.txtaaa/1.txt%%一次性完成打包&amp;&amp;压缩的操作%%产生压缩包：[root@mini1 ~]# tar -zcvf my.tar.gz aaa/aaa/aaa/2.txtaaa/3.txtaaa/1.txt解压缩包：[root@mini1 ~]# tar -zxvf my.tar.gzaaa/aaa/2.txtaaa/3.txtaaa/1.txtlinux 凡是可执行命令，如果 $PATH 环境变量没有 必须 带有路径进行命令执行./ ####安装jdk的过程：解压安装包 tar -zxvf jdk-7u45-linux-x64.tar.gz -C apps/ 然后修改环境变量vi /etc/profile在文件最后添加export JAVA_HOME=/root/apps/jdk1.7.0_45export PATH=$PATH:$JAVA_HOME/bin保存退出*然后重新加载环境变量source /etc/profile// put -r 直接脱windows文件到linux当中3、安装rpm包软件，如mysql%%查看系统中安装的rpm包rpm -qa | grep mysql%%上传rpm安装包MySQL-client-5.5.48-1.linux2.6.x86_64.rpmMySQL-server-5.5.48-1.linux2.6.x86_64.rpmper .rpm%%安装perl依赖rpm -ivh perl*《可能会提示有包冲突，解决： rpm -e 冲突包名 —nodeps 》%%安装serverrpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm卸载冲突的rpm包rpm -e mysql-libs-5.1.73-5.el6_6.x86_64 —nodeps如果成功，会看到进度条，最后，有关于root密码设置的提示，一定要记下来这个版本的提示是，先启动serverservice mysql start然后/usr/bin/mysql_secure_installation 命令去交互式修改root密码%%修改密码时，提示需要先安装clientrpm -ivh MySQL-client-5.5.48-1.linux2.6.x86_64.rpm客户端安装成功后，记得还要用/usr/bin/mysql_secure_installation 命令去交互式修改root密码%%登录验证mysql -uroot -proot 正式版本安装mysql： 上传MySQL-server-5.5.48-1.linux2.6.x86_64.rpm、MySQL-client-5.5.48-1.linux2.6.x86_64.rpm到Linux上 使用rpm命令安装MySQL-server-5.5.48-1.linux2.6.x86_64.rpm，缺少perl依赖 rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm 安装perl依赖，上传6个perl相关的rpm包 rpm -ivh perl-* 再安装MySQL-server，rpm包冲突 rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm 卸载冲突的rpm包 rpm -e mysql-libs-5.1.73-5.el6_6.x86_64 —nodeps 再安装MySQL-client和MySQL-server rpm -ivh MySQL-client-5.5.48-1.linux2.6.x86_64.rpm rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm 启动MySQL服务，然后初始化MySQL service mysql start /usr/bin/mysql_secure_installation 测试MySQL mysql -u root -p 安装过程中的提示为：PLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER !To do so, start the server, then issue the following commands:/usr/bin/mysqladmin -u root password ‘new-password’/usr/bin/mysqladmin -u root -h aclear password ‘new-password’Alternatively you can run:/usr/bin/mysql_secure_installation注意：netstat -nltp //查看对应的正在运行的服务进程 安装Tomcat 上传apache-tomcat-7.0.68.tar.gz到Linux上 解压tomcat tar -zxvf apache-tomcat-7.0.68.tar.gz -C /usr/local/ 启动tomcat /usr/local/apache-tomcat-7.0.68/bin/startup.sh 查看tomcat进程是否启动 jps 查看tomcat进程端口 netstat -anpt | grep 2465 通过浏览器访问tomcat http://192.168.0.101:8080/ 3.本地yum源制作本地YUM源制作 YUM相关概念1.1. 什么是YUMYUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。1.2. YUM的作用在Linux上使用源码的方式安装软件非常满分，使用yum可以简化安装的过程 YUM的常用命令安装httpd并确认安装yum instll -y httpd列出所有可用的package和package组yum list清除所有缓冲数据yum clean all列出一个包所有依赖的包yum deplist httpd删除httpdyum remove httpd 制作本地YUM源3.1. 为什么要制作本地YUM源YUM源虽然可以简化我们在Linux上安装软件的过程，但是生成环境通常无法上网，不能连接外网的YUM源，说以接就无法使用yum命令安装软件了。为了在内网中也可以使用yum安装相关的软件，就要配置yum源。3.2. YUM源的原理YUM源其实就是一个保存了多个RPM包的服务器，可以通过http的方式来检索、下载并安装相关的RPM包3.3. 制作本地YUM源1.准备一台Linux服务器，用最简单的版本CentOS-6.7-x86_64-minimal.iso2.配置好这台服务器的IP地址3.上传CentOS-6.7-x86_64-bin-DVD1.iso到服务器4.将CentOS-6.7-x86_64-bin-DVD1.iso镜像挂载到某个目录mkdir /var/isomount -o loop CentOS-6.7-x86_64-bin-DVD1.iso /var/isoCentOS自动记载光盘镜像文件到：mount -o loop /dev/cdrom /var/iso注意：因为 /dev/cdrom -&gt; sr0 只是指针的指向。并不是一个文件夹，所以我们应该自己手动挂载到一个文件夹这样才能看到对应文件夹5.修改本机上的YUM源配置文件，将源指向自己备份原有的YUM源的配置文件cd /etc/yum.repos.d/rename .repo .repo.bak vi CentOS-Local.repo[base]name=CentOS-Localbaseurl=file:///var/isogpgcheck=1enabled=1 #很重要，1才启用gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6添加上面内容保存退出6.清除YUM缓冲yum clean all7.列出可用的YUM源yum repolist8.安装相应的软件yum install -y httpd9.开启httpd使用浏览器访问http://192.168.0.100:80（如果访问不通，检查防火墙是否开启了80端口或关闭防火墙）service httpd start10.将YUM源配置到httpd（Apache Server）中，其他的服务器即可通过网络访问这个内网中的YUM源了cp -r /var/iso/ /var/www/html/CentOS-6.711.取消先前挂载的镜像umount /var/iso12.在浏览器中访问http://192.168.0.100/CentOS-6.7/13.让其他需要安装RPM包的服务器指向这个YUM源，准备一台新的服务器，备份或删除原有的YUM源配置文件cd /etc/yum.repos.d/rename .repo .repo.bak vi CentOS-Local.repo[base]name=CentOS-Localbaseurl=http://192.168.0.100/CentOS-6.7gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6添加上面内容保存退出14.在这台新的服务器上执行YUM的命令yum clean allyum repolist15.安装相应的软件yum install -y gcc16、加入依赖包到私有yum的repository进入到repo目录执行命令： createrepo . 高并发网站技术架构演变:]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ssh免密码登陆及其原理]]></title>
    <url>%2Fpost%2Fd7aef0f8.html</url>
    <content type="text"><![CDATA[ssh 无密码登录要使用公钥与私钥。linux下可以用用ssh-keygen生成公钥/私钥对，下面我以CentOS为例。 有机器A(192.168.1.155)，B(192.168.1.181)。现想A通过ssh免密码登录到B。 1.在A机下生成公钥/私钥对。 [chenlb@A ~]$ ssh-keygen -t rsa -P ‘’ 直接ssh-keygen然后三次回车就可以了。 -P表示密码，-P ‘’ 就表示空密码，也可以不用-P参数，这样就要三车回车，用-P就一次回车。 它在/home/chenlb下生成.ssh目录，.ssh下有id_rsa和id_rsa.pub。 2.把A机下的id_rsa.pub复制到B机下，在B机的.ssh/authorized_keys文件里，我用scp复制。（如果B机器没有.ssh和authorized_keys文件则创建这个文件夹和文件先） [chenlb@A ~]$ scp .ssh/id_rsa.pub chenlb@192.168.1.181:/home/chenlb/id_rsa.pub chenlb@192.168.1.181’s password: id_rsa.pub 100% 223 0.2KB/s 00:00 由于还没有免密码登录的，所以要输入密码。 3.B机把从A机复制的id_rsa.pub添加到.ssh/authorzied_keys文件里。 [chenlb@B ~]$ cat id_rsa.pub &gt;&gt; .ssh/authorized_keys [chenlb@B ~]$ chmod 600 .ssh/authorized_keys authorized_keys的权限要是600。 4.A机登录B机。 [chenlb@A ~]$ ssh 192.168.1.181 The authenticity of host ‘192.168.1.181 (192.168.1.181)’ can’t be established. RSA key fingerprint is 00:a6:a8:87:eb:c7:40:10:39:cc:a0:eb:50:d9:6a:5b. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added ‘192.168.1.181’ (RSA) to the list of known hosts. Last login: Thu Jul 3 09:53:18 2008 from chenlb [chenlb@B ~]$ 第一次登录是时要你输入yes。 现在A机可以无密码登录B机了。 小结：登录的机子可有私钥，被登录的机子要有登录机子的公钥。这个公钥/私钥对一般在私钥宿主机产生。上面是用rsa算法的公钥/私钥对，当然也可以用dsa(对应的文件是id_dsa，id_dsa.pub) 想让A，B机无密码互登录，那B机以上面同样的方式配置即可。 ———————————————————————————————————————————————————————————————————————————————————————————————————————— SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH 协议可以有效防止远程管理过程中的信息泄露问题。 从客户端来看，SSH提供两种级别的安全验证： 1、基于口令的验证 只要知道帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但缺点是：不能保证你正在连接的服务器就是你想连接的服务器。以下是我画了的登录验证流程： 当第一次链接远程主机时，会提示您当前主机的”公钥指纹”，询问您是否继续，如果选择继续后就可以输入密码进行登录了，当远程的主机接受以后，该台服务器的公钥就会保存到~/.ssh/known_hosts文件中。 2、基于密钥的验证 这种验证的前提是客户端需要生成一对密钥，将公钥放到需访问的远程服务器。这种验证比上一种的好处是，不能仿冒真正的服务器，因为要仿冒必须拿到客户端生成的公钥。缺点就是验证等待过程稍长些。 如何生成密钥： 1、在客户端打开终端，执行ssh-keygen，该命令会默认在~/.ssh/目录下创建id_rsa、id_rsa.pub两个文件，分别为您的公钥和私钥。 2、将公钥id_rsa.pub文件拷贝到服务器端的~/.ssh/authorized_keys文件中，有三种方法： 通过scp拷贝： 例：scp -P 22 ~/.ssh/id_rsa.pub user@host:~/authorized_keys #可选参数-P代表指定用端口号22 通过ssh-copyid程序： 在进行免密登录配置的时候：yum -y install expect #用到expect命令，但是一般是没有安装的. 注意在 执行这个命令之前 需要先进行。ssh-keygen #即先把本地的公钥、私钥生成了~ 例：ssh-copy-id user@host #此种方式简单，不需追加改文件名，但不能指定端口号，默认以22端口 通过cat方法： 例：cat ~/.ssh/id_rsa.pub | ssh -p 22 user@host ‘cat &gt;&gt; ~/.ssh/authorized_keys’ ---------------------------------------------------------------------------------------------------- 免密码登录原理 图解，server A免登录到server B: 1.在A上生成公钥私钥。 2.将公钥拷贝给server B，要重命名成authorized_keys(从英文名就知道含义了) 3.Server A向Server B发送一个连接请求。 4.Server B得到Server A的信息后，在authorized_key中查找，如果有相应的用户名和IP，则随机生成一个字符串，并用Server A的公钥加密，发送给Server A。 5.Server A得到Server B发来的消息后，使用私钥进行解密，然后将解密后的字符串发送给Server B。Server B进行和生成的对比，如果一致，则允许免登录。 总之：A要免密码登录到B，B首先要拥有A的公钥，然后B要做一次加密验证。对于非对称加密，公钥加密的密文不能公钥解开，只能私钥解开。]]></content>
      <categories>
        <category>Big Data</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day01_hadoop渐进学习，aclear，fire]]></title>
    <url>%2Fpost%2F6a8a330a.html</url>
    <content type="text"><![CDATA[Linux常用软件安装1. 课程目标1.1. 熟练使用Linux常用命令1.2. 熟练修改Linux的基本配置1.3. 熟练在Linux上安装JDK、Tomcat、MySQL软件2. 修改Linux的基本配置3. NAT之以太网局域网的配置**IP地址配置，最简单的一种 在命令运行 setup，带提示，按照提示修改即可 修改主机名 vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=server1.itcast.cn 修改ip地址 vi /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 HWADDR=00:0c:29:7d:a5:f3 TYPE=Ethernet UUID=ec6ae84a-f295-4e8e-9e2e-a9b7160ab8d4 ONBOOT=yes NM_CONTROLLED=yes BOOTPROTO=none IPADDR=192.168.78.200 NETMASK=255.255.255.0 GATEWAY=192.168.78.2 DNS1=192.168.78.2 IPV6INIT=no USERCTL=no service network restart 修改ip地址和主机名的映射关系 vi /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.0.101 server1.itcast.cn 关闭iptables并设置其开机启动/不启动 service iptables stop chkconfig iptables on chkconfig iptables off 3. 安装JDK 上传jdk-7u45-linux-x64.tar.gz到Linux上 解压jdk到/usr/local目录 tar -zxvf jdk-7u45-linux-x64.tar.gz -C /usr/local/ 设置环境变量，在/etc/profile文件最后追加相关内容 vi /etc/profile export JAVA_HOME=/usr/local/jdk1.7.0_45 export PATH=$PATH:$JAVA_HOME/bin 刷新环境变量 source /etc/profile 测试java命令是否可用 java -version 4. 安装Tomcat 上传apache-tomcat-7.0.68.tar.gz到Linux上 解压tomcat tar -zxvf apache-tomcat-7.0.68.tar.gz -C /usr/local/ 启动tomcat /usr/local/apache-tomcat-7.0.68/bin/startup.sh 查看tomcat进程是否启动 jps 查看tomcat进程端口 netstat -anpt | grep 2465 通过浏览器访问tomcat http://192.168.0.101:8080/ 5. 安装MySQL 上传MySQL-server-5.5.48-1.linux2.6.x86_64.rpm、MySQL-client-5.5.48-1.linux2.6.x86_64.rpm到Linux上 使用rpm命令安装MySQL-server-5.5.48-1.linux2.6.x86_64.rpm，缺少perl依赖 rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm 安装perl依赖，上传6个perl相关的rpm包 rpm -e perl-* 再安装MySQL-server，rpm包冲突 rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm 卸载冲突的rpm包 rpm -e mysql-libs-5.1.73-5.el6_6.x86_64 —nodeps 再安装MySQL-client和MySQL-server rpm -ivh MySQL-client-5.5.48-1.linux2.6.x86_64.rpm rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm 启动MySQL服务，然后初始化MySQL service mysql start /usr/bin/mysql_secure_installation 测试MySQL mysql -u root -p 命令课程中所用的linux命令：linux的命令操作1、日常操作命令查看当前所在的工作目录pwd 查看当前系统的时间date查看有谁在线（哪些人登陆到了服务器）who 查看当前在线last 查看最近的登陆历史记录2、文件系统操作 ls / 查看根目录下的子节点（文件夹和文件）信息ls -al -a是显示隐藏文件 -l是以更详细的列表形式显示切换目录cd /home 创建文件夹mkdir aaa 这是相对路径的写法mkdir -p aaa/bbb/cccmkdir /data 这是绝对路径的写法删除文件夹rmdir 可以删除空目录rm -r aaa 可以把aaa整个文件夹及其中的所有子节点全部删除rm -rf aaa 强制删除aaa 修改文件夹名称mv aaa angelababy创建文件touch somefile.1 创建一个空文件echo “i miss you,my baby” &gt; somefile.2 利用重定向“&gt;”的功能，将一条指令的输出结果写入到一个文件中，会覆盖原文件内容echo “huangxiaoming ,gun dan” &gt;&gt; somefile.2 将一条指令的输出结果追加到一个文件中，不会覆盖原文件内容用vi文本编辑器来编辑生成文件**最基本用法vi somefile.41、首先会进入“一般模式”，此模式只接受各种快捷键，不能编辑文件内容2、按i键，就会从一般模式进入编辑模式，此模式下，敲入的都是文件内容3、编辑完成之后，按Esc键退出编辑模式，回到一般模式；4、再按：，进入“底行命令模式”，输入wq命令，回车即可**一些常用快捷键一些有用的快捷键（在一般模式下使用）：a 在光标后一位开始插入A 在该行的最后插入I 在该行的最前面插入gg 直接跳到文件的首行G 直接跳到文件的末行dd 删除行，如果 5dd ，则一次性删除光标后的5行yy 复制当前行, 复制多行，则 3yy，则复制当前行附近的3行p 粘贴v 进入字符选择模式，选择完成后，按y复制，按p粘贴ctrl+v 进入块选择模式，选择完成后，按y复制，按p粘贴shift+v 进入行选择模式，选择完成后，按y复制，按p粘贴查找并替换（在底行命令模式中输入）%s/sad/88888888888888 效果：查找文件中所有sad，替换为88888888888888/you 效果：查找文件中出现的you，并定位到第一个找到的地方，按n可以定位到下一个匹配位置（按N定位到上一个）后退与前进在vi中按u可以撤销一次操作u 撤销上一步的操作Ctrl+r 恢复上一步被撤销的操作注意：如果你输入“u”两次，你的文本恢复原样，那应该是你的Vim被配置在Vi兼容模式了。重做如果你撤销得太多，你可以输入CTRL-R（redo）回退前一个命令。换句话说，它撤销一个撤销。要看执行的例子，输入CTRL-R两次。字符A和它后面的空格就出现了：young intelligent turtle有一个特殊版本的撤销命令：“U”（行撤销）。行撤销命令撤销所有在前一个编辑行上的操作。 输入这些命令两次取消前一个“U”：A very intelligent turtlexxxx 删除veryA intelligent turtlexxxxxx 删除turtleA intelligent用“U”恢复行A very intelligent turtle用“u”撤销“U”A intelligent“U”命令自己改变自己，“u”命令撤销操作，CTRL-R命令重做操作。这有点乱，但不用担心，用“u”和CTRL-R命令你可以切换到任何状态。流行的文本编辑器通常都有前进和后退功能，可以在文件中曾经浏览过的位置之间来回移动。在 vim 中使用 Ctrl-O 执行后退，使用 Ctrl-I 执行前进。相关帮助： :help CTRL-O :help CTRL-I :help jump-motions 拷贝文件cp somefile.1 /home/hadoop/somefile.2*查看文件内容cat somefile 一次性将文件内容全部输出（控制台）more somefile 可以翻页查看, 下翻一页(空格) 上翻一页（b） 退出（q）less somefile 可以翻页查看,下翻一页(空格) 上翻一页（b），上翻一行(↑) 下翻一行（↓） 可以搜索关键字（/keyword）tail -10 install.log 查看文件尾部的10行tail -f install.log 小f跟踪文件的唯一inode号，就算文件改名后，还是跟踪原来这个inode表示的文件tail -F install.log 大F按照文件名来跟踪head -10 install.log 查看文件头部的10行3、文件权限的操作linux文件权限的描述格式解读drwxr-xr-x （也可以用二进制表示 111 101 101 —&gt; 755）d：标识节点类型（d：文件夹 -：文件 l:链接）r：可读 w：可写 x：可执行第一组rwx： 表示这个文件的拥有者对它的权限：可读可写可执行第二组r-x： 表示这个文件的所属组对它的权限：可读，不可写，可执行第三组r-x： 表示这个文件的其他用户（相对于上面两类用户）对它的权限：可读，不可写，可执行 修改文件权限chmod g-rw haha.dat 表示将haha.dat对所属组的rw权限取消chmod o-rw haha.dat 表示将haha.dat对其他人的rw权限取消chmod u+x haha.dat 表示将haha.dat对所属用户的权限增加x也可以用数字的方式来修改权限chmod 664 haha.dat就会修改成 rw-rw-r—如果要将一个文件夹的所有内容权限统一修改，则可以-R参数chmod -R 770 aaa/chown angela:angela aaa/ &lt;只有root能执行&gt;目录没有执行权限的时候普通用户不能进入文件只有读写权限的时候普通用户是可以删除的(删除文件不是修改它,是操作父及目录),只要父级目录有执行和修改的权限注意：当我们的 bbb目录下”haha.dat”权限是400时 我们照样可以删除 haha.dat ————即W权限是对haha.dat做出了写修改！ 如果不让删除haha.dat 就把bbb 目录的权限修改为不让写（dr-x———）这样子，haha.dat就删除不了了！ 因为我们删除haha.dat的操作是对父目录进行的！4、基本的用户管理*添加用户useradd angela要修改密码才能登陆passwd angela 按提示输入密码即可chown root:root haha.dat将文件当前的用户和组修改为 root为用户配置sudo权限用root编辑 vi /etc/sudoers在文件的如下位置，为hadoop添加一行即可root ALL=(ALL) ALLhadoop ALL=(ALL) ALL然后，hadoop用户就可以用sudo来执行系统级别的指令[hadoop@shizhan ~]$ sudo useradd huangxiaoming5、系统管理操作*查看主机名hostname修改主机名(重启后无效)hostname hadoop*修改主机名(重启后永久生效)vi /ect/sysconfig/network修改IP(重启后无效)ifconfig eth0 192.168.12.22 修改IP(重启后永久生效)vi /etc/sysconfig/network-scripts/ifcfg-eth0mount 挂载外部存储设备到文件系统中mkdir /mnt/cdrom 创建一个目录，用来挂载mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom/ 将设备/dev/cdrom(挂在上就在这)挂载到 挂载点 ： /mnt/cdrom中（默认是在media中） 文件系统 读写权限（read only） 光驱的设备名称*umountumount /mnt/cdrom*统计文件或文件夹的大小du -sh /mnt/cdrom/Packages//du -sh / 查看根目录下所有文件夹 统计的大小df -h 查看磁盘的空间！！！关机halt 重启reboot**shell里面如果新建session或者使用命令行直接登录系统ssh root@192.168.**.*远程拷贝到另一台 linux远程服务器上面scp haha.dat root@192.168.78.199:/home///下一步就让输入 root对应的密码**配置主机之间的免密ssh登陆假如 A 要登陆 B在A上操作：%%首先生成密钥对ssh-keygen (提示时，直接回车即可)%%再将A自己的公钥拷贝并追加到B的授权列表文件authorized_keys中ssh-copy-id B**后台服务管理service network status 查看指定服务的状态service network stop 停止指定服务service network start 启动指定服务service network restart 重启指定服务service —status-all 查看系统中所有的后台服务设置后台服务的自启配置chkconfig 查看所有服务器自启配置chkconfig iptables off 关掉指定服务的自动启动chkconfig iptables on 开启指定服务的自动启动//vi /etc/inittab 下面的配置，表示 0 1 2 3 4 5 6 对应在什么系统，进行自启动的关闭或开启*系统启动级别管理vi /etc/inittab# Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)#id:3:initdefault:---------注意用自己的公钥存放在自己的 密钥池中自动化操作 启动某些进程，不一定在哪进行 本机不确定启不启动。所以最好在windows当中启动一下ssh。然后在此时再 ssh root@192.168.78.199 在连接一次本机！ --------- service —status-all | grep httpd 注意这个 “|” 是管道函数——即前方命令 的输出 ，当做管道后方的输入；然后在输入当中查找 httpd！ 注意：在进行平时的学习]]></content>
      <categories>
        <category>Big Data</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[6级复习]]></title>
    <url>%2Fpost%2F8c2d4240.html</url>
    <content type="text"><![CDATA[阅读理解填空、匹配、阅读 作文 翻译 听力 单词 1、 可以在 14 日或15 日早间 9:00 或下午 3:00 进行一次完整的模拟考试，不关注结果， 只关注时间控制； 2、 全面停止做新题，新题中的错误会让你更加慌乱；最后两日只有两个重点：背已经背过 但是不够熟练的词语（尤其是准确答案中的）；浏览或者重做已经做过的题目（尤其是 错题）； 3、 手边随时拿着做过的真题集，用各种重复，加强印象； 4、 做听力时，听不懂，还继续听，就属于浪费时间，建议停止，打开原文，看懂再合上书 本听，听懂后，再听新材料； 5、 做阅读时，发现大段文字都读得含义模糊，只能看懂大意，建议逐句进行翻译（口头即 可），发现翻译不出来的，就是之前做题没有全部消化的部分； 6、 最后写两篇文章，争取把自己背过的模板句都用进来； 7、 反复浏览翻译部分的准确答案，有必要的话，可以尝试背会； 8、 不要再纠结听不懂，读不快，一做题就紧张这样的无价值问题，一切均源自于之前练习 不足实力太弱；与其无聊的哀鸣，不如背写几个模板句，听些听力，背些单词来的有用； 9、 文具，收音工具，证件之类的，可以开始准备了； 10、 看完本篇文章就下线，排除干扰，安静准备。]]></content>
      <categories>
        <category>日记之家</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android——Android Bundle详解【转】]]></title>
    <url>%2Fpost%2F3e5b391e.html</url>
    <content type="text"><![CDATA[1 Bundle介绍Bundle主要用于传递数据；它保存的数据，是以key-value(键值对)的形式存在的。 我们经常使用Bundle在Activity之间传递数据，传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口。下面分别介绍Activity之间如何传递基本类型、传递对象。 2传递基本类型Bundle提供了各种常用类型的putXxx()/getXxx()方法，用于读写基本类型的数据。Bundle操作基本数据类型的API表格如下所示： 写数据的方法如下： // “com.test” is the package name of the destination class// “com.test.Activity02” is the full class path of the destination classIntent intent = new Intent().setClassName(“com.bundletest”, “com.bundletest.Bundle02”);Bundle bundle = new Bundle();bundle.putString(“name”, “skywang”);bundle.putInt(“height”, 175);intent.putExtras(bundle);startActivity(intent);// end current classfinish(); 对应的读数据的方法如下： Bundle bundle = this.getIntent().getExtras();String name = bundle.getString(“name”);int height = bundle.getInt(“height”); 3传递Parcelable类型的对象3.1 Parcelable说明Parcelable是Android自定义的一个接口，它包括了将数据写入Parcel和从Parcel中读出的API。一个实体（用类来表示），如果需要封装到bundle消息中去，可以通过实现Parcelable接口来实现。 Parcelable和Serializable的API如下表： 3.2 Parcelable接口说明 public interface Parcelable { //内容描述接口，基本不用管 public int describeContents(); //写入接口函数，打包 public void writeToParcel(Parcel dest, int flags); //读取接口，目的是要从Parcel中构造一个实现了Parcelable的类的实例处理。因为实现类在这里还是不可知的，所以需要用到模板的方式，继承类名通过模板参数传入。 //为了能够实现模板参数的传入，这里定义Creator嵌入接口,内含两个接口函数分别返回单个和多个继承类实例。 public interface Creator { public T createFromParcel(Parcel source); public T[] newArray(int size); }} 3.3 Parcelable接口的实现方法从parcelable接口定义中，我们可以看到，实现parcelable接口，需要我们实现下面几个方法： (01)describeContents方法。内容接口描述，默认返回0就可以; (02)writeToParcel 方法。该方法将类的数据写入外部提供的Parcel中.即打包需要传递的数据到Parcel容器保存，以便从parcel容器获取数据，该方法声明如下： writeToParcel(Parcel dest, int flags) 具体参数含义见doc文档 (3.)静态的Parcelable.Creator接口，本接口有两个方法： createFromParcel(Parcelin) 从Parcel容器中读取传递数据值，封装成Parcelable对象返回逻辑层。 newArray(int size) 创建一个类型为T，长度为size的数组，仅一句话（returnnew T[size])即可。方法是供外部类反序列化本类数组使用。 4传递Serializable类型的对象4.1 Serializable说明Serializable是一个对象序列化的接口。一个类只有实现了Serializable接口，它的对象才是可序列化的。因此如果要序列化某些类的对象，这些类就必须实现Serializable接口。而实际上，Serializable是一个空接口，没有什么具体内容，它的目的只是简单的标识一个类的对象可以被序列化。 4.2 Serializable接口的实现方法很简单，只要implements Serializable接口就可以了 5 demo演示程序下面是对实现上述三种数据传递方式的BundleTest(demo程序)进行简要介绍 5.1 demo概要BundleTest共包含了4个java文件和2个layout文件(main.xml和main2.xml) Bundle01.java —— 默认的主Activity窗口。 Bundle02.java —— 主Activity用于跳转的目的窗口。 Book.java —— 实现Parcelable接口的类 Person.java —— 实现Serializable接口的类 main.xml —— Bundle01.java的layout文件 main2.xml —— Bundle02.java的layout文件 工程文件结构如下所示： 5.2代码AndroidManifest.xml &lt;?xml version=”1.0” encoding=”utf-8”?&gt; main.xml &lt;?xml version=”1.0” encoding=”utf-8”?&gt; main2.xml &lt;?xml version=”1.0” encoding=”utf-8”?&gt; strings.xml &lt;?xml version=”1.0” encoding=”utf-8”?&gt; Hello MyBundleTest! MyBundleTest Bundle\_01 Bundle\_02 Bundle Basic Data Bundle Parcelable Data Bundle Seriable Data Jump Back to Bundler01 Bundle01.java package com.bundletest;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.content.Intent;import android.util.Log;public class Bundle01 extends Activity implements View.OnClickListener{ private static final String TAG = “skywang—&gt;Bundle01”; private Button mBtnBasic = null; private Button mBtnPar = null; private Button mBtnSer = null; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); mBtnBasic = (Button) findViewById(R.id.btnBasic); mBtnBasic.setOnClickListener(this); mBtnPar = (Button) findViewById(R.id.btnPar); mBtnPar.setOnClickListener(this); mBtnSer = (Button) findViewById(R.id.btnSer); mBtnSer.setOnClickListener(this); } @Override public void onClick(View view) { switch (view.getId()) { case R.id.btnBasic: sendBasicDataThroughBundle(); break; case R.id.btnPar: sendParcelableDataThroughBundle(); break; case R.id.btnSer: sendSeriableDataThroughBundle(); break; default: break; } } // sent basic data, such as int, strin, etc… through bundle private void sendBasicDataThroughBundle(){ // “com.test” is the package name of the destination class // “com.test.Activity02” is the full class path of the destination class Intent intent = new Intent().setClassName(“com.bundletest”, “com.bundletest.Bundle02”); Bundle bundle = new Bundle(); bundle.putString(“name”, “skywang”); bundle.putInt(“height”, 175); intent.putExtras(bundle); startActivity(intent); // end current class finish(); } // sent object through Pacelable private void sendParcelableDataThroughBundle(){ Intent intent = new Intent().setClassName(“com.bundletest”, “com.bundletest.Bundle02”); Book mBook = new Book(); mBook.setBookName(“Android”); mBook.setAuthor(“skywang”); mBook.setPublishTime(2013); Bundle mBundle = new Bundle(); mBundle.putParcelable(“ParcelableValue”, mBook); intent.putExtras(mBundle); startActivity(intent); finish(); } // sent object through seriable private void sendSeriableDataThroughBundle(){ Intent intent = new Intent().setClassName(“com.bundletest”, “com.bundletest.Bundle02”); Person mPerson = new Person(); mPerson.setName(“skywang”); mPerson.setAge(24); Bundle mBundle = new Bundle(); mBundle.putSerializable(“SeriableValue”,mPerson); intent.putExtras(mBundle); startActivity(intent); finish(); }} Bundle02.java package com.bundletest;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.content.Intent;import android.util.Log;public class Bundle02 extends Activity implements View.OnClickListener { private static final String TAG = “skywang—&gt;Bundle02”; private Button mBtnBack = null; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main2); mBtnBack = (Button) findViewById(R.id.btnBack); mBtnBack.setOnClickListener(this); receiveBasicData(); receiveParcelableData(); receiveSeriableData(); } private void receiveBasicData() { Bundle bundle = this.getIntent().getExtras(); String name = bundle.getString(“name”); int height = bundle.getInt(“height”); if (name != null &amp;&amp; height != 0) Log.d(TAG, “receice basic data — “ + “name=”+name+”, height=”+height); } private void receiveParcelableData() { Book mBook = (Book)getIntent().getParcelableExtra(“ParcelableValue”); if (mBook != null) Log.d(TAG, “receice parcel data — “ + “Book name is: “ + mBook.getBookName()+”, “+ “Author is: “ + mBook.getAuthor() + “, “+ “PublishTime is: “ + mBook.getPublishTime()); } private void receiveSeriableData() { Person mPerson = (Person)getIntent().getSerializableExtra(“SeriableValue”); if (mPerson != null) Log.d(TAG, “receice serial data — “ + “The name is:” + mPerson.getName() + “, “+ “age is:” + mPerson.getAge()); } @Override public void onClick(View view) { switch (view.getId()) { case R.id.btnBack: { // “com.test” is the package name of the destination class // “com.test.Activity01” is the full class path of the destination class Intent intent = new Intent().setClassName(“com.bundletest”, “com.bundletest.Bundle01”); startActivity(intent); // end current class finish(); } break; default: break; } }} Book.java package com.bundletest;import android.os.Parcel;import android.os.Parcelable;public class Book implements Parcelable { private String bookName; private String author; private int publishTime; public String getBookName() { return bookName; } public void setBookName(String bookName) { this.bookName = bookName; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public int getPublishTime() { return publishTime; } public void setPublishTime(int publishTime) { this.publishTime = publishTime; } public static final Parcelable.Creator CREATOR = new Creator() { @Override public Book createFromParcel(Parcel source) { Book mBook = new Book(); mBook.bookName = source.readString(); mBook.author = source.readString(); mBook.publishTime = source.readInt(); return mBook; } @Override public Book[] newArray(int size) { return new Book[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel parcel, int flags) { parcel.writeString(bookName); parcel.writeString(author); parcel.writeInt(publishTime); }} Person.java package com.bundletest;import java.io.Serializable;public class Person implements Serializable { private static final long serialVersionUID = 1L; private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 5.3输出图片Bundle01.java对应的界面如下： 点击“Bundle Basic Data”、“Bundle Parcelable Data”、“Bundle Seriable Data”均跳转到如下界面，但它们对应的logcat信息不同。 点击“Bundle Basic Data”的logcat如下： 点击“Bundle Parcelable Data”的logcat如下： 点击“Bundle Seriable Data”的logcat如下： 转自：http://www.cnblogs.com/skywang12345/archive/2013/03/06/3165555.html]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[View inflate方法和LayoutInflater inflate方法的区别详解]]></title>
    <url>%2Fpost%2F65de7690.html</url>
    <content type="text"><![CDATA[《第二行代码》当中的第三章的ListView以及RecycleView当中出现的LayoutInflater.inflate()和 我们在核心代码当中的View.inflate() 当中的“打气筒”参数在子项&lt;数值&gt;当中加载传入的布局. P.S.Inflate可用于将一个xml中定义的布局控件找出来. 因为在一个Activity里如果直接用findViewById()的话,对应的是setConentView()的那个layout里的组件。因此如果当前Activity里需要用到别的layout（xml文件）,比如对话框上的layout,这时还要设置对话框上的layout里的组件(像图片ImageView,文字TextView)上的内容,所以，就必须用inflate()先将对话框的layout找出来,然后再用这个layout对象去找到它上面的组件,如: View view=View.inflate(this,R.layout.dialog_layout,null); TextViewdialogTV=(TextView)view.findViewById(R.id.dialog_tv); dialogTV.setText(“abcd”); 如果直接用this.findViewById(R.id.dialog_tv)肯定会报错. 生成LayoutInflater的方法： 上文示例中写的方法来创建inflate一般不常用，一般通过LayoutInflater来创建inflate。主要有三种方式可以生成LayoutInflater： LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View layout = inflater.inflate(R.layout.main, null); LayoutInflater inflater = LayoutInflater.from(context); 原创文章，转载请注明出处：http://www.cnblogs.com/baipengzhan/p/6257510.html 我们在Android开发中，对于将布局填充成View对象，最常用的两种办法是：View类的方法inflate和LayoutInflater类的inflate方法， 今天有朋友问到这两种填充方法的区别，就查看了一下两者的区别，写成文章，以方便有需要的人。 首先我们要清楚两者大致的区别，之后我们再来慢慢看两者具体的不同之处。 LayoutInflater类的inflate方法适用于所有需要进行布局填充的场景，是Android中专门进行布局填充的方法，Android中其他需要 使用布局填充的地方，都会调用本方法，而不是View类中的inflate方法。该方法不是静态方法，需要先创建LayoutInflater类的对象 才能调用。 View类中的inflate方法内部包裹了LayoutInflater类的inflate方法，这个方法是一个静态方法，不需要创建View类的对象，直接使用 View类名调用，相比上一种方法是一种简便方法。但很明显，这个方法不如上一个方法功能强大。 若是您只想大概了解两者的区别，您读到这里已经足够了，下面的分析较为详细，请根据您的需要阅读下面的内容。 现在我们开始慢慢的研究两者具体的不同之处。 因为LayoutInflater类的inflate方法是所有布局填充方法的基石，我们先来看看这个方法吧。 我们从Google官方的SDK中的定义入手，得到比较标准的概念。 关于LayoutInflater类 该类是一个抽象类，继承自Object，存在于android.view包下。接下来我们只看和本文相关的内容， 不会再做过多的扩展。 以下是SDK中的叙述： Instantiates a layout XML file into its corresponding View objects. It is never used directly. Instead, use getLayoutInflater() or getSystemService(String) to retrieve a standard LayoutInflater instance that is already hooked up to the current context and correctly configured for the device you are running on. For example: 1 LayoutInflater inflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); To create a new LayoutInflater with an additional LayoutInflater.Factory for your own views, you can use cloneInContext(Context) to clone an existing ViewFactory, and then call setFactory(LayoutInflater.Factory) on it to include your Factory. For performance reasons, view inflation relies heavily on pre-processing of XML files that is done at build time. Therefore, it is not currently possible to use LayoutInflater with an XmlPullParser over a plain XML file at runtime; it only works with an XmlPullParser returned from a compiled resource (R._something_ file.) 翻译和阐述： LayoutInflater类的作用是，将xml布局文件实例化为它对应的View对象。这个类不能直接使用，也就是不能直接调用其中的成员。一般，我们通过getLayoutInflater()方法或者 getSystemService(String) 方法来获得该类的实例，通过以上两个方法获得的LayoutInflater类实例，已经和当前的上下文关联起来，并且已经正确配置在当前程序运行的设备上。我们顺便说一下这两个获得实例的方法：getLayoutInflater()方法， 并不是上下文的方法，Activity类有这个方法，不需要传入参数，在Activity中直接调用即可。Fragment类也有这个方法，但是需要传入一个Bundle对象作为参数。可以看到，通过该方法获得的LayoutInflater类对象 和上下文环境相配合。getSystemService(String)方法是Context的方法，需要传入Context的成员变量作为参数，获得相应的对象，要获得LayoutInflater对象，需要传入Context.LAYOUT_INFLATER_SERVICE 以上介绍的LayoutInflater类是Android系统为我们提供的通用类，如果我们想要为我们的View对象创建专用的LayoutInflater类，则可以用到LayoutInflater.Factory ，这是一个LayoutInflater类内部的接口，通过 工厂设计模式可以使我们获得定制的专用LayoutInflater类。我们可以使用cloneInContext(Context)来克隆一个已经存在的ViewFactory，然后调用setFactory(LayoutInflater.Factory)方法，将我们创建好的 工厂包括进来。在这里我大概说明一下这段话的意思和作用：当我在一个上下文环境中创建好了一个LayoutInflater工厂之后，我们又想在另一个上下文环境中使用这个LayoutInflater工厂，那该怎么办？这里说的一种方法 是，我们在当前上下文环境中，使用LayoutInflater类对象调用cloneInContext(Context)方法，其中的参数填写新上下文对象，因为我们要在新的上下文环境中使用。然后接着调用setFactory(LayoutInflater.Factory)方法， 其中的参数就是我们目前创建的LayoutInflater工厂。这样创建完成后，我们在新上下文环境中，就可以调用目前上下文环境中绑定了LayoutInflater工厂的LayoutInflater类对象了。关于这里的更详细用法在本文中就不更多阐述了，有兴趣的朋友请参看我的另一篇文章。 xml文件在创建阶段的前处理过程严重影响View对象填充阶段的性能（进而影响整体软件的性能），这是因为inflate方法内部使用的pull解析，若是xml文件在进行填充之前已经被xml解析了，那么inflate方法在使用时就非常轻松，否则会非常困难。因此，我们不会使用LayoutInflater类处理普通的xml文件，而是用来处理已经编译的xml文件，例如R.··········，这样的xml文件会返回一个已经解析了xml文件的pull解析器，而普通的xml文件返回的解析器则不然。更详细的内容请参看我的另一篇文章。 好啦，通过以上介绍，我们大概对LayoutInflater类有了一个大概了解，之后我们来看以下这个类中的4个重载的inflate方法应该如何使用。 这4个方法中，有两个是通过XmlPullParser作为数据来源创建view对象，剩下两个就是我们平时常用的两个通过resource目录下的文件作为数据来源的方法。 前两个方法在此我们不做详细介绍，这两个方法我们平时工作根本不会用，但是Android源文件中则大量使用，后边我们详细介绍的方法内部就是用前两种实现的。今后我会在其他文章中细细的分析这两个方法的使用，希望能帮助到感兴趣的朋友。 接下来我们就看看下边两个常用方法的使用。 三个参数的方法 public View inflate (int resource, ViewGroup root, boolean attachToRoot)Inflate a new view hierarchy from the specified xml resource. Throws InflateException if there is an error. 从指定的xml文件生成新的view视图关系。出现错误时，抛出InflateException异常。 参数分析 第一个参数，就是我们要填充的xml文件 第二个参数，这个要和第三个参数有关系，大家慢慢看。若是第三个参数为true，那么第二个参数的意义是，从第一个参数填充成的view对象的父控件；若是第三个参数为false，那么第二个参数的意义是， 可以为第一个参数生成的view对象的根布局提供一系LayoutParams参数的控件。 第三个参数，从第一个参数填充成的view对象是否要附着到第二个参数指定的空间上作为子控件。 说明：第一个参数不需多说，我们一般就从resource目录下找到我们要填充的布局文件即可，切不可用普通的xml文件进行填充，除非我们自己做好了相应的xmlpullparser。 若第二个参数为null，也就是我们不指定父控件，那么新生产的view对象的根布局的某些参数会失效，比如Layout_width和Layout_height会失效，这个大家可以做实验尝试，无论第三个参数是什么。 关于该方法的使用只介绍到这里，更详细的用法请查找专门讲解该方法的文章。 返回：若提供了root，且第三个参数为true，则返回root作为根布局，否则，返回填充出的view对象的根布局作为根布局。 两个参数的用法 public View inflate (int resource, ViewGroup root)从指定的xml文件生成新的view视图关系。出现错误时，抛出InflateException异常。 参数分析： 第一个参数，要填充的xml文件。 第二个参数，生成的view对象的父控件。同样该参数可以为null。若提供了root，则返回root作为根布局，否则，返回填充出的view对象的根布局作为根布局。 该方法内部调用了三个参数的方法，请看下面源码： 1 2 3 public View inflate(``@LayoutRes int resource, ``@Nullable ViewGroup root) { return inflate(resource, root, root != ``null``); } 两个参数方法的使用完全和三个参数方法相对应，在此不做更多介绍。 关于View类的inflate方法 public static View inflate (Context context, int resource, ViewGroup root)Inflate a view from an XML resource. This convenience method wraps the LayoutInflater class, which provides a full range of options for view inflation. 将一个xml资源填充成一个view对象。这个简便的方法包裹了LayoutInflater类，后者提供了view对象填充的所有方法。 参数分析： 第一个参数，上下文 第二个参数，要填充的xml资源 第三个参数，填充成的view对象的根布局 说明，从SDK解释中的“convenience”一词中，我们就可以看到View类中inflate的主要特点，就是简便。它将LayoutInflater类封装，且是一个静态方法，便于调用。 以下为源码： 1 2 3 4 public static View inflate(Context context, ``@LayoutRes int resource, ViewGroup root) { LayoutInflater factory = LayoutInflater.from(context); return factory.inflate(resource, root); } 可以看到其内部也就是调用了LayoutInflater两个参数的inflate方法而已，已经在上面介绍过了，不再赘述。 好啦，那我们总结一下吧： LayoutInflater类的inflate方法适用于所有需要进行布局填充的场景，是Android中专门进行布局填充的方法，Android中其他需要 使用布局填充的地方，都会调用本方法，而不是View类中的inflate方法。该方法不是静态方法，需要先创建LayoutInflater类的对象 才能调用。 View类中的inflate方法内部包裹了LayoutInflater类的inflate方法，这个方法是一个静态方法，不需要创建View类的对象，直接使用 View类名调用，相比上一种方法是一种简便方法。但很明显，这个方法不如上一个方法功能强大。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[draw9patch详解]]></title>
    <url>%2Fpost%2F12b97dd5.html</url>
    <content type="text"><![CDATA[想了解更多的点这个地址吧： http://user.qzone.qq.com/469241633/infocenter#!app=2&amp;via=QZ.HashRefresh&amp;pos=1341830433 draw9patch.bat这个工具是在android的sdk目录中的tools里,首先来看一下运行它后的界面: 一、名字介绍 为什么叫9patch呢？Patch的中文意思是”片，块”的意思，那这里按中文的意思来说就是9片或9块.因此可想而知这个图片会被分为9片，如下图片所示 二、打开源图片 如果要制作一张9patch图片，就得先有图片源，也就是要制作成9patch图片的源图片,有了源图片，怎么用它来打开图片进行编辑呢？有三种方式可以进行打开: 1、点击菜单栏中的 “file”—&gt;”Open 9-patch…” 如图： 2、用键盘的快捷键”Ctrl+O”打开 3、在选中要打开的源图片文件，然后拖进draw9patch的工作区 三、制作9Patch 图片加载进来后，我们会看到图片的上下左右都各多了一像素，这几个狭小的地方就是让我们工作的地方，现在来介绍一下上下左右的四条像素分别表示的什么: 上面的一像素,在这里我可以用鼠标来点击，点击后，会看到黑色的小点，如图所示: 这里看上去不直观也不好介绍，先把下面工具栏中的Show patches选中,如果所示: 然后中间工作区中的图片就变成了: 这样了，这里中间紫色的区域就是我们上面画的黑色的小点所对的区域，如果我们按住Shift再左击黑色的小点的时候，我们可以看到，黑色的小点可以被擦除掉，并且它所对的紫色的区域也会变成绿色的。这紫色的区域代表什么呢？这紫色的区域代表被拉伸的区域,也就是说，当我们把这个图片设置成其它组件的背景的时候，如果所在的组件比较大，那么图片的这块区域就会被重复的绘制，而其它的部分则会不变，结果的效果就在工作区的右侧显示，如下图所示: 这里只画了上侧，上侧的黑点表示的是，横向拉伸的部分，如果不绘制左侧的话，那么纵向拉伸的区域默认会为紫色区域纵向的全部的都被拉伸。 左侧与上侧的所代表的意思差不多，只不过是代表绘制纵向的区域，这里就不重复的介绍，如图所示: 这里结果的效果就是当背景变大时，只有中间紫色的部分会被拉伸. 那这右侧与下侧的区域又有什么用呢？ 右侧与下侧的绘制与上侧和左侧的绘制流程都差不多，但表示的含义不一样，右侧表示纵向显示内容的区域，如果不画则代表纵向全部可显示内容，当绘制右侧后，选中下边工具栏中的Show content，如图所示: 再看工作区右边的效果显示栏中效果，就可以看见蓝色的区域，这片区域就是显示内容的地方，如图所示： 同样下侧的那一像素表示的也是显示内容的区域，但不同的是它表示的横向显示内容的区域.比如说：这个图片宽有30px,我们把下面的那一条线的横向的第20px到25px画上了黑点，那么这个图片设置成某个组件的背景后，这个组件的paddingleft就会设置成20dp,paddingRight就会设置成5dp,如果再在布局文件里面设置这两个值，那个这里画的黑点就不起作用了，同样右边的一排黑点也是一样，只不过设置的是paddingTop与paddingBottom,这里就不多介绍了。 四、高级运用 1、Show bad patches,这是工具上面的一个按钮，如图所示: 这个按钮有什么用呢？当我们绘制完上侧与左侧就可以点击这个按钮来观察绘制的结果是否符合建议要求，如下图所示，就是其中被选中的3块不符合要求: 这里它是根据什么来判断这个绘制的结果不符合要求呢？怎么就认为这三块不符合要求呢？它是根据左侧的黑色的小点所对过来的部分里面的每一个像素点的颜色是否一样，比如上图中的横向中间的两像素颜色就有细微的差异，如图所示： 这个要仔细看才能分辨出来，其中下面部分的颜色要深一点，这样的结果就是当背景变大的时候就有两种颜色要被重复的绘制，系统就不知道到底绘制这两种颜色哪一种多一点，因此这个工具建议被拉伸的区域只能选择一种颜色，如下图，再点击Show bad patches就没有效果了: 2、右下角坐标显示 如果对结果要求比较高的，这个就起作用了,如下图所示: 这个就是显示当前鼠标在图片中所在的为位置。如果有的什么，要求上边与下边或者左右与右边所不变的长度或宽度要一样，这样就得计算一下了，在绘制的时候就要看这个区域所显示的数字了，看开始和结束的位置是否是所计算得出来的数字。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++指针free()函数深入理解加思考]]></title>
    <url>%2Fpost%2F68c8139b.html</url>
    <content type="text"><![CDATA[今天由于老师代码中free（）函数过后又进行 =NULL操作特来反馈、回忆深入理解。 其实早在我的这篇文章当中就对于C++的一些指针的机制进行反思过。 自己对于已经学过去的知识并没有即使的反思回顾。导致遗忘。 对于C语言free()函数的一些反思上周在解决一道课后习题的时候，偶然间发现了一个自己从未注意过的问题，问题描述如下: 在遍历一个循环链表时，我发现在我调用free()函数删除了一个节点之后，仍然能用printf打印出原先的数据，起初我以为是巧合，并未加以注意。今天我又尝试free其他节点，之后仍然能够通过printf打印出原先的值，这个问题立刻引起了我的注意。下面将出现问题的代码附在下方，供各位查看: include include include include include include include using namespace std;int main(){ struct stu { int num; char name; char sex; float score; } ps; ps = (struct stu)malloc(sizeof(struct stu)); ps-&gt;num = 102; ps-&gt;name = “Zhang ping”; ps-&gt;sex = ‘M’; ps-&gt;score = 62.5; printf(“Number=%d Name=%s “, ps-&gt;num, ps-&gt;name); printf(“sex=%c Score=%f “, ps-&gt;sex, ps-&gt;score); free(ps); cout &lt;&lt; endl &lt;&lt; “新的 free() 测试开始： “; cout &lt;&lt; endl; int \a = (int *)malloc(sizeof(int)); a = 5; printf(“前 本身地址 a = %d 和值：%d 存放地址：%d\\n”, &amp;a, a,a); //free(a); printf(“后 本身地址 a = %d 和值：%d 存放地址：%d\\n”, &amp;a, a, a); a = 4; printf(“本身地址a = %d 和值：%d 存放地址：%d\\n”, &amp;a, a, a); int b; b = (int )malloc(sizeof(int)); b = 5; printf(“b赋值后 b本身地址：%d 和值：%d 存放地址：%d\\n”, &amp;b, b, b); printf(“a赋值后 a本身地址：%d 和值：%d 存放地址：%d\\n”, &amp;a, a, a); cout &lt;&lt; “int 的长度： “ &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; “a指针 的长度： “ &lt;&lt; sizeof(a) &lt;&lt; endl; cout &lt;&lt; “&amp;a指针 的长度： “ &lt;&lt; sizeof(&amp;a) &lt;&lt; endl; system(“pause”); return 0;} 从理论上看，free之后不应该打印出原数值，但事实是，我加粗的那行代码成功地打印出了原数值，在我google之后，得到了这样的解答: “你在free(p)之后，最好加上p = NULL; 要不然容易导致野指针。你在free(p)之后，你只是使用 if(p != NULL) 你想的是用来进行防止误用操作对吧。。 你进入了一个误区，误认为free(p)之后，p就指向了NULL，而其实不然。 free(p)的言外之意就是告诉编译器：大家注意啦哈，这块内存我现在不用了，你们谁想用就拿去用哈。而p在这里你可以完全理解成就是这块内存的地址，也就是告诉编译器，这块内存现在不被占用了，而里面的内容此时就是我们所说的“垃圾”，因为作为主人的我已经丢弃它了，里面的内容就是不可控的。 注意p是个地址，你没有强行置为空，那还是原来的那个值。只是里面的内容不受控啦，有可能不会变，有可能会被改写，而结果是未知的。” 之前在知乎上总是看到大牛们大书特书C语言内存管理机制的缺陷，野指针的种种危害。却从未想过究竟什么是“野指针”，今天遇到的这个问题就是野指针带来的，自己对于已经学过去的知识并没有即使的反思回顾。导致遗忘。 关于占位——字节对齐回顾一般都是用sizeof来看占位的字节数。 %d &amp;a 取地址因为是d所以地址为十进制每字节。~~~ 引用 6 楼 u012461368 的回复: Quote: 引用 5 楼 bhfdcn 的回复: Quote: 引用 3 楼 u012461368 的回复: Quote: 引用 1 楼 bhfdcn 的回复: 第一个是因为内存对齐的原因，你的32位机器指针大小是4，第二个是因为两个指针 内存对齐？就是也有可能不是6吗？ 举个简单的例子吧，比如你的代码改成如下： C/C++ code ? 1 2 3 4 5 typedef struct qnode { char data; struct qnode * next; }QNode; 然后你在输出sizeof(QNode)，大小为8，因为data之后补齐了3个字节，实际指针还是4个字节，内存布局如下图所示： 哦哦，是指结构体运用指针后大小始终保持4的倍数的意思吗？ 不完全正确，你把指针换成int类型或别的大于1字节的类型也可能引起结构体大小变化，比如： C/C++ code ? 1 2 3 4 5 typedef struct qnode { char data; int next; }QNode; 大小也为8，再比如： C/C++ code ? 1 2 3 4 5 6 typedef struct qnode { char data1; char data2; int next; }QNode; 的大小也为8，但是你要把data2和next位置换一下，大小就变成12了，如下： C/C++ code ? 1 2 3 4 5 6 typedef struct qnode { char data1; int next; char data2; }QNode; 大小为12。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[白说_读书笔记]]></title>
    <url>%2Fpost%2F13846908.html</url>
    <content type="text"><![CDATA[致青春：做一个和自己赛跑的人 学会接受“平淡”这一生活现实，然后把平淡向幸福那儿靠。你的收入与你的不可替代性成正比。 有了感触不必立即表达，中间该有一段“追寻”的时间。 大学期间，要有舍友的集体生活但自己也要守得住寂寞、静得下心做东西。 锻炼出强大的心理素质。即是——面对挫折时仍然保有乐观的态度和坚定的信心，这是这个年龄阶段必修的一门功课。“抗打击能力”和“坑表扬能力”都需要自己经得住考验。 大学期间：智商能决定你能和什么人共事，而情商能让你走的更远。之所以毕业后的差距如此巨大是因为： 首先是专业的设置 再来重要的一点是：你的独立思考能力、独特的人格魅力——使你成为不可替代的人。 永远别忘了安静地做好眼前的事。是一个自然而然的过程，踏踏实实做好眼前的事，把四年后的事交给四年后去解决，好过程必然有好结果。 希望你能展示出良好的学习性和成长性。一个人的做人品行、人品是很重要的。 只有接受平淡，才有可能不平淡。如果总是试图对抗平淡，你注定平庸，相信吗？因为生活不会给你那么多的机会，所有的不平淡，都是在忍耐了足够多的平淡之后诞生的。 活的认真才好玩。 佛教讲苦集灭道，什么意思？“苦”就是每天你要面对的事情，“集”是你要把苦归纳收集下来之后面对，“灭”就是想出办法来，把它给解决了，“道”就是变成共同的规矩，可以应付你将来的事情。 好的书籍就如同平日里每一都要做的事情。长久的坚持，变成人生中开阔眼界、看看前辈们解决问题”苦集”的过程。好的书籍会不断交给你，怎么积极乐观地去面对这样一个实则消极的过程。]]></content>
      <categories>
        <category>日记之家</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[封装vue组件或用轮子时的思考]]></title>
    <url>%2Fpost%2F1f81ed1d.html</url>
    <content type="text"><![CDATA[我希望在这个插件的同要看到轮子背后的本质不仅仅是通过一篇文章学到、掌握封装一个 scroll 组件，还要有把第三方插件（原生 JS 实现）Vue 化的思考过程。有时候学习 Vue.js 的过程中思想还停留在 “XX 效果如何用 Vue.js 实现” 的程度，其实把插件 Vue 化有两点很关键，一个是对插件本身的实现原理很了解，另一个是对 Vue.js 的特性很了解。对插件本身的实现原理了解需要的是一个思考和钻研的过程，这个过程可能困难，但是收获也是巨大的；而对 Vue.js 的特性的了解，是需要对 Vue.js 多多使用，学会从平时的项目中积累和总结，也要善于查阅 Vue.js 的官方文档，关注一些 Vue.js 的升级等。 所以，我们常说的拒绝伸手党，但也不是鼓励大家什么时候都要去造轮子，当我们在使用一些现成插件的同时，也希望大家能多多思考，去探索一下现象背后的本质，把 “XX 效果如何用 Vue.js 实现” 这句话从问号变成句号。 参考API文档：https://ustbhuangyi.github.io/better-scroll/doc/zh-hans/api.html 内容本周在实现页面滚动过程中用到了这一控件，顺带了解下背后的一点点实质。 better-scroll 是一个移动端滚动的解决方案，它是基于 iscroll 的重写，它和 iscroll 的主要区别在这里。better-scroll 也很强大，不仅可以做普通的滚动列表，还可以做轮播图、picker 等等。 better-scroll 的滚动原理 better-scroll 初始化了， 但是没法滚动。 不能滚动是现象，我们得搞清楚这其中的根本原因。在这之前，我们先来看一下浏览器的滚动原理： 浏览器的滚动条大家都会遇到，当页面内容的高度超过视口高度的时候，会出现纵向滚动条；当页面内容的宽度超过视口宽度的时候，会出现横向滚动条。也就是当我们的视口展示不下内容的时候，会通过滚动条的方式让用户滚动屏幕看到剩余的内容。 那么对于 better-scroll 也是一样的道理，我们先来看一下 better-scroll 常见的 html 结构： ... ... ... 为了更加直观，我们再来看一张图： 绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。 那么，我们怎么初始化 better-scroll 呢，如果是上述 html 结构，那么初始化代码如下： import BScroll from ‘better-scroll’let wrapper = document.querySelector(‘.wrapper’)let scroll = new BScroll(wrapper, {}) better-scroll 对外暴露了一个 BScroll 的类，我们初始化只需要 new 一个类的实例即可。第一个参数就是我们 wrapper 的 DOM 对象，第二个是一些配置参数，具体参考 better-scroll 的文档。 better-scroll 的初始化时机很重要，因为它在初始化的时候，会计算父元素和子元素的高度和宽度，来决定是否可以纵向和横向滚动。因此，我们在初始化它的时候，必须确保父元素和子元素的内容已经正确渲染了。如果子元素或者父元素 DOM 结构发生改变的时候，必须重新调用 scroll.refresh() 方法重新计算来确保滚动效果的正常。所以同学们反馈的 better-scroll 不能滚动的原因多半是初始化 better-scroll 的时机不对，或者是当 DOM 结构发送变化的时候并没有重新计算 better-scroll。 better-scroll 遇见 Vue 把 better-scroll 和 Vue 做了结合，实现了很多列表滚动的效果。在 Vue 中的使用方法如下： ... ... ... import BScroll from 'better-scroll' export default { mounted() { this.$nextTick(() => { this.scroll = new Bscroll(this.$refs.wrapper, {}) }) } } Vue.js 提供了我们一个获取 DOM 对象的接口—— vm.$refs。在这里，我们通过了 this.$refs.wrapper 访问到了这个 DOM 对象，并且我们在 mounted 这个钩子函数里，this.$nextTick 的回调函数中初始化 better-scroll 。因为这个时候，wrapper 的 DOM 已经渲染了，我们可以正确计算它以及它内层 content 的高度，以确保滚动正常。 这里的 this.$nextTick 是一个异步函数，为了确保 DOM 已经渲染，感兴趣的同学可以了解一下它的[内部实现细节](https://github.com/vuejs/vue/blob/dev/src/core/util/env.js#L66-L122)，底层用到了 MutationObserver 或者是 setTimeout(fn, 0)。其实我们在这里把 this.$nextTick 替换成 setTimeout(fn, 20) 也是可以的（20 ms 是一个经验值，每一个 Tick 约为 17 ms），对用户体验而言都是无感知的。 异步数据的处理 在我们的实际工作中，列表的数据往往都是异步获取的，因此我们初始化 better-scroll 的时机需要在数据获取后，代码如下： { {item}} import BScroll from 'better-scroll' export default { data() { return { data: \[\] } }, created() { requestData().then((res) => { this.data = res.data this.$nextTick(() => { this.scroll = new Bscroll(this.$refs.wrapper, {}) }) }) } } 这里的 requestData 是伪代码，作用就是发起一个 http 请求从服务端获取数据，并且这个函数返回的是一个 promise（实际项目中我们可能会用 [axios](https://github.com/mzabriskie/axios) 或者 [vue-resource](https://github.com/pagekit/vue-resource)）。我们获取到数据的后，需要通过异步的方式再去初始化 better-scroll，因为 Vue 是数据驱动的， Vue 数据发生变化（this.data = res.data）到页面重新渲染是一个异步的过程，我们的初始化时机是要在 DOM 重新渲染后，所以这里用到了 this.$nextTick，当然替换成 setTimeout(fn, 20) 也是可以的。 为什么这里在 created 这个钩子函数里请求数据而不是放到 mounted 的钩子函数里？因为 requestData 是发送一个网络请求，这是一个异步过程，当拿到响应数据的时候，Vue 的 DOM 早就已经渲染好了，但是数据改变 —> DOM 重新渲染仍然是一个异步过程，所以即使在我们拿到数据后，也要异步初始化 better-scroll。 **数据的动态更新** 我们在实际开发中，除了数据异步获取，还有一些场景可以动态更新列表中的数据，比如常见的下拉加载，上拉刷新等。比如我们用 better-scroll 配合 Vue 实现下拉加载功能，代码如下： { {item}} import BScroll from 'better-scroll' export default { data() { return { data: \[\] } }, created() { this.loadData() }, methods: { loadData() { requestData().then((res) => { this.data = res.data.concat(this.data) this.$nextTick(() => { if (!this.scroll) { this.scroll = new Bscroll(this.$refs.wrapper, {}) this.scroll.on('touchend', (pos) => { // 下拉动作 if (pos.y > 50) { this.loadData() } }) } else { this.scroll.refresh() } }) }) } } } 这段代码比之前稍微复杂一些, 当我们在滑动列表松开手指时候， better-scroll 会对外派发一个 touchend 事件，我们监听了这个事件，并且判断了 pos.y > 50（我们把这个行为定义成一次下拉的动作）。如果是下拉的话我们会重新请求数据，并且把新的数据和之前的 data 做一次 concat，也就更新了列表的数据，那么数据的改变就会映射到 DOM 的变化。需要注意的一点，这里我们对 this.scroll 做了判断，如果没有初始化过我们会通过 new BScroll 初始化，并且绑定一些事件，否则我们会调用 this.scroll.refresh 方法重新计算，来确保滚动效果的正常。 这里，我们就通过 better-scroll 配合 Vue，实现了列表的下拉刷新功能，上拉加载也是类似的套路，一切看上去都是 ok 的。但是，我们发现这里写了大量命令式的代码（这一点不是 Vue.js 推荐的），如果有很多类似滚动的组件，我们就需要写很多类似的命令式且重复性的代码，而且我们把数据请求和 better-scroll 也做了强耦合，这些对于一个追求编程逼格的人来说，就不 ok 了。 ### scroll 组件的抽象和封装 因此，我们有强烈的需求抽象出来一个 scroll 组件，类似小程序的 scroll-view 组件，方便开发者的使用。 首先，我们要考虑的是 scroll 组件本质上就是一个可以滚动的列表组件，至于列表的 DOM 结构，只需要满足 better-scroll 的 DOM 结构规范即可，具体用什么标签，有哪些辅助节点（比如下拉刷新上拉加载的 loading 层），这些都不是 scroll 组件需要关心的。因此， scroll 组件的 DOM 结构十分简单，如下所示： 这里我们用到了 Vue 的特殊元素—— slot 插槽，它可以满足我们灵活定制列表 DOM 结构的需求。接下来我们来看看 JS 部分： import BScroll from 'better-scroll' export default { props: { /\*\* \* 1 滚动的时候会派发scroll事件，会截流。 \* 2 滚动的时候实时派发scroll事件，不会截流。 \* 3 除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件 */ probeType: { type: Number, default: 1 }, /\*\* \* 点击列表是否派发click事件 */ click: { type: Boolean, default: true }, /\*\* \* 是否开启横向滚动 */ scrollX: { type: Boolean, default: false }, /\*\* \* 是否派发滚动事件 */ listenScroll: { type: Boolean, default: false }, /\*\* \* 列表的数据 */ data: { type: Array, default: null }, /\*\* \* 是否派发滚动到底部的事件，用于上拉加载 */ pullup: { type: Boolean, default: false }, /\*\* \* 是否派发顶部下拉的事件，用于下拉刷新 */ pulldown: { type: Boolean, default: false }, /\*\* \* 是否派发列表滚动开始的事件 */ beforeScroll: { type: Boolean, default: false }, /\*\* \* 当数据更新后，刷新scroll的延时。 */ refreshDelay: { type: Number, default: 20 } }, mounted() { // 保证在DOM渲染完毕后初始化better-scroll setTimeout(() => { this._initScroll() }, 20) }, methods: { _initScroll() { if (!this.$refs.wrapper) { return } // better-scroll的初始化 this.scroll = new BScroll(this.$refs.wrapper, { probeType: this.probeType, click: this.click, scrollX: this.scrollX }) // 是否派发滚动事件 if (this.listenScroll) { let me = this this.scroll.on('scroll', (pos) => { me.$emit('scroll', pos) }) } // 是否派发滚动到底部事件，用于上拉加载 if (this.pullup) { this.scroll.on('scrollEnd', () => { // 滚动到底部 if (this.scroll.y { // 下拉动作 if (pos.y > 50) { this.$emit('pulldown') } }) } // 是否派发列表滚动开始的事件 if (this.beforeScroll) { this.scroll.on('beforeScrollStart', () => { this.$emit('beforeScroll') }) } }, disable() { // 代理better-scroll的disable方法 this.scroll && this.scroll.disable() }, enable() { // 代理better-scroll的enable方法 this.scroll && this.scroll.enable() }, refresh() { // 代理better-scroll的refresh方法 this.scroll && this.scroll.refresh() }, scrollTo() { // 代理better-scroll的scrollTo方法 this.scroll && this.scroll.scrollTo.apply(this.scroll, arguments) }, scrollToElement() { // 代理better-scroll的scrollToElement方法 this.scroll && this.scroll.scrollToElement.apply(this.scroll, arguments) } }, watch: { // 监听数据的变化，延时refreshDelay时间后调用refresh方法重新计算，保证滚动效果正常 data() { setTimeout(() => { this.refresh() }, this.refreshDelay) } } } JS 部分实际上就是对 better-scroll 做一层 Vue 的封装，通过 props 的形式，把一些对 better-scroll 定制化的控制权交给父组件；通过 methods 暴露的一些方法对 better-scroll 的方法做一层代理；通过 watch 传入的 data，当 data 发生改变的时候，在适当的时机调用 refresh 方法重新计算 better-scroll 确保滚动效果正常，这里之所以要有一个 refreshDelay 的设置是考虑到如果我们对列表操作用到了 transition-group 做动画效果，那么 DOM 的渲染完毕时间就是在动画完成之后。 有了这一层 scroll 组件的封装，我们来修改刚刚最复杂的代码（假设我们已经全局注册了 scroll 组件）。 { {item}} import BScroll from 'better-scroll' export default { data() { return { data: \[\], pulldown: true } }, created() { this.loadData() }, methods: { loadData() { requestData().then((res) => { this.data = res.data.concat(this.data) }) } } } 可以很明显的看到我们的 JS 部分精简了非常多的代码，没有对 better-scroll 再做命令式的操作了，同时把数据请求和 better-scroll 也做了剥离，父组件只需要把数据 data 通过 prop 传给 scroll 组件，就可以保证 scroll 组件的滚动效果。同时，如果想实现下拉刷新的功能，只需要通过 prop 把 pulldown 设置为 true，并且监听 pulldown 的事件去做一些数据获取并更新的动作即可，整个逻辑也是非常清晰的。 小结-关于插件 Vue 化引发的一些思考不仅仅是通过一篇文章学到、掌握封装一个 scroll 组件，还要有把第三方插件（原生 JS 实现）Vue 化的思考过程。有时候学习 Vue.js 的过程中思想还停留在 “XX 效果如何用 Vue.js 实现” 的程度，其实把插件 Vue 化有两点很关键，一个是对插件本身的实现原理很了解，另一个是对 Vue.js 的特性很了解。对插件本身的实现原理了解需要的是一个思考和钻研的过程，这个过程可能困难，但是收获也是巨大的；而对 Vue.js 的特性的了解，是需要对 Vue.js 多多使用，学会从平时的项目中积累和总结，也要善于查阅 Vue.js 的官方文档，关注一些 Vue.js 的升级等。 所以，我们常说的拒绝伸手党，但也不是鼓励大家什么时候都要去造轮子，当我们在使用一些现成插件的同时，也希望大家能多多思考，去探索一下现象背后的本质，把 “XX 效果如何用 Vue.js 实现” 这句话从问号变成句号。 参考API文档：https://ustbhuangyi.github.io/better-scroll/doc/zh-hans/api.html]]></content>
      <categories>
        <category>ES6</category>
        <category>VUEJS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[论文写作]]></title>
    <url>%2Fpost%2F5cbfbe67.html</url>
    <content type="text"><![CDATA[干货: 【论文写作】 1、克雷斯威尔五步文献综述法：http://t.cn/ROAb2RZ 2、本科毕业论文写作指南：http://t.cn/ROAb2R7 3、文献综述的写法：http://t.cn/ROAb2RA 4、本科毕业论文如何撰写文献综述：http://t.cn/ROAb2Rz 5、怎样找到质量好的数据来源：http://t.cn/Ri8H7DF 6、写论文需要的工具及软件：http://t.cn/R4AQ8YJ 7、研究生如何检索和阅读外文文献：http://t.cn/ROzxC43 8、博士论文写作指导：http://t.cn/ROAb2R0 9、毕业论文写作指导（公开课）：http://t.cn/RpZwen5 10、心理学研究与论文写作（公开课）：http://t.cn/RSRFEuC 11、科学研究与论文写作（公开课）：http://t.cn/RSRFEu9 12、如何看懂英文文献：http://t.cn/RqJikst 13、如何写好一篇毕业论文：http://t.cn/RGQCfs2 14、如何在论文中画出漂亮的插图：http://t.cn/RqKkHOv 15、写文献综述的28个要点：http://t.cn/ROAb2Rw]]></content>
      <categories>
        <category>干货即用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[玩转git系列—补充]]></title>
    <url>%2Fpost%2Fc0884e61.html</url>
    <content type="text"><![CDATA[一、关于.git文件的理解修改用户信息，global层级中的修改可以在~/.gitconfig中查询 git config —global user.name “NAME” git config —global user.email “EMAIL” git status 可以让我们时刻掌握仓库当前的状态。 git diff 可以查看文件历史变更。 git add 把文件添加到仓库 git commit -m 把文件提交到仓库 git log 可以让我们查看历史记录(打印出的一串随机码是COMMIT ID) 在GIT中HEAD表示当前版本，上个版本是HEAD^，上上个版本是HEAD^^，如果是上100个版本那就是HEAD~100。 git reset —hard HEAD^ 可以回退到上一个版本 git reflog 在你反悔的时候可以用这个命令查找回退之前版本的COMMIT ID 工作区(Working Directory)是指在电脑里能看到的目录。 版本库(Repository)是指在工作区有一个隐藏目录.git，这个不算是工作区而是GIT的版本库。GIT的版本库里存了很多东西，其中最重要的就是称为stage或者叫做index的暂存区，其中还有GIT为我们自动创建第一个分支master，以及指向master的一个指针叫HEAD。 可以简单的理解为需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改。每次commit提交仅会提交暂存区的文件，所以如果没有使用git add的话直接commit就无影响了。 注意 无论是在AS等Jetbrain家族平台的任何Git控制插件——我们都可以这样做： 暂存区：防止 误操作；暂时未开发完成-随时保存0-放在放在暂存区里面！ 保护工作区和版本区 ； 分支处理 注意 红的是工作区！ 绿色的是 经过add 到暂存区的！工作区/修改/删除 二、git commit -m 与 git commit -am 的区别字面解释的话，git commit -m用于提交暂存区的文件；git commit -am用于提交跟踪过的文件 要理解它们的区别，首先要明白git的文件状态变化周期，如下图所示 工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区 下面以一个实例说明 在项目文件夹中新增一个文件如’a.txt’时，该文件处于untracked未跟踪状态。未跟踪状态的文件是无法提交的 接下来，使用git add a.txt，使其变成已跟踪状态 这时，如果使用git commit -m ‘add a.txt’就可以顺利提交了 但是，git commit -m 和 git commit -am的区别在哪里？在于a.txt文件修改之后的处理 下面，向a.txt添加内容’a’ 文件a.txt处于已跟踪，但未暂存状态。这时，如果使用git commit -m是无法提交最新版本的a.txt的，提交的只是最开始空内容的旧版本a.txt 要提交新版本a.txt，即内容为’a’的a.txt，则需要使用git add a.txt，将新版本的a.txt放到staged暂存区，然后才能使用git commit -m进行提交 而如果使用git commit -am，则可以省略git add a.txt这一步，因为git commit -am可以提交跟踪过的文件，而a.txt一开始已经被跟踪过了 总结，使用这两个命令区别的关键就是git add命令 git add命令是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等 我们需要用git add命令来跟踪新文件，但如果使用git commit -am可以省略使用git add命令将已跟踪文件放到暂存区的功能 详情见文档 我的项目开发—项目开发笔记]]></content>
      <categories>
        <category>git</category>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git-merge完全解析]]></title>
    <url>%2Fpost%2F903a4462.html</url>
    <content type="text"><![CDATA[git merge的基本用法为把一个分支或或某个commit的修改合并到现在的分支上。 git-merge完全解析 结合码云做出更改 Git的git-merge是在Git中频繁使用的一个命令，很多人都觉得git合并是一个非常麻烦的事情，一不小心就会遇到丢失代码的问题，从而对git望而却步。本文基于Git 2.8.2对git-merge命令进行完整详细的介绍，特别是关于交叉合并所带来的代码遗失问题，在文末给出自己的建议，希望能够帮助到git的使用者。本文所介绍的内容基于Git 2.8.2 git-merge命令是用于将两个或两个以上的开发历史合并在一起的操作，通常也可写作：git merge。 1.git-merge相关的选项参数1.1摘要在git-merge命令中，有以下三种使用参数： git merge [-n] [--stat] [--no-commit] [--squash] [--[no-]edit] [-s &lt;strategy&gt;] [-X &lt;strategy-option&gt;] [-S[&lt;keyid&gt;]] [--[no-]rerere-autoupdate] [-m &lt;msg&gt;] [&lt;commit&gt;...] git merge &lt;msg&gt; HEAD &lt;commit&gt;... git merge --abort 1.2git-merge简介 git-merge命令是用于从指定的commit(s)合并到当前分支的操作。 注：这里的指定commit(s)是指从这些历史commit节点开始，一直到当前分开的时候。 git-merge命令有以下两种用途： 用于git-pull中，来整合另一代码仓库中的变化（即：git pull = git fetch + git merge） 用于从一个分支到另一个分支的合并 假设下面的历史节点存在，并且当前所在的分支为“master”： 7810BEAB-4124-48D7-A185-CD0A1626CFC8.png 那么git merge topic命令将会把在master分支上二者共同的节点（E节点）之后分离的节点（即topic分支的A B C节点）重现在master分支上，直到topic分支当前的commit节点（C节点），并位于master分支的顶部。并且沿着master分支和topic分支创建一个记录合并结果的新节点，该节点带有用户描述合并变化的信息。 即下图中的H节点，C节点和G节点都是H节点的父节点。 C8CF6D76-B282-42E6-ABAF-E481223835FB.png 1.3git merge &lt;msg&gt; HEAD &lt;commit&gt;...命令该命令的存在是由于历史原因，在新版本中不应该使用它，应该使用git merge -m &lt;msg&gt; &lt;commit&gt;....进行替代 1.4git merge --abort命令该命令仅仅在合并后导致冲突时才使用。git merge --abort将会抛弃合并过程并且尝试重建合并前的状态。但是，当合并开始时如果存在未commit的文件，git merge --abort在某些情况下将无法重现合并前的状态。（特别是这些未commit的文件在合并的过程中将会被修改时） 警告：运行git-merge时含有大量的未commit文件很容易让你陷入困境，这将使你在冲突中难以回退。因此非常不鼓励在使用git-merge时存在未commit的文件，建议使用git-stash命令将这些未commit文件暂存起来，并在解决冲突以后使用git stash pop把这些未commit文件还原出来。 —-MORE—-原文： http://www.tech126.com/git-fetch-pull/ Git中从远程的分支获取最新的版本到本地有这样2个命令： git fetch：相当于是从远程获取最新版本到本地，不会自动merge git fetch origin mastergit log -p master..origin/mastergit merge origin/master 以上命令的含义： 首先从远程的origin的master主分支下载最新的版本到origin/master分支上 然后比较本地的master分支和origin/master分支的差别 最后进行合并 上述过程其实可以用以下更清晰的方式来进行： git fetch origin master:tmpgit diff tmpgit merge tmp 从远程获取最新的版本到本地的test分支上 之后再进行比较合并 git pull：相当于是从远程获取最新版本并merge到本地git pull origin master上述命令其实相当于git fetch 和 git merge在实际使用中，git fetch更安全一些因为在merge前，我们可以查看更新情况，然后再决定是否合并结束 2.参数本部分用于介绍git-merge命令中使用的参数 2.1--commit和--no-commit--commit参数使得合并后产生一个合并结果的commit节点。该参数可以覆盖--no-commit。 --no-commit参数使得合并后，为了防止合并失败并不自动提交，能够给使用者一个机会在提交前审视和修改合并结果。 2.2--edit和-e以及--no-edit--edit和-e用于在成功合并、提交前调用编辑器来进一步编辑自动生成的合并信息。因此使用者能够进一步解释和判断合并的结果。 --no-edit参数能够用于接受自动合并的信息（通常情况下并不鼓励这样做）。 如果你在合并时已经给定了-m参数（下文介绍），使用 --edit（或-e）依然是有用的，这将在编辑器中进一步编辑-m所含的内容。 旧版本的节点可能并不允许用户去编辑合并日志信息。 2.3--ff命令--ff是指fast-forward命令。当使用fast-forward模式进行合并时，将不会创造一个新的commit节点。默认情况下，git-merge采用fast-forward模式。 关于fast-forward模式的详细解释，请看我的另一篇文章：一个成功的Git分支模型的“关于fast forward”一节。 2.4--no-ff命令即使可以使用fast-forward模式，也要创建一个新的合并节点。这是当git merge在合并一个tag时的默认行为。 2.5--ff-only命令除非当前HEAD节点已经up-to-date（更新指向到最新节点）或者能够使用fast-forward模式进行合并，否则的话将拒绝合并，并返回一个失败状态。 2.5 --log[=&lt;n&gt;]和 --no-log--log[=&lt;n&gt;]将在合并提交时，除了含有分支名以外，还将含有最多n个被合并commit节点的日志信息。 --no-log并不会列出该信息。 2.6 --stat, -n, --no-stat命令--stat参数将会在合并结果的末端显示文件差异的状态。文件差异的状态也可以在git配置文件中的merge.stat配置。 相反，-n, --no-stat参数将不会显示该信息。 2.7--squash 和--no-squash--squash 当一个合并发生时，从当前分支和对方分支的共同祖先节点之后的对方分支节点，一直到对方分支的顶部节点将会压缩在一起，使用者可以经过审视后进行提交，产生一个新的节点。 注意1:该参数和--no-ff冲突 注意2:该参数使用后的结果类似于在当前分支提交一个新节点。在某些情况下这个参数非常有用，例如使用Git Flow时（关于Git Flow，请参考：一个成功的Git分支模型），功能分支在进行一个功能需求的研发时，开发者可能在本地提交了大量且无意义的节点，当需要合并到develop分支时，可能仅仅需要用一个新的节点来表示这一长串节点的修改内容，这时--squash命令将会发挥作用。此外，如果功能分支的多次提交并不是琐碎而都是有意义的，使用--no-ff命令更为合适。 --no-squash的作用正好相反。 2.8 -s &lt;strategy&gt;和 --strategy=&lt;strategy&gt;-s &lt;strategy&gt;和 --strategy=&lt;strategy&gt;用于指定合并的策略。默认情况如果没有指定该参数，git将按照下列情况采用默认的合并策略： 合并节点只含有单个父节点时（如采用fast-forward模式时），采用recursive策略（下文介绍）。 合并节点含有多个父节点时(如采用no-fast-forward模式时)，采用octopus策略（下文介绍）。 2.9 -X &lt;option&gt;和 --strategy-option=&lt;option&gt;在-s &lt;strategy&gt;时指定该策略的具体参数（下文介绍）。 2.10 --verify-signatures, --no-verify-signatures用于验证被合并的节点是否带有GPG签名，并在合并中忽略那些不带有GPG签名验证的节点。 (以下引用摘自一篇转载的文章，由于我没有找到原作者，因此无法提供原作者信息和原文链接，如果有所侵权请私信或者评论告知，我将删除以下引用内容。) GPG是加密软件，可以使用GPG生成的公钥在网上安全的传播你的文件、代码。 为什么说安全的？以Google所开发的repo为例，repo即采用GPG验证的方式，每个里程碑tag都带有GPG加密验证，假如在里程碑v1.12.3处你想要做修改，修改完后将这个tag删除，然后又创建同名tag指向你的修改点，这必然是可以的。但是，在你再次clone你修改后的项目时，你会发现，你对此里程碑tag的改变不被认可，验证失败，导致你的修改在这里无法正常实现。这就是GPG验证的作用，这样就能够保证项目作者（私钥持有者）所制定的里程碑别人将无法修改。那么，就可以说，作者的代码是安全传播的。 为什么会有这种需求？一个项目从开发到发布，再到后期的更新迭代，一定会存在若干的稳定版本与开发版本（存在不稳定因素）。作为项目发起者、持有者，有权定义他（们）所认可的稳定版本，这个稳定版本，将不允许其他开发者进行改动。还以Google的repo项目为例，项目所有者定义项目开发过程中的点A为稳定版v1.12.3，那么用户在下载v1.12.3版本后，使用的肯定是A点所生成的项目、产品，就算其他开发者能够在本地对v1.12.3进行重新指定，指定到他们修改后的B点，但是最终修改后的版本给用户用的时候，会出现GPG签名验证不通过的问题，也就是说这样的修改是不生效的。 2.11 —summary,--no-summary和--stat与 --no-stat相似，并将在未来版本移除。 2.12 -q和 --quiet静默操作，不显示合并进度信息。 2.13 -v和 --verbose显示详细的合并结果信息。 2.14 --progress和 --no-progress切换是否显示合并的进度信息。如果二者都没有指定，那么在标准错误发生时，将在连接的终端显示信息。请注意，并不是所有的合并策略都支持进度报告。 2.15-S[&lt;keyid&gt;]和 --gpg-sign[=&lt;keyid&gt;]GPG签名。 2.16-m &lt;msg&gt;设置用于创建合并节点时的提交信息。 如果指定了--log参数，那么commit节点的短日志将会附加在提交信息里。 2.17--[no-]rerere-autoupdatererere即reuse recorded resolution，重复使用已经记录的解决方案。它允许你让 Git 记住解决一个块冲突的方法，这样在下一次看到相同冲突时，Git 可以为你自动地解决它。 2.18--abort抛弃当前合并冲突的处理过程并尝试重建合并前的状态。 3.关于合并的其他概念3.1合并前的检测在合并外部分支时，你应当保持自己分支的整洁，否则的话当存在合并冲突时将会带来很多麻烦。 为了避免在合并提交时记录不相关的文件，如果有任何在index所指向的HEAD节点中登记的未提交文件，git-pull和git-merge命令将会停止。 3.2fast-forward合并通常情况下分支合并都会产生一个合并节点，但是在某些特殊情况下例外。例如调用git pull命令更新远端代码时，如果本地的分支没有任何的提交，那么没有必要产生一个合并节点。这种情况下将不会产生一个合并节点，HEAD直接指向更新后的顶端代码，这种合并的策略就是fast-forward合并。 3.3合并细节除了上文所提到的fast-forward合并模式以外，被合并的分支将会通过一个合并节点和当前分支绑在一起，该合并节点同时拥有合并前的当前分支顶部节点和对方分支顶部节点，共同作为父节点。 一个合并了的版本将会使所有相关分支的变化一致，包括提交节点，HEAD节点和index指针以及节点树都会被更新。只要这些节点中的文件没有重叠的地方，那么这些文件的变化都会在节点树中改动并更新保存。 如果无法明显地合并这些变化，将会发生以下的情况： HEAD指针所指向的节点保持不变 MERGE_HEAD指针被置于其他分支的顶部 已经合并干净的路径在index文件和节点树中同时更新 对于冲突路径，index文件记录了三个版本：版本1记录了二者共同的祖先节点，版本2记录了当前分支的顶部，即HEAD，版本3记录了MERGE_HEAD。节点树中的文件包含了合并程序运行后的结果。例如三路合并算法会产生冲突。 其他方面没有任何变化。特别地，你之前进行的本地修改将继续保持原样。 如果你尝试了一个导致非常复杂冲突的合并，并想重新开始，那么可以使用git merge --abort 关于三路合并算法： 三路合并算法是用于解决冲突的一种方式，当产生冲突时，三路合并算法会获取三个节点：本地冲突的B节点，对方分支的C节点，B，C节点的共同最近祖先节点A。三路合并算法会根据这三个节点进行合并。具体过程是，B，C节点和A节点进行比较，如果B，C节点的某个文件和A节点中的相同，那么不产生冲突；如果B或C只有一个和A节点相比发生变化，那么该文件将会采用该变化了的版本；如果B和C和A相比都发生了变化，且变化不相同，那么则需要手动去合并;如果B，C都发生了变化，且变化相同，那么并不产生冲突，会自动采用该变化的版本。最终合并后会产生D节点，D节点有两个父节点，分别为B和C。 3.4合并tag当合并一个tag时，Git总是创建一个合并的提交，即使这时能够使用fast-forward模式。该提交信息的模板预设为该tag的信息。额外地，如果该tag被签名，那么签名的检测信息将会附加在提交信息模板中。 3.5冲突是如何表示的当产生合并冲突时，该部分会以&lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======和 &gt;&gt;&gt;&gt;&gt;&gt;&gt;表示。在=======之前的部分是当前分支这边的情况，在=======之后的部分是对方分支的情况。 3.6如何解决冲突在看到冲突以后，你可以选择以下两种方式： 决定不合并。这时，唯一要做的就是重置index到HEAD节点。git merge --abort用于这种情况。 解决冲突。Git会标记冲突的地方，解决完冲突的地方后使用git add加入到index中，然后使用git commit产生合并节点。 你可以用以下工具来解决冲突: 使用合并工具。git mergetool将会调用一个可视化的合并工具来处理冲突合并。 查看差异。git diff将会显示三路差异（三路合并中所采用的三路比较算法）。 查看每个分支的差异。git log --merge -p &lt;path&gt;将会显示HEAD版本和MERGE_HEAD版本的差异。 查看合并前的版本。git show :1:文件名显示共同祖先的版本，git show :2:文件名显示当前分支的HEAD版本，git show :3:文件名显示对方分支的MERGE_HEAD版本。 4.合并策略Git可以通过添加-s参数来指定合并的策略。一些合并策略甚至含有自己的参数选项，通过-X&lt;option&gt;设置这些合并策略的参数选项。(不要忘记，合并可以在git merge和git pull命令中发生，因此该合并策略同样适用于git pull)。 4.1resolve仅仅使用三路合并算法合并两个分支的顶部节点（例如当前分支和你拉取下来的另一个分支）。这种合并策略遵循三路合并算法，由两个分支的HEAD节点以及共同子节点进行三路合并。 当然，真正会困扰我们的其实是交叉合并（criss-cross merge）这种情况。所谓的交叉合并，是指共同祖先节点有多个的情况，例如在两个分支合并时，很有可能出现共同祖先节点有两个的情况发生，这时候无法按照三路合并算法进行合并（因为共同祖先节点不唯一）。resolve策略在解决交叉合并问题时是这样处理的，这里参考《Version Control with Git》： In criss-cross merge situations, where there is more than one possible merge basis, the resolve strategy works like this: pick one of the possible merge bases, and hope for the best. This is actually not as bad as it sounds. It often turns out that the users have been working on different parts of the code. In that case, Git detects that it’s remerging some changes that are already in place and skips the duplicate changes, avoiding the conflict. Or, if these are slight changes that do cause conflict, at least the conflict should be easy for the developer to handle 这里简单翻译一下：在交叉合并的情况时有一个以上的合并基准点（共同祖先节点），resolve策略是这样工作的：选择其中一个可能的合并基准点并期望这是合并最好的结果。实际上这并没有听起来的那么糟糕。通常情况下用户修改不同部分的代码，在这种情况下，很多的合并冲突其实是多余和重复的。而使用resolve进行合并时，产生的冲突也较易于处理，真正会遗失代码的情况很少。 4.2recursive仅仅使用三路合并算法合并两个分支。和resolve不同的是，在交叉合并的情况时，这种合并方式是递归调用的，从共同祖先节点之后两个分支的不同节点开始递归调用三路合并算法进行合并，如果产生冲突，那么该文件不再继续合并，直接抛出冲突；其他未产生冲突的文件将一直执行到顶部节点。额外地，这种方式也能够检测并处理涉及修改文件名的操作。这是git合并和拉取代码的默认合并操作。 recursive合并策略有以下参数： 4.2.1 ours该参数将强迫冲突发生时，自动使用当前分支的版本。这种合并方式不会产生任何困扰情况，甚至git都不会去检查其他分支版本所包含的冲突内容这种方式会抛弃对方分支任何冲突内容。 4.2.2 theirs正好和ours相反。 theirs和ours参数都适用于合并二进制文件冲突的情况。 4.2.2 patience在这种参数下，git merge-recursive花费一些额外的时间来避免错过合并一些不重要的行（如函数的括号）。如果当前分支和对方分支的版本分支分离非常大时，建议采用这种合并方式。 4.2.3diff-algorithm=[patience|minimal|histogram|myers]告知git merge-recursive使用不同的比较算法。 4.2.4 ignore-space-change, ignore-all-space, ignore-space-at-eol根据指定的参数来对待空格冲突。 如果对方的版本仅仅添加了空格的变化，那么冲突合并时采用我们自己的版本 如果我们的版本含有空格，但是对方的版本包含大量的变化，那么冲突合并时采用对方的版本 采用正常的处理过程 4.2.5 no-renames关闭重命名检测。 4.2.6subtree[=&lt;path&gt;]该选项是subtree合并策略的高级形式，将会猜测两颗节点树在合并的过程中如何移动。不同的是，指定的路径将在合并开始时除去，以使得其他路径能够在寻找子树的时候进行匹配。（关于subtree合并策略详见下文） 4.3octopus这种合并方式用于两个以上的分支，但是在遇到冲突需要手动合并时会拒绝合并。这种合并方式更适合于将多个分支捆绑在一起的情况，也是多分支合并的默认合并策略。 4.4ours这种方式可以合并任意数量的分支，但是节点树的合并结果总是当前分支所冲突的部分。这种方式能够在替代旧版本时具有很高的效率。请注意，这种方式和recursive策略下的ours参数是不同的。 4.5subtreesubtree是修改版的recursive策略。当合并树A和树B时，如果B是A的子树，B首先调整至匹配A的树结构，而不是读取相同的节点。 4.5总结在使用三路合并的策略时（指默认的recursive策略），如果一个文件（或一行代码）在当前分支和对方分支都产生变化，但是稍后又在其中一个分支回退，_那么这种回退的变化将会在结果中体现_。这一点可能会使一些人感到困惑。这是由于在合并的过程中，git仅仅关注共同祖先节点以及两个分支的HEAD节点，而不是两个分支的所有节点。因此，合并算法将会把被回退的部分认为成_没有变化_，这样，合并后的结果就会变为另一个分支中变化的部分。 5.关于Git使用的一些个人看法本人一直认为Git是一款非常优秀的版本控制工具，但是在公司中很多人觉得Git很难使用。这种情况很大一部分原因是之前使用subversion时带来的使用惯性对接受新技术造成了影响；另一方面，很多人仅仅通过GUI客户端去使用Git。很久以来，大部分人认为使用GUI是一种较为便捷的入门方式，其实这是值得商榷的。依我个人的经验来说，使用GUI会形成惰性，往往点击几个按钮就能完成操作，使得很多人认为学习Git的命令是一种浪费时间和精力的行为。但是事实上，在没有理解清楚Git命令和思想的情况下，使用那些简单的按钮其实会带来很大的困扰：很多人根本不知道点击按钮后会发生什么，GUI的过于智能让同一个按钮的点击事件可能对应着不同参数的命令。最后真正受到伤害的是可怜的使用者们，因为他们根本不知道问题出在哪里。 综合全文的内容，这里总结一些个人使用Git时所遵守的约定。所谓约定，即非强迫性的，自愿的行为。不遵守这些约定并不会带来什么缺陷，但是遵守这些约定可能会减轻在使用Git时带来的困难，提高效率。 多提交，少推送。多人协作时，推送会频繁地带来合并冲突的问题，影响效率。因此，尽量多使用提交命令，减少合并的使用，这样会节省很多时间。 使用Git流（Git Flow），详见我的另一篇文章：一个成功的Git分支模型 使用分支，_保持主分支的整洁_。这是我强烈推荐的一点，在分支进行提交，然后切到主分支更新(git pull —rebase)，再合并分支、推送。这样的流程会避免交叉合并的情况出现（不会出现共同祖先节点为多个的情况）。事实上，git合并操作让很多人感到不知所措的原因就是各种原因所产生的交叉合并问题，从而造成在合并的过程中丢失某些代码。保持主分支的整洁能够避免交叉合并的情况出现。 禁用fast-forward模式。在拉取代码的时候使用rebase参数（前提是保持主分支的整洁）、合并的时候使用—no-ff参数禁用fast-forward模式，这样做既能保证节点的清晰，又避免了交叉合并的情况出现。 作者：Chuckiefan链接：http://www.jianshu.com/p/58a166f24c81來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>git</category>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android四大组件：Service服务史上最全面解析]]></title>
    <url>%2Fpost%2F1abae223.html</url>
    <content type="text"><![CDATA[前言 Service作为Android四大组件之一，应用非常广泛 本文将介绍对Service进行全面介绍（基础认识、生命周期、使用和应用场景） 目录 目录 1. 基础知识 定义：服务，属于Android中的计算型组件 作用：提供需要在后台长期运行的服务（如复杂计算、下载等等） 特点：长生命周期的、没有用户界面、在后台运行 2. 生命周期方法详解具体请看我写的文章：Android：Service生命周期最全面解析 3. Service分类3.1 Service的类型 分类 3.2 详细介绍 Service类型的详细介绍 4. Service的使用解析由上述可知，服务Service总共分为： 分类 接下来，我将介绍每种Service的具体使用，具体请看我写的文章:Android：（本地、可通信的、前台、远程）Service使用全面介绍 5. 使用场景 通过上述描述，你应该对Service类型及其使用非常了解； 那么，我们该什么时候用哪种类型的Service呢？ 各种Service的使用场景请看下图： 使用场景 6. 其他思考6.1 Service和Thread的区别 结论：Service和Thread之间没有任何关系 之所以有不少人会把它们联系起来，主要因为Service的后台概念 后台的定义：后台任务运行完全不依赖UI，即使Activity被销毁，或者程序被关闭，只要进程还在，后台任务就可以继续运行 其实二者存在较大的区别，如下图： Paste_Image.png 一般来说，会将Service和Thread联合着用，即在Service中再创建一个子线程（工作线程）去处理耗时操作逻辑，如下代码： @Override public int onStartCommand(Intent intent, int flags, int startId) { //新建工作线程 new Thread(new Runnable() { @Override public void run() { // 开始执行后台任务 } }).start(); return super.onStartCommand(intent, flags, startId); } class MyBinder extends Binder { public void service_connect_Activity() { //新建工作线程 new Thread(new Runnable() { @Override public void run() { // 执行具体的下载任务 } }).start(); } } 6.2 Service和IntentService的区别具体请看我写的文章：Android多线程全面解析：IntentService用法&amp;源码 7.总结 本文对Service的所有知识进行了全面解析（基础认识、生命周期、使用和应用场景） 如果你还想了解关于Service的其他知识，请浏览以下文章： Android：Service服务史上最全面解析 Android：Service生命周期最全面解析 Android：（本地、可通信的、前台、远程）Service使用全面介绍 Android：远程服务Service（含AIDL &amp; IPC讲解） Android多线程全面解析：IntentService用法&amp;源码 接下来会介绍继续介绍Android开发中的相关知识，有兴趣可以继续关注Carson_Ho的安卓开发笔记 作者：Carson_Ho链接：http://www.jianshu.com/p/d963c55c3ab9來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Studio小知识及错误]]></title>
    <url>%2Fpost%2Fee15b0a9.html</url>
    <content type="text"><![CDATA[【小知识】 1.开始界面RecentProject删除不用的工程：鼠标移动到该工程，使焦点在该工程，按退格键，会提示是否删除 2.拷贝类的全名，Studio总为Copy Reference 3.Activity的onCreate方法，代码提示默认是第一个public，其实应该为第二行protected的那个，否则不显示内容 3.Studio代码提示忽略大小写：Settings —&gt; 搜索Sensitive —&gt; Case sensitive completion: None 5.运行java，新建一个项目，新建一个java library，添加main方法，去掉文件头部package xxx，cmd下进入到该java文件目录，javac编译java运行。 6.自定义组合控件，控件的属性名，不能与系统预定义的冲突，否则构建不过。 7.Studio建立aidl文件不生成对应的java文件，Sync project with gradle files 就OK了，生成之后再调用。 8.Studio使用自定义控件，要先构建一下检查一下是否与系统预定义的属性字段冲突。 9.Gradle有时需要下载，可能会因为网速或网络提供商的问题，导致不能正确下载，一直停留在转圈等待状态，此时可以切换网络，例如手机网络下载。 10.2.x版本安装插件却安装不上，不显示，在idea.properties文件中最后一行添加如下一句话： idea.plugins.path=${idea.system.path}/plugins 11.1.5版本导入settings.jar文件，先不要设置Studio安装目录下bin目录的idea.properties中.AndroidStudio目录的路径，导入以后再设置，然后把C盘用户目录下的这个目录整个剪切到Studio安装目录 12.若要使用butterknife，可在app的build.gradle中dependencies内添加compile ‘com.jakewharton:butterknife:6.1.0’ 13.插件默认是下载到F:\\AndroidStudio\\Studio\.AndroidStudio1.5\\system\\plugins目录，如果安装插件重启AS以后看不到插件，需要在F:\\AndroidStudio\\Studio\\plugins目录下建立对应的目录，再新建一个lib目录，把jar文件放入，如果插件是一个zip包，直接解压到该目录即可，里面自带lib目录，目录下是jar文件，重启AS即可看到插件 【错误/BUG】 1.eclipse和studio一样都存在移除断点后运行apk还会调试模式的bug,重启手机即可 2.studio导入eclipse项目常见错误及解决方法： (1).SDK版本问题，多换几个版本试一试，有些源码需要sdk版本较高 (2).9 patches图片问题，build.gradle中添加下面两行代码，修改一下图片或将后缀去掉.9改为.png即可 aaptOptions.cruncherEnabled = false aaptOptions.useNewCruncher = false (3).AndroidManifest.xml问题，有些重复的权限，或者某些标签过时了，去掉即可，按照下方给出的建议修改即可 (4).编码问题 (5).导入eclipse导出的项目，可能会报一大堆的错误，这个时候不妨新建一个项目，然后把eclipse导出的项目所有源文件、资源覆盖到新建的项目。 3.svn提交代码，需要取消勾选右边的两个代码处理选项，另外必须取消勾选build文件夹，否则不会提交。 4.studio的一个小BUG，包名下应当先建立两个包，然后再把java文件拖动到其中一个进去，否则，会包名合并， 例如com.itheima.phonesafe，建立包activities,直接把SplashActivity.java剪切进去，会包名合并。 5.导入eclipse有库项目的工程时，会不能导入，原因是没有找到库工程，设置一下eclipse项目的project.properties文件里面库项目的引用 6.AS在导入eclipse的库项目时，IDE可能图片显示不正常 7.导入工程以后 Error:Could not find com.Android.tools.build:gradle:1.3.1. Searched in the following locations: file:/E:/android-studio/gradle/m2repository/com/android/tools/build/gradle/1.3.1/gradle-1.3.1.pom file:/E:/android-studio/gradle/m2repository/com/android/tools/build/gradle/1.3.1/gradle-1.3.1.jar http://mirrors.ibiblio.org/maven2/com/android/tools/build/gradle/1.3.1/gradle-1.3.1.pom http://mirrors.ibiblio.org/maven2/com/android/tools/build/gradle/1.3.1/gradle-1.3.1.jar Required by: :DynamicAPK-master:unspecified 解决这个问题根据提示打开E:/android-studio/gradle/m2repository/com/android/tools/build/gradle看看该目录下有几个版本,修改成本地存在的即可 8.编译工具找不到 Error:A problem occurred configuring project ‘:bundle’. &gt; failed to find Build Tools revision 21.1.2 file —&gt; default settings —- android sdk —&gt; sdk Tools选项卡 看看sdk manager上安装的版本号是多少, 修改成存在的即可 9.关于Xutils框架出现无法访问HttpRequestBase 找不到org.apache.http.client.methods.HttpRequestBase Android 6.0后,Android的网络请求强制使用HttpUrlConnection,SDK中已经移除了HttpClient, 需要在eclipse下libs里添加org.apache.http.legacy.jar，android studio里在相应的module下的build.gradle中加入： android{ useLibrary’org.apache.http.legacy’ } 10.Unable to find optional library: org.apache.http.legacy create a file called optional.json in \\platforms\\android-23\\optional\ directory with the following content: [ { “name”: “org.apache.http.legacy”, “jar”: “org.apache.http.legacy.jar”, “manifest”: false } ] 添加org.apache.http.legacy.jar 这个jar到android sdk安装目录下的 /android-23/optional, 没有的话就去网上下载吧 11. Error:(7, 1) A problem occurred evaluating project ‘:demo1’. &gt; Could not resolve all dependencies for configuration ‘classpath’. &gt; Could not resolve net.sf.proguard:proguard-gradle:5.2.1. Required by: unspecified:unspecified:unspecified &gt; Could not resolve net.sf.proguard:proguard-gradle:5.2.1. &gt; Could not get resource ‘https://repo1.maven.org/maven2/net/sf/proguard/proguard-gradle/5.2.1/proguard-gradle-5.2.1.pom‘. &gt; Could not GET ‘https://repo1.maven.org/maven2/net/sf/proguard/proguard-gradle/5.2.1/proguard-gradle-5.2.1.pom‘. &gt; peer not authenticated 这个是用于没法访问 https://repo1.maven.org/maven2/net/sf/proguard/proguard-gradle/5.2.1/proguard-gradle-5.2.1.pom 没办法只能翻墙了 12.xxx.java使用或覆盖了已过时的 API。有关详细信息请使用-Xlint:deprecation重新编译 去项目对应的build.gradle中添加配置： allprojects { gradle.projectsEvaluated { tasks.withType(JavaCompile) { options.compilerArgs &lt;&lt; “-Xlint:unchecked” &lt;&lt; “-Xlint:deprecation” } } } 13.Plugin with id ‘com.github.dcendents.android-maven’ not found 你需要在Project的build.gradle下面（buildscript-dependencies）添加这两个依赖项 classpath ‘com.github.dcendents:android-maven-gradle-plugin:1.3’ classpath ‘com.jfrog.bintray.gradle:gradle-bintray-plugin:1.2’ 另外需要注意的是不仅要加这两个，还要保证后面的版本号是对的才行（这个你其实可以在你下载下来的github源项目的配置文件里去找），我之前就是因为把上面两个版本号都写成了1.2，1.2就都没编译过 14.Error:Execution failed for task ‘:app:transformClassesWithDexForDebug’解决记录 详细解决过程看csdn日志 14.Error: org/gradle/api/publication/maven/internal/DefaultMavenFactory Android 当你使用的Gradle版本是2.4以上，Android插件版本是1.3.0以上的时候就会出现这个问题，这时候你只需将build.gradle文件中在’com.github.dcendents:android-maven-plugin:1.2’前面一行添加classpath ‘com.github.dcendents:android-maven-gradle-plugin:1.3’。 15.Failed to resolve: junit:junit:4.12 allprojects { repositories { jcenter { url “http://jcenter.bintray.com/“ } } } 16.Error:Unable to start the daemon process. This problem might be caused by incorrect configuration of the deamon. 解决方案： C：USER_NAME/.Gradle/(如果没有新建)gradle.properties 内容如下： org.gradle.daemon=true org.gradle.jvmargs=-Xmx1024m -XX:MaxPermSize=1024m 重启Studio 17.Error running app: This version of Android Studio is incompatible with the Gradle Plugin used step1: 禁用Instant Run，在Settings/Preferneces &gt; Build, Execution, Deployment option &gt; Instant Run 中，取消所有的选中项 step2: 删除project下的build文件夹 step3: clean项目，重新编译跑程序 18.warning :uninstalling will remove the application data! 禁用Instant Run，在Settings/Preferneces &gt; Build, Execution, Deployment option &gt; Instant Run 中，取消所有的选中项 19.无法安装 Java 配置文件 C:\\ProgramData\\Oracle\\Java\\java.settings.cfg 在行 1 中格式 首先显示隐藏文件夹，因为 C:\\ProgramData是一个隐藏文件。 然后删掉 C:\\ProgramData下的Oracle文件夹。 重新安装即可。 20.Error:Execution failed for task ‘:app:transformClassesWithJarMergingForDebug’. &gt; com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/graphics/drawable/RoundedBitmapDrawable.class 使用compile ‘com.github.chrisbanes:PhotoView:2.1.3’这个包必须将compile ‘com.android.support:appcompat-v7:25.3.1’的版本设置为23.x.x以上否则可能导致这个错误 未完待续..。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6数组方法汇总]]></title>
    <url>%2Fpost%2Fd6d0aa3f.html</url>
    <content type="text"><![CDATA[【转】当做工具使用会改变自身的方法：array.copyWithin（target, start [, end = this.length]）【有兼容性问题】 用于在数组内的替换操作，即替换元素和被替换元素都是数组内的元素 参数皆为整数，允许start，end为负数（倒数第n个） array.fill(value [,statrt = 0[, end = this.length]]) 将数组中指定区间的所有元素的值，都替换成value start，end允许为负值，同上 array.pop() 删除一个数组中的最后一个元素，并且返回这个元素 array.push(element1, ...elementN) 添加一个或多个元素到数组的末尾，并返回数组新的长度 array.reverse() 前后颠倒数组中元素的位置，第一个元素会成为最后一个 array.shift() 删除数组的第一个元素，并返回这个元素 array.unshift(element1, ...elementN) 在数组的开头插入一个或多个元素，并返回数组的新长度 array.sort([function(a, b)]) 对数组的元素做原地的排序，并返回这个数组。sort可能_不稳定_，默认按照字符串的unicode码位点排序 记a和b是两个将要被比较的元素： 如果函数function（a， b）返回值小于0， 则a会排在b之前 如何函数返回值等于0， 则a和b的相对位置不变（并不被保证） 如果函数返回值大于0，则a会排在b之后 比较函数输出结果必须稳定，否则排序的结果将是不确定的 array.splice(start, deleteCount[, item1[, item2...]) 在任意的位置给数组添加或删除任意个元素（拼接），返回被删除的元素组成的数组，没有则返回空数组 start: 开始操作的索引 deleteCount：要移除的数组元素的个数 itemN:要添加进数组的元素，如果不指定，则splice只删除数组元素 不会改变自身的方法array.concat(value1, value2.....) 将传入的数组或非数组值与原数组合并，组成一个新的数组并返回 注意：concat方法在拷贝原数组的过程中， 对象引用（非对象直接量）：concat方法会复制对象引用放到组合的新数组里，原数组和新数组中的对象引用都指向同一个实际的对象，所以，当实际的对象被修改时，两个数组也同时被修改 字符串和数字（是原始值，而不是包装原始值的string和number对象）：concat方法会复制字符串和数字的值放到新数组里 一个栗子： var arr1 = [1, 2, {a: &#39;test&#39;}] var arr2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] var output = arr1.concat(arr2) console.log(output) // output[2].a == &#39;test&#39; setTimeout(function(){ arr1[2].a = &#39;has changed&#39; console.warn(output) //output[2].a == &#39;has changed&#39; }, 5000) 另一个栗子： var arr1 = [1, 2, 3] var arr2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] var output = arr1.concat(arr2) console.log(output) setTimeout(function(){ arr1[2] = 99 console.warn(output) //output值并不会改变 }, 5000) 将非数组值合并到数组里： var alpha = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] var output = alpha.concat(1, [2, 3]) //[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3] array.includes(searchElement, [, fromIndex])[实验性质，es7，可能会改变或删除] 用来判断当前数组是否包含某指定的值，如果是，则返回true，否则false array.join([separator = &#39;,&#39;]) 将数组中的所有元素连接成一个字符串(默认用逗号作为分隔符，如果separator是一个空字符串，那么数组中的所有元素将被直接连接) 如果元素是undefined或者null，则会转化成空字符串 array.slice([begin = 0 [, end = this.length - 1]]) 把数组中一部分的浅复制（shallow copy）存入一个新的数组对象中，并返回这个新的数组 不修改原数组，只会返回一个包含了原数组中提取的部分元素的一个新数组 具体拷贝规则同concat函数 array.toString() 返回一个字符串，该字符串由数组中的每个元素的toString（）返回值经调用join（）方法连接（由逗号隔开）组成。 一个例子： var arr = [&#39;abc&#39;, 2, {a: &#39;test&#39;}] console.log(arr.toString()) //&#39;abc,2,[object Object]&#39; array.toLocaleString() 返回一个字符串表示数组中的元素。数组中的元素将使用各自的toLocaleString方法转化成字符串，这些字符串将使用一个特定语言环境的字符串（例如逗号）隔开 array.indexOf(searchElement[, fromIndex = 0]) 返回指定元素能在数组中找到的第一个索引值，否则返回-1 fromIndex可以为负，表示从倒数第n个开始（此时仍然从前向后查询数组） 使用“严格相等”（===）进行匹配 一个例子： var obj = {a: &#39;test&#39;} var arr = [&#39;a&#39;, &#39;b&#39;, {a: &#39;test&#39;}] console.log(arr.indexOf(obj)) //-1 var arr2 = [1, &#39;b&#39;, {a: &#39;test&#39;}] console.log(arr2.indexOf(&#39;1&#39;)) //-1 array.lastIndexOf(searchElement[, fromIndex = arr.length - 1]) 返回指定元素在数组中的最后一个的索引，如果不存在则返回-1， 从数组的后面向前查找 同上 遍历方法array.forEach((v, i, a) =&gt; {}) 让数组的每一项都执行一次给定的函数 v表示当前项的值，i表示当前索引，a表示数组本身 _forEach遍历的范围在第一次调用 callback前就会确定。调用forEach后添加到数组中的项不会被 callback访问到。如果已经存在的值被改变，则传递给 callback的值是 forEach遍历到他们那一刻的值。已删除的项不会被遍历到。_ array.entries() 返回一个Array Iterator对象，该对象包含数组中每一个索引的键值对 一个例子： var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; var eArr = arr.entries(); console.log(eArr.next().value); // [0, &quot;a&quot;] console.log(eArr.next().value); // [1, &quot;b&quot;] console.log(eArr.next().value); // [2, &quot;c&quot;] array.every(callback(v, i, a){}) callback只会为那些已经被赋值的索引调用，不会为那些被删除或从来没有被赋值的索引调用 _和forEach函数类似_ 注意：array.every()返回一个布尔值，即对每个元素的callback函数结果作逻辑“&amp;”操作 array.some() 使用方法同上， 注意：对每个元素的callback函数结果作逻辑“||”操作 array.filter((v, i, a) =&gt; {}) 使用指定的函数测试所有元素，并创建一个包含所有测试通过的元素的新数组 callback函数返回一个布尔值，true即通过测试 callback只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用 _不会改变原数组_ array.find((v, i, a) =&gt;{})【有兼容性问题目前】 返回数组中满足测试条件的第一个元素，如果没有满足条件的元素，则返回undefined array.keys() 返回一个数组索引的迭代器（类似于array.entries()方法） array.map((v, i, a) =&gt; {}) 返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组 map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组） array.reduce(callback[, initialValue]) 该方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值 callback参数： previousValue:上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue: 数组中当前被处理的元素 index： index array： 调用的数组 如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。 一个例子 [0, 1, 2, 3, 4, 5].reduce((p, v, i , a) =&gt; { return p + v }) //15 数组扁平化： var flattened = [[0, 1], [2, 3], [4, 5]].reduce((a, b) =&gt; { return a.concat(b) }) //flattened is [0, 1, 2, 3, 4, 5] array.reduceRight() 使用同上，与reduce（）的执行方向相反 作者：mochase链接：http://www.jianshu.com/p/ec79c4e47370來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>ES6</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6的一些基本用法及个别的区别]]></title>
    <url>%2Fpost%2F16326d07.html</url>
    <content type="text"><![CDATA[【转】 更多请参考:ECMAScript6入门 ● let ● variable hoisting ● arrow Function, Lambda表达式 ● Destructuring Assignments 解构赋值 ● 默认参数值 Default Parameters ● 可变参数 ● 解构参数 ● 解构数组 ● 解构对象 ● 遍历 ● Generators ● String Templates ● 快速创建对象 ● 只读变量 ● Sets ● Maps ● Symbols ● WeakMaps ● Promises ● 创建类 ● Modules ● 内置函数 let使用let声明的变量只在语句块内有效。 “use strict”;function blockBindingDemo(){ let a = 123; var b = 123; if(true){ let a = 456; b = 456; console.log(“使用let语句块中的a为” +a);//456 console.log(“使用var语句块中的b为” +b) } console.log(“使用let语句块外的a为” +a);//123 console.log(“使用var语句块外的b为” +b);//456}blockBindingDemo(); 以上，以let方式声明的变量只在语句块内有效，而以var方式的变量是一个全局变量。 variable hoisting可以先初始化变量，再声明变量，如下是可以的： x=6; var x; console.log(x); 相当于： var x; x = 6; 变量首先得初始化，否则会呈现undefined var x = 5; console.log(x + “ “ + y); //5 undefined var y = 7; 因为在声明变量y之前还没有初始化，y还没有被hoisted。 Arrow Function, Lambda表达式 在es6之前，通常这样定义和使用函数： var helloWorld = function(name, greeting){ return name + “ “ + greeting;}console.log(helloWorld(“darren”,”hello”)); es6中可以使用Lambda表达式： var newGreeting = (name, greeting) =&gt; { return name + “ “ + greeting;}console.log(newGreeting(“darren”,”hello”)); 还可以简化成这样的写法： var newGreeting = (name, greeting) =&gt; name + “ “ + greeting;console.log(newGreeting(“darren”,”hello”)); 如果只有一个参数，可以写成： var greeting = greeting =&gt; “Hello “ + greeting; 如果没有参数，可以写成： var greeting = () =&gt; “Hello Darren”; ■ 遍历一个数组，把数组内的元素变成大写。 var courses = [‘hello’,’world’];cosnole.log(courses.map(course =&gt; { return course.toUpperCase();})) ■ 对数组排序。 var myArr = [2, 4.6];var sortedArr = myArr.sort((a, b) =&gt; a &lt; b ? 1 : -1);console.log(sortedArr); ■ this的作用域。 function Course(){ this.name = “”; this.description = “”; this.author = “”; this.getSummary = function(){ return this.name + “, “ + this.description; }; this.getDetails = fuction(){ window.setTimeout(() =&gt; {console.log(this.getSummary() + “ “ + this.author)},1000); }}var course = new Course();course.getDetails(); 以上，this的作用域指的是Course，而不是window。也就是说，lambda表达式中的this的作用域的指向取决于在哪里定义，而不是取决于在哪里使用。 Destructuring Assignments 解构赋值es6之前这样写： var x=1,y=2,z=3; 现在可以这样写： var [x, y, z] = [1, 2, 3]; [y,z] =[z,y]; ■ 从数组中解构赋值 function getDate(){ return [15,07,2015];}var [x, y] = getDate();var [,,z] = getDate();console.log(x);console.log(y);console.log(z); ■ 从对象中解构赋值 function currentDate(){ return {x:1, y:2, z:3};}var {y: myy, z: myz} = currentDate();console.log(myy);console.log(myz); 默认参数值 Default Parameterses6之前，这样写默认参数值： function sayHi(firstname, lastname){ firstname = firstname || “darren”; lastname = lastname || “ji”; console.log(firstname + “ “ + lastname);}sayHi(); 现在可以这么写： function sayHi(firstname=”darren”,lastname=”ji”){ console.log(firstname + “ “ + lastname);}sayHi(); 可变参数把可变参数拼接成字符串，以前这样写： function joinArgus(){ return Array.prototype.slice.call(arguments).join(‘ ‘);}var result = joinArgus(‘hello’,’world’ );console.log(result); 现在可以这么写： function joinArgus(…words){ return words.join(‘ ‘);}var result = joinArgus(‘’,’’);console.log(result); 可以结合Spread Operator来处理可变参数。 function logMessages(message, …args){ console.log(message, …args);}logMessages(“he %s : %s”, “”,””); 解构参数function logMessage(msg, {name: courseName, publisher: publisherName}){ console.log(msg + “ “ + courseName + “ by “ + publisherName);}logMessage(“”, {name:””,publisher:””}); 解构数组 //赋值的时候解构var numbers = [1, 2, 3, 4, 5];var [first, second, third, , fifth] = numbers;console.log(fifth);//使用参数的时候解构function arrayDestructuring([first, second,…rest]){ console.log(first); console.log(second); console.log(rest);}arrayDestructuring(numbers);//嵌套数组的解构var numbers_nested = [1, 2, [3, 4, 5]];var [first, second, [third,,fifth]] = numbers_nested;console.log(first);console.log(second);console.log(third); 解构对象 引用如下：browser.min.js “use strict”;var course = { name: “”, publisher: “”};function courseDetails(course){ let {name, publisher} = course; console.log(name + “ “ + publisher);}courseDetails(course); 遍历 “use strict”;var words = [‘’,’’,’’];//输出键和值for(let word of words.etrieis()){ console.log(word);}//输出值for(let word of words.values()){ console.log(word);}//输出键for(let word of words.keys()){ console.log(word);} Generators有以下的一个Generator的写法： function* greet(){ console.log(调用了greet方法);}greet(); 显示结果： 什么都不显示 按照以往调用函数的方式调用，结果什么都不显示。greet()到底是什么呢？不妨打印出一探究竟。 function* greet(){ console.log(调用了greet方法);}let greeter = greet();console.log(greeter); 显示结果： {next:[Function], throw:[Function]} 原来，当调用greet()的时候并没有执行方法，而是返回一个object对象。 既然next是greet()返回结果中的一个函数，那就调用next()。 function* greet(){ console.log(调用了greet方法);}let greeter = greet();let next = greeter.next();console.log(next); 显示结果： 调用了greet方法 {value:undefined, done: true} value:undfined说明还没有从generator中返回任何值，done:true说明yield已经被执行,这里是null。 yield到底是什么？ function* greet(){ console.log(调用了greet方法); yield “hello”;}let greeter = greet();let next = greeter.next();console.log(next); 显示结果： 调用了greet方法 {value:’hello’, done: false} value:’hello’说明yield返回一个hello值, done:false说明yield还没被执行。如果再执行一次next方法会怎样？ function* greet(){ console.log(调用了greet方法); yield “hello”;}let greeter = greet();let next = greeter.next();console.log(next);let done = greeter.next();console.log(done); 显示结果： 调用了greet方法 {value:’hello’, done: false} {value:undefined, done:true} 可见，当第一次执行next方法时，yield返回hello,但还没真正执行yield语句；当第二次执行next方法时，执行了yield语句，value再次变为undefined。 ● 多个yield语句 如果有多个yield语句呢？ function* greet(){ console.log(`Generators会延迟加载,第一次调用next方法时执行`); yield “How”; console.log(第二次调用next方法时执行); yield “are”; console.log(第三次调用next方法时执行);}var greeter = greet();console.log(greeter.next());console.log(greeter.next());console.log(greeter.next()); 结果： Generators会延迟加载,第一次调用next方法时执行 {value: ‘How’, done:false} 第二次调用next方法时执行 {value: ‘are’, done:false} 第三次调用next方法时执行 {value: undefined, done:true} 还可以通过遍历greet()来分别执行。 function* greet(){ console.log(`Generators会延迟加载,第一次调用next方法时执行`); yield “How”; console.log(第二次调用next方法时执行); yield “are”; console.log(第三次调用next方法时执行);}var greeter = greet();for(let word of greeter){ console.log(word);} 结果： Generators会延迟加载,第一次调用next方法时执行 How 第二次调用next方法时执行 are 第三次调用next方法时执行 可见，greet()集合的集合元素是每一个yield的返回值，也就是调用next方法后返回对象中的value字段对应的值。 也就是按如下写也能获取相同的返回结果： function* greet(){ console.log(`Generators会延迟加载,第一次调用next方法时执行`); yield “How”; console.log(第二次调用next方法时执行); yield “are”; console.log(第三次调用next方法时执行);}var greeter = greet();console.log(greeter.next().value);console.log(greeter.next().value);console.log(greeter.next().value); ● yield赋值 function* greet(){ let a = yield “first”; console.log(a); yield “second”;}var greeter = greet();console.log(greeter.next().value);console.log(greeter.next().value); 结果： first undefined second 而预期的结果是： first first second 真实的结果和预期的结果不一样，yield语句并不能赋值。那么，变量a该如何赋值呢？ function* greet(){ let a = yield “first”; console.log(a); yield “second”;}var greeter = greet();console.log(greeter.next().value);console.log(greeter.next(‘给上一个yield中的变量a赋的值’).value); 结果： first 给上一个yield中的变量a赋的值 second 所以，通过next方法可以给上一个yield语句中的变量赋值。 再看一个yield赋值的例子。 function* greet(){ let a = yield “first”; a = yield a + “hello”; yield a + “hello”;}var greeter = greet();console.log(greeter.next().value);console.log(greeter.next(“first”).value);console.log(greeter.next(“second”).value); 结果： first firsthello secondhello → 当执行console.log(greeter.next().value);时，把第一个yield的返回结果first打印出来。 → 当执行console.log(greeter.next(“first”).value);先把first赋值给上一个yield,即第一个yield中的变量a，打印出firsthello。 → 当执行console.log(greeter.next(“second”).value);先把second赋值给上一个yield,即第二个yield中的变量a，打印出secondhello。 String Templates 以前这样拼接字符串。 var a = “Hello”; var greeting = a + “, World”; console.log(greeting); ES6中可以这样写： var a = “Hello”; var greeting = ${a} , World; console.log(greeting); 在之内的接受空白、换行等，可以把变量放在${}之内。 var msg = \`it&#39;s time ${new Date().getHours()}, I&#39;m sleeping\`; console.log(msg);之内还可以作为参数传递给某个方法并分别取出字符串和变量： function conclude(strings, …values){ console.log(strings); console.log(values);}conclude`it’s time ${new Date().getHours()} I’m sleeping`; 结果： it’s time , I’m sleeping 20 以上之内的字符串自动拼接以逗号分隔，之内变量赋值给 values。 快速创建对象 _let firstName = “Darren”;_ _let lastName = “Ji”; let person = {firstName, lastName}; console.log(person);_ 结果： {firstName: ‘Darren’, lastName: ‘Ji’} 甚至可以创建嵌套对象。 let firstName = “Darren”; let lastName = “Ji”; let person = {firstName, lastName}; let teamName = “恒大”; let team = {person, teamName}; console.log(team); 结果： {person:{firstName: ‘Darren’, lastName: ‘Ji’}, teamName: ‘恒大’} 只读变量 变量值通常可以改变： let a = 100; a = 200; console.log(a); ES6中多了一个修饰符const，把变量设置成只读。 const val = ‘hi’; val = ‘yes’; console.log(val); Sets ES6使用Set类构造集合。 let s = new Set([10, 20, 30]); s.add(40); console.log(s); s.delete(30); console.log(s); 结果： [10, 20, 30, 40] [10, 20, 40] Maps ES6使用Map类处理键值对集合。 var map = new Map();var myKey = {name: ‘darren’};map.set(myKey, ‘my favorite book’);//是否包含某键console.log(map.has(myKey));//根据键获取值console.log(map.get(myKey));//遍历值for(var item of map.values()){ console.log(item);} 结果： true my favorite book my favorite book SymbolsES6是唯一、不可变的，使用Symbol类创建Symbol实例。 Symbol可以作为键。 let a = new Map();{ let key = Symbol(); a.set(key, ‘book’); console.log(a.get(key));} Symbol还可以作为对象的字段。 let courseName = Symbol();let course = { publisher: ‘hd’, [courseName]: ‘lesson’};console.log(course); 结果： {publisher: ‘hd’, Symbol(): ‘lesson’} 如果想遍历Couse对象的字段，Symbol()是获取不到的。使用这一特点可以隐藏某些信息。 let courseName = Symbol();let course = { publisher: ‘hd’, [courseName]: ‘lesson’};console.log(course);var props = [];for(var c in course){ props.push(c);}console.log(props.length);console.log(props); 结果： {publisher: ‘hd’, Symbol(): ‘lesson’} 1 publisher 但可以通过以下方式获取到Symbol以及对应的值。 console.log(Object.getOwnPropertySymbols(course)[0]); let keySymbol = Object.getOwnPropertySymbols(course)[0]; console.log(course[keySymbol]); WeakMaps不能使用字符串作为键。键只能是对象、函数。 var w = new WeakMap();var course = {name: ‘t’, publisher:’hd’};var company = {name: ‘sup’};w.set(course, {price:59});w.set(company, ‘s’);console.log(w.has(course));w.delete(course);w.clear(course);console.log(w.get(company)); Promises fetch(“http://services.odata.org/V4/Northwind/Northwind.svc/&quot;,{ method: ‘get’}).then(function(response){ return response.json();}).then(function(data){ console.log(data.value);}).catch(function(){ console.log(‘failed’);}); 还可以这么写： var promise = new Promise(function(resolve, reject){ $.ajax(“http://services.odata.org/V4/Northwind/Northwind.svc/&quot;,{ success: function(data){ resolve(data); }, error: function(){ reject(“Error”); } })});promise.then(function(result){ console.log(result);}, function(err){ console.log)(err);});//如果有多个promise//Promise.all([promise]).then(function(results){ //results[0] results[1] …},function(){})//Promise.race([promise]);//Promise.reject(reason); 创建类 class Shape{ constructor(w,l){ this.w = w; this.l = l; } render(){ console.log(“开始构建图形…”) }}class Circle extens Shape{ constructor(w, l, radius){ super(w, l); this.radius = radius; } static getpi(){ return 3014; } get area(){ return Circle.pi this.radiusthis.radius; } render(){ console.log(“正在构建圆形…”); }}var obj = new Circle(0, 0, 20);obj.l = 40;obj.render(); Modules Module中的函数除非使用export，否则对外不可用。使用import使用某个函数。 ● 通过export方法导出函数 addition.js function sum(a, b){ return a + b;}function sumThree(a, b, c){ return a + b + c;}export {sum, sumThree}; main.js import {sum, sumThree} from ‘addition’console.log(sum(2,3));console.log(sumTrhee(2, 3, 4)); ● 通过函数上的export方法导出 addition.js export function sum(a, b){ return a + b;}export function sumThree(a, b, c){ return a + b + c;} ● 导入函数使用别名 main.js mport {sum as addTwoNumbers,sumThree} from ‘addition’;console.log(addTwoNumbers(2,3));console.log(sumTrhee(2, 3, 4)); ● 给导入的函数统一的命名空间。 import * as addition from ‘addition’;import {sum as addTwoNumbers,sumThree} from ‘addition’;console.log(addition.sum(2,3));console.log(addition.sumTrhee(2, 3, 4)); 内置函数 //字符串conole.log(‘ha’.repeat(2));console.log(“world”.includes(“rl”));console.log(“Skill”.startsWith(“Skill”));console.log(“Hello”.endsWith(“lo”));//遍历字符串for(var ch of ‘hello’){ console.log(ch);}//近似值检查Math.trunc(39.7); //39Math.trunc(0.5);//0Math.trunc(-0.3);//-0//数值类型检查Number.isNan(45)Number.isFinite();//SignMath.sign();//数值安全性检查Number.isSafeInteger(42);//过滤数组var result = [“”,””,””].find(x =&gt; x == “”);console.log(result);//从某个源获取数组var result = Array.from(document.querySelectorAll(‘*’));console.log(result);//从Map从获取数组var m = new Map([[1,2],[2,4],[4,8]]);console.log(Array.from(m));//从字符串中获取数组console.log(Array.from(“hello”));//创建数组var arr = Array.of(1, 2, 3);//其它数组方法[0, 0, 0].fill(7, 1);[1, 2, 3].findIndex( x =&gt; x == 2);[1, 2, 3, 4, 5].copyWithin(3, 1);//对象属性赋值//{distance:40, duration:20, interval:10, start:0}var first = {start:0};var second = {interval:10, duration:20};var third = {distance: 40};Object.assign(first, second, third);console.log(first);]]></content>
      <categories>
        <category>ES6</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[理解 $nextTick 的作用]]></title>
    <url>%2Fpost%2F210ada31.html</url>
    <content type="text"><![CDATA[结合此图：做出一下理解 有同学在看 Vue 官方文档时，对 API 文档中的 Vue.nextTick 和 vm.$nextTick 的作用不太理解。 其实如果看一下深入响应式原理 - vue.js中的有关内容，可能会有所理解，不过有些同学可能看到这个标题之后就选择跳过了，因此这里简述如下： Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。 $nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM，API 文档中官方示例如下： new Vue({ // … methods: { // … example: function () { // modify data this.message = ‘changed’ // DOM is not updated yet this.$nextTick(function () { // DOM is now updated // `this` is bound to the current instance this.doSomethingElse() }) } }}) 有些同学可能不大理解什么叫 DOM is now updated，在深入响应式原理 - vue.js中的示例情况也比较罕见，Vue 模板中直接在根无素中进行插值，然后在实例方法中使用了 this.$el.textContent 来获得更新之后的 DOM。 为了更好地理解这一点，修改示例如下： 模板—— { {msg}} Message got outside $nextTick: { {msg1}} Message got inside $nextTick: { {msg2}} Message got outside $nextTick: { {msg3}} Change the Message Vue实例— new Vue({ el: ‘.app’, data: { msg: ‘Hello Vue.’, msg1: ‘’, msg2: ‘’, msg3: ‘’ }, methods: { changeMsg() { this.msg = “Hello world.” this.msg1 = this.$refs.msgDiv.innerHTML this.$nextTick(() =&gt; { this.msg2 = this.$refs.msgDiv.innerHTML }) this.msg3 = this.$refs.msgDiv.innerHTML } }}) 点击按钮前的界面： 点击按钮之后，界面如下，注意观察三个条件渲染的结果之间的差异。 看完这个示例，也许有人会问，我在 Vue 实例方法中修改了数据，然后再在 $nextTick 回调中获取该数据在相应 DOM 元素所绑定的内容（或属性）殊无必要，我为什么需要这样的 API 呢？ 考虑这样一种场景，你有一个 jQuery 插件，希望在 DOM 元素中某些属性发生变化之后重新应用该插件，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。]]></content>
      <categories>
        <category>VUEJS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0以上进行垃圾短信屏蔽-需要设置广播软件为默认系统软件]]></title>
    <url>%2Fpost%2Ffe2a948b.html</url>
    <content type="text"><![CDATA[要设为系统默认的短信应用首先要配置一下AndroidManifest.xml文件，添加下列： &lt;!-- BroadcastReceiver that listens for incoming SMS messages —&gt; &lt;/intent-filter&gt; &lt;!-- BroadcastReceiver that listens for incoming MMS messages —&gt; &lt;/intent-filter&gt; &lt;!-- Activity that allows the user to send new SMS/MMS messages —&gt; &lt;/intent-filter&gt; &lt;!-- Service that delivers messages from the phone “quick response” —&gt; &lt;/intent-filter&gt; 其中ComposeSmsActivity.activity可以作为启动的Activity，我的是将Main.activity作为启动Activity的，那就要用Main.activity代替ComposeSmsActivity.activity了，如下： 至于SmsReceiver,MmsReceiver还继承BroadcastReceiver的广播，HeadlessSmsSendService是继承Service的服务，把这几个文件创建出来就可以了，暂时不用做什么操作 设为系统默认短信的关键在ComposeSmsActivity.activity中，如下： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); String defaultSmsApp = null; String currentPn = getPackageName();//获取当前程序包名if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.KITKAT){ defaultSmsApp = Telephony.Sms.getDefaultSmsPackage(this);//获取手机当前设置的默认短信应用的包名}if (!defaultSmsApp.equals(currentPn)) { Intent intent = new Intent(Telephony.Sms.Intents.ACTION_CHANGE_DEFAULT); intent.putExtra(Telephony.Sms.Intents.EXTRA_PACKAGE_NAME, currentPn); startActivity(intent);} }]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Activity的四种launchMode]]></title>
    <url>%2Fpost%2F2a135223.html</url>
    <content type="text"><![CDATA[合抱之木，生於毫末；九層之台，起於累土；千里之行，始於足下。《老子》 今天在社区看到有朋友问“如何在半年内成为顶级架构师”，有网友道“关灯睡觉，不用半年的…”,的确，做梦还来的快一些。作为一个程序员，树立远大的目标是值得欣赏的，但不能只去空想，要一步一步地实践才行。成大事者，须从小事做起；万事起于忽微，量变引起质变。 我们今天要讲的是Activity的四种launchMode。 launchMode在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。这里简单介绍一下task的概念，task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。 Activity一共有以下四种launchMode： 1.standard 2.singleTop 3.singleTask 4.singleInstance 我们可以在AndroidManifest.xml配置的Android:launchMode属性为以上四种之一即可。 [caption id=”attachment_906” align=”aligncenter” width=”1128”] day06 2、3的区别在于一个任务栈都要在栈顶当中，但是3 必须一个任务栈只有一个实例、2可以有多个实例；[/caption] 4 直接将模式为instance的任务栈单独出来作为一个任务栈来使用！ 下面我们结合实例一一介绍这四种lanchMode： 1.standard standard模式是默认的启动模式，不用为配置android:launchMode属性即可，当然也可以指定值为standard。 我们将会一个Activity，命名为FirstActivity，来演示一下标准的启动模式。FirstActivity代码如下： [java] view plain copy packagescott.launchmode; importapp.Activity; importcontent.Intent; importos.Bundle; importview.View; importwidget.Button; importwidget.TextView; public**classFirstActivity extends** Activity { @Override public**void** onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.first); TextView textView = (TextView) findViewById(R.id.textView); setText(this.toString()); Button button = (Button) findViewById(R.id.button); setOnClickListener(newView.OnClickListener() { @Override public**void** onClick(View v) { Intent intent = newIntent(FirstActivity.this, FirstActivity.class); startActivity(intent); } }); } } 我们FirstActivity界面中的TextView用于显示当前Activity实例的序列号，Button用于跳转到下一个FirstActivity界面。 然后我们连续点击几次按钮，将会出现下面的现象： 我们注意到都是FirstActivity的实例，但序列号不同，并且我们需要连续按后退键两次，才能回到第一个FristActivity。standard模式的原理如下图所示： 如图所示，每次跳转系统都会在task中生成一个新的FirstActivity实例，并且放于栈结构的顶部，当我们按下后退键时，才能看到原来的FirstActivity实例。 这就是standard启动模式，不管有没有已存在的实例，都生成新的实例。 2.singleTop 我们在上面的基础上为指定属性android:launchMode=”singleTop”，系统就会按照singleTop启动模式处理跳转行为。我们重复上面几个动作，将会出现下面的现象： 我们看到这个结果跟standard有所不同，三个序列号是相同的，也就是说使用的都是同一个FirstActivity实例；如果按一下后退键，程序立即退出，说明当前栈结构中只有一个Activity实例。singleTop模式的原理如下图所示： 正如上图所示，跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用。也许朋友们会有疑问，我只看到栈内只有一个Activity，如果是多个Activity怎么办，如果不是在栈顶会如何？我们接下来再通过一个示例来证实一下大家的疑问。 我们再新建一个Activity命名为SecondActivity，如下： [java] view plain copy packagescott.launchmode; importapp.Activity; importcontent.Intent; importos.Bundle; importview.View; importwidget.Button; importwidget.TextView; public**classSecondActivity extends** Activity { @Override protected**void** onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.second); TextView textView = (TextView) findViewById(R.id.textView); setText(this.toString()); Button button = (Button) findViewById(R.id.button); setOnClickListener(newView.OnClickListener() { @Override public**void** onClick(View v) { Intent intent = newIntent(SecondActivity.this, FirstActivity.class); startActivity(intent); } }); } } 然后将之前的FirstActivity跳转代码改为： [java] view plain copy Intent intent = newIntent(FirstActivity.this, SecondActivity.class); startActivity(intent); 是的，FirstActivity会跳转到SecondActivity，SecondActivity又会跳转到FirstActivity。演示结果如下： 我们看到，两个FirstActivity的序列号是不同的，证明从SecondActivity跳转到FirstActivity时生成了新的FirstActivity实例。原理图如下： 我们看到，当从SecondActivity跳转到FirstActivity时，系统发现存在有FirstActivity实例,但不是位于栈顶，于是重新生成一个实例。 这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。 3.singleTask 在上面的基础上我们修改FirstActivity的属性android:launchMode=”singleTask”。演示的结果如下： 我们注意到，在上面的过程中，FirstActivity的序列号是不变的，SecondActivity的序列号却不是唯一的，说明从SecondActivity跳转到FirstActivity时，没有生成新的实例，但是从FirstActivity跳转到SecondActivity时生成了新的实例。singleTask模式的原理图如下图所示： 在图中的下半部分是SecondActivity跳转到FirstActivity后的栈结构变化的结果，我们注意到，SecondActivity消失了，没错，在这个跳转过程中系统发现有存在的FirstActivity实例，于是不再生成新的实例，而是将FirstActivity之上的Activity实例统统出栈，将FirstActivity变为栈顶对象，显示到幕前。也许朋友们有疑问，如果将SecondActivity也设置为singleTask模式，那么SecondActivity实例是不是可以唯一呢？在我们这个示例中是不可能的，因为每次从SecondActivity跳转到FirstActivity时，SecondActivity实例都被迫出栈，下次等FirstActivity跳转到SecondActivity时，找不到存在的SecondActivity实例，于是必须生成新的实例。但是如果我们有ThirdActivity，让SecondActivity和ThirdActivity互相跳转，那么SecondActivity实例就可以保证唯一。 这就是singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。 4.singleInstance 这种启动模式比较特殊，因为它会启用一个新的栈结构，将Acitvity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。 我们修改FirstActivity的launchMode=”standard”，SecondActivity的launchMode=”singleInstance”，由于涉及到了多个栈结构，我们需要在每个Activity中显示当前栈结构的id，所以我们为每个Activity添加如下代码： [java] view plain copy TextView taskIdView = (TextView) findViewById(R.id.taskIdView); setText(“current task id: “+ this.getTaskId()); 然后我们再演示一下这个流程： 我们发现这两个Activity实例分别被放置在不同的栈结构中，关于singleInstance的原理图如下： 我们看到从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，然后按下后退键，再次回到原始栈结构；图中下半部分显示的在SecondActivity中再次跳转到FirstActivity，这个时候系统会在原始栈结构中生成一个FirstActivity实例，然后回退两次，注意，并没有退出，而是回到了SecondActivity，为什么呢？是因为从SecondActivity跳转到FirstActivity的时候，我们的起点变成了SecondActivity实例所在的栈结构，这样一来，我们需要“回归”到这个栈结构。 如果我们修改FirstActivity的launchMode值为singleTop、singleTask、singleInstance中的任意一个，流程将会如图所示： singleInstance启动模式可能是最复杂的一种模式，为了帮助大家理解，我举一个例子，假如我们有一个share应用，其中的ShareActivity是入口Activity，也是可供其他应用调用的Activity，我们把这个Activity的启动模式设置为singleInstance，然后在其他应用中调用。我们编辑ShareActivity的配置： [html] view plain copy &lt;activityandroid:name=”.ShareActivity” android:launchMode=”singleInstance”&gt; &lt;action android:name=”android.intent.action.MAIN” /&gt; &lt;category android:name=”android.intent.category.LAUNCHER” /&gt; &lt;/intent-filter&gt; &lt;action android:name=”android.intent.action.SINGLE_INSTANCE_SHARE” /&gt; &lt;category android:name=”android.intent.category.DEFAULT” /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 然后我们在其他应用中这样启动该Activity： [java] view plain copy Intent intent = newIntent(“android.intent.action.SINGLE_INSTANCE_SHARE”); startActivity(intent); 当我们打开ShareActivity后再按后退键回到原来界面时，ShareActivity做为一个独立的个体存在，如果这时我们打开share应用，无需创建新的ShareActivity实例即可看到结果，因为系统会自动查找，存在则直接利用。大家可以在ShareActivity中打印一下taskId，看看效果。关于这个过程，原理图如下：]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【转】Activity生命周期]]></title>
    <url>%2Fpost%2Fe2da3f79.html</url>
    <content type="text"><![CDATA[子曰：溫故而知新，可以為師矣。《論語》 学习技术也一样，对于技术文档或者经典的技术书籍来说，指望看一遍就完全掌握，那基本不大可能，所以我们需要经常回过头再仔细研读几遍，以领悟到作者的思想精髓。 近来回顾了一下关于Activity的生命周期，参看了相关书籍和官方文档，也有了不小的收获，对于以前的认知有了很大程度上的改善，在这里和大家分享一下。 熟悉javaEE的朋友们都了解servlet技术，我们想要实现一个自己的servlet，需要继承相应的基类，重写它的方法，这些方法会在合适的时间被servlet容器调用。其实Android中的Activity运行机制跟servlet有些相似之处，Android系统相当于servlet容器，Activity相当于一个servlet，我们的Activity处在这个容器中，一切创建实例、初始化、销毁实例等过程都是容器来调用的，这也就是所谓的“Don’t call me, I’ll call you.”机制。 我们来看一下这一张经典的生命周期流程图： 相信不少朋友也已经看过这个流程图了，也基本了解了Activity生命周期的几个过程，我们就来说一说这几个过程。 1.启动Activity：系统会先调用onCreate方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。 2.当前Activity被其他Activity覆盖其上或被锁屏：系统会调用onPause方法，暂停当前Activity的执行。 3.当前Activity由被覆盖状态回到前台或解锁屏：系统会调用onResume方法，再次进入运行状态。 4.当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。 5.用户后退回到此Activity：系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。 6.当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用onCreate方法、onStart方法、onResume方法，进入运行状态。 7.用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。 但是知道这些还不够，我们必须亲自试验一下才能深刻体会，融会贯通。 下面我们就结合实例，来演示一下生命周期的几个过程的详细情况。我们新建一个名为lifecycle的项目，创建一个名为LifeCycleActivity的Activity，如下： [java] view plain copy packagescott.lifecycle; importapp.Activity; importcontent.Context; importcontent.Intent; importos.Bundle; importutil.Log; importview.View; importwidget.Button; public**classLifeCycleActivity extends** Activity { private**static final** String TAG = “LifeCycleActivity”; privateContext context = this; private**int** param = 1; //Activity创建时被调用 @Override public**void** onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); i(TAG, “onCreate called.”); setContentView(R.layout.lifecycle); Button btn = (Button) findViewById(R.id.btn); setOnClickListener(newView.OnClickListener() { @Override public**void** onClick(View v) { Intent intent = newIntent(context, TargetActivity.class); startActivity(intent); } }); } //Activity创建或者从后台重新回到前台时被调用 @Override protected**void** onStart() { super.onStart(); i(TAG, “onStart called.”); } //Activity从后台重新回到前台时被调用 @Override protected**void** onRestart() { super.onRestart(); i(TAG, “onRestart called.”); } //Activity创建或者从被覆盖、后台重新回到前台时被调用 @Override protected**void** onResume() { super.onResume(); i(TAG, “onResume called.”); } //Activity窗口获得或失去焦点时被调用,在onResume之后或onPause之后 /*@Override public void onWindowFocusChanged(boolean hasFocus) { onWindowFocusChanged(hasFocus); i(TAG, “onWindowFocusChanged called.”); }*/ //Activity被覆盖到下面或者锁屏时被调用 @Override protected**void** onPause() { super.onPause(); i(TAG, “onPause called.”); //有可能在执行完onPause或onStop后,系统资源紧张将Activity杀死,所以有必要在此保存持久数据 } //退出当前Activity或者跳转到新Activity时被调用 @Override protected**void** onStop() { super.onStop(); i(TAG, “onStop called.”); } //退出当前Activity时被调用,调用之后Activity就结束了 @Override protected**void** onDestroy() { super.onDestroy(); i(TAG, “onDestory called.”); } /** Activity被系统杀死时被调用. 例如:屏幕方向改变时,Activity被销毁再重建;当前Activity处于后台,系统资源紧张将其杀死. 另外,当跳转到其他Activity或者按Home键回到主屏时该方法也会被调用,系统是为了保存当前View组件的状态. 在onPause之前被调用. */ @Override protected**void** onSaveInstanceState(Bundle outState) { putInt(“param”, param); i(TAG, “onSaveInstanceState called. put param: “+ param); super.onSaveInstanceState(outState); } /** Activity被系统杀死后再重建时被调用. 例如:屏幕方向改变时,Activity被销毁再重建;当前Activity处于后台,系统资源紧张将其杀死,用户又启动该 这两种情况下onRestoreInstanceState都会被调用,在onStart之后. */ @Override protected void onRestoreInstanceState(Bundle savedInstanceState) { param = savedInstanceState.getInt(“param”); i(TAG, “onRestoreInstanceState called. get param: “+ param); super.onRestoreInstanceState(savedInstanceState); } } 大家注意到，除了几个常见的方法外，我们还添加了onWindowFocusChanged、onSaveInstanceState、onRestoreInstanceState方法： 1.onWindowFocusChanged方法：在Activity窗口获得或失去焦点时被调用，例如创建时首次呈现在用户面前；当前Activity被其他Activity覆盖；当前Activity转到其他Activity或按Home键回到主屏，自身退居后台；用户退出当前Activity。以上几种情况都会调用onWindowFocusChanged，并且当Activity被创建时是在onResume之后被调用，当Activity被覆盖或者退居后台或者当前Activity退出时，它是在onPause之后被调用，如图所示： 这个方法在某种场合下还是很有用的，例如程序启动时想要获取视特定视图组件的尺寸大小，在onCreate中可能无法取到，因为窗口Window对象还没创建完成，这个时候我们就需要在onWindowFocusChanged里获取；如果大家已经看过我写的Android动画之Frame Animation这篇文章就会知道，当时试图在onCreate里加载frame动画失败的原因就是因为窗口Window对象没有初始化完成，所以最后我将加载动画的代码放到了onWindowFocusChanged中，问题迎刃而解。不过大家也许会有疑惑，为什么我在代码里将它注释掉了，因为对当前Activity每一个操作都有它的执行log，我担心这会影响到整个流程的清晰度，所以将它注掉，大家只要了解它应用的场合和执行的顺序就可以了。 2.onSaveInstanceState：(1)在Activity被覆盖或退居后台之后，系统资源不足将其杀死，此方法会被调用；(2)在用户改变屏幕方向时，此方法会被调用；(3)在当前Activity跳转到其他Activity或者按Home键回到主屏，自身退居后台时，此方法会被调用。第一种情况我们无法保证什么时候发生，系统根据资源紧张程度去调度；第二种是屏幕翻转方向时，系统先销毁当前的Activity，然后再重建一个新的，调用此方法时，我们可以保存一些临时数据；第三种情况系统调用此方法是为了保存当前窗口各个View组件的状态。onSaveInstanceState的调用顺序是在onPause之前。 3.onRestoreInstanceState：(1)在Activity被覆盖或退居后台之后，系统资源不足将其杀死，然后用户又回到了此Activity，此方法会被调用；(2)在用户改变屏幕方向时，重建的过程中，此方法会被调用。我们可以重写此方法，以便可以恢复一些临时数据。onRestoreInstanceState的调用顺序是在onStart之后。 以上着重介绍了三个相对陌生方法之后，下面我们就来操作一下这个Activity，看看它的生命周期到底是个什么样的过程： 1.启动Activity： 在系统调用了onCreate和onStart之后，调用了onResume，自此，Activity进入了运行状态。 2.跳转到其他Activity，或按下Home键回到主屏： 我们看到，此时onSaveInstanceState方法在onPause之前被调用了，并且注意，退居后台时，onPause后onStop相继被调用。 3.从后台回到前台： 当从后台会到前台时，系统先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，Activity又进入了运行状态。 4.修改TargetActivity在AndroidManifest.xml中的配置，将android:theme属性设置为@android:style/Theme.Dialog，然后再点击LifeCycleActivity中的按钮，跳转行为就变为了TargetActivity覆盖到LifeCycleActivity之上了，此时调用的方法为： 注意还有一种情况就是，我们点击按钮，只是按下锁屏键，执行的效果也是如上。 我们注意到，此时LifeCycleActivity的OnPause方法被调用，并没有调用onStop方法，因为此时的LifeCycleActivity没有退居后台，只是被覆盖或被锁屏；onSaveInstanceState会在onPause之前被调用。 5.按回退键使LifeCycleActivity从被覆盖回到前面，或者按解锁键解锁屏幕： 此时只有onResume方法被调用，直接再次进入运行状态。 6.退出： 最后onDestory方法被调用，标志着LifeCycleActivity的终结。 大家似乎注意到，在所有的过程中，并没有onRestoreInstanceState的出现，这个并不奇怪，因为之前我们就说过，onRestoreInstanceState只有在杀死不在前台的Activity之后用户回到此Activity，或者用户改变屏幕方向的这两个重建过程中被调用。我们要演示第一种情况比较困难，我们可以结合第二种情况演示一下具体过程。顺便也向大家讲解一下屏幕方向改变的应对策略。 首先介绍一下关于Activity屏幕方向的相关知识。 我们可以为一个Activity指定一个特定的方向，指定之后即使转动屏幕方向，显示方向也不会跟着改变： 1.指定为竖屏：在AndroidManifest.xml中对指定的Activity设置android:screenOrientation=”portrait”，或者在onCreate方法中指定： [java] view plain copy setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); //竖屏 2.指定为横屏：在AndroidManifest.xml中对指定的Activity设置android:screenOrientation=”landscape”，或者在onCreate方法中指定： [java] view plain copy setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); //横屏 为应用中的Activity设置特定的方向是经常用到的办法，可以为我们省去不少不必要的麻烦。不过，我们今天讲的是屏幕方向改变时的生命周期，所以我们并不采用固定屏幕方向这种办法。 下面我们就结合实例讲解一下屏幕转换的生命周期，我们新建一个Activity命名为OrientationActivity，如下： [java] view plain copy packagescott.lifecycle; importapp.Activity; importcontent.res.Configuration; importos.Bundle; importutil.Log; public**class OrientationActivity extends** Activity { private**static final** String TAG = “OrientationActivity”; private**int** param = 1; @Override protected**void** onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.orientation_portrait); i(TAG, “onCreate called.”); } @Override protected**void** onStart() { super.onStart(); i(TAG, “onStart called.”); } @Override protected**void** onRestart() { super.onRestart(); i(TAG, “onRestart called.”); } @Override protected**void** onResume() { super.onResume(); i(TAG, “onResume called.”); } @Override protected**void** onPause() { super.onPause(); i(TAG, “onPause called.”); } @Override protected**void** onStop() { super.onStop(); i(TAG, “onStop called.”); } @Override protected**void** onDestroy() { super.onDestroy(); i(TAG, “onDestory called.”); } @Override protected**void** onSaveInstanceState(Bundle outState) { putInt(“param”, param); i(TAG, “onSaveInstanceState called. put param: “+ param); super.onSaveInstanceState(outState); } @Override protected**void** onRestoreInstanceState(Bundle savedInstanceState) { param = savedInstanceState.getInt(“param”); i(TAG, “onRestoreInstanceState called. get param: “+ param); super.onRestoreInstanceState(savedInstanceState); } //当指定了android:configChanges=”orientation”后,方向改变时onConfigurationChanged被调用 @Override public**void** onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); i(TAG, “onConfigurationChanged called.”); switch(newConfig.orientation) { caseORIENTATION_PORTRAIT: setContentView(R.layout.orientation_portrait); break; caseORIENTATION_LANDSCAPE: setContentView(R.layout.orientation_landscape); break; } } } 首先我们需要进入“Settings-&gt;Display”中，将“Auto-rotate Screen”一项选中，表明可以自动根据方向旋转屏幕，然后我们就可以测试流程了，当我们旋转屏幕时，我们发现系统会先将当前Activity销毁，然后重建一个新的： 系统先是调用onSaveInstanceState方法，我们保存了一个临时参数到Bundle对象里面，然后当Activity重建之后我们又成功的取出了这个参数。 为了避免这样销毁重建的过程，我们需要在AndroidMainfest.xml中对OrientationActivity对应的配置android:configChanges=”orientation”，然后我们再测试一下，我试着做了四次的旋转，打印如下： 可以看到，每次旋转方向时，只有onConfigurationChanged方法被调用，没有了销毁重建的过程。 以下是需要注意的几点： 1.如果配置了android:screenOrientation属性，则会使android:configChanges=”orientation”失效。 2.模拟器与真机差别很大：模拟器中如果不配置android:configChanges属性或配置值为orientation，切到横屏执行一次销毁-&gt;重建，切到竖屏执行两次。真机均为一次。模拟器中如果配置android:configChanges=”orientation|keyboardHidden”（如果是Android4.0，则是”orientation|keyboardHidden|screenSize”），切竖屏执行一次onConfigurationChanged，切横屏执行两次。真机均为一次。 Activity的生命周期与程序的健壮性有着密不可分的关系，希望朋友们能够认真体会、熟练应用。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【转添】Vue2.0 探索之路——生命周期和钩子函数的一些理解]]></title>
    <url>%2Fpost%2Fd43c3157.html</url>
    <content type="text"><![CDATA[前言在使用vue一个多礼拜后，感觉现在还停留在初级阶段，虽然知道怎么和后端做数据交互，但是对于mounted这个挂载还不是很清楚的。放大之，对vue的生命周期不甚了解。只知道简单的使用，而不知道为什么，这对后面的踩坑是相当不利的。 因为我们有时候会在几个钩子函数里做一些事情，什么时候做，在哪个函数里做，我们不清楚。 于是我开始先去搜索，发现vue2.0的生命周期没啥文章。大多是1.0的版本介绍。最后还是找到一篇不错的（会放在最后） vue生命周期简介 咱们从上图可以很明显的看出现在vue2.0都包括了哪些生命周期的函数了。 生命周期探究对于执行顺序和什么时候执行，看上面两个图基本有个了解了。下面我们将结合代码去看看钩子函数的执行。 ps:下面代码可以直接复制出去执行 &lt;!DOCTYPE html&gt; { { message }} var app = new Vue({ el: '#app', data: { message : "xuxiao is boy" }, beforeCreate: function () { console.group('beforeCreate 创建前状态===============》'); console.log("%c%s", "color:red" , "el : " + this.$el); //undefined console.log("%c%s", "color:red","data : " + this.$data); //undefined console.log("%c%s", "color:red","message: " + this.message) }, created: function () { console.group('created 创建完毕状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); //undefined console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 }, beforeMount: function () { console.group('beforeMount 挂载前状态===============》'); console.log("%c%s", "color:red","el : " + (this.$el)); //已被初始化 console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 }, mounted: function () { console.group('mounted 挂载结束状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); //已被初始化 console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 }, beforeUpdate: function () { console.group('beforeUpdate 更新前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, updated: function () { console.group('updated 更新完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, beforeDestroy: function () { console.group('beforeDestroy 销毁前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, destroyed: function () { console.group('destroyed 销毁完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message) } }) create 和 mounted 相关咱们在chrome浏览器里打开，F12看console就能发现 beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载 另外在标红处，我们能发现el还是 { {message}}，这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。到后面mounted挂载的时候再把值渲染进去。 create\\mount[/caption] update 相关这里我们在 chrome console里执行以下命令 app.message= &#39;yes !! I do&#39;; 下面就能看到data里的值被修改后，将会触发update的操作。 update[/caption] destroy 相关有关于销毁，暂时还不是很清楚。我们在console里执行下命令对 vue实例进行销毁。销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。 app.$destroy(); destroy[/caption] 生命周期总结这么多钩子函数，我们怎么用呢，我想大家可能有这样的疑问吧，我也有，哈哈哈。 beforecreate : 举个栗子：可以在这加个loading事件 created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情 beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 当然，还有更多，继续探索中…… 写在最后本文是一个vue的生命周期的理解，如有错误还请大牛指正，让小子也有得进步。 如果对你有所帮助，那是我最大的荣幸。 对了，兄台，对你有帮助的话不妨点个收藏或者推荐再走。 参考文献 https://segmentfault.com/q/10… http://www.cnblogs.com/gagag/… 感谢上面几位兄台的文章和提问。 另外新写了篇 vuex 的文章，欢迎各位给点意见。传送门：Vue2.0 探索之路——vuex入门教程和思考 新写了篇 vue-router的文章，也欢迎各位给点意见。传送门:Vue2.0 探索之路——vue-router入门教程和总结 最近更新文章: Node环境变量 process.env 的那些事儿 vue实例简单方法: vm.$el -&gt; 就是元素 vm.$data -&gt; 就是data vm.$mount -&gt; 手动挂在vue程序 vm.$options -&gt; 获取自定义属性 eg: vm.$options.aa vm.$options.show() //对应于 自定义数据与 方法 vm.$destroy -&gt; 销毁对象 vm.$log(); -&gt; 查看现在数据(data的状态 //console.log(vm.$log());]]></content>
      <categories>
        <category>JS</category>
        <category>VUEJS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java多线程实现下载功能]]></title>
    <url>%2Fpost%2Fff1d6f88.html</url>
    <content type="text"><![CDATA[思路： 1、基本思路是将文件分段切割、分段传输、分段保存。 2、分段切割用到HttpUrlConnection对象的setRequestProperty(“Range”, “bytes=” + start + “-“ + end)方法。 3、分段传输用到HttpUrlConnection对象的getInputStream()方法。 4、分段保存用到RandomAccessFile的seek(int start)方法。 5、创建指定长度的线程池，循环创建线程，执行下载操作。 首先，我们要先写一个方法，方法的参数包含URL地址，保存的文件地址，切割后的文件开始位置和结束位置，这样我们就能把分段文件下载到本地。并且这个方法要是run方法，这样我们启动线程时就直接执行该方法。 public class DownloadWithRange implements Runnable { private String urlLocation; private String filePath; private long start; private long end; DownloadWithRange(String urlLocation, String filePath, long start, long end) { this.urlLocation = urlLocation; this.filePath = filePath; this.start = start; this.end = end; } @Override public void run() { try { HttpURLConnection conn = getHttp(); conn.setRequestProperty(“Range”, “bytes=” + start + “-“ + end); File file = new File(filePath); RandomAccessFile out = null; if (file != null) { out = new RandomAccessFile(file, “rwd”); } out.seek(start); InputStream in = conn.getInputStream(); byte[] b = new byte[1024]; int len = 0; while ((len = in.read(b)) != -1) { out.write(b, 0, len); } in.close(); out.close(); } catch (Exception e) { e.getMessage(); } } public HttpURLConnection getHttp() throws IOException { URL url = null; if (urlLocation != null) { url = new URL(urlLocation); } HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setReadTimeout(5000); conn.setRequestMethod(“GET”); return conn; } } 然后我们创建线程池，线程池的长度可以自定义，然后循环创建线程来执行请求，每条线程的请求开始位置和结束位置都不同，本地存储的文件开始位置和请求开始位置相同，这样就可以实现多线程下载了。 public class DownloadFileWithThreadPool { public void getFileWithThreadPool(String urlLocation,String filePath, int poolLength) throws IOException { Executor threadPool = Executors.newFixedThreadPool(poolLength); long len = getContentLength(urlLocation); for(int i=0;i&lt;poolLength;i++) { long start=i*len/poolLength; long end = (i+1)*len/poolLength-1; if(i==poolLength-1) { end =len; } DownloadWithRange download=new DownloadWithRange(urlLocation, filePath, start, end); threadPool.execute(download); } } public static long getContentLength(String urlLocation) throws IOException { URL url = null; if (urlLocation != null) { url = new URL(urlLocation); } HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setReadTimeout(5000); conn.setRequestMethod(“GET”); long len = conn.getContentLength(); return len; }]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java多线程分段下载原理分析和实现]]></title>
    <url>%2Fpost%2F3fe459e1.html</url>
    <content type="text"><![CDATA[多线程下载介绍 多线程下载技术是很常见的一种下载方案，这种方式充分利用了多线程的优势，在同一时间段内通过多个线程发起下载请求，将需要下载的数据分割成多个部分，每一个线程只负责下载其中一个部分，然后将下载后的数据组装成完整的数据文件，这样便大大加快了下载效率。常见的下载器，迅雷，QQ旋风等都采用了这种技术。 实现方案 原理很清楚，但是其中涉及到两个关键问题： 需要请求的数据如何分段。 分段下载的数据如何组装成完整的数据文件。 要解决这两个问题，需要掌握下面两个知识点。 Range范围请求 Range，是在 HTTP/1.1里新增的一个 header field，它允许客户端实际上只请求文档的一部分，或者说某个范围。 有了范围请求，HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这次发出范围请求的时段内，该对象没有改变过。例如： GET /bigfile.html HTTP/1.1 Host: www.joes-hardware.com Range: bytes=4000- User-Agent: Mozilla/4.61 [en] (WinNT; I) 上述请求中，客户端请求的是文档开头 4000 字节之后的部分（不必给出结尾字节数，因为请求方可能不知道文档的大小）。在客户端收到了开头的 4000 字节之后就失败的情况下，可以使用这种形式的范围请求。还可以用 Range 首部来请求多个范围（这些范围可以按任意顺序给出，也可以相互重叠）。例如，假设客户端同时连接到多个服务器，为了加速下载文档而从不同的服务器下载同一个文档的不同部分。对于客户端在一个请求内请求多个不同范围的情况，返回的响应也是单个实体，它有一个多部分主体及 Content-Type: multipart/byteranges 首部。 Range头域使用形式如下。例如： 表示头500个字节：bytes=0-499 表示第二个500字节：bytes=500-999 表示最后500个字节：bytes=-500 表示500字节以后的范围：bytes=500- 第一个和最后一个字节：bytes=0-0,-1 如果客户端发送的请求中Range这个值存在而且有效，则服务端只发回请求的那部分文件内容，响应的状态码变成206，表示 Partial Content，并设置Content-Range。如果无效，则返回416状态码，表明Request Range Not Satisfiable如果不包含Range的请求头，则继续通过常规的方式响应。 比如某文件的大小是 1000 字节，client 请求这个文件时用了 Range: bytes=0-500，那么 server 应该把这个文件开头的 501 个字节发回给 client，同时回应头要有如下内容：Content-Range: bytes 0-500/1000,并返回206状态码。 并不是所有服务器都接受范围请求，但很多服务器可以。服务器可以通过在响应中包含 Accept-Ranges 首部的形式向客户端说明可以接受的范围请求。这个首部的值是计算范围的单位，通常是以字节计算的。 随机访问文件RandomAccessFile类 RandomAccessFile适用于由大小已知的记录组成的文件，所以我们可以使用seek()将记录从一处转移到另一处，然后读取或修改记录。 随机访问文件的行为类似存储在文件系统中的一个大型 byte 数组。存在指向该隐含数组的光标或索引，称为文件指针；输入操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，并随着对字节的写入而前移此文件指针。写入隐含数组的当前末尾之后的输出操作导致该数组扩展。该文件指针可以通过 getFilePointer 方法读取，并通过 seek 方法设置。 RandomAccessFile虽然位于 Java.io包中，但从RandomAccessFile类的层级结构来看，它并不是InputStream或者OutputStream继承层次结构中的一部分。除了实现了DataInput和DataOutput接口（DataInputStream和DataOutputStream也实现了这两个接口），它和这个两个继承层次结构没有任何关联。它甚至不适用InputStream和OutputStream类中已有的任何功能。它是一个完全独立的类，从头开始编写其所有的方法（大多数都是native的）。这么做是因为RandomAccessFile拥有和别的I/O类型本质不同的行为，我们可以通过它在一个文件内向前和向后移动。在任何情况下，它都是自我独立的，直接派生自Object类。 本质上来说，RandomAccessFile的工作方式类似于把DataInputStream和DataOutStream组合起来使用，还添加了一些方法。 以下是一些比较重要的方法。 构造方法**RandomAccessFile** public RandomAccessFile(File file, String mode) throws FileNotFoundException 创建从中读取和向其中写入（可选）的随机访问文件流，该文件由 File 参数指定。将创建一个新的 FileDescriptor 对象来表示此文件的连接。 mode 参数指定用以打开文件的访问模式。允许的值及其含意为： “r“——以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。 “rw“——打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。 “rws“—— 打开以便读取和写入，对于 “rw”，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。 “rwd“——打开以便读取和写入，对于 “rw”，还要求对文件内容的每个更新都同步写入到底层存储设备。 getFilePointer public native long getFilePointer() throws IOException; 返回此文件中的当前偏移量,以字节为单位。 length public native long length() throws IOException; 返回此文件的长度。 setLength public native void setLength(long newLength) throws IOException 设置此文件的长度。 seek public native void seek(long pos) throws IOException 设置到此文件开头测量到的文件指针偏移量，在该位置发生下一个读取或写入操作。 write public void write(byte[] b,int off,int len) throws IOException 将 len 个字节从指定 byte 数组写入到此文件，并从偏移量 off 处开始。 RandomAccessFile类特殊之处在于支持搜寻方法，并且只适用于文件，这种随机访问特性，为多线程下载提供了文件分段写的支持。 需要注意的是，在RandomAccessFile的大多函数均是native的，在JDK1.4之后，RandomAccessFile大多数功能由nio存储映射文件所取代。所谓存储映射文件，简单来说 是由一个文件到一块内存的映射。内存映射文件与虚拟内存有些类似，通过内存映射文件可以保留一个地址空间的区域，同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作，使得内存映射文件在处理大数据量的文件时能起到相当重要的作用。有了内存映射文件，我们就可以假定整个文件都放在内存中，而且可以完全把它当做非常大的数组来访问。 了解了上面两个知识点，下面看一下多线程下载的具体实现。 多线程下载代码实现 MutiThreadDownLoad.java import java.io.InputStream;import java.io.RandomAccessFile;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.CountDownLatch;/** * 多线程下载模型 * * @author bridge /public class MutiThreadDownLoad { /\* * 同时下载的线程数 / private int threadCount; /\* * 服务器请求路径 / private String serverPath; /\* * 本地路径 / private String localPath; /\* * 线程计数同步辅助 / private CountDownLatch latch; public MutiThreadDownLoad(int threadCount, String serverPath, String localPath, CountDownLatch latch) { this.threadCount = threadCount; this.serverPath = serverPath; this.localPath = localPath; this.latch = latch; } public void executeDownLoad() { try { URL url = new URL(serverPath); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(5000); conn.setRequestMethod(“GET”); int code = conn.getResponseCode(); if (code == 200) { //服务器返回的数据的长度，实际上就是文件的长度,单位是字节 int length = conn.getContentLength(); System.out.println(“文件总长度:” + length + “字节(B)”); RandomAccessFile raf = new RandomAccessFile(localPath, “rwd”); //指定创建的文件的长度 raf.setLength(length); raf.close(); //分割文件 int blockSize = length / threadCount; for (int threadId = 1; threadId &lt;= threadCount; threadId++) { //第一个线程下载的开始位置 int startIndex = (threadId - 1) blockSize; int endIndex = startIndex + blockSize - 1; if (threadId == threadCount) { //最后一个线程下载的长度稍微长一点 endIndex = length; } System.out.println(“线程” + threadId + “下载:” + startIndex + “字节~” + endIndex + “字节”); new DownLoadThread(threadId, startIndex, endIndex).start(); } } } catch (Exception e) { e.printStackTrace(); } } /** * 内部类用于实现下载 / public class DownLoadThread extends Thread { /\* * 线程ID / private int threadId; /\* * 下载起始位置 / private int startIndex; /\* * 下载结束位置 */ private int endIndex; public DownLoadThread(int threadId, int startIndex, int endIndex) { this.threadId = threadId; this.startIndex = startIndex; this.endIndex = endIndex; } @Override public void run() { try { System.out.println(“线程” + threadId + “正在下载…”); URL url = new URL(serverPath); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(“GET”); //请求服务器下载部分的文件的指定位置 conn.setRequestProperty(“Range”, “bytes=” + startIndex + “-“ + endIndex); conn.setConnectTimeout(5000); int code = conn.getResponseCode(); System.out.println(“线程” + threadId + “请求返回code=” + code); InputStream is = conn.getInputStream();//返回资源 RandomAccessFile raf = new RandomAccessFile(localPath, “rwd”); //随机写文件的时候从哪个位置开始写 raf.seek(startIndex);//定位文件 int len = 0; byte[] buffer = new byte[1024]; while ((len = is.read(buffer)) != -1) { raf.write(buffer, 0, len); } is.close(); raf.close(); System.out.println(“线程” + threadId + “下载完毕”); //计数值减一 latch.countDown(); } catch (Exception e) { e.printStackTrace(); } } }} 测试类 package MutiThreadDown;import java.util.concurrent.CountDownLatch;/** * @author bridge */public class Client { public static void main(String[] args) { int threadSize = 4; String serverPath = “http://file.ws.126.net/3g/client/netease\_newsreader\_android.apk“; String localPath = “NewsReader.apk”; CountDownLatch latch = new CountDownLatch(threadSize); MutiThreadDownLoad m = new MutiThreadDownLoad(threadSize, serverPath, localPath, latch); long startTime = System.currentTimeMillis(); try { m.executeDownLoad(); latch.await(); } catch (InterruptedException e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(“全部下载结束,共耗时” + (endTime - startTime) / 1000 + “s”); }} 运行结果 文件总长度:22848007字节(B)线程1下载:0字节~5712000字节线程1正在下载…线程2下载:5712001字节~11424001字节线程2正在下载…线程3下载:11424002字节~17136002字节线程3正在下载…线程4下载:17136003字节~22848007字节线程4正在下载…线程2请求返回code=206线程1请求返回code=206线程4请求返回code=206线程3请求返回code=206线程3下载完毕线程2下载完毕线程4下载完毕线程1下载完毕全部下载结束,共耗时5s 上面的例子，采取4个线程同时下载了网易新闻Android客户端安装包，可以看到成功获取到了文件。 抓包分析验证 采用抓包工具对上述多线程下载过程进行分析，windows上可以采用wireShark，Mac 上可以用Charles,以下是对一次多线程下载的抓包过程。 可以看到本次多线程下载共发起了5次请求，其中第一次请求用于取得文件大小，其余4次用于用于多线程下载文件。可以看到4个线程同时发起请求， 线程1的请求报文如下 可以看到Range字段标识了此次请求只获取0-5712000的文档数据。 服务器的响应报文如下 可以看到服务器响应报文的内容中，状态行Partial Content 标识了此次请求为范围请求，响应内容为部分内容。 Content-Length:5712001标识此次返回的内容长度， Content-Range:bytes 0-5712000/22848007标识了它提供了请求实体所在的原始实体内的位置（范围），还给出了整个实体的长度。 参考资料 《Java 编程思想》 《HTTP 权威指南》 转自：http://blog.csdn.net/lyt_7cs1dn9/article/details/75105266]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【转】Android Studio---断点调试和高级调试]]></title>
    <url>%2Fpost%2F558b253e.html</url>
    <content type="text"><![CDATA[有人说Android 的调试是最坑的，那我只能说是你不会用而已，我可以说Android Studio的调试是我见过最棒的。 好了开始写一个简单的调试程序，我们先来一个for循环 ? 1 2 3 4 5 6 7 8 &lt;code ``class``=``&quot;language-java hljs &quot;``&gt;``for``(``int``i = ``0``; i &lt;``10``; i++) { //获取当前i的值 int``selector = i; //打log查看当前i的值（此步多余，实际开发请忽略） Logger.e(``&quot;for当前的i的值：&quot;``+ i); //调用方法 stepNext(i); }&lt;/code&gt; 设置断点（点击红点位置添加或取消断点） 点击debug模式运行 查看调试面板 一、简单调试 1. step over：一步步往下走 当前程序运行的位置，我们看到i的值已经在程序代码中展示出来了，黄色的代码处，这个是AS的功能，对于我们调试来讲，这简直是非常大的福利了。 点击单步调试按钮或按快捷键F8，看看效果。这里我们看到selector变量的值已经出来了selector：0,我们在看看黄色位置i的当前值是0。 这时我们继续F8，我们切换到logcat查看日志，我打印出的i的值是0， 我们在切回道Debugger面板，可以看到Variables显示面板中，有i的值是0，selector的值是0。以及我们可以看到Frames控制面板中可以显示出当前程序的位置在：onCreate():28,第28行。 2. step into：看到方法往里走 比如我们的for循环当中调用了一个stepNext(int i)方法，当我们走到这里想看看这个方法里面的运行过程的时候我们可以这样，当走到这个方法的时候我们可以按下F7,或者如下图的图标。 这时就走到了stepNext方法当中。 在这里打印了一个log，我们再按一下F8我们来看看Logcat, 这里我打印的log都是为了做教程用，调试我们就不用打log了直接看显示面板就OK了 3. force step into :所有方法看完整 这个是可以看到你所调用的所有方法的实现会让你跟着它走一遍，研究源码使用非常方便 4. step out ：有断点下一个，走完断点继续走 这里如果我们的一个流程当中，包括调用的方法，如果有断点走到下一个断点，如果没有断点，而是在一个调用的方法当中，会跳出这个方法，继续走。 vc/E0aOsvtm49sD919OjujxiciAvPg0KPGltZyBhbHQ9”这里写图片描述” src=”http://www.2cto.com/uploadfile/Collfiles/20150616/20150616083836160.png“ title=”\\” /&gt; (上图)我现在程序位置在第一个断点位置（24行），我调用的stepNext方法中也有一个断点，此时我按下step out按钮会走到stepNext中的断点处（39行）我此时如果再按一下step out 会走到stepNext方法的调用出的下一个可执行代码（30行） (上图)如果我现在程序位置在stepNext的方法中，如果我此时按下step out，会走到stepNext方法的调用出的下一个可执行代码（30行） 5. run to Cursor ：下个断点我们见 这里的意思就是说，会很快执行到下一个断点的位置，而且可以静如任何调用的方法 二、高级调试 1. 跨断点调试 如果我们设置了多个断点，现在我们需要直接跳转到下一个断点，那么直接点击下图就可以了 2.观察变量 如果我们想观察1个或者几个变量的值的变化，如果我们在Variables显示面版中观察如果我这里有太多太多的自定义变量和系统变量了，那么就难观察了，我们可以做如下操作： 点击Watches,点击＋号，然后输入变量的名称回车就OK了，而且会有历史记录哦 如果变量名比较长我们可以这样： 选择［Variables］中的变量名然后点击［右键］，选择［Add to Watches],然后Watches面板中就有了 3.设置变量的值 在程序中有很多的条件语句和循环语句，调试也是比较耗时的，我们可以通过快速设置变量的值来加快调试速度，我们可以做如下操作： 选择［Variables］中的变量名然后点击［右键］，选择［Set Value..]或者选择之后直接F2(如上图)（下图为Variables面板） 4.查看断点 点击之后我们可以看到所有的断点，以及位置代码,也可以设置一些属性 5.停止调试 要注意的是这里的［停止调试］不是让程序停止，而是跳过所有调试 到这里我们的Android Studio的断点调试和高级调试就完毕了。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ready For IT?]]></title>
    <url>%2Fpost%2Fd0d0c7f5.html</url>
    <content type="text"><![CDATA[Ready For IT? 不忘初心，阔别三年， Taylor Swift第六张录音专辑《Reputation》11月10日全球发行。 三年之久，历经全身心投入及精心雕琢，Taylor Swift将以《Reputation》为名，开启主流音乐新纪元。 作为一个程序员。我们也是因为有自己的理想呢。所以不分日夜的在敲打着代码，虽然有时候，可能一下午都只是因为一个小小的bug而度过一下午，一天天，但是…回想 初心真的是很喜欢计算机。这次真的是我最接近梦想的时间、时机了！我想：今后无论如何克服一切困难上升为必须做的事情。加油！无悔青春！ 其实正如，乔布斯“帮主”所说：如果你把每一天都当作生命中最后一天去生活的话，那么有一天你会发现你是正确的。 Stay hungry、 Stay foolish. ——2018-1-3——- 其实真的不知道是什么阻断了你追求梦想的脚步。明明现在不是你想要的地方。你想要的远方还有很远，却还是不知初心的、不知目标的担惊受怕。 所以当初那个中学奋斗6年，不知“天高地厚”的你，去哪了呢？对，没错，说的就是你。 大学四年真的是白驹过隙，如果真的想去985院校，特别是wd 现在的你真的还有好多好多的路要走呢！怎么能不尝试 就放弃呢！！！ 改变心智模式——希望你遇到更好的自己。 其实，你就是“珞珈追梦学子”。 ——2017-11-25—— 不得不说《梦想的声音》真的是一部非常优良的节目，从上面看到了许许多多的优秀歌手、看到了许许多多为了梦想、为了未来努力奋斗、同时看到了导师们之所以为导师的、之所以为大家的理由——无论什么时候 做自己热爱的事情、每一场虽允许有瑕疵但都至诚至深、拼尽全力到无能无力！ JiahaoZhang,希望你也能找到自己热爱的事情、梦想，在自己的方向上真诚、拼尽全力！为梦想勇敢！ 自强、求是、弘毅、拓新. ——2017-11-24—— 武大武大，早起第二天打卡！ ——2017-11-23—— 早起第一天打卡！7点 武大武大，现在忽然发现，对于武汉的渴望又进一步加强！ 武大武大，就算是为了疯狂的青春也要奋力一把！宁愿完整无悔，也不愿后悔没有拼搏！ 【每日一句】 Many of our fears are tissue-paper-thin, and a single courageous step would carry us clear through them. 很多恐惧都像是窗户纸，只要有一丁点勇气就会发现，一捅就破。 【每日一句】 Too many people overvalue what they are not and undervalue what they are. 太多的人高估他们所欠缺的，却又低估了他们所拥有的。 1.注意关于iPoli 在googleService当中添加下载服务 2.注意Bmob哪款日记用这个进行后台开发的思想 简书 视频 购买项目 3.MD风格参考 4.注意已经更新iPoli为API26 即Android8.0 5.发现Ming标签登录提醒 coolnotes、iPoli计划习惯、Bomb Diary-master 6.最好统一UTF-8风格！ ——2017-11-13—— 今天在挣扎了一番之后终于。要坚定自己的决心了！只有半年的时间： 不逼自己一把，你永远也不知道自己有多优秀！一年！半年能改变的有很多！ 首先信念、态度真正转换为自己的力量之行！！！克服一切困难！上！ 到达一切地域、夺占一切先机、克服一切困难、战胜一切对手 选择一个方向或者自己感兴趣的东西（作为毕业设计），真正的深入下去！去做、去融入、去实践！ 主攻Android、Vue前端 辅助：6级、考研方面、创业创新。 ——2017-11-07—— 好久没有听到霉霉的歌曲了。霉霉的回归，11.10号最新专辑——无与伦比的霉霉还是如此的优秀！也许霉霉真的是一位最能明确自己的方向、最能为了自己的梦想打拼、奋斗、沉寂的才华与努力兼具的女歌手了！ Ready For it…付费听歌，寻找方向。其实IT行业也是如许许多多的行业一般，我真的不知道未来我究竟相要些什么？想要去做些什么呢？也许思考懂了这个问题才能像霉霉一样或者比她去花更多的时间去拥有匠心精神…精雕细琢、不忘初心、不畏将来！——So…IT For What??? 这半年先把手头的项目完成吧！Android 一定上升为必须完成的！！！、vue？————脚踏实地、不忘初心、aclear清晰学习can！]]></content>
      <categories>
        <category>日记之家</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ADB Shell操作指令]]></title>
    <url>%2Fpost%2F6fd4de0b.html</url>
    <content type="text"><![CDATA[（一）adb shell命令基础运用—-【速递】adb操作下载不同虚拟机的文件到本地电脑—- adb devices adb -s 192.168.186.102:5555 shell adb -s 192.168.186.102:5555 pull sdcard/info2.xml ls -l —-在开始运行命令前，需要将adb配置到系统环境变量中。然后打开cmd窗口，就可以直接运行adb命令了 1. 显示系统中全部Android平台： android list targets 2. 显示系统中全部AVD（模拟器）： android list avd 3. 创建AVD（模拟器）： android create avd -n 模拟器名称 -t target的id（android-8） 4. 启动模拟器： emulator -avd 模拟器名称 5. 删除AVD（模拟器）： android delete avd -n 模拟器名称 6. 创建SDCard：（未验证） mksdcard 1024M ~/名称.img 7. AVD(模拟器)所在位置：（未验证） Linux(~/.android/avd) Windows(C:Documents and SettingsAdministrator.androidavd) 8. 启动DDMS： ddms 9. 显示当前运行的全部模拟器： adb devices 10. 对某一模拟器执行命令： abd -s 模拟器编号 命令 11. 安装应用程序： adb install -r 应用程序.apk 12. 获取模拟器中的文件： adb pull 13. 向模拟器中写文件： adb push 14. 进入模拟器的shell模式： adb shell 15. 启动SDK，文档，实例下载管理器： android 16. 缷载apk包： adb shell cd data/app rm apk包 exit adb uninstall apk包的主包名 adb install -r apk包 17. 查看adb命令帮助信息： adb help 18. 在命令行中查看LOG信息： adb logcat -s 标签名 19. adb shell后面跟的命令主要来自： 源码systemcoretoolbox目录和源码frameworksbasecmds目录。 20. 删除系统应用： adb remount （重新挂载系统分区，使系统分区重新可写）。 adb shell cd system/app rm *.apk 21. 获取管理员权限： adb root 22. 启动Activity：（很实用的命令） adb shell am start -n 包名/包名＋类名（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等）。 23、发布端口： 你可以设置任意的端口号，做为主机向模拟器或设备的请求端口。如： adb forward tcp:5555 tcp:8000 24、复制文件： 你可向一个设备或从一个设备中复制文件，复制一个文件或目录到设备或模拟器上： adb push 如：adb push test.txt /tmp/test.txt 从设备或模拟器上复制一个文件或目录： adb pull 如：adb pull /addroid/lib/libwebcore.so . 25、搜索模拟器/设备的实例： 取得当前运行的模拟器/设备的实例的列表及每个实例的状态： adb devices 26、查看bug报告：adb bugreport 27、记录无线通讯日志： 一般来说，无线通讯的日志非常多，在运行时没必要去记录，但我们还是可以通过命令，设置记录：adb shell logcat -b radio 28、获取设备的ID和序列号： adb get-product adb get-serialno 29、访问数据库SQLite3 adb shell sqlite3 #cd system/sd/data //进入系统内指定文件夹#ls //列表显示当前文件夹内容 #rm -r xxx //删除名字为xxx的文件夹及其里面的所有文件 #rm xxx //删除文件xxx #rmdir xxx //删除xxx的文件夹 （二）adb环境的搭建 第一步，打开环境变量配置窗口。右击计算机，属性-高级系统设置-环境变量。 第二步，添加android系统环境变量。在系统变量下点击新建按钮，输入环境变量名android（自己的习惯命名），将android开发工具的路径导入，如图： 第三步，在path中添加刚刚添加的环境。选择系统变量中Path，点击编辑按钮，输入刚刚建好的环境，方法和配置java一样，记住要加两个百分号，如图： 第四步，测试环境变量。 首先打开运行命令，运行在开始菜单中就有，如果找不到可以在开始中搜索即可，也可以直接按住win+R快捷键，打开运行。 最后一步，在运行中输入cmd，调用命令操作窗口。进入后输入adb查看运行结果。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【转】Android res与assets资源的区别]]></title>
    <url>%2Fpost%2F37783254.html</url>
    <content type="text"><![CDATA[android应用可以将资源存储在两个目录：res和assets。其中res目录中的资源只能存储在相应的 子目录(如res/layout、res/values等)中，不能直接将资源存储在res目录中。assets目录中的 资源可以任意存放，也可以建立任意层次的子目录。res和assets资源的主要区别如下。 1、引用资源的方式不同 res目录中的所有资源都会在R类的相应子类中生成对应的int类型变量，需要使用这些变量 来引用资源。例如res/layout/main.xml是布局文件资源，会在R.layout类中生成一个名为main的 变量，所以需要使用R.layout.main来引用main.xml。 assets目录中的资源需要直接使用文件名来引用，例如assets/xyz.xml、assets/abc/test.db是 assets目录中的两个资源文件，其中abc是assets中的子目录。可以使用如下的代码引用这两个资源文件， 并返回与资源文件对应的InputStream对象，剩下的操作就是普通的Java代码输入流操作了。 InputStream is1=getResources().getAssets().open(“xyz.xml”);InputStream is2=getResources().getAssets().open(“abc/test.db”); 2、处理方式不同 res目录中的资源子目录除了raw外，其他资源目录中的资源文件都会被编译，这也是为什么 将APK文件解压后无法直接查看XML格式资源文件内容的原因。而assets与res/raw目录中的资源 文件不会做任何处理，所以将APK解压后，这两个目录中的资源文件都会保持原样. 3、子目录不同 res目录只能有一层子目录，而且这些子目录必须是预定义的，如res/layout、res/values等都是 合法的，而res/abc,res/xyz并不是合法的资源目录，在assets目录中可以建任意层次的子目录(只受操作系统的限制)]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio快捷键]]></title>
    <url>%2Fpost%2F1c15dad9.html</url>
    <content type="text"><![CDATA[Alt+回车 导入包,自动修正 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 Ctrl+Alt+L 格式化代码 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) Ctrl+E或者Alt+Shift+C 最近更改的代码 Ctrl+R 替换文本 Ctrl+F 查找文本 Ctrl+Shift+Space 自动补全代码 Ctrl+空格 代码提示 Ctrl+Alt+Space 类名或接口名提示 Ctrl+P 方法参数提示 Ctrl+Shift+Alt+N 查找类中的方法或变量 Alt+Shift+C 对比最近修改的代码 Ctrl+Alt+F 使局部变量成为成员变量 Ctrl+Shift+U 大小写转换 Alt+F7 全局搜索字符串 Ctrl+Alt+T SurroundWith，语句块包裹 Shift+F6 重构-重命名 Ctrl+Shift+先上键 Ctrl+Y 删除行（ctrl+x不是删除行，是剪切。如果不选中，则为剪切当行。ths for 貌似掉线） Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ） Ctrl+J 自动代码 Ctrl+E 最近打开的文件 Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Ctrl+Alt+ left/right 返回至上次浏览的位置 Alt+ left/right 切换代码视图 Alt+ Up/Down 在方法间快速移动定位 Ctrl+Shift+Up/Down 代码向上/下移动。 F2 或Shift+F2 高亮错误或警告快速定位 代码标签输入完成后，按Tab，生成代码。 选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。 Ctrl+W 选中代码，连续按会有其他效果 选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 最常用快捷键 1.Ctrl＋E，可以显示最近编辑的文件列表 2.Shift＋Click可以关闭文件 3.Ctrl＋[或]可以跳到大括号的开头结尾 4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方 5.Ctrl＋F12，可以显示当前文件的结构 6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择 7.Ctrl＋N，可以快速打开类 8.Ctrl＋Shift＋N，可以快速打开文件 9.Alt＋Q可以看到当前方法的声明 10.Ctrl＋W可以选择单词继而语句继而行继而函数 11.Alt＋F1可以将正在编辑的元素在各个面板中定位 12.Ctrl＋P，可以显示参数信息 13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入 14.Alt＋Insert可以生成构造器/Getter/Setter等 15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量 16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch 17.Alt＋Up and Alt＋Down可在方法间快速移动 下面的不是很有用 18.在一些地方按Alt＋Enter可以得到一些Intention Action，例如将”==”改为”equals()” 19.Ctrl＋Shift＋Alt＋N可以快速打开符号 20.Ctrl＋Shift＋Space在很多时候都能够给出Smart提示 21.Alt＋F3可以快速寻找 22.Ctrl＋/和Ctrl＋Shift＋/可以注释代码 23.Ctrl＋Alt＋B可以跳转到抽象方法的实现 24.Ctrl＋O可以选择父类的方法进行重写 25.Ctrl＋Q可以看JavaDoc 26.Ctrl＋Alt＋Space是类名自动完成 27.快速打开类/文件/符号时，可以使用通配符，也可以使用缩写 28.Live Templates! Ctrl＋J 29.Ctrl＋Shift＋F7可以高亮当前元素在当前文件中的使用 30.Ctrl＋Alt＋Up /Ctrl＋Alt＋Down可以快速跳转搜索结果 31.Ctrl＋Shift＋J可以整合两行 32.Alt＋F8是计算变量值 IntelliJ IDEA使用技巧一览表 在使用 InelliJ IDEA 的过程中，通过查找资料以及一些自己的摸索，发现这个众多 Java 程序员喜欢的 IDE 里有许多值得一提的小窍门，如果能熟练的将它们应用于实际开发过程中，相信它会大大节省你的开发时间，而且随之而来的还会有那么一点点成就感：） Try it ！ 1 、写代码时用 Alt-Insert （ Code|Generate… ）可以创建类里面任何字段的 getter 与 setter 方法。 &lt;?xml:namespace prefix = v ns = “urn:schemas-microsoft-com:vml” /&gt; 2 、右键点击断点标记（在文本的左边栏里）激活速查菜单，你可以快速设置 enable/disable 断点或者条件它的属性。 3 、 CodeCompletion （代码完成）属性里的一个特殊的变量是，激活 Ctrl-Alt-Space 可以完成在或不在当前文件里的类名。如果类没有引入则 import 标志会自动创建。 4 、使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。 5 、利用 CodeCompletion （代码完成）属性可以快速地在代码中完成各种不同地语句，方法是先键入一个类名地前几个字母然后再用 Ctrl-Space 完成全称。如果有多个选项，它们会列在速查列表里。 6 、用 Ctrl-/ 与 Ctrl-Shift-/ 来注释 / 反注释代码行与代码块。 -/ 用单行注释标记（“ //… ”）来注释 / 反注释当前行或者选择地代码块。而 Ctrl-Shift-/ 则可以用块注释标记（“ /…/ ”）把所选块包围起来。要反注释一个代码块就在块中任何一个地方按 Ctrl-Shift-/ 即可。 7 、按 Alt-Q （ View|Context Info ）可以不需要移动代码就能查看当前方法地声明。连续按两次会显示当前所编辑的类名。 8 、使用 Refactor|Copy Class… 可以创建一个所选择的类的“副本”。这一点很有用，比如，在你想要创建一个大部分内容都和已存在类相同的类时。 9 、在编辑器里 Ctrl-D 可以复制选择的块或者没有所选块是的当前行。 10 、 Ctrl-W （选择字）在编辑器里的功能是先选择脱字符处的单词，然后选择源代码的扩展区域。举例来说，先选择一个方法名，然后是调用这个方法的表达式，然后是整个语句，然后包容块，等等。 11 、如果你不想让指示事件细节的“亮球”图标在编辑器上显示，通过按 Alt-Enter 组合键打开所有事件列表然后用鼠标点击它就可以把这个事件文本附件的亮球置成非活动状态。 这样以后就不会有指示特殊事件的亮球出现了，但是你仍然可以用 Alt-Enter 快捷键使用它。 12 、在使用 CodeCompletion 时，可以用逗点（ . ）字符，逗号（，）分号（；），空格和其它字符输入弹出列表里的当前高亮部分。选择的名字会随着输入的字符自动输入到编辑器里。 13 、在任何工具窗口里使用 Escape 键都可以把焦点移到编辑器上。 Shift-Escape 不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口。 F12 键把焦点从编辑器移到最近使用的工具窗口。 14 、在调试程序时查看任何表达式值的一个容易的方法就是在编辑器中选择文本（可以按几次 Ctrl-W 组合键更有效地执行这个操作）然后按 Alt-F8 。 15 、要打开编辑器脱字符处使用的类或者方法 Java 文档的浏览器，就按 Shift-F1 （右键菜单的 External JavaDoc ）。 要使用这个功能须要把加入浏览器的路径，在“ General ”选项中设置（ Options | IDE Settings ），另外还要把创建的 Java 文档加入到工程中（ File | Project Properties ）。 16 、用 Ctrl-F12 （ View | File Structure Popup ）键你可以在当前编辑的文件中快速导航。 这时它会显示当前类的成员列表。选中一个要导航的元素然后按 Enter 键或 F4 键。要轻松地定位到列表中的一个条目，只需键入它的名字即可。 17 、在代码中把光标置于标记符或者它的检查点上再按 Alt-F7 （右键菜单中的 Find Usages… ）会很快地查找到在整个工程中使用地某一个类、方法或者变量的位置。 18 、按 Ctrl-N （ Go to | Class… ）再键入类的名字可以快速地在编辑器里打开任何一个类。从显示出来的下拉列表里选择类。 同样的方法你可以通过使用 Ctrl-Shift-N （ Go to | File… ）打开工程中的非 Java 文件。 19 、要导航代码中一些地方使用到的类、方法或者变量的声明，把光标放在查看项上再按 Ctrl-B 即可。也可以通过按 Ctrl 键的同时在查看点上单击鼠标键调转到声明处。 20 、把光标放到查看点上再按 Ctrl-Alt-B 可以导航到一个抽象方法的实现代码。 21 、要看一个所选择的类的继承层次，按 Ctrl-H （ Browse Type Hierarchy ）即可。也可以激活编辑器中的继承关系视图查看当前编辑类的继承关系。22 、使用 Ctrl-Shift-F7 （ Search | Highlight Usages in File ）可以快速高亮显示当前文件中某一变量的使用地方。按 Escape 清除高亮显示。 23 、用 Alt-F3 （ Search | Incremental Search ）在编辑器中实现快速查查找功能。 在“ Search for: ”提示工具里输入字符，使用箭头键朝前和朝后搜索。按 Escape 退出。 24 、按 Ctrl-J 组合键来执行一些你记不起来的 Live Template 缩写。比如，键“ it ”然后按 Ctrl-J 看看有什么发生。 25 、 Introduce Variable 整合帮助你简化代码中复杂的声明。举个例子，在下面的代码片断里，在代码中选择一个表达式：然后按 Ctrl-Alt-V 。 26 、 Ctrl-Shift-J 快捷键把两行合成一行并把不必要的空格去掉以匹配你的代码格式。 27 、 Ctrl-Shift-Backspace （ Go to | Last Edit Location ）让你调转到代码中所做改变的最后一个地方。 多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。 28 、用 Tools | Reformat Code… 根据你的代码样式参考（查看 Options | IDE Setting | Code Style ）格式化代码。 使用 Tools | Optimize Imports… 可以根据设置（查看 Options | IDE Setting | Code Style | Imports ）自动“优化” imports （清除无用的 imports 等）。 29 、使用 IDEA 的 Live Templates | Live Templates 让你在眨眼间创建许多典型代码。比如，在一个方法里键入 再按 Tab 键看有什么事情发生了。 用 Tab 键在不同的模板域内移动。查看 Options | Live Templates 获取更多的细节。 30 、要查看一个文件中修改的本地历史，激活右键菜单里的 Local VCS | Show History… 。也许你可以导航不同的文件版本，看看它们的不同之处再回滚到以前的任何一个版本吧。 使用同样的右键菜单条目还可以看到一个目录里修改的历史。有了这个特性你就不会丢失任何代码了。 31 、如果要了解主菜单里每一个条目的用途，把鼠标指针移到菜单条目上再应用程序框架的底部的状态栏里就会显示它们的一些简短描述，也许会对你有帮助。 32 、要在编辑器里显示方法间的分隔线，打开 Options | IDE Settings | Editor ，选中“ Show method separators ”检查盒（ checkbox ）。 33 、用 Alt-Up 和 Alt-Down 键可以在编辑器里不同的方法之间快速移动。 34 、用 F2/Shift-F2 键在高亮显示的语法错误间跳转。 用 Ctrl-Alt-Down/Ctrl-Alt-Up 快捷键则可以在编译器错误信息或者查找操作结果间跳转。 35 、通过按 Ctrl-O （ Code | Override Methods… ）可以很容易地重载基本类地方法。 要完成当前类 implements 的（或者抽象基本类的）接口的方法，就使用 Ctrl-I （ Code | Implement Methods… ）。 36 、如果光标置于一个方法调用的括号间，按 Ctrl-P 会显示一个可用参数的列表。 37 、要快速查看编辑器脱字符处使用的类或方法的 Java 文档，按 Ctrl-Q （在弹出菜单的 Show Quick JavaDoc 里）即可。 38 、像 Ctrl-Q （ Show Quick JavaDoc 显示简洁 Java 文档）， Ctrl-P （ Show Parameter Info 显示参数信息）， Ctrl-B （ Go to Declaration 跳转到声明）， Shift-F1 （ External JavaDoc 外部 Java 文档）以及其它一些快捷键不仅可以在编辑器里使用，也可以应用在代码完成右键列表里。 39 、 Ctrl-E （ View | Recent Files ）弹出最近访问的文件右键列表。选中文件按 Enter 键打开。 40 、在 IDEA 中可以很容易地对你的类，方法以及变量进行重命名并在所有使用到它们的地方自动更正。 试一下，把编辑器脱字符置于任何一个变量名字上然后按 Shift-F6 （ Refactor | Rename… ）。在对话框里键入要显示地新名字再按 Enter 。你会浏览到使用这个变量地所有地方然后按“ Do Refactor ”按钮结束重命名操作。 41 、要在任何视图（ Project View 工程视图， Structure View 结构视图或者其它视图）里快速 选择当前编辑地部分（类，文件，方法或者字段），按 Alt-F1 （ View | Select in… ）。 42 、在“ new ”字符后实例化一个已知类型对象时也许你会用到 SmartType 代码完成这个特性。比如，键入 再按 Ctrl-Shift-Space ： 43 、通过使用 SmartType 代码完成，在 IDEA 中创建接口的整个匿名 implementation 也是非常容易的，比如，对于一些 listener （监听器），可以键入 Component component; component.addMouseListener( new ); 然后再按 Ctrl-Shift-Space 看看有什么发生了。 44 、在你需要设置一个已知类型的表达式的值时用 SmartType 代码完成也很有帮助。比如，键入 String s = ( 再按 Ctrl-Shift-Space 看看会有什么出现。 45 、在所有视图里都提供了速查功能：在树里只需键入字符就可以快速定位到一个条目。 46 、当你想用代码片断捕捉异常时，在编辑器里选中这个片断，按 Ctrl-Alt-T （ Code | Surround with… ）然后选择“ try/catch ”。它会自动产生代码片断中抛出的所有异常的捕捉块。在 Options | File Templates | Code tab 中你还可以自己定制产生捕捉块的模板。 用列表中的其它项可以包围别的一些结构。 47 、在使用代码完成时，用 Tab 键可以输入弹出列表里的高亮显示部分。 不像用 Enter 键接受输入，这个选中的名字会覆盖掉脱字符右边名字的其它部分。这一点在用一个方法或者变量名替换另一个时特别有用。 48 、在声明一个变量时代码完成特性会给你显示一个建议名。比如，开始键入“ private FileOutputStream ”然后按 Ctrl-Space 在 Options | IDE Setting | Code Style 中还可以为本地变量，参数，实例及静态字段定制名字。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TableLayout表格布局详解]]></title>
    <url>%2Fpost%2Fd10c68c3.html</url>
    <content type="text"><![CDATA[这篇博文包括的内容： 1、TableLayout简介 2、**TableLayout行列数的确定 3、**TableLayout可设置的属性详解 4、一个包含4个TableLayout布局的实例及效果图 一、Tablelayout简介 Tablelayout类以行和列的形式对控件进行管理，每一行为一个TableRow对象，或一个View控件。 当为TableRow对象时，可在TableRow下添加子控件，默认情况下，每个子控件占据一列。 当为View时，该View将独占一行。 二、TableLayout行列数的确定TableLayout的行数由开发人员直接指定，即有多少个TableRow对象（或View控件），就有多少行。 TableLayout的列数等于含有最多子控件的TableRow的列数。如第一TableRow含2个子控件，第二个TableRow含3个，第三个TableRow含4个，那么该TableLayout的列数为4. 三、TableLayout可设置的属性详解 TableLayout可设置的属性包括全局属性及单元格属性。 1、全局属性也即列属性，有以下3个参数： android:stretchColumns 设置可伸展的列。该列可以向行方向伸展，最多可占据一整行。 android:shrinkColumns 设置可收缩的列。当该列子控件的内容太多，已经挤满所在行，那么该子控件的内容将往列方向显示。 android:collapseColumns 设置要隐藏的列。 示例： android:stretchColumns=”0” 第0列可伸展 android:shrinkColumns=”1,2” 第1,2列皆可收缩 android:collapseColumns=”*” 隐藏所有行 说明：列可以同时具备stretchColumns及shrinkColumns属性，若此，那么当该列的内容N多时，将“多行”显示其内容。（这里不是真正的多行，而是系统根据需要自动调节该行的layout_height） 2、单元格属性，有以下2个参数： android:layout_column 指定该单元格在第几列显示 android:layout_span 指定该单元格占据的列数（未指定时，为1） 示例： android:layout_column=”1” 该控件显示在第1列 android:layout_span=”2” 该控件占据2列 说明：一个控件也可以同时具备这两个特性。 四、一个包含4个TableLayout布局的实例及效果图 &lt;?xml version=”1.0” encoding=”utf-8”?&gt; 说明：第4个TableLayout里的均匀布局的均匀效果是有限的。其有限性体现在，当该行有N列，则每列的控件内容不能多于1/N。运行效果图：（如图1） 图1 TableLayout运行结果图 参考书目： [1] 《android基础教程》，[美]Ed Burnette 著，张波，高朝勤，杨月等译，北京：人民邮电出版社，2009.11 [2] 《android开发入门教程》，[美]Mark L. Murphy著，李雪飞，吴明晖译，北京：人民邮电出版社，2010.12 [3] 《android核心技术与实例详解》，吴亚峰，索依娜，北京：电子工业出版社，2010.10 参考文章： Android 使用 TableLayout 布局拉伸宽度]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android M之权限请求（Android 6.0 M系统TargetsdkVersion on 23 (含)）]]></title>
    <url>%2Fpost%2F8bbe80d9.html</url>
    <content type="text"><![CDATA[权限分类 normal permissions dangerous permissions 检查权限 请求权限 解释为何需要这个权限 请求权限 处理请求结果 何时请求权限 从Android Marshmallow开始，应用权限是在运行时获得的，而不是6.0之前的安装时获得，当然这是为用户的使用体验考虑，毕竟安装应用时一长串的权限说明看起来也是挺晕的（这是对于在Google Play商店下载安装应用而言，安装未知来源APK对于6.0和pre6.0都会在安装时看到一长串的权限说明） 当然也并不是说对与pre6.0的版本就没有用，用户是有可能在安装应用后限制应用的权限的（虽然原生的权限管理是Android M才开始加入的，不过很多定制系统都有加入权限管理功能，因此这也是需要考虑的），所以运行时的权限检查是有必要的，因此Google也提供了相对应的support包 本篇将对Android Support Library提供的权限请求功能，进行相应的学习和研究 权限分类Android M对权限进行了分类。系统权限可以分为两种：一般的（normal）和危险的（dangerous） normal permissions那些可能需要访问数据和资源，但对用户的隐私的影响比较小的权限。如果应用已经在Android Manifest中声明了需要这些权限，系统会默认允许，而不会和用户交互。包含的权限有： ACCESS_LOCATION_EXTRA_COMMANDS ACCESS_NETWORK_STATE ACCESS_NOTIFICATION_POLICY ACCESS_WIFI_STATE BLUETOOTH BLUETOOTH_ADMIN BROADCAST_STICKY CHANGE_NETWORK_STATE CHANGE_WIFI_MULTICAST_STATE CHANGE_WIFI_STATE DISABLE_KEYGUARD EXPAND_STATUS_BAR GET_PACKAGE_SIZE INSTALL_SHORTCUT INTERNET KILL_BACKGROUND_PROCESSES MODIFY_AUDIO_SETTINGS NFC READ_SYNC_SETTINGS READ_SYNC_STATS RECEIVE_BOOT_COMPLETED REORDER_TASKS REQUEST_IGNORE_BATTERY_OPTIMIZATIONS REQUEST_INSTALL_PACKAGES SET_ALARM SET_TIME_ZONE SET_WALLPAPER SET_WALLPAPER_HINTS TRANSMIT_IR UNINSTALL_SHORTCUT USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_SYNC_SETTINGS dangerous permissions可能会访问用户隐私数据，修改用户和其他应用的数据的权限。危险的权限需要运行时进行请求 权限分组 任何一个危险权限都归属与一个权限分组。权限组有如下行为： 当应用请求一个权限，且该应用还未有该权限所在的权限组中的其他的权限时，请求权限所显示的对话框将会对该权限组进行描述，而不是这个权限 当应用请求一个权限，且该应用已经具有该权限所在的权限组中一个权限时，系统将会默认地允许该请求，而不会显式地让用户决定 这些分组可能会在未来发生改变，所以不要太依赖权限分组，需要用到的权限还是要一个一个去检查和请求 各个组别如下： 组名 权限 CALENDAR READ_CALENDAR WRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS LOCATION ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATE CALL_PHONE READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS STORGE READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 检查权限在进行涉及危险权限的操作前，需要先检查应用是否具有对应的权限。建议总是在操作前检查权限，因为用户有可能会在设置面板取消对应的权限 调用ActivityCompat.checkSelfPermission()进行检查： int isPermissionReady = ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS); 需要提供的参数是当前的上下文和对应的权限。android.Manifest.permission中定义了各个权限对应的标志 如果已经拥有该权限，则会返回PackageManager.PERMISSION_GRANTED，否则返回PackageManager.PERMISSION_DENIED 请求权限解释为何需要这个权限Android考虑到用户的体验，当用户拒绝了第一次的权限请求后，再次收到该权限请求时，对话框中会有一个“Don’t ask again”的checkbox，用户勾选了这个CB后将不会再收到这个权限的请求。那么开发者该如何知道呢？ ActivityCompat有一个方法shouldShowRequestPermissionRationale()，字面意思是“是否应该显示所请求权限的理由”，表示你是否需要对用户说明这个功能是怎样的，为何需要这个权限。如果用户已经拒绝了之前的请求，该方法会返回true；当用户拒绝了之前的请求并勾选了Don’t ask again”的checkbox，或者用户主动在权限管理中取消了该权限，则会返回false 请求权限请求权限使用ActivityCompat.requestPermissions()方法，需要提供参数是上下文，权限标志数组，以及这次请求对应的请求码。 当然权限的请求必须是异步的，因为从显示对话框，再到用户对对话框做出选择都是需要时间的，requestPermissions()会立即返回，至于请求的结果则会在回掉函数中体现（下面讲） 结合上面的内容，一次请求应该这么写： private void readContacts() { if (Activity.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { //如果没有该权限，进行请求 requestReadContactsPermission(); } else { //进行联系人读取 } } private void requestReadContactsPermission() { if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)) { //进行相应的解释。要注意必须是异步的，不要阻塞主线程 } else { //直接请求 ActivityCompat.requestPermissions(thisActivity, new String[]{Manifest.permission.READ_CONTACTS}, REQUEST_READ_CONTACTS}; } } 处理请求结果由于权限请求是异步的，因此请求结果将会以回调的形式返回，ActivityCompat类中有一个回调接口OnRequestPermissionsResultCallback，因此请求代码所处的Activity需要实现这个接口 这个接口中只有一个方法： onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) 参数依次是你的请求所设置的请求码，权限列表，以及每个权限对应的请求结果 具体实现可以这么写： @Override public void onRequestPermissionsResult(int requestCode, @NonNull String permissions[], @NonNull int[] grantResults) { switch (requestCode) { case REQUEST_READ_CONTACTS: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { //获得权限，继续对应的操作 readContacts(); } else { //未能获得权限，取消该操作但不要让应用退出 } break; //... } } 参数中的权限数组和结果数组是一一对应的。根据请求码判断是哪个请求，并对各个权限进行检查 何时请求权限根据Android Developer的介绍，权限请求的情况有两个因素：权限的重要性，以及用户对权限必要性的认识 讲权限的重要性分为重要的（critical）和次要的（secondary），用户的认识分为清除的（clear）和不清楚的（unclear）。对于一款相机应用来说，可以有如下四种情况： 1. 如果该权限对应用来说很重要，而且用户也很清楚，例如CAMERA权限。直接启动时请求权限，不需要多余地说明 2. 如果该权限对应用来说很重要，但用户不能马上认识到其必要，例如记录相片地理位置的功能。对于这种很吸引人的功能，或者是更新后加入的新特性，可以在用户教程（tutorial）界面时进行介绍，然后再请求权限 3. 如果该权限是比较次要的，但用户很清楚权限的必要，例如给相片加入语音。对于这种功能，当用户点击使用，直接在上下文种请求权限就行了 4. 如果该权限是比较次要的，而且用户不能马上认识到其必要，例如读取短信中的验证码。自动读取短信中的验证码是有用的，但用户有时并不能马上认识到它的便利，这样的话可以在上下文中适当地说明这个功能，当用户启动该功能时再请求权限 引用官方的说明图： 关于Android M的权限请求大概就是这么多。从官方的说明文档可以看出来，权限请求这个改动其实是充满了设计感的，无论是请求策略，还是请求代码，都体现了Android在用户体验，以及帮助开发者开发更优质的应用，所做出的努力。谷歌在优质化应用上所做的其实并不止是Material Design，很多小细节都在大大地改变Android应用在人们心中的印象。 另附： 官方说明文档 android-RuntimePermissions]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[专题Android开发之路——改头换面之属性重写配置]]></title>
    <url>%2Fpost%2F1ead2caf.html</url>
    <content type="text"><![CDATA[Android Studio 2.3.3 gradle 3.3-all.zip 下的属性配置： 1. classpath ‘com.android.tools.build:gradle:2.3.3’2. app-gradle compileSdkVersion 25 buildToolsVersion “25.0.2” defaultConfig { applicationId “com.example.recyclerviewtest” minSdkVersion 21 targetSdkVersion 25 versionCode 1 versionName “1.0” }3. distributionUrl=https\\://services.gradle.org/distributions/gradle-3.3-all.zip]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux下iptables 禁止端口和开放端口]]></title>
    <url>%2Fpost%2Fe0eed9b0.html</url>
    <content type="text"><![CDATA[TIPS：我们配置开放的端口的时候最好不要开放1-1023端口！1.首先介绍一下指令和相关配置文件 启动指令:service iptables start 重启指令:service iptables restart 关闭指令:service iptables stop 然后是相关配置:/etc/sysconfig/iptables 如何操作该配置呢？ vim /etc/sysconfig/iptables 然后进去修改即可，修改完了怎么办？这里很多人会想到/etc/rc.d/init.d/iptables save指令，但是一旦你这么干了你刚才的修改内容就白做了。。。 具体方法是： 只修改/etc/sysconfig/iptables 使其生效的办法是修改好后先service iptables restart，然后才调用/etc/rc.d/init.d/iptables save， 因为/etc/rc.d/init.d/iptables save会在iptables服务启动时重新加载，要是在重启之前直接先调用了/etc/rc.d/init.d/iptables save那么你 的/etc/sysconfig/iptables 配置就回滚到上次启动服务的配置了，这点必须注意！！！ 2.下面介绍一些指令用法（主要还是man iptables看下相关资料才行） -A：指定链名 -p：指定协议类型 -d：指定目标地址 —dport：指定目标端口（destination port 目的端口） —sport：指定源端口（source port 源端口） -j：指定动作类型 3.如果我不像修改文件直接打命令可以吗，当然没问题，步骤如下: 例如我给SSH加放行的语句： 添加input记录： iptables -A INPUT -p tcp —dport 22 -j ACCEPT 添加output记录： iptables -A OUTPUT -p tcp —sport 22 -j ACCEPT 最后注意需要再执行一下 /etc/init.d/iptables save，这样这两条语句就保存到刚才那个/etc/sysconfig/iptables 文件中了。 4.接下来说明一下步骤，如果机器不在我身边，我只能SSH进去做iptables规则，那么我必须注意每一步，千万别搞错了，否则就SSH链接不上都有可能！ 首先要做的是给咱的SSH进行ACCEPT配置，以免直接无法连接的情况发生: 1.如果SSH端口是22（这里不建议用默认端口最好改掉SSH端口） iptables -A INPUT -p tcp —dport 22 -j ACCEPT iptables -A OUTPUT -p tcp —sport 22 -j ACCEPT 注意要/etc/rc.d/init.d/iptables save，以下每一步都最好执行一遍此语句，以下不再累述。 2.vim /etc/sysconfig/iptables确定是否已经加入配置，可以的话执行service iptables restart重启后生效 3.下面是很危险的操作，如果你第一步没做就会直接可能导致你连不上SSH，此步骤前切记执行第一步！！！ iptables -P INPUT DROP iptables -P OUTPUT DROP iptables -P FORWARD DROP 这个步骤是把所有不符合自己配置的规则ACCEPT的连接全部DROP掉，执行完以后如果咱SSH还没掉，那么谢天谢地，安全了，重启下iptables后继续下面的配置！ 4.下面咱就不细说了，具体就是看自己服务器要开放哪些端口或者是要访问哪些端口来做具体的配置，下面是我自己的机器的配置： /etc/sysconfig/iptables文件配置如下: Generated by iptables-save v1.4.7 on Fri Mar 2 19:59:43 2012 *filter :INPUT DROP [0:0] :FORWARD DROP [0:0] :OUTPUT DROP [8:496] -A INPUT -m state —state RELATED,ESTABLISHED -j ACCEPT ping使用的端口 -A INPUT -p icmp -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -s 127.0.0.1/32 -d 127.0.0.1/32 -j ACCEPT -A INPUT -s 192.168.2.200/32 -d 192.168.2.200/32 -j ACCEPT 允许服务器自己的SSH（对外部请求来说服务器是目标所以使用—dport） -A INPUT -p tcp -m tcp —dport 22 -j ACCEPT 80端口不用说了吧，服务器网站访问端口 -A INPUT -p tcp -m tcp —dport 80 -j ACCEPT -A INPUT -p tcp -m tcp —dport 3306 -j ACCEPT -A INPUT -p tcp -m tcp —dport 11211 -j ACCEPT -A INPUT -p tcp -m tcp —dport 11212 -j ACCEPT -A FORWARD -j REJECT —reject-with icmp-host-prohibited 53端口是DNS相关，TCP和UDP都要配置 -A INPUT -p tcp -m tcp —dport 53 -j ACCEPT -A INPUT -p udp -m udp —dport 53 -j ACCEPT ping使用的端口 -A OUTPUT -p icmp -j ACCEPT -A OUTPUT -s 127.0.0.1/32 -d 127.0.0.1/32 -j ACCEPT -A OUTPUT -s 192.168.2.200/32 -d 192.168.2.200/32 -j ACCEPT 允许服务器SSH到其他机器（使用外部端口就使用—dport） -A OUTPUT -p tcp -m tcp —dport 22 -j ACCEPT 允许服务器自己的SSH（自已为源输出就使用—sport） -A OUTPUT -p tcp -m tcp —sport 22 -j ACCEPT 访问外部网站80端口（使用外部端口就使用—dport） -A OUTPUT -p tcp -m tcp —dport 80 -j ACCEPT 如果服务器需要访问外部网站，那么OUTPUT也需要配置53端口（使用外部端口就使用—dport） -A OUTPUT -p tcp -m tcp —dport 53 -j ACCEPT -A OUTPUT -p udp -m udp —dport 53 -j ACCEPT 如果有访问外部邮箱，那么打开邮箱相关端口（使用外部端口就使用—dport） -A OUTPUT -p tcp -m tcp —dport 465 -j ACCEPT -A OUTPUT -p tcp -m tcp —dport 25 -j ACCEPT -A OUTPUT -p tcp -m tcp —dport 110 -j ACCEPT 服务器网站访问端口（自已为源输出就使用—sport） -A OUTPUT -p tcp -m tcp —sport 80 -j ACCEPT -A OUTPUT -p tcp -m tcp —sport 3306 -j ACCEPT -A OUTPUT -p tcp -m tcp —sport 11211 -j ACCEPT -A OUTPUT -p tcp -m tcp —sport 11212 -j ACCEPT COMMIT Completed on Fri Mar 2 19:59:43 2012 5.可能有时候需要删除规则，最简单就是修改一下/etc/sysconfig/iptables然后service iptables restart,最后/etc/rc.d/init.d/iptables save即可。 当然也可以使用指令完成: 在网上找了一下，删除规则的方法： 语法是： iptables -D chain rulenum [options] 其中： chain 是链的意思，就是INPUT FORWARD 之类的 rulenum 是规则的编号。从1 开始。可以使用 —line-numbers 列出规则的编号 所以，例如上面要删除一个INPUT链的规则的话可以这样：iptables -D INPUT 3 意思是删除第3条规则。 还有第二种方法。第二种办法是 -A 命令的映射，不过用-D替换-A。当你的链中规则很复杂，而你不想计算它们的编号的时候这就十分有用了。也就是说，你如何用iptables -A…. 语句定义了一个规则，则删除此规则时就用 -D 来代替- A 其余的都不变即可。 ====================== 说一下上面的 —line-numbers 选项，如下面的命令： iptables -L INPUT —line-numbers 列出INPUT 链所有的规则 num target prot opt source destination 1 REJECT tcp — anywhere anywhere tcp dpt:microsoft-ds reject-with icmp-port-unreachable 2 REJECT tcp — anywhere anywhere tcp dpt:135 reject-with icmp-port-unreachable 3 REJECT tcp — anywhere anywhere tcp dpt:netbios-ssn reject-with icmp-port-unreachable … … 删除指定行规则： [root@localhost rc.d]# iptables -D INPUT 4 6.最后补充一下，如果想针对某IP进行单独开放端口可以如下配置： 如果我需要对内网某机器单独开放mysql端口，应该如下配置： iptables -A INPUT -s 192.168.2.6 -p tcp -m tcp —dport 3306 -j ACCEPT iptables -A OUTPUT -s 192.168.2.6 -p tcp -m tcp —sport 3306 -j ACCEPT 7.彻底禁止某IP访问: 屏蔽单个IP的命令是 iptables -I INPUT -s 123.45.6.7 -j DROP 封整个段即从123.0.0.1到123.255.255.254的命令 iptables -I INPUT -s 123.0.0.0/8 -j DROP 封IP段即从123.45.0.1到123.45.255.254的命令 iptables -I INPUT -s 124.45.0.0/16 -j DROP 封IP段即从123.45.6.1到123.45.6.254的命令是 iptables -I INPUT -s 123.45.6.0/24 -j DROP 指令I是insert指令 但是该指令会insert在正确位置并不像A指令看你自己的排序位置，因此用屏蔽因为必须在一开始就要加载屏蔽IP，所以必须使用I命令加载，然后注意执行/etc/rc.d/init.d/iptables save进行保存后重启服务即可 1、关闭所有的 INPUT FORWARD OUTPUT 只对某些端口开放。 下面是命令实现： iptables -P INPUT DROP iptables -P FORWARD DROP iptables -P OUTPUT DROP 再用命令 iptables -L -n 查看 是否设置好， 好看到全部 DROP 了 这样的设置好了，我们只是临时的， 重启服务器还是会恢复原来没有设置的状态 还要使用 service iptables save 进行保存 看到信息 firewall rules 防火墙的规则 其实就是保存在 /etc/sysconfig/iptables 可以打开文件查看 vi /etc/sysconfig/iptables 2、 下面我只打开22端口，看我是如何操作的，就是下面2个语句 iptables -A INPUT -p tcp —dport 22 -j ACCEPT iptables -A OUTPUT -p tcp —sport 22 -j ACCEPT 再查看下 iptables -L -n 是否添加上去, 看到添加了 Chain INPUT (policy DROP) target prot opt source destination ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpt:22 Chain FORWARD (policy DROP) target prot opt source destination Chain OUTPUT (policy DROP) target prot opt source destination ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp spt:22 现在Linux服务器只打开了22端口，用putty.exe测试一下是否可以链接上去。 可以链接上去了，说明没有问题。 最后别忘记了保存 对防火墙的设置 通过命令：service iptables save 进行保存 iptables -A INPUT -p tcp —dport 22 -j ACCEPT iptables -A OUTPUT -p tcp —sport 22 -j ACCEPT 针对这2条命令进行一些讲解吧 -A 参数就看成是添加一条 INPUT 的规则 -p 指定是什么协议 我们常用的tcp 协议，当然也有udp 例如53端口的DNS 到时我们要配置DNS用到53端口 大家就会发现使用udp协议的 而 —dport 就是目标端口 当数据从外部进入服务器为目标端口 反之 数据从服务器出去 则为数据源端口 使用 —sport -j 就是指定是 ACCEPT 接收 或者 DROP 不接收 3、禁止某个IP访问 1台Linux服务器,2台windows xp 操作系统进行访问 Linux服务器ip 192.168.1.99 xp1 ip: 192.168.1.2 xp2 ip: 192.168.1.8 下面看看我2台xp 都可以访问的 192.168.1.2 这是 xp1 可以访问的， 192.168.1.8 xp2 也是可以正常访问的。 那么现在我要禁止 192.168.1.2 xp1 访问， xp2 正常访问， 下面看看演示 通过命令 iptables -A INPUT -p tcp -s 192.168.1.2 -j DROP 这里意思就是 -A 就是添加新的规则， 怎样的规则呢？ 由于我们访问网站使用tcp的， 我们就用 -p tcp , 如果是 udp 就写udp，这里就用tcp了， -s就是 来源的意思， ip来源于 192.168.1.2 ，-j 怎么做 我们拒绝它 这里应该是 DROP 好，看看效果。好添加成功。下面进行验证 一下是否生效 一直出现等待状态 最后 该页无法显示 ，这是 192.168.1.2 xp1 的访问被拒绝了。 再看看另外一台 xp 是否可以访问， 是可以正常访问的 192.168.1.8 是可以正常访问的 4、如何删除规则 首先我们要知道 这条规则的编号，每条规则都有一个编号 通过 iptables -L -n —line-number 可以显示规则和相对应的编号 num target prot opt source destination 1 DROP tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpt:3306 2 DROP tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpt:21 3 DROP tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 多了 num 这一列， 这样我们就可以 看到刚才的规则对应的是 编号2 那么我们就可以进行删除了 iptables -D INPUT 2 删除INPUT链编号为2的规则。 再 iptables -L -n 查看一下 已经被清除了。 5、过滤无效的数据包 假设有人进入了服务器，或者有病毒木马程序，它可以通过22，80端口像服务器外传送数据。 它的这种方式就和我们正常访问22，80端口区别。它发向外发的数据不是我们通过访问网页请求 而回应的数据包。 下面我们要禁止这些没有通过请求回应的数据包，统统把它们堵住掉。 iptables 提供了一个参数 是检查状态的，下面我们来配置下 22 和 80 端口，防止无效的数据包。 iptables -A OUTPUT -p tcp —sport 22 -m state —state ESTABLISHED -j ACCEPT 可以看到和我们以前使用的： iptables -A OUTPUT -p tcp —sport 22 -j ACCEPT 多了一个状态判断。 同样80端口也一样， 现在删掉原来的2条规则， iptables -L -n —line-number 这个是查看规则而且带上编号。我们看到编号就可以 删除对应的规则了。 iptables -D OUTPUT 1 这里的1表示第一条规则。 当你删除了前面的规则， 编号也会随之改变。看到了吧。 好，我们删除了前面2个规则，22端口还可以正常使用，说明没问题了 下面进行保存，别忘记了，不然的话重启就会还原到原来的样子。 service iptables save 进行保存。 Saving firewall rules to /etc/sysconfig/iptables: [ OK ] 其实就是把刚才设置的规则写入到 /etc/sysconfig/iptables 文件中。 6、DNS端口53设置 下面我们来看看如何设置iptables来打开DNS端口，DNS端口对应的是53 大家看到我现在的情况了吧，只开放22和80端口， 我现在看看能不能解析域名。 hostwww.google.com 输入这个命令后，一直等待，说明DNS不通 出现下面提示 ： ;; connection timed out; no servers could be reached ping 一下域名也是不通 [root@localhost ~pingwww.google.com ping: unknown hostwww.google.com 我这里的原因就是 iptables 限制了53端口。 有些服务器，特别是Web服务器减慢，DNS其实也有关系的，无法发送包到DNS服务器导致的。 下面演示下如何使用 iptables 来设置DNS 53这个端口，如果你不知道 域名服务端口号，你 可以用命令 : grep domain /etc/services [root@localhost ~grep domain /etc/services domain 53/tcp # name-domain server domain 53/udp domaintime 9909/tcp # domaintime domaintime 9909/udp # domaintime 看到了吧， 我们一般使用 udp 协议。 好了， 开始设置。。。 iptables -A OUTPUT -p udp —dport 53 -j ACCEPT 这是我们 ping 一个域名，数据就是从本机出去，所以我们先设置 OUTPUT， 我们按照ping这个流程来设置。 然后 DNS 服务器收到我们发出去的包，就回应一个回来 iptables -A INPUT -p udp —sport 53 -j ACCEPT 同时还要设置 iptables -A INPUT -p udp —dport 53 -j ACCEPT iptables -A OUTPUT -p udp —sport 53 -j ACCEPT 好了， 下面开始测试下， 可以用 iptables -L -n 查看设置情况，确定没有问题就可以测试了 [root@localhost ~iptables -L -n Chain INPUT (policy DROP) target prot opt source destination ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpt:22 ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 ACCEPT udp — 0.0.0.0/0 0.0.0.0/0 udp spt:53 ACCEPT udp — 0.0.0.0/0 0.0.0.0/0 udp dpt:53 Chain FORWARD (policy DROP) target prot opt source destination Chain OUTPUT (policy DROP) target prot opt source destination ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp spt:22 state ESTABLISHED ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp spt:80 state ESTABLISHED ACCEPT udp — 0.0.0.0/0 0.0.0.0/0 udp dpt:53 ACCEPT udp — 0.0.0.0/0 0.0.0.0/0 udp spt:53 可以测试一下 是否 DNS 可以通过iptables 了。 [root@localhost ~hostwww.google.com www.google.comis an alias forwww.l.google.com. www.l.google.comis an alias for www-china.l.google.com. www-china.l.google.com has address 64.233.189.104 www-china.l.google.com has address 64.233.189.147 www-china.l.google.com has address 64.233.189.99 正常可以解析 google 域名。 ping 方面可能还要设置些东西。 用 nslookup 看看吧 [root@localhost ~nslookup &gt;www.google.com Server: 192.168.1.1 Address: 192.168.1.1#53 Non-authoritative answer: www.google.comcanonical name =www.l.google.com. www.l.google.com canonical name = www-china.l.google.com. Name: www-china.l.google.com Address: 64.233.189.147 Name: www-china.l.google.com Address: 64.233.189.99 Name: www-china.l.google.com Address: 64.233.189.104 说明本机DNS正常， iptables 允许53这个端口的访问。 7、iptables对ftp的设置 现在我开始对ftp端口的设置，按照我们以前的视频，添加需要开放的端口 ftp连接端口有2个 21 和 20 端口，我现在添加对应的规则。 [root@localhost rootiptables -A INPUT -p tcp —dport 21 -j ACCEPT [root@localhost rootiptables -A INPUT -p tcp —dport 20 -j ACCEPT [root@localhost rootiptables -A OUTPUT -p tcp —sport 21 -j ACCEPT [root@localhost rootiptables -A OUTPUT -p tcp —sport 20 -j ACCEPT 好，这样就添加完了，我们用浏览器访问一下ftp,出现超时。 所以我刚才说 ftp 是比较特殊的端口，它还有一些端口是 数据传输端口， 例如目录列表， 上传 ，下载 文件都要用到这些端口。 而这些端口是 任意 端口。。。 这个 任意 真的比较特殊。 如果不指定什么一个端口范围， iptables 很难对任意端口开放的， 如果iptables允许任意端口访问， 那和不设置防火墙没什么区别，所以不现实的。 那么我们的解决办法就是 指定这个数据传输端口的一个范围。 下面我们修改一下ftp配置文件。 我这里使用vsftpd来修改演示，其他ftp我不知道哪里修改，大家可以找找资料。 [root@localhost rootvi /etc/vsftpd.conf 在配置文件的最下面 加入 pasv_min_port=30001 pasv_max_port=31000 然后保存退出。 这两句话的意思告诉vsftpd, 要传输数据的端口范围就在30001到31000 这个范围内传送。 这样我们使用 iptables 就好办多了，我们就打开 30001到31000 这些端口。 [root@localhost rootiptables -A INPUT -p tcp —dport 30001:31000 -j ACCEPT [root@localhost rootiptables -A OUTPUT -p tcp —sport 30001:31000 -j ACCEPT [root@localhost rootservice iptables save 最后进行保存， 然后我们再用浏览器范围下 ftp。可以正常访问 用个账号登陆上去，也没有问题，上传一些文件上去看看。 看到了吧，上传和下载都正常。。 再查看下 iptables 的设置 [root@localhost rootiptables -L -n Chain INPUT (policy DROP) target prot opt source destination ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpt:22 ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpt:21 ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpt:20 ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpts:30001:31000 Chain FORWARD (policy DROP) target prot opt source destination Chain OUTPUT (policy DROP) target prot opt source destination ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp spt:22 ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp spt:21 ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp spt:20 ACCEPT tcp — 0.0.0.0/0 0.0.0.0/0 tcp spts:30001:31000 这是我为了演示ftp特殊端口做的简单规则，大家可以添加一些对数据包的验证 例如 -m state —state ESTABLISHED,RELATED 等等要求更加高的验证 转自：http://hi.baidu.com/beijiqieys/item/5ee9bbcf94f0a712b67a24cf]]></content>
      <categories>
        <category>CentOS</category>
        <category>工具_etc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[专题Android开发之路——填坑之路Fight！Day0_AndroidStudio环境配置]]></title>
    <url>%2Fpost%2F316fb71f.html</url>
    <content type="text"><![CDATA[禁用**Windows中Ctrl+Space**切换输入法的快捷键 Windows的Ctrl+Space快捷键（切换中文输入法）跟一堆IDE的冲突，所以必须禁用掉，按照下图那样修改注册表即可。还好我用的eclipse快捷键不用修改. 修改**idea.properties**文件 找到\\bin\\idea.properties文件，打开，在文件末尾加上： # 禁止第一次运行Android Studio时，自动检查和升级Android SDK disable.android.first.run=true 设置主题**,窗口大小,**动画效果 ①修改主题 ②修改全局窗口字体(需要选择中文字体,最好默认不做修改),字号 ③ 窗口动画(电脑性能不怎样可以禁止掉) 修改**menu或者toolBar 打开工程设置 ①禁用自动打开上次关闭工程 ,禁用退出提示 ②打开新项目提示方式 禁用自动检查更新 ①取消自动更新 配置快捷键 ①自定义快捷键②根据内容搜索快捷键③根据按键搜索快捷键④删除快捷键 编辑器 ①鼠标悬停显示文档 ②格式化&amp;导包提示 鼠标指针悬停若干时间，显示文档，时间自己改。就是按格式化代码或者导包时，是否会显示个对话框，觉得烦人的话，都取消掉吧 显示行号，显示方法分隔线 ①显示行号 ②显示方法分隔符 代码折叠 ①取消方法自动折叠 代码智能提示** 敲什么都提示②③提示时间设置 敲什么字符会提示，All(大小写全部符合)，None（不管大小写，符合就提示），（First letter）（第一个字符符合就OK，其他随意）。 自动导包 Optimize imports on the fly：优化导包，格式化代码时会删掉多余的导包。Add unambiguous imports on the fly：敲代码时，敲简单类名就帮你把包导了。 创建个人代码样式配置 估计是为了保护默认的代码样式配置，让用户把配置搞坏了也能一键还原，IDEA不允许修改默认的配置，需要用户创建配置才能进行修改。 选择基于哪个主题的，然后Save As一份即可。 修改代码字体 强烈建议用Consolas字体，好看！！！ 修改控制台字体 Logcat**字体 要改的话，得先把1那个地方的勾取消掉,默认android Logcat 每个级别的颜色都是一样的.建议修改 修改注释位置 禁用“语句堆一行” Comment at frist column：启用的话，注释符号就会在行首，否则就按照缩进来注释。Control statement in one line：格式化代码的时候，会把些很短的语句合并成一行。这样影响代码可读性. 修改变量前后缀 静态成员是s，普通成员是m，转换成成员变量的时候自动加上m,生成setter,getter的时候会忽视m,很好很强大. 取消**Android Lint 检查 一定程度加快速度吧 修改新建文件文件头 每次建新类,会加上这样的头信息 修改文件编码为**UTF-8 别坑队友，小伙伴们都统一改为UTF-8吧。 自己定义**Live Templates 模板定义,方便开发,减少重复代码 添加管理插件 Github**账号绑定 配置git安装路径 项目自动编译 优化-取消同步 Gradle**离线工作 在第一次进入了AS之后，AS自动下载或者手动下载Gradle到目标目录下，开启离线工作，否则如果打开别人的项目，使用的是不同版本的Gradle，都会进行下载，离线工作之后，只需要修改代码中的Gradle版本为当前已经下载好的版本即可。注意，需要在第一次进入界面之后已经成功下载(包括手动下载)再开启，否则会导致错误提示没有Gradle。 —live template— _width _width android:layout_width=”match_parent” android:layout_height=”wrap_content$HEIGHT$” bmp_file decodeFile Bitmap $var$ = BitmapFactory.decodeFile($Content$); bmp_res decodeResource Bitmap $var$ = BitmapFactory.decodeResource($resource$, R.id.$resId$); bmp_strm decodeStream Bitmap $var$ = BitmapFactory.decodeStream($Content$); click click event public void click(View view) { $Content$ } conststr const str private static final String $var$ = “$Content$”; fdv findViewById findViewById(R.id.$resId$); fdv_child (root)(cast)findViewById $root$.findViewById(R.id.$resId$); fdvc (cast)findViewById ($cast$) findViewById(R.id.$resId$); fdvc_child (cast)(root)findViewById ($cast$) $root$.findViewById(R.id.$resId$); feach for each for ($i$ : $data$) { $cursor$ } fiter for for ($i$=$start$; $i$&lt;$end$; $i$++) { $cursor$ } fiter_with_init for init for (int $i$=$start$; $i$&lt;$end$; $i$++) { $cursor$ } for for for (int i = 0; i &lt; $length$; i++) { $content$ } fore for each for ($iterable_type$ $iterable_element$ : $iterable$) { $cursor$ } getsp getSharedPreferences SharedPreferences $var$ = getSharedPreferences(“$Content$”, MODE_PRIVATE); ifelse if else if ($Cursor$) { $Content$ } else { $Content2$ } ifelseif if else if if ($Cursor$) { $Content$ } else if ($Cursor2$){ $Content2$ } ifelseifelse if elseif else if ($Cursor$) { $Content$ } else if ($Cursor2$){ $Content2$ } else { $Content3$ } iid android:id=”@+id/$ID$” isempty TextUtils.isEmpty TextUtils.isEmpty($Content$) ld Log.d Log.d(TAG, “$method_name$” + $content$); le Log.e Log.e(TAG, “$method_name$” + $content$); li Log.i Log.i(TAG, “$method_name$” + $content$); lv Log.v Log.v(TAG, “$method_name$” + $content$); lw Log.w Log.w(TAG, “$method_name$” + $content$); main java main method public static void main(String[] args) { $Cursor$ } newintent new Intent Intent intent = new Intent(this, $Name$.class); note1 note1 /*$note$/ note2 note2 /———————- $note$ ———————-/ note3 note3 /=============== $note$ ===============/ note4 note4 /############### $note$ ###############/ note5 note5 /#######################################/ note_ /————————-$note$——————————/ obtmsg Message.obtain(); Message $var$ = Message.obtain(); $var$.what = 0; $var$.obj = $Content$; sfi static final int public static final int $VAR$ = $VALUE$; sfs static final string public static final String $VAR$ = $VALUE$; str_trim string.getText().toString().trim() String $var$ = $cursor$.getText().toString().trim(); sw switch switch ($key$) { case $value$: break; default: break; } syso syso System.out.println(“$END$”); sysof sysof java.lang.System.out.println(“———————$note$———————“); tag TAG private static final String TAG = “$class_name$”; toast Toast.makeText(this,”$CONTENT$”,android.widget.Toast.LENGTH_SHORT).show(); try try catch try { $cursor$ } catch (Exception e) { e.printStackTrace(); } view_inf View.inflate $cast$ $var$ = ($cast$) $root$.inflate(this, R.layout.$resId$, null); while while while ($cursor$) { $content$ }]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[转]给 ANDROID 初学者的 GRADLE 知识普及]]></title>
    <url>%2Fpost%2F76d1d368.html</url>
    <content type="text"><![CDATA[1. 前言前一段时间有人在我的邪教群里问「刚学 Android 不久，对 Gradle 不懂，看了很多资料依然一知半解，希望张哥给讲讲 Gradle 」，没想到群里很多人都响应，表示同感，有人在群里推荐了一本书，说看这本书就行了。说实在的，我不反对看书，但是我反对的是为了弄懂一个知识点就需要看一本书那效率也太低了，于是我良心张就随口说了句「要不我在群里开个讲座给你们普及下 Gradle 基本概念吧？」没想到平时潜水的人全都出来了，然后纷纷回复「666…」，讲真，刚说过我就后悔了，主要没有那么多时间，但是毕竟已经放开话了，当晚加班回到家，没有一点准备就在群里给他们开始了长达一个多小时的普及工作，事后，出乎意料的大家一致反映效果很好，而且听课的全都很认真，有很多有心的人把我在群里一字一句打的聊天记录整理成了笔记分享在群里，我觉得这个主题可能对我的很多读者也都很有帮助，所以我在群里整理的笔记的基础上做了点补充与改进，希望这篇文章对你们有帮助！ 2. 什么是构建工具？我们大家都知道 Gradle 是一种构建工具，那么什么是构建工具呢？ 网上一大堆的文字解释我觉得很难理解，这里我以咱们 Android 开发来举个例子吧。 我们以前开发都是用 Eclipse ，而 Eclipse 大家都知道是一种 IDE （集成开发环境），最初是用来做 Java 开发的，而 Android 是基于 Java 语言的，所以最初 Google 还是希望 Android 能在 Eclipse 上进行开发，为了满足这个需求，Google 开发了一个叫 ADT （Android Developer Tools）的东西，相信以前从 Eclipse 时代过来的对 ADT 应该都不陌生，正是因为有了 ADT ，从此我们只需要码好代码，然后直接在 Eclipse 上进行编译、运行、签名、打包等一系列流程，而这背后的工作都是 ADT 的功劳。某种意义上 ADT 就是我们的构建工具。 而自 Google 推出 Android Studio 以来，就宣布默认使用 Gradle 来作为构建工具，并且之后放弃更新 ADT ，从此 Gradle 走入 Android 开发者的视野，而我也是在 AS 的 Beta 版开始接触并学习 Gradle。 一般来说，构建工具除了以上提到的编译、运行、签名、打包等，还具备依赖管理的功能，什么是依赖管理呢？还是拿 Eclipse 来说，我们以前在 Eclipse 上开发 Android ，如果需要用到第三方库的时候一般都是先下载 jar 文件，然后把 jar 文件添加到 libs 目录，然后项目中就可以引用了。但是你不觉得这种管理方式很麻烦么？假设第三方库有更新，需要下载最新的 Jar 文件，然后替换掉原来的，引用的库少还好，一旦引用的第三方库多，那简直麻烦死，可以说这种方式只有依赖，而没有管理。 现在大家不陌生的 Gradle 引用第三方库方式是这样的： compile &#39;com.android.support:support-v4:24.0.1&#39; 类似这样的依赖方式，是不是很方便？而且很直观，直接可以看到源地址，升级的话直接改下版本号就可以了，这就是所谓的依赖管理。 所以构建工具就是对你的项目进行编译、运行、签名、打包、依赖管理等一系列功能的合集，传统的构建工具有 Make、Ant、Maven、Ivy等，而 Gradle 是新一代的自动化构建工具。 3. 什么是 Gradle ？上面说了，Gradle 是新一代的自动化构建工具，它是一个独立的项目，跟 AS、Android 无关，官方网站：https://gradle.org/ , 类似 Ant、Maven这类构建工具都是基于 xml 来进行描述的，很臃肿，而 Gradle 采用的是一种叫做 Groovy 的语言，语法跟 Java 语法很像，但是是一种动态语言，而且在 Java 基础上做了不少改进，用起来更加简洁、灵活，而且 Gradle 完全兼容 Maven、Ivy，这点基本上宣布了 Maven、Ivy 可以被抛弃了，Gradle 的推出主要以 Java 应用为主，当然目前还支持 Android、C、C++。 4. Gradle 与 Android Studio 的关系上面也提到，Gradle 跟 Android Studio 其实没有关系，但是 Gradle 官方还是很看重 Android 开发的，Google 在推出 AS 的时候选中了 Gradle 作为构建工具，为了支持 Gradle 能在 AS 上使用，Google 做了个 AS 的插件叫 Android Gradle Plugin ，所以我们能在 AS 上使用 Gradle 完全是因为这个插件的原因。在项目的根目录有个 build.gradle 文件，里面有这么一句代码： classpath &#39;com.android.tools.build:gradle:2.1.2&#39; 这个就是依赖 gradle 插件的代码，后面的版本号代表的是 android gradle plugin 的版本，而不是 Gradle 的版本，这个是 Google 定的，跟 Gradle 官方没关系。关于 android gradle plugin 的更多信息可以到这里查看，这里列举了 android gradle plugin 每个版本的具体变化与具体功能： http://tools.android.com/tech-docs/new-build-system 友情提示，需要科学上网！ 5. Gradle Wrapper现在默认新建一个项目，然后点击 AS 上的运行，默认就会直接帮你安装 Gradle ，我们不需要额外的安装 Gradle 了，但是其实这个 Gradle 不是真正的 Gradle ，他叫 Gradle Wrapper ，意为 Gradle 的包装，什么意思呢？假设我们本地有多个项目，一个是比较老的项目，还用着 Gradle 1.0 的版本，一个是比较新的项目用了 Gradle 2.0 的版本，但是你两个项目肯定都想要同时运行的，如果你只装了 Gradle 1.0 的话那肯定不行，所以为了解决这个问题，Google 推出了 Gradle Wrapper 的概念，就是他在你每个项目都配置了一个指定版本的 Gradle ，你可以理解为每个 Android 项目本地都有一个小型的 Gradle ，通过这个每个项目你可以支持用不同的 Gradle 版本来构建项目。 理解了 Gradle Wrapper 的概念就好办了，以下的所有操作都是基于 Gradle Wrapper 的。 默认我们在 AS 上第一次创建项目会自动下载 Gradle 的，这个过程很漫长，出奇的慢，但是第一次之后就ok了，接下来就是教大家用命令行测试下，请大家在终端或者 AS 带的终端上切换到所在项目的目录，然后输入 ./gradlew -v (win用户直接输入 gradlew -v) ，即可以查看当前项目所用的 gradle 的版本，gradlew 即为 gradle wrapper 的缩写，如果你是第一次执行命令行，那么会出现一个下载的提示，紧接着会打印一个个的点，这个过程很漫长，依赖你的网速，时间几分钟到几十分钟不等。 有人有疑问，我 AS 上明明已经可以正常运行该项目的，说明 Gradle 已经下载过了，为什么命令行还要再下载一次？我也一直有这个疑问，理论上是不该再下载的，但是事实他就是要重新下载一次，我猜测可能是bug吧。 如果下载完成输入 ./gradlew -v 出现如下结果，证明你的项目是ok的，否则就是你的项目配置有问题了。 6. Android 项目包含的 Gradle 配置文件这里姑且以我很早在 GitHub 开源的 9GAG 项目为例，来稍微介绍下一个完整的 Android 项目包含的基本 Gradle 相关的配置文件： 红色标记部分从上到下咱们来一步步分析： 9GAG/app/build.gradle 这个文件是 app 文件夹下这个 Module 的 gradle 配置文件，也可以算是整个项目最主要的 gradle 配置文件，具体里面的配置以后再介绍。 9GAG/extras/ShimmerAndroid/build.gradle 每一个 Module 都需要有一个 gradle 配置文件，语法都是一样，唯一不同的是开头声明的是 apply plugin: ‘com.android.library’ 9GAG/gradle 这个目录下有个 wrapper 文件夹，里面可以看到有两个文件，我们主要看下 gradle-wrapper.properties 这个文件的内容： 可以看到里面声明了 gradle 的目录与下载路径以及当前项目使用的 gradle 版本，这些默认的路径我们一般不会更改的，这个文件里指明的 gradle 版本不对也是很多导包不成功的原因之一。 9GAG/build.gradle 这个文件是整个项目的 gradle 基础配置文件，默认的内容就是声明了 android gradle plugin 的版本。 9GAG/settings.gradle 这个文件是全局的项目配置文件，里面主要声明一些需要加入 gradle 的 module，我们来看看 9GAG 该文件的内容： 7. 如何正确导入下载的开源项目？!!!我们经常会在 GitHub 发现一些优秀的开源项目，然后想要下载学习，然而第一步一般都是把源码导入到 AS 里，然后运行起来看下效果，但是经常会运行失败，这里我来给大家说下导入开源项目的正确姿势： 下载一个Demo，先打开每个 module下的 gradle 文件，即 app 目录下的 build.gradle 以及各个 library 下的 build.gradle ,首先查看 compileSdkVersion 和 buildToolsVersion，因为有些时候你本地的版本和下载的版本不一致，那么就会导致失败。 然后就是检查 gradle-wrapper ，Google 有些时候要求不同的 AS 支持不同的 gradle 版本。比如 AS 1.0 的时候要求必须使用 gradle 1.x 的版本，等到 AS 2.0 的时候，Google 不支持 gradle1.x 的版本，这个时候你必须手动更新下 android gradle plugin 的版本，然后重新同步下。 检查以上两个地方基本就可以导入并运行了，如果还有其他问题，那可能就是环境或者项目本身的问题了。 8. 认识下几个命令上面提到了，假设我们没有 IDE ，只有类似 Sublime、Atom、Vim这种轻量编辑器怎么办？那我们就没法开发 Android 了么？然而只要有构建工具，不需要 IDE 我们一样有办法开发，这个时候我们就需要用到几个有用的 Gradle 命令了： ./gradlew -v 版本号 ./gradlew clean 清除9GAG/app目录下的build文件夹 ./gradlew build 检查依赖并编译打包 这里注意的是 ./gradlew build 命令把 debug、release 环境的包都打出来，如果正式发布只需要打 Release 的包，该怎么办呢，下面介绍一个很有用的命令 assemble , 如 ./gradlew assembleDebug 编译并打Debug包 ./gradlew assembleRelease 编译并打Release的包 值得注意的是，以上所有命令都是在终端里执行，并且必须要切换到所在项目的根目录下执行，win系统直接执行 gradlew 。 9. 总结以上就是今天给大家普及的 Android 中用到的 Gradle 基础知识，相信大家看完之后就大概理解了 Android 项目中的 Gradle 作用以及一些基本用法，关于 Gradle 的具体配置以及更多的介绍以后有时间再跟大家补充吧，在很早的博客里的 AS 系列文章里其实有写过几篇关于 Gradle 的，感兴趣的不妨看这里去阅读拓展下： /devtools/2015/06/17/android-studio-all/ aclear_zhang 10/28/2017]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CENTOS6.9配置ssr+锐速]]></title>
    <url>%2Fpost%2Fc1fbd534.html</url>
    <content type="text"><![CDATA[科学上网教程（一）——VPS上搭建SSR字数统计 5,469 | 阅读时长 21m 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 更新 2016.06.26 与SSR有关部分基本完成。 2016.09.29 更新SSR部分内容 2016.10.09 更新SSR内容，更新Android端接入。 2016.11.09 更新SSR混淆相关内容，更新SSR-Android，更新部分介绍。 2016.11.20 整合一部分VPS优化内容 2016.12.11 删减调整一部分内容 2016.12.15 替换锐速优化为 BBR，整合TCP优化 2016.12.26 更换TCP BBR 脚本，脚本来自@秋水逸冰 版本，测试通过 2017.01.11 同步更新一部分SSR内容 2017.02.17 同步更新，调整删减内容，降低上手难度，增加VPS测速相关内容 2017.03.28 调整一部分内容，更新Vps推荐 2017.04.08 新增 VPS 安全加固 2017.05.24 同步更新内容，更换协议，增加新内容。 2017.06.28 删减过时内容，同步更新 2017.07.03 更新BBR内容，VPS测速 2017.07.12 更换过时截图，修正错误。 2017.07.28 更换失效链接，可能是最后一次更新了 2017.10.18 更新vps内容,缩减无效信息. SSR原作者已删除代码库,应该不会再更新此教程，这个教程开始到现在1年多，基本没有停更，收获了50000多的没加水的阅读量，谢谢大家！ 我开始有些明白GFW的不断强化并不是最可怕。或者说GFW的存在并不重要.人心的墙永远有人在无偿加固。 安装脚本说明：遇到失效等，请留言或邮件我！ 脚本来源 @秋水逸冰 ShadowsocksR一键安装脚本 隐私/后门：(这个结论仅对本文使用脚本负责) 文章中所使用的脚本，除默认用户名/密码外，没有任何夹带私货。脚本亦开源，不放心可以下载后自行审计！ https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh SSR 服务器端更新： 使用此一键脚本安装的，不能使用其他命令更新，只能通过 备份配置文件，卸载再重新安装！也都不是事，备份一下配置文件，重新安装，覆盖配置文件，重启即可。 基本从0开始的教程，当作自己的备份了。 吐槽 作为一个伪程序员，每次最苦恼的就是Android SDK的更新，当初安装Android Studio时候就因为防火墙折腾了整整2周，简直就是把自学Android的那点耐心都磨没了。各种的搜索文档，离了google效率下降70%！科学上网简直成了程序员的必备生存技能了。 谁比较需要单独购买VPS科学上网？ 只是翻墙简单浏览网页，就不必要再单独花费人民币了，蓝灯、和各个网站的免费ss账户，是你的主菜。 偶尔看看视频、不想画太多精力在寻找免费资源上。可以直接购买现成的ss/vpn账户，在G+相应的社区可以找到很多比较靠谱的提供商。 常年泡视频网站又受不了国内视频网站乱七八糟、24h使用google服务、对稳定性和流量有一定要求、愿意使用一点时间来折腾VPS。比较适合单独购买VPS来科学上网。VPS选择如下会提及。 搜索文档，更新软件源、折腾个人网站又不想备案的、折腾开源的 这部分大神谁会来看这个啊，早自己分分钟写个轮子了 VPS选择选择VPS看那几点 一定要根据自己的具体使用场景和网络环境来选择VPS服务。 选择VPS的一般要注意的几点 自己的具体网络环境 简单来说，一般联通的国际出口稳定性大于电信、移动的国际出口看心情有的地区甩电信联通几条街，坏的时候根本没速度。电信网路比较特殊，国际出口充足，但是限速到不能忍，不挤的时候嗖嗖的，高峰期渣到爆炸.移动出口不错,但墙中墙.. 其他二级宽带商忽略不计 VPS地点。 日本VPS电信网络访问要绕道美国绕道ping一般在200到300了，（9.29）联通直连日本，ping在100！联通目前也分地区有限速。(2.17)联通因为16年年底海底光缆故障损失了30％的国际出口，导致新年到现在出口路由并不稳定，联通-日本ntt延迟有时200有时100.（6.28）目前读者反映ntt比较稳定。已放弃亚洲地区vps(10.18),不稳定相比其他地区. 美国的VPS联通/电信访问延迟基本相当。一般选择靠近美国西海岸节点旧金山、洛杉矶、纽约等地点。电信限速很厉害，所以一般电信网需要开混淆配合FinaSppeed等加速。可以选择便宜cn2线路vps,会好很多. 新加坡节点，在靠近南方地区，可以ping在100以内稳定！youtube 4k不卡。但在偏北一些地区ping不稳定 香港VPS，这个比较特殊，香港的VPS ping值可以低到20几，但是香港本身的国际出口就小，VPS价格也偏高，另外香港毕竟也在政府的直接管辖内，隐私方面风险比其他地区节点要大一些。建议土豪级别的游戏玩家使用。 VPS虚拟化架构 (具体解释请自行google，只说明对科学上网的影响) OpenVZ（简称OVZ） 便宜！但是没法进行修改内核、加锐速之类的优化操作。访问速度基本取决于你的本地网络环境优化的可能性。（不是没有可以加速的手段，就是在基本相同情况下，不如其他架构的vps可以榨干VPS的传输性能）。加速手段：Finaspeed（已停止更新） 和net-speeder。 Xen性能较好，实际用的不多，不做更多评论 Hyper-VH完美支持Windows系统，Hyper-V同样可以超售内存和硬盘，如果服务商超卖较多可能会有性能问题，Linux操作系统性能较低。 KVM全功能虚拟化架构，可上传ISO手动安装系统。KVM VPS相对其它架构的VPS较为自由。虚拟化性能比Xen略低。可以使用TCP优化和锐速，价格比一半OVZ的要高一些。（本教程以KVM为例。。速度需求大的最好使用KVM） VPS提供商 这个就比较多了，尽量选择购买人较多的，而且一般支持支付宝的服务商被国人玩半残居多（比如搬瓦工。。超售严重），所以购买不支持支付宝的vps提供商 (相对) 要靠谱一点。注册paypal国际版（注：是国际版paypal 不是国内的贝宝！）一般的vps提供商都支持paypal付款。与使用信用卡相比，具体的优惠政策不同. 支持支付宝/微信的服务商良莠不齐，第一次购买需要注意退款政策，虚拟化架构等，最好按月支付。现在使用的是洛杉矶的KVM机器，配合BBR基本3网通吃，除个别时段非常稳定。电信推荐洛杉矶C3机房,虽然为半程cn2,但足够便宜稳定. 推荐几个 VPS 的评测网站，相对更新很快。 http://www.laozuo.org/myvps https://doub.io/ https://www.91yun.org/ VPS测速 决定科学上网质量的主要是由vps回城的线路决定. 常用VPS提供商测速地址 vultr http://www.vultrvps.com/test-server 搬瓦工 http://www.64mb.biz/tips/4ip.html 其他待更新，其实只要搜索 测速地址+vps提供商名称就好 以vultr东京节点为例 有的vps提供商只提供测速网址，而测速大多以ip地址为主， ping命令可以获取 测速网址 对应的ip地址 最简单的命令 PING (延迟测试) win+r组合键打开运行栏 输入cmd，回车 如图 输入 ping 你需要测试的ip地址 这里是 1 ping hnd-jp-ping.vultr.com 应答如下 这里可以看到具体的测速ip地址为 108.61.201.151 选中 Ctrl + C复制下来 延迟141 左右，还在接受范围内。丢包大致作为参考即可，只有4个包发送，不足以作为结果 注意这里的延迟只是ping检测的结果，可以作为实际访问延迟的参考值，而不是绝对准确！ 测速相关网站 查询ip地址归属地 不要使用 百度搜索查询ip地址 那些数据国内尚可，vps一般对应国外网站，百度等则错误不少，推荐： ipip.net https://www.ipip.net/ip.html 全国ping检测 有时ss属于合租服务器，可能在不同省份，需要评估ip到不同省份的延迟，这个时候就需要 全国范围内的ping检测 首推： 站长之家ping检测 http://ping.chinaz.com/ 路由追踪 Best Trace Best Trace是由 IPIP.NET 开发的路由追踪检测工具 官方地址下载 路由追踪 即 检测数据 从你的本地宽带开始 到 vps 的整个过程中走的路径，例如 北京联通 到 vultr东京 从北京直接连到日本，而 河南电信到 vultr东京 则是先到美国，再去日本。 上图说话(图片来自91yun) 这款软件几乎没有上手难度 具体介绍如下 http://www.laozuo.org/8277.html 丢包率 WinMTR 具体介绍如下，91yun介绍很详细，并附带下载地址，此处就不多言了 https://www.91yun.org/zh/archives/1120 VPS自身测试（7.03） vps网络测试 https://teddysun.com/444.html vps性能测试 https://teddysun.com/245.html vps部署 我选择的是Vultr VPS。2.5刀/月，500G流量 怎么折腾都够了。 本节内容转载/删节/修正自 https://mpc2008cn.github.io/2015/10/22/vps/ 就是从这开始折腾的，有删减和修改。 Vultr 通过下面链接注册，你可以免费获得 10美元 同时 也能帮助我获得一些奖励，谢谢！ Vultr地址 服务器选择 选择东京或者美国西海岸的服务器,速度相对比较快 操作系统 推荐选择Debian 7 x64 此版本搭建SSR/锐速/bbr基本没有遇到故障 其他版本也可，请自行选择 选择硬件 一个月可以免费用$5的配置,科学上网就够了，建站等需求需要更大的。 创建vps 等待完成。 VPS测试(可忽略，但是推荐进行) 你可以使用上面提到的 VPS测试软件，来查看 自己的vps到本地的 路由追踪 时候与 官方测试地址 相同，丢包率/延迟如何等 现在几乎所有的vps运营商 都有大量的国人涌入，有一点概率你开到的IP 是被 长城防火墙 阻断过，被废弃的ip。在正式搭建 科学上网 服务之前，请确保自己 VPS 的可访问性 配置securecrt(不必在意ip地址) 下载securecrt 复制服务器的IP地址,初始用户名,初始密码 securecrt连接vps 解压下载的secure crt,双击\\SecureCRT_EN\\SecureCRT\\中的SecureCRT.exe 输入IP地址,用户名,点击connect 弹出框点击Accept&amp;Save 输入密码,勾选save password,OK 出现如图所示,标签变绿就说明连接成功啦. 部署ShadowSocksR 为什么选择SSR而不是原版的SS 主要原因如下 可以直接启用chacha20加密，在移动设备上比较好使 TFO(TCP Fast Open)直接自带，减少握手次数。 二次混淆和抗重放等附加功能 shadowsocksR的相关争论在以下网址中，至于用户而言，现在ssr开源，一定的网络环境下比原版的ss稳定就够了。 一些争议如下 https://www.librehat.com/about-shadowsocks-r-and-the-security-of-shadowsocks/ SSR有关网址 (2.17)在2016.12月之前很长一段时间SSR只在 ZeroNet 中更新，17年以后到现在恢复在github上更新！望周知！**SSR已删除库，但还可以安装** ShadowsocksR github主页 https://github.com/breakwa11/shadowsocks-rss ShadowsocksR C#(windows版)下载地址 https://github.com/shadowsocksr/shadowsocksr-csharp/releases shadowsocksr-android版下载地址 https://github.com/shadowsocksr/shadowsocksr-android/releases 用到的一键安装脚本@秋水逸冰(感谢！) https://shadowsocks.be/9.html ZeroNet(目前更新状态未知) SSR-ZeroNet http://127.0.0.1:43110/shadowsocksr.bit （10.9）不安装ZeroNet，直接访问地址 https://bit.no.com:43110/shadowsocksr.bit/ ZeroNet简介和接入 http://www.williamlong.info/archives/4574.html 安装SSR 复制以下代码到登陆成功的securecrt 1 2 3 wget —no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh chmod +x shadowsocksR.sh ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 如图，回车。 输入设定初始密码，也可以直接回车。 输入初始端口，也直接回车 嗯，回车 等待一段时间的滚屏， 最后会提示——成功 shadowsocks.json配置文件 shadowsocks.json文件中定义SSR的访问端口，加密方式等，我们使用 WinSCP软件进行编辑修改(更为友好)，直接使用 securecrt 等工具 使用 vim 命令修改也可，此文中暂不涉及 WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 SCP 协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件. 下载WinSCP绿色中文版。 解压缩打开winscp，保持默认配置不变，输入VPS的ip地址、用户名、密码。点击登陆。 默认在/root文件夹下，要进入/etc文件夹下找到shadowsocks.json 编辑shadowsocks.json文件 下面是一个 shadowsocks.json的注释模板 直接复制粘贴 无注释版本 覆盖原始文件即可，或者在原文件上修改 （建议先看一下注释，了解一下shadowsocks.json的大致内容） 参考资料网址 shadowsocks.json文件各项配置说明 https://github.com/breakwa11/shadowsocks-rss/wiki/Server-Setup 混淆插件说明 https://github.com/breakwa11/shadowsocks-rss/wiki/obfs 注释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { “server”:”0.0.0.0”, “server_ipv6”:”::”, “local_address”:”127.0.0.1”, “local_port”:1080, “port_password”:{ 纯 SS 不带混淆 端口25 密码为123456.“25”:”123456”, 端口443，密码123456 ，protocol选择auth_chain_a。obfs选择tls1.2_ticket_auth，具体插件的介绍如下参考资料中“443”:{“protocol”:”auth_chain_a”, “password”:”123456”, “obfs”:”tls1.2_ticket_auth”, “obfs_param”:””}, 注意无论怎么变化，最后一个端口设置，不带逗号！“3389”:{“protocol”:”auth_aes128_md5”, “password”:”123456”, “obfs”:”tls1.2_ticket_auth”, “obfs_param”:””}#此处没有逗号！ }, “timeout”:400, 默认全局的加密方式，即上边各个端口的默认加密方式。一般为aes-256-cfb， 此处，选择为chacha20，移动设备性能较好。“method”:”chacha20”, protocol.协议定义插件的默认值，origin即使用原版SS协议，不混淆。即上面端口配置中，你没有设置 protocol 和 obfs 情况下，使用的默认值。“protocol”: “origin”, “protocol_param”: “”, protocol.协议定义插件的默认值，plain即使用原协议，不混淆。“obfs”: “plain”, “obfs_param”: “”, “redirect”: “”, “dns_ipv6”: true, TCP FAST OPEN ，打开“fast_open”: true, “workers”: 1 } 无注释版本，直接复制粘贴覆盖原始文件，或者在原文件上修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { “server”:”0.0.0.0”, “server_ipv6”:”::”, “local_address”:”127.0.0.1”, “local_port”:1080, “port_password”:{ “25”:”123456”, “443”:{“protocol”:”auth_chain_a”, “password”:”123456”, “obfs”:”tls1.2_ticket_auth”, “obfs_param”:””}, “3389”:{“protocol”:”auth_aes128_md5”, “password”:”123456”, “obfs”:”tls1.2_ticket_auth”, “obfs_param”:””} }, “timeout”:400, “method”:”chacha20”, “protocol”: “origin”, “protocol_param”: “”, “obfs”: “plain”, “obfs_param”: “”, “redirect”: “”, “dns_ipv6”: true, “fast_open”: true, “workers”: 1 } 重启SSR 配置完成后，重启SSR,以root账户登陆securecrt，复制以下代码，重启ssr。 1 /etc/init.d/shadowsocks restart 会提示shadowsocksr重启成功。（如图） 更新SSR vps端，需要先令存 shadowsocks.json文件。再执行卸载 1 ./shadowsocksR.sh uninstall 之后重新执行安装脚本即可 混淆选择(新手可略过)混淆插件简介 ShadowsocksR目前支持的混淆插件（此类型的插件用于定义加密后的通信协议）： plain ,http_simple ,http_post,random_head ,tls1.2_ticket_auth _协议定义插件(用于定义加密前的协议): origin, auth_sha1, auth_sha1_v2, auth_sha1_v4, auth_aes128_md5/auth_aes128_sha1 auth_aes128_md5/auth_aes128_sha1 支持 单端口多用户，即一个端口 可以配置 几个不同的密码，稍后更新。 ShadowsocksR 协议插件文档 混淆插件选择(5.24) 通用 推荐auth_chain_a+tls1.2_ticket_auth 这种组合目前混淆效果最好，有利于个人VPS的长时间使用。 （5.24）auth_chain_a可不使用用加密，即加密方式None（SSR作者语），但是吧，性能差不多的情况下，加个密没毛病。 auth_aes128_md5或auth_aes128_sha1+随意，即使使用rc4加密亦可（SSR作者语） 玩游戏，或对延迟有要求，不要使用tls1.2_ticket_auth 网络封锁/监控环境下 例如学校教育网/公司内网/广电宽带等等，封杀了BT/禁止访问网盘等等等等。 使用http_simple、http_post或tls1.2_ticket_auth 混淆访问的目标网址。再配合443/80端口通常可以解决问题。 Android (5.24)最好使用auth_chain_a。 如果之前使用的是auth_aes128_md5，推荐以auth_chain_a替换 手机运算能力较差的推荐使用auth_sha1_v4替换auth_aes128_md5 单端口多用户 适用场景: 多人合租,减少vps开放端口. https://breakwa11.blogspot.ru/2017/01/shadowsocksr-mu.html?m=1 官方 ShadowsocksR单端口多用户配置方法 伪装正常网站(推荐) 适用场景 最大程度减少GFW主动扫描,被发现的可能性. (伪装网站后,无法使用单端口多用户) https://doub.io/ss-jc48/ 逗比根据地的介绍，很详细，搭配最新的auth_chain_a 混淆，很好用。 http网站对应混淆选择http 或 post https 网站选择tls1.2 域名申请，免费！ https://my.freenom.com/clientarea.php DNS解析(目前国内网站 域名 CDN DNS解析 均需备案实名,故放弃) https://www.cloudflare.com/ VPS优化 详情在科学上网教程（二）——VPS优化加速 这里只提及 原版BBR BBR目前有很多修改版本，效果很好，BBR属于内核级别，不推荐新手 安装修改版BBR，内核挂掉，新手一般很难处理。 修改版BBR 详情见科学上网教程（二）——VPS优化加速 TCP优化 增加TCP连接数量 1 nano /etc/security/limits.conf 添加两行： 1 2 * soft nofile 51200 * hard nofile 51200 保存(Ctrl + X —— y ——回车) 设置ulimit： 1 ulimit -n 51200 CENTOS6.9不换内核安装锐速 请参照以下示例:1. 使用锐速安装脚本,得知不能匹配到内核. 通过 uname -r 查看到的版本号为 2.6.32-642.el6.x86_64 , 去查看 锐速版本库 发现有个内核版本很接近 2.6.32-573.1.1.el6.x86_64 . 执行安装命令: 1 wget —no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder\_Install/master/appex.sh &amp;&amp; chmod +x appex.sh &amp;&amp; bash appex.sh install ‘2.6.32-573.1.1.el6.x86_64’ 锐速安装脚本就会强制安装内核版本为 2.6.32-573.1.1.el6.x86_64 的锐速. 安装命令中的 2.6.32-573.1.1.el6.x86_64 可自行更改. 启动锐速 如果启动成功，恭喜你! 如果启动失败，请重复 2-5 步骤! 不要害怕失败,安装失败并不会影响系统运行. [锐速] [serverSpeeder] [lotServer] 声明: 毕竟你都要换内核了,就不要谈稳不稳定. 如因此造成损失,本人不负任何责任. 温馨提醒:**数据无价,请及时备份数据.** TCP-BBR(推荐) 脚本来自于@秋水逸冰 敬告： 锐速不支持，更换后的 4.9及以后 内核 加速效果与具体网络状态有关 不推荐新手直接安装修改版BBR，挂掉后很难恢复。 BBR (Bottleneck Bandwidth and RTT)是由google工程师编写的新的 TCP 拥塞控制算法，目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 加速效果不比锐速差， 完全开源，对隐匿性要求高而无法使用锐速的人士，也可以放心使用 开源地址 启用TCP-BBR涉及VPS更换内核，所以如果步骤错误，或者VPS不兼容最新的内核，会导致无法开机等错误 目前在 Vultr / DO 上测试通过。其他主机提供商，请自行测试 连接SSH，运行下面的命令 1 2 3 wget —no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh 提示需要重启 VPS，输入 y 并回车后重启，重连SSH 脚本会自动更新匹配的4.xx版本内核(6.28 目前是4.11），并启用TCP BBR 验证 输入 1 uname -r 有4.9.0 以上就 表示 更新成功 输入 1 lsmod | grep bbr 返回值有 tcp_bbr _即bbr已启动。 添加一些优化内容 修改sysctl.conf 1 nano /etc/sysctl.conf 复制代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 TCP配置优化(不然你自己根本不知道你在干什么)fs.file-max = 51200 提高整个系统的文件限制net.core.rmem_max = 67108864 net.core.wmem_max = 67108864 net.core.netdev_max_backlog = 250000 net.core.somaxconn = 4096 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 0 net.ipv4.tcp_fin_timeout = 30 net.ipv4.tcp_keepalive_time = 1200 net.ipv4.ip_local_port_range = 10000 65000 net.ipv4.tcp_max_syn_backlog = 8192 net.ipv4.tcp_max_tw_buckets = 5000 net.ipv4.tcp_fastopen = 3 net.ipv4.tcp_mem = 25600 51200 102400 net.ipv4.tcp_rmem = 4096 87380 67108864 net.ipv4.tcp_wmem = 4096 65536 67108864 net.ipv4.tcp_mtu_probing = 1 net.ipv4.tcp_congestion_control = bbr END OF LINE保存(Ctrl + X —— y ——回车) 应用 1 sysctl -p 重启SSR 1 /etc/init.d/shadowsocks restart VPS安全加固( 安全性是重中之重！) 必须进行的步骤，安全性是重中之重！ 详情在科学上网教程（三）——VPS安全加固 shadowsocksR 客户端配置shadowsocksR C# windows版本 (6.28)最新的4.6.0客户端(注意MD5校验) 支持hosts文件实验性质，稳定后加入 shadowsocksR C# windows版本 来源于github备份。 解压ShadowsocksR-win-4.6.1.7z（以具体客户端版本为准），打开。 对应上文中SSR服务端配置 输入对应端口配置，ip地址，密码等。 25端口（单SS） 443端口 3389端口 右键shadowsocks快捷图标,选择启用系统代理 现在应该可以访问 谷歌了:) 使用Chrome+SwitchyOmega 推荐！！ Chrome下插件SwitchyOmega可以根据要访问的网址判断是否需要经过代理，做到智能的科学上网。并且现在这个插件的配置可以云同步，再也不用本地保存了！具体教程如下 SwitchyOmega使用ss代理 http://www.ihacksoft.com/chrome-switchyomega.html 配合gfwlist https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList SSR-Android SSR-Android SSR-Android端(注意MD5校验) https://github.com/Jasper-1024/shadowsocksr-android-1/releases (12.11) ssr-android更新到3.2.7.14.版，增加auth_aes128_md5和auth_aes128_sha1,推荐更新！ (1.11) ssr-android更新到3.3.3.1推荐更新！ (2.17) ssr-android更新到3.3.4.5 推荐更新! (6.28) SSR-android更新3.4.0.5 android端使用 可以直接输入SSR配置，较为繁琐 在SSR C#版本，中输入完毕，保存。直接扫描二维码即可！ 二维码必须在光标移到 SSR链接 处才会出现 结束]]></content>
      <categories>
        <category>工具_etc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Eclipse新建Servlet时候，不会自动生成mapping到web.xml，而是在代码中加入注解@WebServlet]]></title>
    <url>%2Fpost%2Fc2e0db1.html</url>
    <content type="text"><![CDATA[对比-原web.xml值: MyServlet&lt;/servlet-name&gt; com.servlet.MyServlet&lt;/servlet-class&gt; MyServlet&lt;/servlet-name&gt; /MyServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 现象： 用Eclipse新版本新建servlet时候，发现创建Servlet后，Eclipse不会自动在web.xml中生成该Servlet对应的mapping信息，而是在Servlet代码中加入注解@WebServlet，如下 分析： 查找文档发现，这是Servlet3.0新特性(得Tomcat7.0版本及以上)，@WebServlet 用于将一个类声明为 Servlet，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为 Servlet。该注解具有下表给出的一些常用属性（以下所有属性均为可选属性，但是 value 或者 urlPatterns 通常是必需的，且二者不能共存，如果同时指定，通常是忽略 value 的取值） 解决方法： 在@WebServlet 中定义Servlet的name、urlPatterns等信息 import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet; @WebServlet(displayName = “This is Login Action”, //描述name = “LoginAction”, //servlet名称urlPatterns = { “/servlet/LoginAction” },//urlloadOnStartup = 1, //启动项initParams = { @WebInitParam(name = “username”, value = “张三”) }//初始化参数)public class LoginAction extends HttpServlet { /** * Constructor of the object. */ public LoginAction() { super(); } } 上面的@WebServlet告知容器，HelloServlet这个Servlet的名称是Hello，这是由name属性指定的，而如果客户端请求的URL是/HW，则由具Hello名称的Servlet来处理，这是由urlPatterns属性来指定的。在Java EE相关应用程序中使用标注时，可以记得的是，没有设置的属性通常会有默认值。例如，若没有设置@WebServlet的name属性，默认值会是Servlet的类完整名称。 注意：Tomcat中， 如果web.xml和@WebServlet属性都设置了，那么对不起，@WebServlet 中的urlPatterns属性就不起作用了！（可以将web.xml从WEB-INF目录中移走，或者删除 这样@WebServlet中的urlPatterns属性值就可以使用了！） Servlet的访问URL是Servlet的必选属性，可以选择使用urlPatterns或者value定义。 像上面的LoginAction可以描述成@WebServlet(name=”LoginAction”,value=”/LoginAction”)。 也定义多个URL访问： 如@WebServlet(name=”LoginAction”,urlPatterns={“/LoginAction”,”/LoginAction2”}) 或者@WebServlet(name=”LoginAction”,value={“/LoginAction”,”/LoginAction2”}) 这样的简化形式也可以，相当于设置了name和urlPattern @WebServlet(“/servlet/LoginAction”) 在新建Servlet时候在URL mapping中可以直接输入]]></content>
      <categories>
        <category>JSP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次搭建SS服务器，完整的过程。]]></title>
    <url>%2Fpost%2Ff09d9872.html</url>
    <content type="text"><![CDATA[前言 这几天为了登录外网查询资料，谷歌经常抽风，国外的博客也打不开，都要整崩溃了。我以前（直到昨天以前）都是使用修改hosts来访问外网的，用的是 老D（https://laod.cn/hosts） 无偿分享的hosts。 直到昨天我终于受不了了，听闻前同事使用的是VULTR 来搭建SS服务器，价格也非常便宜，比买vpn划算多了，还安全，还多了一台服务器。然后就下定决心，一劳永逸的解决上网问题。 vultr VPS 大致浏览了一下他们的vps的价格，比国内的真的便宜的太多太多了。 然后在网上又大致的了解了一下其他的vps性价比，还是vultr 性价比比较高。 鉴于个人使用，也没用额外需求。500G的流量应该够用了，就选择了最便宜的。 支付方式：信用卡，PayPal，比特币。 因为是天朝大陆，天朝信用卡或许可能不一定能在国外使用，如果去其他网站购物也不方便。比特币，这么值钱的东西怎么舍得拿来花。 所以就选择了PayPal，地位相当于国外支付宝。毕竟也是大牌子，值得信任。在没有vpn的情况下打开非常慢，需要耐心。下面就根据他们的提示一步一步的注册，绑定银行卡就行了。 还有一点要注意，结算方式是美元$。当时我打电话给建行客服，想问一问关于双币信用卡的问题。然后我听了20分钟的音乐彩铃，“客服忙”就强行给我挂断了。没有办法，急性子的我，只好先试试看了。幸运的是，我一次就成功了。是按照当天的汇率兑换的，幸好没有那么麻烦，白紧张了。 题外话：我记得2008年前后几年，中国大部分银行卡面上都有visa和银联的标识，我昨天才突然意识到现在卡面上只剩银联了。 安装CentOS 配置shadowsocks 安装CentOS 没有什么好说的了，要注意就是他们是没有图形界面的。vultr自己提供的View Console 一点都不好用，还是使用SecureCRT。这个链接系统没有什么好说的，还有一点，因为是国外服务器，ping可能是比较高，不太稳定。 要耐心多连几次就好了。当时连不上，我还以为我的SecureCRT配置出现什么问题了。 安装配置 shadowsocks：参考：http://morning.work/page/2015-12/install-shadowsocks-on-centos-7.html shadowsocks 帮助文档：https://github.com/shadowsocks/shadowsocks/wiki 我的配置 vi /etc/shadowsocks.json { “server”: “0.0.0.0”, “local_address”: “127.0.0.1”, “local_port”: 1080, “port_password”: { “8080”: “你的密码1”, “8081”: “你的密码2” }, “timeout”: 600, “method”: “aes-256-cfb”} 查看服务是否启用成功： systemctl status shadowsocks -l ● shadowsocks.service - Shadowsocks Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled) Active: active (running) since Wed 2017-03-29 01:54:44 UTC; 4s ago Main PID: 9365 (ssserver) CGroup: /system.slice/shadowsocks.service └─9365 /usr/bin/python /usr/bin/ssserver -c /etc/shadowsocks.jsonMar 29 01:54:44 yezipi systemd[1]: Started Shadowsocks.Mar 29 01:54:44 yezipi systemd[1]: Starting Shadowsocks…Mar 29 01:54:44 yezipi ssserver[9365]: INFO: loading config from /etc/shadowsocks.jsonMar 29 01:54:44 yezipi ssserver[9365]: 2017-03-29 01:54:44 INFO loading libcrypto from libcrypto.so.10Mar 29 01:54:44 yezipi ssserver[9365]: 2017-03-29 01:54:44 INFO starting server at 0.0.0.0:8080 最后的最后，开启CentOS端口： 我当时只注意到vulrt的防火墙，忘记打开CentOS的防火墙端口了。让我又折腾了两个小时。。。 firewall-cmd —zone=public —add-port=8080/tcp —permanentfirewall-cmd —zone=public —add-port=8081/tcp —permanentfirewall-cmd —reload 客户端连接 客户端连接我目前只用到 windows 和 Android的: windows: http://www.iyingsuo.com/windows-shadowsocks-tutorials.html 上面有各个release版本，支持不同的.NET FrameWork https://github.com/shadowsocks/shadowsocks-windows/releases 目前github上面的最近版本，支持.NET Framework 4.6.2 。由于本地装的是4.5，不想麻烦，就没有在上面下载。 Android： https://github.com/shadowsocks/shadowsocks-android/releases 安卓直接下载最新的安装就行了。 安装软件后，配置客户端都比较简单。Android 没有找到运行日志，查找原因比较麻烦。 我在测试的时候，用的是windows版本的，通过日志调通了。然后就愉快的上网玩耍了。 补充： 建议使用谷歌黑科技 BBR 算法，提升ss服务器上传速率的。BBR 目的是要尽量跑满带宽, 并且尽量不要有排队的情况。需要升级到Linux kernel 4.9+的内核。 劝君曰：秋名山上行人稀，常有车手较高低；如今车道依旧在，不见当年老司机。 黄泉路上无老少，生死有命不用吵；活着快乐是最好，及时行乐才最妙。]]></content>
      <categories>
        <category>工具_etc</category>
        <category>计算机基础--安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小白教程-一看就懂得SSR免流量教程]]></title>
    <url>%2Fpost%2F7d83c3a.html</url>
    <content type="text"><![CDATA[小白福利-全网最详细的SSR免流教程作者：可乐，转载 前言： 本教程纯粹为小白而写，老司机不必看，也请口下留情 教程分为三部分： 第一部分：性价比最高的服务器-Vultr的购买与创建 第二部分：SSR搭建、配置、提速，适用于所有服务器 第三部分：抓包（端口和混淆参数） 第一部分：性价比最高的服务器-Vultr的购买与创建 提前介绍下SSR免流，SSR免流和OPENVPN免流一样，都属于云免，不同的是SSR免流暂时没有成熟的流控，所以不适用于商业化，适合自用，相对于OPENVPN免流来说更简单、更省电； 要用SSR免流，首先要有服务器，既然是自用，那国内服务器显然太贵，一般都用国外服务器搭建，免流的同时还能翻 Q，翻Q就是可以浏览国外网站，外面的世界很精彩，有什么好处，老司机都懂的； 国外服务器，这里推荐Vultr，看下去你就明白为什么推荐它。 Vultr简介：机器采用E3的CPU，清一色SSD硬盘，全球15个数据中心，全天24小时都可创建，60秒内部署好，所有的VPS都配备了真正的root权限和一个独立的IP地址，按小时计费，最便宜的套餐2.5美元/月(日本只有5的了,纽约有2.5的)(最新支持支付宝支付10$==66人民币的样子)（共享带宽100M，流量1TB/月），换算成小时是0.007美元/小时，也就是不足人民币5分钱，用多少算多少，不想用可以随时删除，删除后不再计费,有人说5美元/月的价格相对于大把十几二十美元包年的国外服务器来说太贵，但vultr家最厉害的是新用户优惠，新注册用户使用PayPal支付5美元可获得25美元、使用信用卡不用花钱即可获得20美元，都是一年有效期，也就是说，如果你有信用卡，你可以免费用5美元的套餐4个月，如果你只有银行卡，你也只需要支付5美元就可以用5美元的套餐5个月，而且最重要的是，Vultr家的VPS都是kvm架构，可以安装锐速或BBR（作者亲测vultr日本机房装完锐速后延迟140ms，下载7m/s），相对于OVZ架构的VPS拥有巨大优势，而十几二十美元包年或二三美元包月的国外服务器一般都是OVZ架构，延迟感人，速度堪忧 下面介绍怎么购买vultr 1、首先，购买前要确认你的信用卡或银行卡是否支持多币种，请自行百度，不支持的话请直接看本教程第二部分，支持的话继续往下看 2、如果你有多币种信用卡，那没什么说的，按后续教程输入信用卡信息购买即可；如果你只有多币种银行卡的话，由于国内银行卡不能直接用于国外网付，所以要先注册PayPal绑定银行卡，注册步骤如下： 一、打开PayPal官网https://www.paypal.com，免费注册 二、输入邮箱，要设置的密码 三、输入姓、名、出生日期、地址（可随意）、邮编（与地址对应）、手机号码，除地址和邮编外 其他一定要保证真实 四、点同意并创建用户 五、输入银行卡号、与银行卡对应的手机号码，点下一步（用PayPal付款必须绑定信用卡或者支持双币支付的银行卡，如62开头的光大银行） 六、输入手机验证码，点验证，按提示操作，如提示扣款不用担心，这是预付款验证，不会真扣，即使扣了也会返还你的账户余额里 七、点转至您的账户 八、点验证邮箱地址 九、点发送电子邮件 十、登陆邮箱，打开PayPal发来的邮件，选择点击此处激活账户 十一、输入你设置的密码，点验证邮箱地址 十二、大功告成，可以在支持PayPal的国外网站购物了 3、注册Vultr 一、注册地址：http://www.vultr.com/?ref=7142841 （使用本地址注册才能得到20美元的赠送），进入后按图输入邮箱和要设置的密码（最少10位，要同时有数字和大小写字母），最后点击create account创建 二、注册成功后，首先确认右侧有$20字样，然后再继续用信用卡或者PayPal充值激活账户，在右侧选中Credit Card或PayPal(最新支持支付宝)，分别按对应截图填入信息购买 4、注意事项 一、信用卡可能会扣取1美元用作验证，成功后过段时间会自动返回账户 二、一个信用卡或PayPal只能给一个账号付款，如果用不同的邮箱去注册多个账号，然后用同一个信用卡或PayPal付款，最后的结果是这个PayPal付过款的所有的vultr关联账号会被官方封杀，且不会退款，一定要注意，不要贪心 ④在Vultr中创建VPS，依次按照下面的截图创建即可 第二部分：SSR搭建、配置、提速，适用于所有服务器 SSR简介：一款优秀的代理软件，本意是让更多的网友畅游网络，却被天朝的大神开发成了免流 SSR免流方式：免流端口加混淆参数 免流端口常见的有移动：137,138,8080,80，440,443.8989.351.366,电信：189,8080,80,443,440,3389,联通：8080,80,53(空中卡),130,131,132,155,156,185,186,145,176,443,440,3389 混淆参数就是免流网址，由于最近和谐了很多，就不写了，请自行收集测试，也可以自己抓包，抓包教程在最后面 SSR客户端下载： 安卓https://github.com/shadowsocksr/shadowsocksr-android/releases、或者直接百度 IOS登录商店下载wingy（免费）、LIFI（免费）、netkit（收费）、pototso（俗称土豆丝，收费）、surge（收费，很贵）、shadowsocks（俗称小火箭，最好用，也是用的人最多的，收费）、或者用电脑端爱思助手连接手机直接下载shadowsocks（免费，推荐此方法） ④SSR搭建 一、准备好你的服务器，确认账号（一般是root）和密码，系统建议Centos6 ×64 二、手机用juicessh连接服务器，(电脑Xshell 5 )教程如下 #juicessh使用教程 0.进入juicessh 1.点上侧连接 2.点右下角+ 3.昵称随意，类型SSH，地址你的服务器ip，端口默认22不变（映射端口和自设端口除外） 4.认证选新建 5.昵称随意，用户名一般为root，密码填你的服务器密码 6.√ 7.√ 8.点你设置的配置，如无昵称就是以服务器ip命名 9.如无意外，这时就自动登陆服务器了，如果提示你输入密码，再输一遍就行 了，输入后记得点保存 10.进入服务器后，就可以运行代码了，本机键盘手打或者复制粘帖均可 三、电脑用xshell连接服务器，教程如下 xshell使用教程: 0.进入xshell 1、 点左上角文件 2、点新建 3、名称随意，协议SSH，主机你的服务器IP，端口默认22不变（映射端口和自设端口除外） 4、确定 5、选中设置的配置双击打开 6、提示输入账号和密码，输入后记得点保存 7、进入服务器后，就可以运行代码了，本机键盘手打或者复制粘帖均可 四、进入服务器后，就可以运行SSR代码了，这里推荐用西门吹雪的，当然 也可以用其他的，网上代码很多 wget http://vpn.ximcx.cn/SSR/SSR &amp;&amp; bash SSR 如提示 : wget not found 请先执行：yum install -y wget 五、运行后，会首先提示你输入授权码（yaohuo.me，界面最上方有），然后提示你设置端口（port）和密码（password），端口一般是移动137、138、8080，联通和电信80和8080，具体设置哪个视自己情况而定，设置错了也不要紧，后面有配置多端口方法 七、SSR常用命令 SSR常用命令 启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 卸载（仅限本教程西门吹雪脚本）：wget http://vpn.ximcx.cn/SSR/SSR &amp;&amp; bash SSR uninstall 八、SSR修改密码、配置多端口 *#SSR修改密码、配置多端口教程* 1、输入vi /etc/shadowsocks.json 2、按“i”进入编辑模式，编辑如下 { “server”: “0.0.0.0”, “server_ipv6”: “::”, “local_address”: “127.0.0.1”, “local_port”: 1081, “port_password”:{ “端口1”:”密码1”, “端口2”:”密码2”, “端口3”:”密码3”, “端口4”:”密码4” }, “timeout”: 120, “udp_timeout”: 60, “method”: “chacha20”, “protocol”: “auth_sha1_compatible”, “protocol_param”: “”, “obfs”: “http_simple_compatible”, “obfs_param”: “”, “dns_ipv6”: false, “connect_verbose_info”: 0, “redirect”: “”, “fast_open”: false, “workers”: 1} 3、按esc返回，输入:wq回车保存 4、输入/etc/init.d/shadowsocks restart重启ssr 5、如不能联网，则关闭防火墙（逐条输入） service iptables stop chkconfig iptables off ⑤SSR手机端配置（安卓，IOS作者不熟悉，请自行学习） #SSR软件配置教程 0.进入SSR 1.配置名称随意 2.服务器你的IP 3.远程端口你设置的端口 4.本地端口默认 5.密码你设置的密码 6.加密方法chacha20 7.协议auth-sha1 8.混淆方式http-simple 9.混淆参数填对应运营商免流网址，网上很多 10.点右上角飞机图标 11、让SSR软件保留在后台 12、百度输入“ip”回车 13、如果显示的是你的服务器IP即证明配置成功 14、接下来就是测试免不免流量了，方法是先关闭网络，开关几次飞行模式，5分钟后打开网络按上面的教程连接SSR后进移动app查询流量，然后下载5M左右的文件，再重复开头的方法关网开飞行等5分钟后再查流量，如果流量没少，即证明99%免流成功 15、注意，SSR软件一定要保留在后台运行，不然会扣流量 ⑥SSR提速之锐速（仅支持KVM,Xen,vmare架构） _由于锐速对内核要求严格，所以要先更换内核_ 在锐速ServerSpeeder无限带宽破解版Linux一键自动安装包文章中介绍了如何使用一键包安装锐速，优化服务器网络速度。其实要想在自己的VPS安装锐速，首先内核必须要匹配锐速版本。如果内核不支持安装锐速，我们需要手动修改内核为支持安装锐速版本，不过OpenVZ虚拟技术架设的VPS是无法是无法更换内核，另外并不是所有的XEN和KVM虚拟技术架设的VPS都支持更换内核，像Linode VPS就不支持以下方法修改，需在VPS管理页面修改（Linode VPS如何在管理页面更换内核）。 一、CentOS 6内核更换教程：CentOS 6支持安装锐速的内核：2.6.32-504.3.3.el6.x86_64 1、首先运行下面命令为自己的VPS下载安装内核。 uname -r #查看当前内核版本 rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-2.6.32-504.3.3.el6.x86_64.rpm —force 2、执行命令“rpm -qa | grep kernel”，查看内核是否安装成功。如果显示你安装的内核版本，表示安装成功。 rpm -qa | grep kernel 3、重启VPS，查看内核是否修改成功。 reboot #重启VPS uname -r #当前使用内核版本 二、CentOS 7内核更换教程 CentOS 7支持安装锐速的内核：3.10.0-327.el7.x86_64 1、首先使用下面命令下载及更换内核， rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-3.10.0-229.1.2.el7.x86_64.rpm —force rpm -qa | grep kernel #查看内核是否安装成功 2、重启VPS，查看内核是否修改成功。 reboot #重启VPS uname -r #当前使用内核版本 3、目前Centos 7小问题比较多，锐速针对centos 7的版版本较少。推荐在CentOS 6.中安装。 再安装锐速 wget -N —no-check-certificate https://raw.githubusercontent.com/wn789/serverspeeder/master/serverspeeder.shbash serverspeeder.sh （centos6 64位） wget http://wget.ca/Sh/Serverspeeder/rscentos&amp;&amp;sh rscentos （centos7 64位） wget http://wget.ca/Sh/Serverspeeder/rscentos7&amp;&amp;sh rscentos7 锐速常用命令5、锐速serverspeeder常用命令： service serverSpeeder start #启动service serverSpeeder stop #停止service serverSpeeder reload #重新加载配置service serverSpeeder restart #重启service serverSpeeder status #状态service serverSpeeder stats #统计service serverSpeeder renewLic #更新许可文件service serverSpeeder update #更新chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f #卸载 启动：/serverspeeder/bin/serverSpeeder.sh start 停止：/serverspeeder/bin/serverSpeeder.sh stop 状态：service serverSpeeder status 检查是否有appex0模块：lsmod ⑦SSR提速之BBR（仅支持KVM,Xen,vmare架构，且不可与锐速共存） 使用root用户登录，运行以下命令（逐行运行）： wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh 安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。 重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令： uname -r 查看内核版本，含有 4.9.0 就表示 OK 了 sysctl net.ipv4.tcp_available_congestion_control 返回值一般为： net.ipv4.tcp_available_congestion_control = bbr cubic reno sysctl net.ipv4.tcp_congestion_control 返回值一般为： net.ipv4.tcp_congestion_control = bbr sysctl net.core.default_qdisc 返回值一般为： net.core.default_qdisc = fq lsmod | grep bbr 返回值有 tcp_bbr 模块即说明bbr已启动。 ⑧SSR提速之NetSpeed（支持KVM、OVZ） 这个直接搬砖了，有大神已经写好了教程： https://www.dou-bi.co/netspeeder-jc1/ ⑨SSR提速之KCPTun 仍然直接搬砖： 服务器配置https://www.dou-bi.co/ss-jc36/ 电脑客户端配置https://www.dou-bi.co/ss-jc37/ 安卓客户端配置https://www.dou-bi.co/ss-jc38/ ⑩SSR提速之FinalSpeed（仅支持电脑，不支持手机） 同样直接搬砖 服务器配置https://www.dou-bi.co/ss-jc19/ 客户端配置https://www.dou-bi.co/ss-jc18/ 电脑端局域网内共享给安卓https://www.dou-bi.co/ss-jc21/ ⑪SSR开热点 ROOT或越狱了的手机才能开热点 1、安卓用openvpn工具箱，请自行百度下载，开热点步骤如下 openvpn工具箱开热点教程 一、先打开热点，让其他设备连上你的热点 二、打开openvpn工具箱 三、点VPN共享向导 四、点通用模式 五、点起点 六、搞定，接着在连接你热点的设备上百度输入“IP”,如果显示的是你的服务器IP，那就没错了 七、如果不能正常上网，就需要设置静态IP，方法就是打开对方设备的WiFi高级设置，IP设为192.168.43.2-255，子网掩码255.255.255.0，网关192.168.43.1，DNS8.8.8.8，然后就可以正常连接了（PS，也可以用路由器中继热点，在路由器里同样按以上静态IP方法设置，路由器中继的好处就是设备可以随连随上、发射信号更远更强） 2、IOS添加雷锋源下载TETHERME插件，由于作者没用过，所以请自行学习，听说很简单，安装后点开启即可 第三部分：抓包（端口和混淆参数）_作者一直用移动，不熟悉联通和电信，不过三网原理都一样，熟悉了后自然可以举一反三_ SSR免流靠混淆参数和端口(没有的话就只能光fan qiang用了) 混淆参数，就是免流网址，就是host，其实能免的host几乎都能在网上找到，不过还是自己学会怎么抓比较好，万一哪天就抓到了新的host了呢。作者常用的抓包软件有两个，一个是wi.cap，一个是packet capture，但是wi.cap需要root和xp框架，要求比较高，所以本教程只介绍不用root也不用框架的packet capture #packet capture抓包教程 1、首先安装packet capture，可以百度，也可以去我分享的百度链接里下载 2、关闭所有联网软件，打开手机网络（net和wap都可以试下） 3、打开packet capture 4、点击上方绿色三角形按钮 5、打开要抓包的软件（免流量软件，比如掌厅、咪咕、沃TV等），随便操作软件，尽可能多操作几次 6、返回packet capture 7、点进去上方日期、时间命名的标题栏 8、找到Host字样的信息，那就是混淆参数，如下图 #端口 以前137、138基本可免全国移动，现在和谐的差不多了，基本只有8080可用（有的host也可以用80和443），怎么确认一个host打开了哪些端口呢？最简单的自然是用站长工具，当然，老司机可以用各种扫端口软件，比如安卓软件IPScanner就不错，支持自定义端口范围、逐个扫描 站长工具-端口扫描http://tool.chinaz.com/port/，用法很简单，具体如下图 ④你用哪个远程端口，对应的混淆参数一定要打开这个端口，不然99%不会免，抓到host后扫描下host开了哪些端口，然后就剩测试了。 好了，本教程到此结束，祝各位小伙伴早日用上SSR免流。 yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh #宝塔安装]]></content>
      <categories>
        <category>工具_etc</category>
      </categories>
      <tags>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期工作反思]]></title>
    <url>%2Fpost%2F2326e2a0.html</url>
    <content type="text"><![CDATA[首先自己的 计划并没有按时跟进！静心 此视频课可以自己跟着 码出一片技术文档来，会使用即可.VUE 6级单词跟进 JSP连接数据库 加 自我扩展学习！mysql / servlet 导师制检查！编译原理 文法分析。]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NODE_GCC6.1.0安装更新+问题解决+Vue.js之中学习进度记录]]></title>
    <url>%2Fpost%2F46f00fc9.html</url>
    <content type="text"><![CDATA[课本到了第八章：过渡（动画）第九章：Methods 第十章：Vue实例方法 第十一章：组件 第十二章：表单校验 第十三章：与服务端通信 第十四章：陆游与视图 第十五章： vue-cli 所以在进行到 第九章的时候：看了第三讲！！！完成第三讲！第二讲！ 目前视频中直接用的 vuejs 1.0 bower -&gt; (前端)包管理器 npm install node.js安装： 基于centeos _下载：_ https://nodejs.org/en/download/ http://ftp.gnu.org/gnu/gcc/ http://www.runoob.com/nodejs/nodejs-install-setup.html _vuejs 中文官方文档：_ https://cn.vuejs.org/v2/guide/transitions.html === make[1]: [/usr/local/src/node-v6.11.4/out/Release/obj.target/v8_base/deps/v8/src/accessors.o] Error 1 make[1]: Leaving directory `/usr/local/src/node-v6.11.4/out’ make: [node] Error 2 其中出现两个错误！ —centos 6.5安装更新 G++/GCC —-恢复内容开始—- CentOS 6.6 升级GCC G++ (当前最新GCC/G++版本为v6.1.0) 没有便捷方式, yum update…. yum install 或者 添加yum 的 repo 文件 也不行, 只能更新到 4.4.7! then, 只能手动编译安装了,那么开始第一步下载源代码吧,GO! 1、 获取安装包并解压 wget http://ftp.gnu.org/gnu/gcc/gcc-6.1.0/gcc-6.1.0.tar.bz2 tar -jxvf gcc-6.1.0.tar.bz2 当然，http://ftp.gnu.org/gnu/gcc 里面有所有的gcc版本供下载，最新版本已经有6.1.0啦. 建议下载.bz2的压缩包,文件更小,下载时间更少. 2、 下载供编译需求的依赖项 参考文献[1]中说：这个神奇的脚本文件会帮我们下载、配置、安装依赖库，可以节约我们大量的时间和精力。 cd gcc-6.1.0 ./contrib/download_prerequisites 3、 建立一个目录供编译出的文件存放 mkdir gcc-build-6.1.0 cd gcc-build-6.1.0 4、 生成**Makefile**文件 ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib 5、 编译 make -j4 -j4选项是make对多核处理器的优化，如果不成功请使用 _make_，(进行单核处理)相关优化选项可以移步至参考文献[2]。 （注意：此步骤非常耗时,我虚拟机耗时近3小时; 实体机近80分钟,CPU基本是满的,内存也使用不少） 注意make的-j选项可以指定同时运行的作业数量，即CPU核数，如果有4核则可以加上-j4 出错解决1.make过程中可能会出现以下错误信息： build/genattrtab ../.././gcc/config/i386/i386.md insn-conditions.md \ -Atmp-attrtab.c -Dtmp-dfatab.c -Ltmp-latencytab.cmake[3]: [s-attrtab] Killedmake[3]: Leaving directory `/usr/src/gcc-4.9.2/host-x86_64-unknown-linux-gnu/gcc’make[2]: [all-stage1-gcc] Error 2make[2]: Leaving directory /usr/src/gcc-4.9.2&#39; make\[1\]: *** \[stage1-bubble\] Error 2 make\[1\]: Leaving directory/usr/src/gcc-4.9.2’make: * [all] Error 2 可以通过添加swap分区的方法解决： http://blog.csdn.net/qq_20480611/article/details/52144399 2.动态库libstdc++.so.6版本不匹配 可以正常编译程序，但是运行时出现以下问题： /usr/lib/libstdc++.so.6: version `GLIBCXX_3.4.15’ not found 添加LD_LIBRARY_PATH环境变量即可解决： # vim ~/.bash_profileexport LD_LIBRARY_PATH=/usr/local/lib:/usr/lib:/usr/local/lib64:/usr/lib64# source ~/.bash_profile GCC新特征GCC 6.1 发布了，该版本较之前GCC5 新怎了大量的功能特性，默认采用C++14为新的标准，替代了之前的C++98。OpenMP 4.5规范将在本版本中被支持。此外，GCC 6.1 增强了对 C++17 的试验性支持；大大改进了诊断特性，包括位置，位置范围，拼写错误标识符建议，选项名字等等改进；新增了修复提示和一些警告提示。改进记录如下： UndefinedBehaviorSanitizer gained a new sanitization option, -fsanitize=bounds-strict, which enables strict checking of array bounds. In particular, it enables -fsanitize=bounds as well as instrumentation of flexible array member-like arrays. Type-based alias analysis now disambiguates accesses to different pointers. This improves precision of the alias oracle by about 20-30% on higher-level C++ programs. Programs doing invalid type punning of pointer types may now need -fno-strict-aliasing to work correctly. Alias analysis now correctly supports weakref and alias attributes. This makes it possible to access both a variable and its alias in one translation unit which is common with link-time optimization. Value range propagation now assumes that the this pointer of C++ member functions is non-null. This eliminates common null pointer checks but also breaks some non-conforming code-bases (such as Qt-5, Chromium, KDevelop). As a temporary work-around-fno-delete-null-pointer-checks can be used. Wrong code can be identified by using-fsanitize=undefined. 完整发布说明，可以在这里查看。 参考文章CentOS下安装gcc-4.9.2 centos6.5安装gcc6.1等c++环境 https://gcc.gnu.org/onlinedocs/libstdc++/faq.html#faq.how_to_set_paths （CSDN的Markdown不好用） 6、 安装make install (安装需要root权限!) 查看安装 ls /usr/local/bin | grep gcc 7、 重启，然后查看gcc版本gcc -v 8、 写个C++11 特性的程序段 测试tryCpp11.cc 代码省略…. g++ -std=c++11 -o tryCpp11 tryCpp11.cc 9、升级gcc，生成的动态库没有替换老版本gcc的动态库 源码编译升级安装了gcc后，编译程序或运行其它程序时，有时会出现类似/usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21&#39; not found的问题。这是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库导致的，将gcc最新版本的动态库替换系统中老版本的动态库即可解决。 9.1 运行以下命令检查动态库： strings /usr/lib64/libstdc++.so.6 | grep GLIBC 从输出可以看出，gcc的动态库还是旧版本的。说明出现这些问题，是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库。 9.2 执行以下命令，查找编译gcc时生成的最新动态库： find / -name “libstdc++.so*” 将上面的最新动态库libstdc++.so.6.0.22复制到/usr/lib64目录下 cd /usr/lib64 cp /root/Downloads/gcc-6.1.0/gcc-build-6.1.0/stage1-x86_64-pc-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so.6.0.22 ./ 9.3 删除原来软连接： rm -rf libstdc++.so.6 9.4 将默认库的软连接指向最新动态库： ln -s libstdc++.so.6.0.22 libstdc++.so.6 9.5 默认动态库升级完成。重新运行以下命令检查动态库： strings /usr/lib64/libstdc++.so.6 | grep GLIBC 可以看到 输出有”GLIBCXX_3.4.21” 了 [注:摘抄自http://www.linuxidc.com/Linux/2015-01/112595.htm, http://itbilu.com/linux/management/NymXRUieg.html, _原作者编译有出错过,但是我编译没有出错过_] [参考1:http://www.tuicool.com/articles/FVN7jez\] [参考2:http://blog.chinaunix.net/uid-14735472-id-5546560.html\] 10.新的主题（npm下安装node.js）参考：【1】http://blog.csdn.net/haoaiqian/article/details/72453286 【2】http://blog.csdn.net/sinat_29412671/article/details/53690658 【3】http://www.runoob.com/vue2/vue-install.html 一、开发环境 vue推荐开发环境: Node.js: javascript运行环境(runtime),不同系统直接运行各种编程语言 npm: Nodejs下的包管理器。 webpack: 它主要的用途是通过 CommonJS 的语法把所有浏览器端需要发布的静态资源做相应的准备，比如资源的合并和打包。 vue-cli: 用户生成Vue工程模板 二、环境搭建 安装node.js： 1. 从node.js官网下载并安装node，安装过程很简单。 2. npm 版本需要大于 3.0，如果低于此版本需要升级它： # 查看版本$ npm -v2.3.0 升级 npmcnpm install npm -g 3.基于node.js,利用淘宝npm镜像安装相关依赖。由于国内使用npm会很慢,这里推荐使用淘宝NPM镜像（http://npm.taobao.org/） $ npm install -g cnpm —registry=https://registry.npm.taobao.org 完成之后，我们就可以用cnpm代替npm来安装依赖包了。 三、安装vue-cli脚手架构建工具 安装全局vue-cli脚手架,用于帮助搭建所需的模板框架 $ cnpm install -g vue-cli# 回车，等待安装…$ vue# 回车，若出现vue信息说明表示成功 四、用vue-cli构建项目 # 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 这里需要进行一些配置，默认回车即可This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 my-project? Project name my-project? Project description A Vue.js project? Author runoob &#x74;&#101;&#115;&#116;&#x40;&#x72;&#117;&#x6e;&#111;&#111;&#98;&#x2e;&#x63;&#x6f;&#x6d;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated “my-project”. To get started: cd my-project npm install npm run devDocumentation can be found at https://vuejs-templates.github.io/webpack 五、安装依赖 在cmd里 1).输入：cd my-project（项目名），回车，进入到具体项目文件夹2).输入：cnpm install，回车，等待一小会儿 回到项目文件夹，会发现项目结构里，多了一个node_modules文件夹（该文件里的内容就是之前安装的依赖） 六、测试环境是否搭建成功 方法1：在cmd里输入：npm run dev 方法2：在浏览里输入：localhost:8080(默认端口为8080) 解决在 make当中出错的问题：由于temp 分区过小：根据Redhat公司的建议,Linux系统swap分区最适合的大小是物理内存的1-2倍.不过Linux上有些软件对swap分区得需求较大,例如要顺利执行Oracle数据库软件,swap分区至少需要400MB或者物理内存2倍以上的空间.当然我们在安装Linux的时候,就能直接讲swap分区设置到足够的大小,但如果已经安装好Linux了,之后又想再安装类似Oracle的软件,却发现swap分区空间不够,该如何处理? 针对此种情况,有两种解决方法:一是创建新的swap分区;另一则是创建swap文件. 点此查看如何创建新分区 下面介绍创建swap文件的过程： 如果你的硬盘空间已经全部分配给其他分区,也没有多余的预算新添购硬盘,我们可以利用swap文件的方式增加虚拟的swap空间,不过执行性能会较实际的swap分区差. 产生swap文件执行dd命令新增一个1G的swap文件： # dd if=/dev/zero of=/opt/swapfile bs=1M count=1000 更多关于dd命令的解释请参考man手册man dd 格式化swap文件接下来执行mkswap命令,将myswap文件格式化成swap文件系统： 注意 我的在 /opt/swapfile 下面有1G的空间！ 下面的的 /tmp/myswap 全部修改为 /opt/swapfile # mkswap /tmp/myswap 使能swap文件执行swapon命令可以使能myswap文件为swap分区，对应的执行swapoff命令可以关闭这种效果： # swapon /tmp/myswap 此时可以通过 free -h 查看内存使用情况及swap分区 自动挂载编辑/etc/fstab文件，添加开机使能swap文件项： # vim /tmp/myswap/tmp/myswap swap swap defaults 0 0 # 待添加的行 最后执行以下命令自动挂载所有在fstab中的文件系统 # mount -a]]></content>
      <categories>
        <category>JS</category>
        <category>VUEJS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSP中关于中文编码的解释]]></title>
    <url>%2Fpost%2F32060da8.html</url>
    <content type="text"><![CDATA[前言：注意使用 bean的时候对于中文的处理：equals 要提前处理（因为 bean里面String已经转换为gb2312了！） jsp中的contentType与pageEncoding的区别和作用 &lt;%@ page contentType=”text/html; charset=utf-8” pageEncoding=”utf-8”%&gt; pageEncoding是jsp文件本身的编码 contentType的charset是指服务器发送给客户端时的内容编码 关于JSP页面中的pageEncoding和contentType两种属性的区别： pageEncoding是jsp文件本身的编码 contentType的charset是指服务器发送给客户端时的内容编码 JSP要经过两次的“编码”，第一阶 段会用pageEncoding，第二阶段会用utf-8至utf-8，第三阶段就是由Tomcat出来的网页， 用的是contentType。 第一阶段是jsp编译成.java，它会根据pageEncoding的设定读取jsp，结果是由指定的编码方案翻译成统一的UTF-8 JAVA源码（即.java），如果pageEncoding设定错了，或没有设定，出来的就是中文乱码。 第二阶段是由JAVAC的JAVA源码至java byteCode的编译，不论JSP编写时候用的是什么编码方案，经过这个阶段的结果全部是UTF-8的encoding的java源码。 JAVAC用UTF-8的encoding读取java源码，编译成UTF-8 encoding的二进制码（即.class），这是JVM对常数字串在二进制码（java encoding）内表达的规范。 第三阶段是Tomcat（或其的application container）载入和执行阶段二的来的JAVA二进制码，输出的结果，也就是在客户端见到的，这时隐藏在阶段一和阶段二的参数contentType就发挥了功效 contentType的設定. pageEncoding 和contentType的预设都是 ISO-8859-1. 而随便设定了其中一个, 另一个就跟着一样了(TOMCAT4.1.27是如此). 但这不是绝对的, 这要看各自JSPC的处理方式. 而pageEncoding不等于contentType, 更有利亚洲区的文字 CJKV系JSP网页的开发和展示, (例pageEncoding=GB2312 不等于 contentType=utf-8)。 jsp文件不像.java，.java在被编译器读入的时候默认采用的是操作系统所设定的locale所对应的编码，比如中国大陆就是GBK，台湾就是BIG5或者MS950。而一般我们不管是在记事本还是在ue中写代码，如果没有经过特别转码的话，写出来的都是本地编码格式的内容。所以编译器采用的方法刚好可以让虚拟机得到正确的资料。 但是jsp文件不是这样，它没有这个默认转码过程，但是指定了pageEncoding就可以实现正确转码了。 _注意所以说 这个是后转码的！！！根据我们写的头文件！_ 举个例子: &lt;%@ page contentType=”text/html;charset=utf-8” %&gt; 大都会打印出乱码，因为我输入的“你好吗”是gbk的，但是服务器是否正确抓到“你好吗”不得而知。 但是如果更改为 &lt;%@ page contentType=”text/html;charset=utf-8” pageEncoding=”GBK”%&gt; 这样就服务器一定会是_正确抓到_“你好吗”了。 举个例子： 最近在学JSP，在学习处理get方式提交数据出现乱码问题的时候，对其中的一个解决方法new String(s.getBytes(“iso-8859-1”),”utf-8”);产生了疑问，就是为什么要使用s.getBytes(“iso-8859-1”)？ 当时只这样想的：客户端向服务器发送一个请求，比如说是一个字符串”请求”；之后服务器接收到这个请求，也就是这个字符串，可是这时由于某种原因出现了乱码！这时为了解决这个问题，使用new String(s.getBytes(“iso-8859-1”),”utf-8”);解决问题。看到这条语句，我感觉想不通啊，字符使用iso-8859-1编码取得字节序列，再由utf-8解码取得字符串，得到的还是乱码啊！怎么会取得正确的字符呢！！！想不通啊！ 之后，通过查找资料，得到了一点想法，代码如下： public class ThinkIng { public static void main(String[] args) throws Exception { System.out.println(“\\t———JSP模拟———“); System.out.println(“客户端，有一个中文字符的请求(转换成了字节序列发送)，发送至服务器端”); String request=”请求”; byte[] client=request.getBytes();//客户端的请求的字节序列 print(client); System.out.println();//分割用的 System.out.println(“有一中间件，将发送的字符序列一默认的编码格式(iso-8859-1)进行解码”); String sever=new String(client,”iso-8859-1”); System.out.println(sever); System.out.println(“程序猿发现，这边有问题，中文有乱码，前来解决！”); String debug=new String(sever.getBytes(“iso-8859-1”),”gbk”);//还原字节序列，使用“gbk”重新进行解码！ System.out.println(debug); System.out.println(“问题解决！”); } public static void print(byte[] b){//用于显示字节序列的 for(byte b1:b){ System.out.print(Integer.toHexString(b1 &amp; 0xff)+” “); } }}----------———JSP模拟———客户端，有一个中文字符的请求(转换成了字节序列发送)，发送至服务器端c7 eb c7 f3有一中间件，将发送的字符序列一默认的编码格式(iso-8859-1)进行解码???ó程序猿发现，这边有问题，中文有乱码，前来解决！请求问题解决！ 先前没有想通主要是自己没注意到： 没有着重的想为什么会在输出时出现字符乱码？ 客户端发送求时，字符转换成字节序列时的编码方式是什么样的？ 总的来说，乱码是由于编码方式与解码方式不一致导致的，这一句话没有理解透！如果当时这样想既然出现了乱码，肯定是那边的编码格式和解码格式不一致，就好了！ 注：编码：将字符串转换成字节序列；解码：将字节序列转换成字符串 感谢：http://liguocai2009.iteye.com/blog/1602256,”GBK”)的实质”)这篇文章给我的启发！]]></content>
      <categories>
        <category>JSP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSP编码_applicationETC报错信息The superclass "javax.servlet.http.HttpServlet" was not found on the Java Build Path]]></title>
    <url>%2Fpost%2Ffbff6d04.html</url>
    <content type="text"><![CDATA[pageEncoding jsp 文件本身的代码 contentType charset 是指服务器发送给客户端时的内容编码 1.Application对象 Application用于保存所有用户的公共的数据信息,如果使用Application对象,一个需要考虑的问题是任何写操作都要在 Application_OnStart事件(global.asax)中完成.尽管使用Application.Lock和Applicaiton.Unlock方法来避免写操作的同步,但是 它串行化了对Application对象的请求,当网站访问量大的时候会产生严重的性能瓶颈.因此最好不要用此对象保存大的数据集合 2.Session对象 Session用于保存每个用户的专用信息.她的生存期是用户持续请求时间再加上一段时间(一般是20分钟左右).Session中的信息 保存在Web服务器内容中,保存的数据量可大可小.当Session超时或被关闭时将自动释放保存的数据信息.由于用户停止使用应用程 序后它仍然在内存中保持一段时间,因此使用Session对象使保存用户数据的方法效率很低.对于小量的数据,使用Session对象保存 还是一个不错的选择.使用Session对象保存信息的代码如下: //存放信息 Session[“username”]=”zhouhuan”; //读取数据 string UserName=Session[“username”].ToString(); — application全局变量,session是会话变量，比如说：（1）session：声明一个session变量。打开一个网站，session就存在了， 更换页，只要是这个网站的页，session始终存在，当关闭这个网站的时候，session就结束了，这叫会话变量。。。(2) application:声明一个application变量。不关你前台有多少客户打开该网站的页，有多少客户关闭该网站的页，只要服务器端不 关闭该网站，application始终存在。 http://www.cnblogs.com/an5211/p/6635607.html JavaWeb: 报错信息The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path好久不写Jsp，今天建立了一个Javaweb工程，并在eclipse中配置了Web容器Tomcat。原本开心的新建jsp页面，添加一个简单的Java类。可是，JSP页面顶端出现“红色”的报错信息：The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path。原来Javaweb工程类中没有添加Tomcat运行时相关类导致。 下面是具体的解决方法： 1、右击web工程-》属性或Build Path-》Java Build Path-&gt;Libraries-&gt; Add Libray…-&gt;Server Runtime -》Tomcat Server 2、切换到Java Build Path界面中的Orader and Export，选择Tomcat。 注意： 按以上方法操作时，若打开Server Runtime后一片空白，需要设置Apache服务器。设置方法为：window-&gt;Preferences-&gt;Server-&gt;Runtime Environment -&gt; add —&gt; 选择Apache的版本后点Next，再填入你apache服务器软件的安装（解压后）地址。]]></content>
      <categories>
        <category>JSP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GitHub入门全笔记_图片截图见百度云或附件]]></title>
    <url>%2Fpost%2F7311ad8b.html</url>
    <content type="text"><![CDATA[玩转Git 和 GitHub Git 工具、版本控制 github 网站、社交平台、开源项目、远程仓库 svn是集中式（有一台集中式服务器上进行存储） Git 是分布式的！直接克隆版本开发项目；不需要连接服务器、本地就有直接进行开发进行！ # Next 分支进行开发。Next版本库 开发稳定之后 与主分支合并！ 是主分支！ 暂存区：防止 误操作；暂时未开发完成-随时保存0-放在放在暂存区里面！ 保护工作区和版本区 ； 分支处理 #注意 红的是工作区！ 绿色的是 经过add 到暂存区的！ 工作区/修改/删除 命令： Git status . git commit git add 可以连这些： git commit -m “change js” git commit -a -m “js” //”” 日志文件 -a//可以直接跳过add（跳过暂存区） 到达版本库 -m//写上注释 ———第四节 工作区和 暂存区文件的差异对比 //git diff 暂存区与 版本区的对比 //git diff –cached(—staged) //英文 staged 表示暂存区 那么 工作区与版本库对比：git diff master ###第五节： 关于撤销 git reset HEAD drag.js //从暂存区还原回 工作区~！ 根据提示有：git checkout — &lt; file.name&gt; //可以 首先从 暂存区检查还原、再从版本库区检查还原！ Git command amend// 自己提交错误！ git commit -m “change3 drag.js and demo1,html” —amend //注意 commit 还原到暂存区并且与 暂存区的文件 一起上传到。版本区。 ###第六讲： 删除与恢复命令： Git rm test.txt //工作区删除文件 对应手动删除 暂存区的文件！ -f //会删除全部的 暂存区+工作区（文件夹中的文件）。 —cached //只会删除 暂存区的文件，工作取得保存 ——-恢复操作： 注意 ： 在 git log //commit 后面的一串代码显示的是 可以恢复时间的 ID 04eae77462c55e7b97b27 git checkout 04eae77462c55e7b97b27 drag.js //还原 log 中某一个文件的 某一个时间的恢复 —-恢复全部文件：git reset —hard 04eae77462c55e7b97b27 //直接从版本中恢复！ —zhuyi HEAD 向上 未来。向下 过去版本。 //回到过去的版本： Git reset –hard HEAD^ //向下走 回到过去版本 Git reset —hard HEAD~2 //向下走 两个 还原到过去的版本。 //虽然 log 减少了 。但是 git reflog 可以继续向前恢复！ Git reflog //包含所有 log ，并且 不操作这个 的日志！ Gut reset –hard (reflog 中的号码！) ###第八讲 远程登录 github 多人协作 因为我们之前开发都是在本地的！所以 远程仓库的git.com 上面没有我们的信息！ Git remote //远程仓库的名字 Git remote -v //所对应远程仓库的地址！ git push origin master //远程仓库对应的 master 分支“因为目前就只有一个主分支！” ——分配权限 ###第九讲 解决多人协作冲突！ 多人协作之前 希望能先进行同步更新！防止 出现交叉使用！ Git fetch 从远端拉取代码 查看冲突的原因！ Git merge origin/master Git pull 远端拉起代码 并且进行代码合并！ ### 第十讲 进行 fork / pull request 点击 项目的 fork 可以拷贝到咱们的git下面。 再 点击网站上的 pull request(右边！ ###第十一讲 Git 下面的分支处理！ *master 显示为当前选中的分支！ Git branch new1 //新建了一个分支！ Master/new1 其实他们都是分支！-》指示了 当前版本的 指针！ Git checkout new1 //切换分支 Git checkout -b new1 // -b branch 的简写！ //简便 创建分支并改变选中分支，上图一样 就换了分支与旧的分支没有关系了！ #进行 new1 与 master 的快速合并！： Git merge new1 //master 状态下！ 快速的合并方式 即使得master与new1快速合并———master的指针进行了移动! $ git branch —merged //查看下面合并了的分支！ * master new1 // $ git branch —no-merged //没有合并的 分支 不能用 git branch -d new2!！! new2 //但是可以通过 使用 git branch -D new2 强制进行删除的操作！ ———————看一下 有冲突的分支如何解决！ 所以 会在编辑器上显示出来。进行人为的解决 再进行一次 认为 commit ###第十三讲 提交分支 Git push origin new1 //在git 网站上通过切换就可以看到啦！ 在 git 上可以新创建！ 而且可以在 git上直接删除分支！或恢复！ #Releases 打标签//里程碑！ 开发一段时间 打包一个版本！也是可以防止丢失 $ git tag acanprince@DESKTOP-DHMHC68 MINGW64 /g/Movie/2017_第一学期_奋战/Git/testGit/test_login (master) $ git tag v1.0 acanprince@DESKTOP-DHMHC68 MINGW64 /g/Movie/2017_第一学期_奋战/Git/testGit/test_login (master) $ git tag v1.0 watch //关注 有新的动态在主页上有提示！ Star//点赞 fork//镜像分支类似 ####14 讲 —组织 github.com/miaovclass —博客 也可以用自己的域名！ Repository 仓库 organization//组织 New repository 下面 名字和自己一样！ //AclearZhang.github.io http://aclearzhang.github.io/ ###第十五讲 深入/总结 偏 功能性的 工具性的！ 所以 最好深入到某一个项目当中去！因为工具就应该是一个 实践的项目！ 如何深入？ 技巧？ Cd ls notepad hello.txt 资源？ Tab 键也是可以进行补偿！ Git config –global alias.co checkout //checkout 用 co 来进行代表输入！ Git config –list 资源：1. git.oschina.net/progit/ 2.www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 ——————-都要在 项目实战中 继续加深啊！]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【转】学习笔记]]></title>
    <url>%2Fpost%2F8a4ec677.html</url>
    <content type="text"><![CDATA[Github上的watch、star和fork分别是什么意思呢？ 1、watch可以用来设置接收邮件提醒 2、如果想持续关注该项目就star一下 3、如果想将项目拷贝一份到自己的账号下就fork fork就相当于在原本的项目分支上建立一个分支，这个分支属于你自己，你也可以任意修改。如果想将你修改后的代码整合到原有的项目中，需要做pull request操作，当然这得经过作者同意。 有三种方法： 第一种就是 把你同学的 公钥加到你项目的公钥 第二种建一个组织，然后建一个team 把你同学加到team 然后把项目放到team下 第三种就是你同学fork 然后给你发 pull request 推荐第三种方式 转载学习 大约 4 年 ago Git 筆記 - Github 多人合作(設定)CollaboratorsCollaborators適用於一個team之間的合作。 負責開這個repository的人，進入settings，加入collaborators的帳號 【修改】 新版本网站（2017.09.25）多人协作入口.： 這樣所有collaborators名單中的人，在git push的時候，可以輸入自己的帳密，而不是擁有repository人的帳密。 流程會像這樣：A擁有repository，想要B也能更新自己的repository，就把B加入collaborators， 這樣B要一起合做這份code的時候，先按照前一篇的流程設定 B初始化的時候， 注意clone URL 是 A 的 repo 的 clone URL， 然後B就可以在自己的本機盡情修改code (用branch、commit、merge) 最後在push的時候輸入B自己的帳密， 會更新A的repository(A仍就可以繼續更新自己的repository) 但B自己的github帳戶並不會有一份和A相同的repository(只會有A的repo連結) Fork &amp; Pull request另外還有另外一種多人合作方式是 Fork &amp; Pull request 情境像是 A 擁有一個repo a，B看到覺得還不錯 所以就fork一個到自己的repo中，這裡叫做b (雖然a,b實際上名字一樣，不過用a,b稱呼比較容易搞懂) 以下圖中 A 對應到 MarsW ； B 對應到 MarsWeng Then,就如同以往按照流程，初始clone自己的repo b下來， 然後B就可以盡情修改code(branch、commit、merge、push)， 每次 B push更新repo，都只會更新自己的repo b，並不會影響到A的repo a 如果哪天B覺得自己寫的功能很不錯，可以幫助到A，想跟A分享 那就可以發一個pull request，問問A想不想要這一份 A 那邊就會收到這則 pull request， 如果覺得ok，用線上merge，就會將repo b合併到repo a上 (Collaborators也有能merge的權限) 或是覺得有問題，就可以用comment討論]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Eclipse关于JSP中:html,css,js,jsp单独编辑情况下代码提示问题]]></title>
    <url>%2Fpost%2Fe3ac8250.html</url>
    <content type="text"><![CDATA[1.配置完成后，重启eclipse，在window-preference-general-editors里面可以配置js等的编辑工具采用什么，选择aptana的编辑工具，然后设置为default，到此就可以采用aptana插件了，这里面你在使用的时候一定要注意插件的版本和eclipse的版本，不然可能出现插件安装失败和插件安装不成功的情况 *.css添加上即可 有css代码提示 2.注意有关于 在Eclipse或者 MyEclipse当中，request/response等函数点点出不了代码提示。因为并没有吧lib/或者runtime-tomcat加载进来。解决： —————————————————————————————————————————————————— 选中项目—&gt;properties—&gt;Targeted Runtimes—&gt;在右边窗口中选择你使用的服务器即可]]></content>
      <categories>
        <category>JSP</category>
        <category>工具_etc</category>
        <category>计算机基础--安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSP中发生的几种网页类型的错误.]]></title>
    <url>%2Fpost%2F3b6b40d9.html</url>
    <content type="text"><![CDATA[原来，全部在HttpServletResponse接口的字段里 IIS状态代码的含义 概要 当用户试图通过HTTP或文件传输协议(FTP)访问一台正在运行Internet信息服务(IIS)的服务器上的内容时，IIS返回一个表示该请求的状态的数字代码。该状态代码记录在IIS日志中，同时也可能在Web浏览器或FTP客户端显示。状态代码可以指明具体请求是否已成功，还可以揭示请求失败的确切原因。 更多信息 日志文件的位置 在默认状态下，IIS把它的日志文件放在%WINDIR\\System32\\Logfiles文件夹中。每个万维网(WWW)站点和FTP站点在该目录下都有一个单独的目录。在默认状态下，每天都会在这些目录下创建日志文件，并用日期给日志文件命名（例如，exYYMMDD.log）。 HTTP 1xx-信息提示 这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个1xx响应。 100-继续。 101-切换协议。 2xx-成功 这类状态代码表明服务器成功地接受了客户端请求。 200-确定。客户端请求已成功。 201-已创建。 202-已接受。 203-非权威性信息。 204-无内容。 205-重置内容。 206-部分内容。 3xx-重定向 客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。 301-对象已永久移走，即永久重定向。 302-对象已临时移动。 304-未修改。 307-临时重定向。 4xx-客户端错误 发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。400-错误的请求。 401-访问被拒绝。IIS定义了许多不同的401错误，它们指明更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在IIS日志中显示： 401.1-登录失败。 401.2-服务器配置导致登录失败。 401.3-由于ACL对资源的限制而未获得授权。 401.4-筛选器授权失败。 401.5-ISAPI/CGI应用程序授权失败。 401.7–访问被Web服务器上的URL授权策略拒绝。这个错误代码为IIS6.0所专用。 403-禁止访问：IIS定义了许多不同的403错误，它们指明更为具体的错误原因： 403.1-执行访问被禁止。 403.2-读访问被禁止。 403.3-写访问被禁止。 403.4-要求SSL。 403.5-要求SSL128。 403.6-IP地址被拒绝。 403.7-要求客户端证书。 403.8-站点访问被拒绝。 403.9-用户数过多。 403.10-配置无效。 403.11-密码更改。 403.12-拒绝访问映射表。 403.13-客户端证书被吊销。 403.14-拒绝目录列表。 403.15-超出客户端访问许可。 403.16-客户端证书不受信任或无效。 403.17-客户端证书已过期或尚未生效。 403.18-在当前的应用程序池中不能执行所请求的URL。这个错误代码为IIS6.0所专用。 403.19-不能为这个应用程序池中的客户端执行CGI。这个错误代码为IIS6.0所专用。 403.20-Passport登录失败。这个错误代码为IIS6.0所专用。 404-未找到。 404.0-（无）–没有找到文件或目录。 404.1-无法在所请求的端口上访问Web站点。 404.2-Web服务扩展锁定策略阻止本请求。 404.3-MIME映射策略阻止本请求。 405-用来访问本页面的HTTP谓词不被允许（方法不被允许） 406-客户端浏览器不接受所请求页面的MIME类型。 407-要求进行代理身份验证。 412-前提条件失败。 413–请求实体太大。 414-请求URI太长。 415–不支持的媒体类型。 416–所请求的范围无法满足。 417–执行失败。 423–锁定的错误。 5xx-服务器错误 服务器由于遇到错误而不能完成该请求。 500-内部服务器错误。 500.12-应用程序正忙于在Web服务器上重新启动。 500.13-Web服务器太忙。 500.15-不允许直接请求Global.asa。 500.16–UNC授权凭据不正确。这个错误代码为IIS6.0所专用。 500.18–URL授权存储不能打开。这个错误代码为IIS6.0所专用。 500.100-内部ASP错误。 501-页眉值指定了未实现的配置。 502-Web服务器用作网关或代理服务器时收到了无效响应。 502.1-CGI应用程序超时。 502.2-CGI应用程序出错。application. 503-服务不可用。这个错误代码为IIS6.0所专用。 504-网关超时。 505-HTTP版本不受支持。 FTP 1xx-肯定的初步答复 这些状态代码指示一项操作已经成功开始，但客户端希望在继续操作新命令前得到另一个答复。 110重新启动标记答复。 120服务已就绪，在nnn分钟后开始。 125数据连接已打开，正在开始传输。 150文件状态正常，准备打开数据连接。 2xx-肯定的完成答复 一项操作已经成功完成。客户端可以执行新命令。200命令确定。 202未执行命令，站点上的命令过多。 211系统状态，或系统帮助答复。 212目录状态。 213文件状态。 214帮助消息。 215NAME系统类型，其中，NAME是AssignedNumbers文档中所列的正式系统名称。 220服务就绪，可以执行新用户的请求。 221服务关闭控制连接。如果适当，请注销。 225数据连接打开，没有进行中的传输。 226关闭数据连接。请求的文件操作已成功（例如，传输文件或放弃文件）。 227进入被动模式(h1,h2,h3,h4,p1,p2)。 230用户已登录，继续进行。 250请求的文件操作正确，已完成。 257已创建“PATHNAME”。 3xx-肯定的中间答复 该命令已成功，但服务器需要更多来自客户端的信息以完成对请求的处理。331用户名正确，需要密码。 332需要登录帐户。 350请求的文件操作正在等待进一步的信息。 4xx-瞬态否定的完成答复 该命令不成功，但错误是暂时的。如果客户端重试命令，可能会执行成功。421服务不可用，正在关闭控制连接。如果服务确定它必须关闭，将向任何命令发送这一应答。 425无法打开数据连接。 426Connectionclosed;transferaborted. 450未执行请求的文件操作。文件不可用（例如，文件繁忙）。 451请求的操作异常终止：正在处理本地错误。 452未执行请求的操作。系统存储空间不够。 5xx-永久性否定的完成答复 该命令不成功，错误是永久性的。如果客户端重试命令，将再次出现同样的错误。500语法错误，命令无法识别。这可能包括诸如命令行太长之类的错误。 501在参数中有语法错误。 502未执行命令。 503错误的命令序列。 504未执行该参数的命令。 530未登录。 532存储文件需要帐户。 550未执行请求的操作。文件不可用（例如，未找到文件，没有访问权限）。 551请求的操作异常终止：未知的页面类型。 552请求的文件操作异常终止：超出存储分配（对于当前目录或数据集）。 553未执行请求的操作。不允许的文件名。 常见的FTP状态代码及其原因 150-FTP使用两个端口：21用于发送命令，20用于发送数据。状态代码150表示服务器准备在端口20上打开新连接，发送一些数据。 226-命令在端口20上打开数据连接以执行操作，如传输文件。该操作成功完成，数据连接已关闭。 230-客户端发送正确的密码后，显示该状态代码。它表示用户已成功登录。 331-客户端发送用户名后，显示该状态代码。无论所提供的用户名是否为系统中的有效帐户，都将显示该状态代码。 426-命令打开数据连接以执行操作，但该操作已被取消，数据连接已关闭。 530-该状态代码表示用户无法登录，因为用户名和密码组合无效。如果使用某个用户帐户登录，可能键入错误的用户名或密码，也可能选择只允许匿名访问。如果使用匿名帐户登录，IIS的配置可能拒绝匿名访问。 550-命令未被执行，因为指定的文件不可用。例如，要GET的文件并不存在，或试图将文件PUT到您没有写入权限的目录。 &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 无标题文档 div{width:200px;height:200px;background:#CCC;margin:30px;} {margin:30px;} window.onload = function(){ var select1 = document.getElementById('select1'); var select2 = document.getElementById('select2'); select1.onchange = function(){ if(this.value=='1'){ document.getElementById('div1').style.display = 'block'; document.getElementById('div2').style.display = 'none'; }else { document.getElementById('div2').style.display = 'block'; document.getElementById('div1').style.display = 'none'; } } select2.onchange = function(){ if(this.value=='1'){ document.getElementById('div3').style.display = 'block'; document.getElementById('div4').style.display = 'none'; }else { document.getElementById('div4').style.display = 'block'; document.getElementById('div3').style.display = 'none'; } } } 1 2 div1#a div2#b 1 2 div3#a div4#b]]></content>
      <categories>
        <category>JSP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【转】JSP中浅析注释的区别]]></title>
    <url>%2Fpost%2F567eceac.html</url>
    <content type="text"><![CDATA[浅谈JSP注释 HTML注释 JSP文件是由HTML尿急和嵌入的Java程序片段组成的，所以在HTML中的注释同样可以在JSP文件中使用。注释格式： &lt;!-- 欢迎提示信息! —&gt; 欢迎访问! 使用该方法注释的内容在客户端浏览器中是看不到的，但是可以通过查看页面源代码看到注释内容。查看源代码如下: 1 2 3 Expression 4 5 6 7 8 欢迎访问! 9 10 2.带有JSP表达式的注释 注释格式: 包含该注释语句的JSP页面被请求后，服务器能识别注释中的JSP表达式，从而来执行该表达式，而对注释中的其他内容不做任何操作。 1 2 欢迎访问! 被注释的内容依旧不会显示在浏览器中 3.JSP特有的注释（隐性注释） 使用该方法注释的内容，不仅在客户端浏览时看不到，即使查看HTML源代码，也不会看到，安全性较高。注释格式：&lt;%—注释内容—%&gt; 1 &lt;%— 当前用户:&lt;%=name%&gt; —%&gt;2 欢迎访问! 查看页面源代码，也看不到JSP的注释： 1 2 3 Expression 4 5 6 7 欢迎访问!Tom 8 9]]></content>
      <categories>
        <category>JSP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDBC连接SQL Server2016]]></title>
    <url>%2Fpost%2F1e244541.html</url>
    <content type="text"><![CDATA[Quote 首先随着互联网的快速发展。现在不论是软件还是环境的配置，教程的更新都在飞速的更新发展！进来想利用大数据（Hadoop,Spark）进行基于轨迹的聚类分析。奈何时间有限，所以为了进行快速的建模、数据分析的流程（关键是模型的建立。并不一定是算法的实现！^ -&gt;**）. 然而网上的教程大多是版本比较低的（适合于julao兼容好（—~.&gt;）.所以在此进行关于SQL Server和Java的链接（在此以NetBeans为例。） 一、IIS的开启 || 数据库服务端配置1. win10IIS服务开启以及管理器的打开1）右键点击开始菜单或者使用“win+x”组合键，如然后选择“控制面板” 2）再控制面板中选择“程序”—&gt;“启动或关闭windows功能”。然后点击确定按钮，稍等大概2分钟后Win10系统将会统开启IIS服务功能。 2. SQL Server 2016配置管理器在win10中查找SQL Server 2016配置管理器，用来开启SQL Server网络配置，启用实例TCP/IP协议和Name PiPe。 Windows 10： 要打开 SQL Server 配置管理器，请在“起始页”中键入 SQLServerManager13.msc（适用于 SQL Server 2016）。 对于早期版本的 SQL Server ，请将 13 替换为较小的数字。 单击“SQLServerManager13.msc”可打开配置管理器。 要将配置管理器固定到“起始页”或“任务栏”，请右键单击“SQLServerManager13.msc”，然后单击“打开文件位置”。 在“Windows 文件资源管理器”中，右键单击“SQLServerManager13.msc”，然后单击“固定到‘开始’屏幕”或“固定到任务栏”。 第一步：windows模式登录，在对象资源管理的跟节点，右键属性-安全性 选择SQLServer和windows混合登录， 第二步：再在安全性-登录名-Sa中设置Sa登录密码。 第三部：在配置管理器中开启tips中的网络协议。 以上所述是给大家介绍的SQL Server 2016 配置. 二、Java中的链接1.**安装JDBC驱动包 下载地址: http://www.microsoft.com/en-us/download/details.aspx?id=11774 [caption id=”attachment_729” align=”aligncenter” width=”554”] JDBC连接SQLServer 2016[/caption] 下载好之后复制如下图中所指的压缩文件 在D盘下创建一个新文件夹，粘贴(本示例的路径为：_D:\\Temp\\SQLServer\\sqljdbc4_) 在系统变量CLASSPATH里将这个文件添加进去，如下图所示： 将该文件复制到JAVA安装目录下的jre的文件夹里，如下图：（本示例为:_C:\\Program Files\\Java\\jre1.8.0_60\\lib\\ext_) 再将该文件复制到JAVA安装目录下的jdk的jre文件夹里，如下图: （本示例为: _C:\\Program Files\\Java\\jdk1.8.0_60\\jre\\lib\\ext_) 再将该文件复制到要开发的项目的库文件夹中，如下图所示：（本示例为: netbeans的库中,直接复制粘贴进去) 2.**修改数据库连接的用户名和密码 打开SQL Server Management Studio，进行如下图所示操作： 在属性中修改密码（本示例为: sql2016) 3.**测试连接** 在Test项目中新建Main.java。加入代码如下，修改代码中关于所连接数据库的名字为你自己服务器上已存在的数据库（本示例为:display)，修改代码中关于连接数据库使用的用户名及密码（本示例为 用户名：sa，密码：sql2016) package pkg;import java.sql.*;public class Main{ public static void main(String [] args) { String driverName=”com.microsoft.sqlserver.jdbc.SQLServerDriver”; String dbURL=”jdbc:sqlserver://localhost:1433;DatabaseName=display”; String userName=”sa”; String userPwd=”sql2016”; try { Class.forName(driverName); Connection dbConn=DriverManager.getConnection(dbURL,userName,userPwd); System.out.println(“连接数据库成功”); } catch(Exception e) { e.printStackTrace(); System.out.print(“连接失败”); } }} 运行该java文件，结果为 附录：基于密度的聚类算法的DBScan的java实现.]]></content>
      <categories>
        <category>工具_etc</category>
        <category>数学建模</category>
        <category>计算机基础--安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tp5个人快速进入页面]]></title>
    <url>%2Fpost%2F65b08611.html</url>
    <content type="text"><![CDATA[Unit3_URL&amp;路由 tp5全部转换为 小写 控制器首字母是大写 用驼峰法需要hello_world == HelloWorld ‘url_convert’ =&gt; true; 下面是进行 seo优化（搜索引擎优化） ‘hello/[:name]’ =&gt; [‘index/index/hello’ , [‘method’ =&gt; ‘get’,’ext’ =&gt;’html’] ]; //route.php depr =&gt; ‘-‘ 测试 第四节 19min 测试 2017\_8\_27]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数学建模思想方法大全及方法适用范围]]></title>
    <url>%2Fpost%2F5c96ef4a.html</url>
    <content type="text"><![CDATA[数 学 建 模 的 十 大 常 用 算 法1、蒙特卡罗算法（该算法又称随机性模拟算法，是通过计算机仿真来解决问题的算法，同时可以通过模拟可以来检验自己模型的正确性，是比赛时必用的方法） 2、数据拟合、参数估计、插值等数据处理算法（比赛中通常会遇到大量的数据需要处理，而处理数据的关键就在于这些算法，通常使用 Matlab 作为工具） 3、线性规划、整数规划、多元规划、二次规划等规划类问题（建模竞赛大多数问题属于最优化问题，很多时候这些问题可以用数学规划算法来描述，通常使用 Lindo、Lingo 软件实现） 4、图论算法（这类算法可以分为很多种，包括最短路、网络流、二分图等算法，涉及到图论的问题可以用这些方法解决，需要认真准备） 5、动态规划、回溯搜索、分治算法、分支定界等计算机算法（这些算法是算法设计中比较常用的方法，很多场合可以用到竞赛中） 6、最优化理论的三大非经典算法：模拟退火法、神经网络、遗传算法（这些问题是用来解决一些较困难的最优化问题的算法，对于有些问题非常有帮助，但是算法的实现比较困难，需慎重使用） 7、网格算法和穷举法（网格算法和穷举法都是暴力搜索最优点的算法，在很多竞赛题中有应用，当重点讨论模型本身而轻视算法的时候，可以使用这种暴力方案，最好使用一些高级语言作为编程工具） 8、一些连续离散化方法（很多问题都是实际来的，数据可以是连续的，而计算机只认的是离散的数据，因此将其离散化后进行差分代替微分、求和代替积分等思想是非常重要的） 9、数值分析算法（如果在比赛中采用高级语言进行编程的话，那一些数值分析中常用的算法比如方程组求解、矩阵运算、函数积分等算法就需要额外编写库函数进行调用） 10、图象处理算法（赛题中有一类问题与图形有关，即使与图形无关，论文中也应该要不乏图片的，这些图形如何展示以及如何处理就是需要解决的问题，通常使用 Matlab 进行处理） ———我是正文分割线：主要内容正式开始！——— 数学建模思想方法大全及方法适用范围（上） 第一篇：方法适用范围一、统计学方法 1.1 多元回归 1、方法概述： 在研究变量之间的相互影响关系模型时候，用到这类方法，具体地说：其可 以定量地描述某一现象和某些因素之间的函数关系，将各变量的已知值带入回归 方程可以求出因变量的估计值，从而可以进行预测等相关研究。 2、分类 分为两类：多元线性回归和非线性线性回归；其中非线性回归可以通过一 定的变化转化为线性回归，比如：y=lnx 可以转化为 y=u u=lnx 来解决；所以这 里主要说明多元线性回归应该注意的问题。 3、注意事项 在做回归的时候，一定要注意两件事： （1） 回归方程的显著性检验（可以通过 sas 和 spss 来解决） （2） 回归系数的显著性检验（可以通过 sas 和 spss 来解决） 检验是很多学生在建模中不注意的地方，好的检验结果可以体现出你模型的 优劣，是完整论文的体现，所以这点大家一定要注意。 4、使用步骤： （1）根据已知条件的数据，通过预处理得出图像的大致趋势或者数据之间 的大致关系； （2）选取适当的回归方程； （3）拟合回归参数； （4）回归方程显著性检验及回归系数显著性检验 （5）进行后继研究（如：预测等） 1.2 聚类分析 1、方法概述 该方法说的通俗一点就是，将 n 个样本，通过适当的方法（选取方法很多， 大家可以自行查找，可以在数据挖掘类的书籍中查找到，这里不再阐述）选取 m 聚类中心，通过研究各样本和各个聚类中心的距离 Xij，选择适当的聚类标准， 通常利用最小距离法（一个样本归于一个类也就意味着，该样本距离该类对应的 中心距离最近）来聚类，从而可以得到聚类结果，如果利用 sas 软件或者 spss 软 件来做聚类分析，就可以得到相应的动态聚类图。 这种模型的的特点是直观，容易理解。 2、分类 聚类有两种类型： （1） Q 型聚类：即对样本聚类； （2） R 型聚类：即对变量聚类； 通常聚类中衡量标准的选取有两种： （1） 相似系数法 （2） 距离法 聚类方法： （1） 最短距离法（2） 最长距离法 （3） 中间距离法 （4） 重心法 （5） 类平均法 （6） 可变类平均法 （7） 可变法 （8） 利差平均和法 在具体做题中，适当选区方法； 3、注意事项 在样本量比较大时，要得到聚类结果就显得不是很容易，这时需要根据背景 知识和相关的其他方法辅助处理。 4、方法步骤 （1）首先把每个样本自成一类； （2）选取适当的衡量标准，得到衡量矩阵，比如说：距离矩阵或相似性矩 阵，找到矩阵中最小的元素，将该元素对应的两个类归为一类， （3）重新计算类间距离，得到衡量矩阵 （4）重复第 2 步，直到只剩下一个类； 补充：聚类分析是一种无监督的分类，下面将介绍有监督的分类。 1.3 数据分类 1、方法概述 数据分类是一种典型的有监督的机器学习方法，其目的是从一组已知类别的 数据中发现分类模型，以预测新数据的未知类别。这里需要说明的是：预测和分 类是有区别的，预测是对数据的预测，而分类是类别的预测。 2、分类方法： （1）神经网路 （2）决策树（这里不再阐述，有兴趣的同学，可以参考数据挖掘和数据仓 库相关书籍） 3、注意事项 神经网路适用于下列情况的分类： （1） 数据量比较小，缺少足够的样本建立数学模型； （2） 数据的结构难以用传统的统计方法来描述 （3） 分类模型难以表示为传统的统计模型 神经网路的优点： 分类准确度高，并行分布处理能力强，对噪声数据有较强的鲁棒性和容 错能力，能够充分逼近复杂的非线性关系，具备联想记忆的功能等。 神经网路缺点： 需要大量的参数，不能观察中间学习过程，输出结果较难解释，会影响 到结果的可信度，需要较长的学习时间，当数据量较大的时候，学习速度会制约 其应用。 4、步骤 （1）初始化全系数 （2）输入训练样本 （3）计算实际输出值 （4）计算实际输出值和期望输出值之间的误差 （5）用误差去修改权系数 （6）判断是否满足终止条件，如果满足终止，否则进入第二步 1.4 判别分析 1、概述 其是基于已知类别的训练样本，对未知类别的样本判别的一种统计方法，也 是一种有监督的学习方法，是分类的一个子方法！ 具体是：在研究已经过分类的样本基础上，根据某些判别分析方法建立判别式， 然后对未知分类的样本进行分类！ 2、分类 根据判别分析方法的不同，可分为下面几类： （1） 距离判别法 （2） Fisher 判别法 （3） Bayes 判别法 （4） 逐步判别法 关于这几类的方法的介绍，大家可以参考《多元统计学》，其中比较常用的 是 bayes 判别法和逐步判别法 3、注意事项： 判别分析主要针对的是有监督学习的分类问题。共有四种方法，这里重点注 意其优缺点： （1） 距离判别方法简单容易理解，但是它将总体等概率看待，没有差 异性； （2） Bayes 判别法有效地解决了距离判别法的不足，即：其考虑了先 验概率——所以通常这种方法在实际中应用比较多！ （3） 在进行判别分析之前，应首先检验各类均值是不是有差异（因为 判别分析要求给定的样本数据必须有明显的差异），如果检验后某两个总体的差 异不明显，应将这两个总体合为一个总体，再由剩下的互不相同的总体重现建立 判别分析函数。 （4） 这里说明下 Fisher 判别法和 bayes 判别法的使用要求：两者对总 体的数据的分布要求不同，具体的，Fishe 要求对数据分布没有特殊要求，而 bayes 则要求数据分布是多元正态分布，但实际中却没有这么严格！ （5） 可以利用 spss，sas 等软件来轻松实现 4、方法步骤 这里以 bayes 判别法为例讲述 （1） 计算各类中变量的均值 xj 及均值向量 xh，各变量的总均值 xi 及均值 向量 x （2） 计算类内协方差及其逆矩阵 （3） 计算 bayes 判别函数中，各个变量的系数及常数项并写出判别函数 （4）计算类内协方差矩阵及各总协方差矩阵做多个变量的全体判别效果的 检验 （5） 做各个变量的判别能力检验 （6） 判别样本应属于的类别 1.5 主成分分析 1、概述 主成分分析是一种降维数的数学方法，具体就是，通过降维技术立将多个变 量化为少数几个主成分的统计分析方法。在建模中，主要用于降维，系统评估， 回归分析，加权分析等等。 2、分类（无） 3、注意事项 在应用主成分分析时候，应该注意： （1） 综合指标彼此独立或者不想关 （2）每个综合指标所反映的各个样本的总信息量等于对应特征向量的 特征值。 通常要选取的综合指标的特征值贡献率之和应为 80%以上 （3） 其在应用上侧重于信息贡献影响力的综合评价 （4） 当主成分因子负荷的符号有正也有负的时候，综合评价的函数意 义就不明确！ 4、方法步骤 大家可以参考《多元统计学》这本书籍，在这里就不做阐述 1.6 因子分析 1、概述 其是也是将变量总和为数量较少的几个因子，是降维的一种数学技术！它和 主成分分析的最大区别是：其是一种探索性分析方法，即：通过用最少个数的几 个不可观察的变量来说明出现在可观察变量中的相关模型（有点类似于前面讲述 的分类和聚类的区别）它提供了一种有效的利用数学模型来解释事物之间的关 系，体现出数据挖掘的一点精神！他可以用来解决降维，系统评估，加权分析等 方法。 2、分类 因子分析是 R 型，即对变量研究 3、注意事项 （1）其不是对研究总体的变量的降维，而是根据原始变量信息构造新的变 量，作为共同因子 （2）它通过旋转可以使得因子变量具有可解释性 （3）因子分析和主成分分析的区别和联系 两者都是降维数学技术，前者是后者的推广和发展 主成分分析只是一般的变量替换，其始终是基于原始变量研究 数据的模型规律；而因子分析则是通过挖掘出新的少数变量，来研究的一种方法， 有点像数据挖掘中的关联关则发现！ 4、方法步骤 （略）大家可以去论坛上下载相关电子资源，也可以参考《多元统计学》 1.7 残差分析 1、概述 在实际问题中，由于观察人员的粗心或偶然因素的干扰。常会使我们所得到 的数据不完全可靠,即出现异常数据。有时即使通过相关系数或 F 检验证实回归 方程可靠，也不能排除数据存在上述问题。残差分析的目的就在于解决这一问题。 所谓残差是指实际观察值与回归估计值的差。 2、分类 无 3、应用 （1）通过残差分析来排除异常数据 （2）通过残差分析来检验模型的可靠性 还有很多应用，大家在使用过程中据情况选取，灵活应用！ 1．8 典型相关分析 1、概述 前面介绍的方法主要是一个变量和多个变量之间的关系，而典型相关分析研 究的是多个变量和多个变量之间的关系，或者是一组变量和一组变量之间关系！ 其可以揭示两组变量之间的关系，从而供大家研究两个现象之间的关系，例如： 蔬菜的产出水平和影响产出水平的变量之间的关系！ 2、分类 多对多的变量关系研究！ 3、注意事项 （1）其可以很好地解决组合相关性的问题 （2）其还局限于两组变量的研究，而且要求这两组变量都是连续变量且需 服从多元正态分布 1.9 时间序列 1、概述 时间序列预测法是一种定量分析方法，它是在时间序列变量分析的基础上， 运用一定的数学方法建立预测模型，使时间趋势向外延伸，从而预测未来市场的 发展变化趋势，确定变量预测值。 其基本特点是：假定事物的过去趋势会延伸到未来；预测所依据的数据具有 不规则性；撇开市场发展之间的因果关系。 2、分类 时间序列的变动形态一般分为四种：长期趋势变动，季节变动，循环变动， 不规则变动。 方法分类： （1） 平均数预测（简单算术平均法，加权算术平均法，几何平均数法） （2） 移动平均数预测（一次移动平均法，二次移动平均法） （3） 指数平滑法预测（一次，二次，三次指数平滑法） （4） 趋势法预测（分割平均法，最小二乘法，三点法） （5） 季节变动法（简单平均法，季节比例法） 3．注意事项 （1）季节变动法预测需要筹集至少三年以上的资料 （2）移动平均法在短期预测中较准确，长期预测中效果较差； （3）移动平均可以消除或减少时间序列数据受偶然性因素干扰而产生的随 机变动影响。 （4）一次移动平均法适用于具有明显线性趋势的时间序列数据的预测；一次 移动平均法只能用来对下一期进行预测，不能用于长期预测，必须选择合理的移 动跨期，跨期越大对预测的平滑影响也越大，移动平均数滞后于实际数据的偏差 也越大。跨期太小则又不能有效消除偶然因素的影响。跨期取值可在 3~20 间选 取。 （5）二次移动平均法与一次移动平均法相比，其优点是大大减少了滞后偏差， 使预测准确性提高；二次移动平均只适用于短期预测。而且只用于的情形。 （6）最小二乘法即适用于直线趋势的预测，也适用于曲线趋势的预测。 还有一些注意事项，这里就不在意义罗列 4．方法步骤 （略） 统计学的分析方法到这先告一段落！ 数学建模思想方法大全及方法适用范围（中） 优化方法 二、优化方法 1、概述 在一系列的条件限制下，寻求最优方案，使得目标达到最优的问题统称为优 化问题。解决这类问题的方法，自然就称之为优化方法，又成为数学规划！其是 运筹学的一个重要分支！ 2、分类 优化问题可以归结为优化模型，按照优化模型求解方法的不同，可以分为以 下类别： （1） 按照有无约束条件：无约束和约束最优化问题 （2） 按照决策变量是否取之连续分为： a) 数学规划或连续规划：LP,NLP,QP b) 离散优化或组合优化：IP （3） 单目标规划和多目标规划 （4） 确定性规划和不确定性规划 （5） 目标规划，动态规划，非线性规划，多目标规划等 3、注意事项 （1）约束优化问题可以转化为无约束优化问题来解决 （2）多目标规划可以通过适当的方法转化为但目标规划来解决 （3）非线性规划，在一定的条件下，可以近似为线性规划来解决 （4）不确定性规划可以通过适当的技巧转化为确定性方法解决这些转化， 大家可以参阅优秀论文，注意学取人家的经验，从而建立自己的能力提升！ 也可以参考相关优化书籍和运筹学书籍来学习，书上都有介绍！ 4、步骤 简要概括 （1）建立规划模型 （2）选择方法 （3）结果解释 三、排队论 1.概述 在我们的生活中，经常会做和排队想关的事情，比如：银行等待取钱，医院 挂号排队，理发排队等等，都会涉及到排队问题，并且 2009 年国赛 B 题第五小 题就考了和排队论相关的问题。 排队论是一门研究拥挤现象的学科，具体就是研究各种排队系统概率基础 上，解决相应的排队系统的最优设计和最优控制问题（注意：其实解决排队最优 设计和最优控制的问题） 2、分类 （1）泊松输入-指数服务排队模型 （2）M/M/1 等待排队模型 （3）M/M/S/inf 模型（2009 年 B 题的排队就是一个这种模型） 3、注意事项 （1）排队系统常见的优化问题在于 a）确定最优服务率 b)确定最佳服务台数量 c）选择最为合适的服务规则 d）确定上述几个量的最优组合 （2）在使用时候，应该注意模型的选择，模型选择好后，注意顾客到达和 服务时间分布的选择和检验 4、步骤 （略） 四：智能算法的优化应用 遗传算法，蚁群算法，贪婪算法，模拟退火算法，回溯法，分支定界法，禁 忌搜索算法，粒子群算法等启发式算法。 这类算法在实际中应谨慎使用，固然这类算法有其好处，但是其不确定远远 大于其确定性，所以大家在比赛中慎重使用，最好使用成熟的算法！ 五、微分建模 1、使用背景介绍 我们通常会在研究一些问题时候，涉及到某些变量的变化率或导数，这样所 得到的变量之间的关系就是微分方程模型，其反映的是变量之间的间接关系，通 过求解方程，就可以得到直接关系！ 2、分类 按照求解方法的不同分为：精确求解，求数值解，定性分析方法 3、注意事项 （1）微分方程的集中建立方法： A、根据规律建立方程 B、微元法 C、模拟近似 （2）几种常见的微分方程模型： 人口增长模型，传染病模型，捕鱼模型等 4、步骤 （略） 六、差分方程 1、使用背景的介绍 它是研究离散变量的变化规律，具体就是：根据实际的规律性质，平衡关系 等，建立离散变量所满足的平很关系式，从而建立差分方程模型。通过求出和分 析解，研究方程解的性质，比如，平稳性，渐进性，振动性，周期性等等 2、分类 几个重要的差分方程模型： 商业贷款，离散形式的人口模型，汽车租赁，动物养殖问题等经典模型， 大家可以参考，然后对差分方程模型有个全面的认识 七、图论 由于图论设计的内容比较多，系统庞杂，而且模型比较灵活，所以在这里不做介 绍，大家可以自行研究。 八、其他方法介绍 灰色系统主要用来解决少数据的预测问题；层次分析法主要用来解决综合分 析类的问题；模糊数学可以用来做模糊综合评判，模糊聚类分析和模糊线性规划； 蒙特卡洛方法主要是一种计算机仿真方法，通常在排队论问题使用；神经网路可 以用来分类，预测，建立模型等等；还有一些其他的方法，这里就不一一介绍了。 这里我再补充一点： 预测方法的比较： 一般小样本内部预测用插值和拟合，大样本内部预测用回归模型。 移动平均法属于时间序列分析的内容，时间序列分析一般用作大样本外部预测， 就是对未来的预测，灰色理论用于小样本的外部预测，神经网络用于超大样本的 未来预测。 可以把这些预测方法归纳一下，对于建模，主要考虑这些方法的适用性。 上面主要是对 《建模方法的使用范围》 做了一定的介绍， 关于 《数学建模中的思想方法大全》 数学建模思想方法大全及方法适用范围（下） 第二篇《数学建模思想方法大全》 在数学建模中常用的方法：类比法、二分法、量纲分析法、差分法、变分法、 图论法、层次分析法、数据拟合法、回归分析法、数学规划（线性规划，非线性 规划，整数规划，动态规划，目标规划）、机理分析、排队方法、对策方法、决 策方法、模糊评判方法、时间序列方法、灰色理论方法、现代优化算法（禁忌搜 索算法，模拟退火算法，遗传算法，神经网络）。 用这些方法可以解下列一些模型：优化模型、微分方程模型、统计模型、概 率模型、图论模型、决策模型。 拟合与插值方法（给出一批数据点，确定满足特定要求的曲线或者曲面，从 而反映对象整体的变化趋势）：matlab 可以实现一元函数，包括多项式和非线性 函数的拟合以及多元函数的拟合，即回归分析，从而确定函数； 同时也可以用 matlab 实现分段线性、多项式、样条以及多维插值。 在优化方法中，决策变量、目标函数（尽量简单、光滑）、约束条件、求解 方法是四个关键因素。其中包括无约束规则（用 fminserch、fminbnd 实现）线性 规则（用 linprog 实现）非线性规则、（ 用 fmincon 实现）多目标规划（有目标 加权、效用函数）动态规划（倒向和正向）整数规划。 回归分析：对具有相关关系的现象，根据其关系形态，选择一个合适的数学 模型，用来近似地表示变量间的平均变化关系的一种统计方法（一元线性回归、 多元线性回归、非线性回归），回归分析在一组数据的基础上研究这样几个问题： 建立因变量与自变量之间的回归模型（经验公式）；对回归模型的可信度进行检 验；判断每个自变量对因变量的影响是否显著：判断回归模型是否适合这组数据； 利用回归模型对进行预报或控制。相对应的有线性回归、多元二项式回归、非线 性回归。 逐步回归分析：从一个自变量开始，视自变量作用的显著程度，从大到地依 次逐个引入回归方程：当引入的自变量由于后面变量的引入而变得不显著时，要 将其剔除掉；引入一个自变量或从回归方程中剔除一个自变量，为逐步回归的一 步；对于每一步都要进行值检验，以确保每次引入新的显著性变量前回归方程中 只包含对作用显著的变量；这个过程反复进行，直至既无不显著的变量从回归方 程中剔除，又无显著变量可引入回归方程时为止。（主要用 SASmatlab matlab 来实现，也可以用 mmaattllaabb 软件来实现）。 聚类分析：所研究的样本或者变量之间存在程度不同的相似性，要求设法找 出一些能够度量它们之间相似程度的统计量作为分类的依据，再利用这些量将样 本或者变量进行分类。 系统聚类分析:将 n 个样本或者 n 个指标看成 n 类，一类包括一个样本或者 指标，然后将性、质最接近的两类合并成为一个新类，依此类推。最终可以按照 需要来决定分多少类，每类有多少样本（指标）。 系统聚类方法步骤： 1. 计算 n 个样本两两之间的距离 2. 构成 n 个类，每类只包含一个样品 3. 合并距离最近的两类为一个新类 4. 计算新类与当前各类的距离（新类与当前类的距离等于当前类与组合类中 包含的类的距离最小值），若类的个数等于 1，转 5，否则转 3 5. 画聚类图 6. 决定类的个数和类。 判别分析：在已知研究对象分成若干类型，并已取得各种类型的一批已知样 品的观测数据，在此基础上根据某些准则建立判别式，然后对未知类型的样品进 行判别分类。 距离判别法—首先根据已知分类的数据，分别计算各类的重心，计算新个体 到每类的距离，确定最短的距离（欧氏距离、马氏距离） Fisher 判别法—利用已知类别个体的指标构造判别式（同类差别较小、不同 类差别较大），按照判别式的值判断新个体的类别 Bayes 判别法—计算新给样品属于各总体的条件概率，比较概率的大小，然 后将新样品判归为来自概率最大的总体 模糊数学：研究和处理模糊性现象的数学（概念与其对立面之间没有一条 明确的分界线）与模糊数学相关的问题：模糊分类问题—已知若干个相互之间不 分明的模糊概念，需要判断某个确定事物用哪一个模糊概念来反映更合理准确； 模糊相似选择 —按某种性质对一组事物或对象排序是一类常见的问题，但是用 来比较的性质具有边界不分明的模糊性；模糊聚类分析—根据研究对象本身的属 性构造模糊矩阵，在此基础上根据一定的隶属度来确定其分类关系；模糊层次 分析法—两两比较指标的确定；模糊综合评判—综合评判就是对受到多个因素制 约的事物或对象作出一个总的评价，如产品质量评定、科技成果鉴定、某种作物 种植适应性的评价等，都属于综合评判问题。由于从多方面对事物进行评价难免 带有模糊性和主观性，采用模糊数学的方法进行综合评判将使结果尽量客观从而 取得更好的实际效果。 时间序列是按时间顺序排列的、随时间变化且相互关联的数据序列—通过对 预测目标自身时间序列的处理，来研究其变化趋势（长期趋势变动、季节变动、 循环变动、不规则变动） 自回归模型：一般自回归模型 AR(n)—系统在时刻 t 的响应 X(t)仅与其以前 时刻的响应 X(t-1),…，X(t-n)有关，而与其以前时刻进入系统的扰动无关；移动 平均模型 MA(m)—系统在时刻 t 的响应 X(t)，与其以前任何时刻的响应无关，而 与其以前时刻进入系统的扰动 a(t-1),…,a(t-m)存在着一定的相关关系；自回归移 动平均模型 ARMA(n,m)—系统在时刻 t 的响应 X(t)，不仅与其前 n 个时刻的自 身值有关，而且还与其前 m 个时刻进入系统的扰动存在一定的依存关系。 时间序列建模的基本步骤 1. 数据的预处理：数据的剔取及提取趋势项 2. 取 n=1，拟合 ARMA(2n,2n-1)（即 ARMA(2,1)）模型 3. n=n+1，拟合 ARMA(2n,2n-1)模型 4. 用 F 准则检验模型的适用性。若检验显著，则转入第 2 步。若检验不显著， 转入第 5 步。 5. 检查远端时刻的系数值的值是否很小，其置信区间是否包含零。若不是， 则适用的模型就是 ARMA(2n,2n-1)。若很小，且其置信区间包含零，则拟合 ARMA(2n-1,2n-2)。 6. 利用 F 准则检验模型 ARMA(2n,2n-1)和 ARMA(2n-1,2n-2) ，若 F 值不显 著，转入第 7 步；若 F 值显著，转入第 8 步。 7. 舍弃小的 MA 参数，拟合 m&lt;2n-2 的模型 ARMA(2n-1,m)，并用 F 准则进 行检验。重复这一过程，直到得出具有最小参数的适用模型为止 8. 舍弃小的 MA 参数，拟合 m&lt;2n-1 的模型 ARMA(2n,m)，并用 F 准则进行 检验。重复这一过程，直到得出具有最小参数的适用模型为止。 图论方法： 最短路问题：两个指定顶点之间的最短路径—给出了一个连接若干个城镇的 铁路网络，在这个网络的两个指定城镇间，找一条最短铁路线（Dijkstra 算法） 每对顶点之间的最短路径（Dijkstra 算法、Floyd 算法）。 最小生成树问题：连线问题—欲修筑连接多个城市的铁路设计一个线路图， 使总造价最低（prim 算法、Kruskal 算法）。 图的匹配问题：人员分派问题：n 个工作人员去做件 n 份工作，每人适合做 其中一件或几件，问能否每人都有一份适合的工作？如果不能，最多几人可以有 适合的工作？(匈牙利算法)。 遍历性问题：中国邮递员问题—邮递员发送邮件时，要从邮局出发，经过他 投递范围内的每条街道至少一次，然后返回邮局，但邮递员希望选择一条行程最 短的路线 最大流问题，运输问题： 最小费用最大流问题：在运输问题中，人们总是希望在完成运输任务的同时， 寻求一个使总的运输费用最小的运输方案 在数学建模中常用的算法： 1：蒙特卡罗算法； 2：数据拟合、参数估计、插值等数据处理算法（常用 matlab 实现）； 3：线性规划、整数规划、多元规划、二次规划(用 lingo、lingdo、matlab 即 可实现)； 4：图论算法（包括最短路、网络流、二分图）； 5：动态规划、回溯搜索、分治算法、分支界定； 6：最优化理论的三大经典算法（模拟退火算法、神经网络算法、遗传算法）； 7：网格算法和穷举法； 8：连续数据离散化； 9：数值分析算法； 10：图象处理算法（常用 matlab 来实现）。 SPSS求解 非线性回归 solve()%可以求解 解析解]]></content>
      <categories>
        <category>三模</category>
        <category>数学建模</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017暑期数学建模_三模]]></title>
    <url>%2Fpost%2Ff04a8c24.html</url>
    <content type="text"><![CDATA[http://sbp810050504.blog.51cto.com/2799422/1269572 最小二乘法！ 特别重要！ 这段时间学习《机器学习》，学到第5章的“Logistic回归”，感觉相当吃力。追本溯源，从“Logistic回归”到“线性回归”，再到“最小二乘法”。最终定格到了《高等数学》（第六版·下册）第九章第10节“最小二乘法”，这才了解到最小二乘法背后的数学原理出自哪里。 “最小二乘法”是最优化问题中建立经验公式的一种实现方法。了解它的原理，对于了解“Logistic回归”和“支持向量机的学习”都很有裨益。 注意：进行同步的学习！！Ajax：异步的从远端（服务器）提供需要的数据！ .load(url,[data],[callback]) $.get(url,[data],[callback]) $.post(url,[data],[callback],[type]) $.getScript(url,[callback]) $.ajax 事件（有安全机制 所以xw推荐我们使用它！） $.ajax 事件 ```javascript // Using the core $.ajax() method $.ajax({ // the URL for the request url: “post.php”, // the data to send (will be converted to a query string) data: { id: 123 }, // whether this is a POST or GET request type: “GET”, // the type of data we expect back dataType : “json”, // code to run if the request succeeds; // the response is passed to the function success: function( json ) { $( ““ ).text( json.title ).appendTo( “body” ); $( ““).html( json.html ).appendTo( “body” ); }, // code to run if the request fails; the raw request and // status codes are passed to the function error: function( xhr, status, errorThrown ) { alert( “Sorry, there was a problem!” ); console.log( “Error: “ + errorThrown ); console.log( “Status: “ + status ); console.dir( xhr ); }, // code to run regardless of success or failure complete: function( xhr, status ) { alert( “The request is complete!” ); }, beforeSend: function() { }, //在于全部的ajax方法之前 进行加载load， 在complete完成后 进行取消load即可！ cache: true //false 每一秒 每一时都有变动api需要变为false 但是一般时规则是变为true }); ``` beforeSend, cache 具体参数 请参见markdown(前端学习 JQuery) 注意 在F12模式下的 network模式下可以查看进行的ajax等js的操作并且 我们可以在 Sources 模式下进行点击前面的行号。进行 js的调试！鼠标放在 变量上还能进行查看变量的 值！ # JQuery AJAX &gt;其中用到了 $(‘#result’).html(‘’).load(loadUrl+’ #item1’)//这是change 方法？！ 注意这里string里面是有字符的！！ &gt; load( url, [data], [callback] ) ：载入远程 HTML 文件代码并插入至 DOM 中。 url (String) : 请求的HTML页的URL地址。 data (Map) : (可选参数) 发送至服务器的 key/value 数据。 callback (Callback) : (可选参数) 请求完成时(不需要是success的)的回调函数。 $.get( url, [data], [callback] )：使用GET方式来进行异步请求 url (String) : 发送请求的URL地址. data (Map) : (可选) 要发送给服务器的数据，以 Key/value 的键值对形式表示，会做为QueryString附加到请求URL中。 同上个参数：有时用的 {action:”get”,Name:”Ryan”},//这是一个json 对象！因为 api接口里面就是 json对！ callback (Function) : (可选) 载入成功时回调函数(只有当Response的返回状态是success才是调用该方法) 。返回 data，textStatus $.post( url, [data], [callback], [type] ) ：使用POST方式来进行异步请求 url (String) : 发送请求的URL地址. data (Map) : (可选) 要发送给服务器的数据，以 Key/value 的键值对形式表示。 callback (Function) : (可选) 载入成功时回调函数(只有当Response的返回状态是success才是调用该方法)。 type (String) : (可选)官方的说明是：Type of data to be sent。其实应该为客户端请求的类型(JSON,XML,等等) $.getScript( url, [callback] ) : 通过 GET 方式请求载入并执行一个 JavaScript 文件。 url (String) : 待载入 JS 文件地址。 callback (Function) : (可选) 成功载入后回调函数。 * $.ajax 事件 ```javascript // Using the core $.ajax() method $.ajax({ // the URL for the request url: “post.php”, // the data to send (will be converted to a query string) data: { id: 123 }, // whether this is a POST or GET request type: “GET”, // the type of data we expect back dataType : “json”, // code to run if the request succeeds; // the response is passed to the function success: function( json ) { $( ““ ).text( json.title ).appendTo( “body” ); $( ““).html( json.html ).appendTo( “body” ); }, // code to run if the request fails; the raw request and // status codes are passed to the function error: function( xhr, status, errorThrown ) { alert( “Sorry, there was a problem!” ); console.log( “Error: “ + errorThrown ); console.log( “Status: “ + status ); console.dir( xhr ); }, // code to run regardless of success or failure complete: function( xhr, status ) { alert( “The request is complete!” ); }, beforeSend: function() { }, //在于全部的ajax方法之前 进行加载load， 在complete完成后 进行取消load即可！ cache: true //false 每一秒 每一时都有变动api需要变为false 但是一般时规则是变为true }); ``` beforeSend, cache]]></content>
      <categories>
        <category>三模</category>
        <category>数学建模</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SVM算法实现——基于libsvm的模型原理建立]]></title>
    <url>%2Fpost%2F8ee03fb7.html</url>
    <content type="text"><![CDATA[-s 0 [caption id=”attachment_703” align=”alignleft” width=”184”] -s 0 C-SVC[/caption] [caption id=”attachment_704” align=”alignleft” width=”172”] -t 2 RBF核函数[/caption] 关键字(keywords)：SVM 支持向量机 SMO算法 实现 机器学习** 如果对SVM原理不是很懂的，可以先看一下入门的[视频](http://www.ilovematlab.cn/thread-62252-1-1.html)，对帮助理解很有用的，然后再深入一点可以看看这几篇[入门文章](http://www.blogjava.net/zhenandaci/archive/2009/02/13/254519.html)，作者写得挺详细，看完以后SVM的基础就了解得差不多了，再然后买本《支持向量机导论》作者是Nello Cristianini 和 John Shawe-Taylor，电子工业出版社的。然后把书本后面的那个SMO算法实现就基本上弄懂了SVM是怎么一回事，最后再编写一个SVM库出来，比如说像libsvm等工具使用，呵呵，差不多就这样。这些是我学习SVM的整个过程，也算是经验吧。 下面是SVM的简化版SMO算法，我将结合Java*代码来解释一下整个SVM的学习训练过程，即所谓的train训练过程。那么什么是SMO算法呢？ SMO算法的目的无非是找出一个函数f(x)，这个函数能让我们把输入的数据x进行分类。既然是分类肯定需要一个评判的标准，比如分出来有两种情况A和B,那么怎么样才能说x是属于A类的，或不是B类的呢？就是需要有个边界，就好像两个国家一样有边界，如果边界越明显，则就越容易区分，因此，我们的目标是最大化边界的宽度，使得非常容易的区分是A类还是B类。 在SVM中，要最大化边界则需要最小化这个数值： w：是参量，值越大边界越明显 C代表惩罚系数，即如果某个x是属于某一类，但是它偏离了该类，跑到边界上后者其他类的地方去了，C越大表明越不想放弃这个点，边界就会缩小 代表：松散变量 但问题似乎还不好解，又因为SVM是一个凸二次规划问题，凸二次规划问题有最优解，于是问题转换成下列形式（KKT条件）： …………(1) 这里的ai是拉格朗日乘子(问题通过拉格朗日乘法数来求解) 对于（a）的情况，表明ai是正常分类，在边界内部（我们知道正确分类的点yif(xi)&gt;=0） 对于（b）的情况，表明了ai是支持向量，在边界上 对于（c）的情况，表明了ai是在两条边界之间 而最优解需要满足KKT条件，即满足（a）（b）（c）条件都满足 以下几种情况出现将会出现不满足： yiui&lt;=1但是ai=1但是ai&gt;0则是不满足的而原本ai=0 yiui=1但是ai=0或者ai=C则表明不满足的，而原本应该是0&lt;ai&lt;C 所以要找出不满足KKT的这些ai，并更新这些ai，但这些ai又受到另外一个约束，即 因此，我们通过另一个方法，即同时更新ai和aj，满足以下等式 就能保证和为0的约束。 利用yiai+yjaj=常数，消去ai，可得到一个关于单变量aj的一个凸二次规划问题，不考虑其约束0&lt;=aj&lt;=C,可以得其解为： ………………………………………(2) 这里………………(3) 表示旧值，然后考虑约束0&lt;=aj&lt;=C可得到a的解析解为： …………(4) 对于 那么如何求得ai和aj呢？ 对于ai，即第一个乘子，可以通过刚刚说的那几种不满足KKT的条件来找，第二个乘子aj可以找满足条件 …………………………………………………………………………（5） b的更新： 在满足条件：下更新b。……………（6） 最后更新所有ai，y和b，这样模型就出来了，然后通过函数： ……………………………………………………（7） 输入是x，是一个数组，组中每一个值表示一个特征。 输出是A类还是B类。（正类还是负类） ！以下是主要的代码段： /* * 默认输入参数值 * C: regularization parameter * tol: numerical tolerance * max passes / double C = 1; //对不在界内的惩罚因子 double tol = 0.01;//容忍极限值 int maxPasses = 5; //表示没有改变拉格朗日乘子的最多迭代次数 /\ * 初始化a[], b, passes / double a[] = new double[x.length];//拉格朗日乘子 this.a = a; //将乘子初始化为0 for (int i = 0; i &lt; x.length; i++) { a[i] = 0; } int passes = 0; while (passes &lt; maxPasses) { //表示改变乘子的次数（基本上是成对改变的） int num_changed_alphas = 0; for (int i = 0; i &lt; x.length; i++) { //表示特定阶段由a和b所决定的输出与真实yi的误差 //参照公式(7) double Ei = getE(i); /\ * 把违背KKT条件的ai作为第一个 * 满足KKT条件的情况是： * yif(i) &gt;= 1 and alpha == 0 (正确分类) \ yif(i) == 1 and 0&lt;alpha &lt; C (在边界上的支持向量) \ yif(i) &lt;= 1 and alpha == C (在边界之间) \ * * * ri = y[i] Ei = y[i] f(i) - y[i]^2 &gt;= 0 * 如果ri &lt; 0并且alpha &lt; C 则违反了KKT条件 * 因为原本ri &lt; 0 应该对应的是alpha = C * 同理，ri &gt; 0并且alpha &gt; 0则违反了KKT条件 * 因为原本ri &gt; 0对应的应该是alpha =0 / if ((y[i] Ei &lt; -tol &amp;&amp; a[i] &lt; C) || (y[i] Ei &gt; tol &amp;&amp; a[i] &gt; 0)) { /\ * uiyi=1边界上的点 0 &lt; a[i] &lt; C \ 找MAX|E1 - E2| / int j; /\ * boundAlpha表示x点处于边界上所对应的 * 拉格朗日乘子a的集合 / if (this.boundAlpha.size() &gt; 0) { //参照公式(5) j = findMax(Ei, this.boundAlpha); } else //如果边界上没有，就随便选一个j != i的aj j = RandomSelect(i); double Ej = getE(j); //保存当前的ai和aj double oldAi = a[i]; double oldAj = a[j]; /\ * 计算乘子的范围U, V * 参考公式(4) / double L, H; if (y[i] != y[j]) { L = Math.max(0, a[j] - a[i]); H = Math.min(C, C - a[i] + a[j]); } else { L = Math.max(0, a[i] + a[j] - C); H = Math.min(0, a[i] + a[j]); } /\ * 如果eta等于0或者大于0 则表明a最优值应该在L或者U上 / double eta = 2 k(i, j) - k(i, i) - k(j, j);//公式(3) if (eta &gt;= 0) continue; a[j] = a[j] - y[j] (Ei - Ej)/ eta;//公式(2) if (0 &lt; a[j] &amp;&amp; a[j] &lt; C) this.boundAlpha.add(j); if (a[j] &lt; L) a[j] = L; else if (a[j] &gt; H) a[j] = H; if (Math.abs(a[j] - oldAj) &lt; 1e-5) continue; a[i] = a[i] + y[i] y[j] (oldAj - a[j]); if (0 &lt; a[i] &amp;&amp; a[i] &lt; C) this.boundAlpha.add(i); /\ * 计算b1， b2 * 参照公式(6) / double b1 = b - Ei - y[i] (a[i] - oldAi) k(i, i) - y[j] (a[j] - oldAj) k(i, j); double b2 = b - Ej - y[i] (a[i] - oldAi) k(i, j) - y[j] (a[j] - oldAj) * k(j, j); if (0 &lt; a[i] &amp;&amp; a[i] &lt; C) b = b1; else if (0 &lt; a[j] &amp;&amp; a[j] &lt; C) b = b2; else b = (b1 + b2) / 2; num_changed_alphas = num_changed_alphas + 1; } } if (num_changed_alphas == 0) { passes++; } else passes = 0; } return new SVMModel(a, y, b); 运行后的结果还算可以吧，测试数据主要是用了libsvm的heart_scale的数据。 预测的正确率达到73%以上。 如果我把核函数从线性的改为基于RBF将会更好点。 最后，说到SVM算法实现包，应该有很多，包括svm light，libsvm，有matlab本身自带的svm工具包等。 另外，浅显易懂的个人理解 SVM文章请看这里。 豆丁网 上有很多很好的libsvm原理以及源码文档看这里。 如理解有误敬请指正！谢谢！ 更新：（关注的链接/参考网址） http://qing0991.blog.51cto.com/1640542/1770756配置以及使用的参数说明 http://blog.csdn.net/on2way/article/details/47733861附属上个） http://blog.csdn.net/taohuaxinmu123/article/details/20628173 交叉验证 http://blog.csdn.net/zhaomengszu/article/details/67634992 参数调优) http://blog.csdn.net/zhaomengszu/article/details/66971919?locationNum=12&amp;fps=1 参数调优算法设计） http://blog.csdn.net/u014772862/article/details/51835192 底层源码。 http://blog.sina.com.cn/s/blog_6646924501018fqc.html 返回的参数详解 http://blog.csdn.net/u014772862/article/details/51873590 附属上） http://blog.csdn.net/techq/article/details/6171688 SVM算法实现参数说明 http://www.cnblogs.com/zhizhan/p/4430253.html 通俗易懂概念说明） http://www.cnblogs.com/zhizhan/p/4430279.html 使用libsvm对MNIST数据集进行实验—-浅显易懂！）]]></content>
      <categories>
        <category>SVM</category>
        <category>数学建模</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[libsvm参数介绍]]></title>
    <url>%2Fpost%2F4c21898f.html</url>
    <content type="text"><![CDATA[libsvm 训练后的模型参数讲解主要就是讲解利用libsvm-mat工具箱建立分类（回归模型）后，得到的模型model里面参数的意义都是神马？以及如果通过model得到相应模型的表达式，这里主要以分类问题为例子。 测试数据使用的是libsvm-mat自带的heart_scale.mat数据（270*13的一个属性据矩阵，共有270个样本，每个样本有13个属性），方便大家自己测试学习。 首先上一个简短的测试代码： %% ModelDecryption % by faruto @ faruto’s Studio~ % http://blog.sina.com.cn/faruto % Email:faruto@163.com % http://www.matlabsky.com % http://www.mfun.la % http://video.ourmatlab.com % last modified by 2011.01.06 %% a litte clean work tic; close all; clear; clc; format compact; %% % 首先载入数据 load heart_scale; data = heart_scale_inst; label = heart_scale_label; % 建立分类模型 model = svmtrain(label,data,’-s 0 -t 2 -c 1.2 -g 2.8’); model % 利用建立的模型看其在训练集合上的分类效果 [PredictLabel,accuracy] = svmpredict(label,data,model); accuracy %% toc; 运行结果： model = Parameters: [5x1 double] nr_class: 2 totalSV: 259 rho: 0.0514 Label: [2x1 double] ProbA: [] ProbB: [] nSV: [2x1 double] sv_coef: [259x1 double] SVs: [259x13 double] Accuracy = 99.6296% (269/270) (classification) accuracy = 99.6296 0.0148 0.9851 Elapsed time is 0.040155 seconds. 这里面为了简单起见没有将测试数据进行训练集和测试集的划分，这里仅仅是为了简单明了而已，分类结果估计可以不要管，参数优化也不要管，另有帖子讲解。 下面我们就看看 model这个结构体里面的各种参数的意义都是神马，model如下： model = Parameters: [5x1 double] nr_class: 2 totalSV: 259 rho: 0.0514 Label: [2x1 double] ProbA: [] ProbB: [] nSV: [2x1 double] sv_coef: [259x1 double] SVs: [259x13 double] model.Parameters 我们先来看一下model.Parameters里面承装的都是什么： > model.Parameters ans = 0 2.0000 3.0000 2.8000 0 重要知识点： model.Parameters参数意义从上到下依次为： -s svm类型：SVM设置类型(默认0) -t 核函数类型：核函数设置类型(默认2) -d degree：核函数中的degree设置(针对多项式核函数)(默认3) -g r(gama)：核函数中的gamma函数设置(针对多项式/rbf/sigmoid核函数) (默认类别数目的倒数) -r coef0：核函数中的coef0设置(针对多项式/sigmoid核函数)((默认0) 即在本例中通过model.Parameters我们可以得知 –s 参数为0；-t 参数为 2；-d 参数为3；-g 参数为2.8（这也是我们自己的输入）；-r 参数为0。 关于libsvm参数的一点小说明： Libsvm中参数设置可以按照SVM的类型和核函数所支持的参数进行任意组合，如果设置的参数在函数或SVM类型中没有也不会产生影响，程序不会接受该参数；如果应有的参数设置不正确，参数将采用默认值。 model.Label model.nr_class > model.Label ans = 1 -1 > model.nr_class ans = 2 重要知识点： model.Label表示数据集中类别的标签都有什么，这里是 1，-1； model.nr_class表示数据集中有多少类别，这里是二分类。 model.totalSV model.nSV > model.totalSV ans = 259 > model.nSV ans = 118 141 重要知识点： model.totalSV代表总共的支持向量的数目，这里共有259个支持向量； model.nSV表示每类样本的支持向量的数目，这里表示标签为1的样本的支持向量有118个，标签为-1的样本的支持向量为141。 注意：这里model.nSV所代表的顺序是和model.Label相对应的。 model.ProbA model.ProbB 关于这两个参数这里不做介绍，使用-b参数时才能用到，用于概率估计。 -b probability_estimates: whether to train a SVC or SVR model for probability estimates, 0 or 1 (default 0) model.sv_coef model.SVs model.rho sv_coef: [259x1 double] SVs: [259x13 double] model.rho = 0.0514 重要知识点： model.sv_coef是一个259*1的矩阵，承装的是259个支持向量在决策函数中的系数； model.SVs是一个259*13的稀疏矩阵，承装的是259个支持向量。 model.rho是决策函数中的常数项的相反数（-b） 在这里首先我们看一下 通过 –s 0 参数（C-SVC模型）得到的最终的分类决策函数的表达式是怎样的？ 这里如果有关于C-SVC模型不懂的地方，请看这个pdf文件： libsvm_library.pdf 附件： 最终的决策函数为： 在由于我们使用的是RBF核函数（前面参数设置 –t 2），故这里的决策函数即为： 其中|| x-y ||是二范数距离 ; 这里面的 b就是-model.rho（一个标量数字）; b = -model.rho; n代表支持向量的个数即 n = model.totalSV（一个标量数字）； 对于每一个i： wi =model.sv_coef(i); 支持向量的系数（一个标量数字） xi = model.SVs(i,:) 支持向量（1*13的行向量） x 是待预测标签的样本 （1*13的行向量） gamma 就是 -g 参数 好的下面我们通过model提供的信息自己建立上面的决策函数如下： %% DecisionFunction function plabel = DecisionFunction(x,model) gamma = model.Parameters(4); RBF = @(u,v)( exp(-gamma.*sum( (u-v).^2) ) ); len = length(model.sv_coef); y = 0; for i = 1:len u = model.SVs(i,:); y = y + model.sv_coef(i)*RBF(u,x); end b = -model.rho; y = y + b; if y &gt;= 0 plabel = 1; else plabel = -1; end 有了这个决策函数，我们就可以自己预测相应样本的标签了： %% plable = zeros(270,1); for i = 1:270 x = data(i,:); plabel(i,1) = DecisionFunction(x,model); end %% 验证自己通过决策函数预测的标签和svmpredict给出的标签相同 flag = sum(plabel == PredictLabel) over = 1; 最终可以看到 flag = 270 ，即自己建立的决策函数是正确的，可以得到和svmpredict得到的一样的样本的预测标签，事实上svmpredict底层大体也就是这样实现的。 最后我们来看一下，svmpredict得到的返回参数的意义都是什么 在下面这段代码中 : %% % 首先载入数据 load heart_scale; data = heart_scale_inst; label = heart_scale_label; % 建立分类模型 model = svmtrain(label,data,’-s 0 -t 2 -c 1.2 -g 2.8’); model % 利用建立的模型看其在训练集合上的分类效果 [PredictLabel,accuracy] = svmpredict(label,data,model); accuracy 运行可以看到 model = Parameters: [5x1 double] nr_class: 2 totalSV: 259 rho: 0.0514 Label: [2x1 double] ProbA: [] ProbB: [] nSV: [2x1 double] sv_coef: [259x1 double] SVs: [259x13 double] Accuracy = 99.6296% (269/270) (classification) accuracy = 99.6296 0.0148 0.9851 这里面要说一下返回参数accuracy的三个参数的意义。 重要的知识点： 返回参数accuracy从上到下依次的意义分别是： 分类准率（分类问题中用到的参数指标） 平均平方误差（MSE (mean squared error)） [回归问题中用到的参数指标] 平方相关系数（r2 (squared correlation coefficient)）[回归问题中用到的参数指标] 其中mse 和r2的计算公式分别为： 插图： 写在后面的话，至此关于model中相应参数的一些意义，以及到底如果得到决策函数的表达式或者计算方式的就算是说的很明了了。 可能还有的同学会问，如何得到分类决策函数中的那个alpha系数【这个肯定会有人问】，还是再磨叽说一下吧： 上面的wi其实是alpha和支持向量的类别标签（1或-1的乘积），原始决策函数的表达式如下： 插图： 上面的yi是支持向量的类别标签（1或者-1），在libsvm中将yi和alpha的乘积放在一起用model.sv_coef（w）来承装。 都说到这份上，应该能明白了吗？ 再说点废话：就是在关于SVM的学习中，我发现很多朋友都不主动思考和尝试，老是在问，这样很不好，这样很被动，上面这些也没有人教我，都是我自己思考出来，然后编程验证，如果出现不合理的地方就再继续思考，反正道理和书籍里面都有讲解，总能洞穿的啊。O(∩_∩)O• svm-train的用法用法： svm-train [options] training_set_file [model_file] 其中， -s svm训练，默认0, 其中前三种用来做分类问题，后两种用来实现回归问题。 0 c-SVC， 1 nu-SVC， 2 one-class SVM， 3 epsilon-SVR， 4. v-SVR， -t 核函数类型 0 线性核函数， 1 多项式核函数， 2 RBF核函数， 3 sigmoid核函数， 4 自定义核函数 -v n, n-fold交叉验证。 -d degree，设置多项式核函数的参数d，默认为3。 -g gamma，设置多项式、RBF 、sigmoid核函数的参数，在多项式和sigmoid中gamma表示为a，在RBF中表示为r，默认为1/num_features。 -r 设置多项式和sigmoid核函数中的常数项c，默认为0。 -c cost，设置c-svc，epsilon-SVR，nu-SVR类型的惩罚系数C，默认为1。 -n nu，设置nu-SVC，one-class SVM，nu-SVR类型的参数v，默认为0.5。 -p epsilon，设置epsilon-SVR的loss function参数，默认为0.1。 -m cachesize ，设置cache大小，默认为100MB。 -e epsilon，设置终止条件，默认为0.001。 -h shrinking，是否运用shrinking启发式，默认为1。 -b probability_estimates，是否使用概率估计模型，默认0。 -wi weight，将i类的参数C设置为weight*C，默认为1。 -v n， n-fold交叉验证。 使用示例： svmtrain train3.scale train3.model 训练 train3.scale， 将模型保存于文件 train3.model， 并在 dos 窗口中输出如下结果： optimization finished, #iter = 1756 nu = 0.464223 obj = -551.002342, rho = -0.337784 nSV = 604, nBSV = 557 Total nSV = 604 1 2 3 4 5 1 2 3 4 5 其中，#iter 为迭代次数，nu 与前面的操作参数-n ν 相同，obj 为 SVM 文件转换为的二次规划求解得到的最小值，rho 为判决函数的常数项 b ，nSV 为支持向量个数，nBSV 为边界上的支持向量个数，Total nSV 为支持向量总个数。 模型文件介绍： svm_type c_svc % 训练所采用的svm类型，此处为C SVC − kernel_type rbf % 训练采用的核函数类型，此处为RBF核 gamma 0.047619 % 与操作参数设置中的 γ 含义相同 nr_class 2 % 分类时的类别数，此处为两分类问题 total_sv 604 % 总共的支持向量个数 rho -0.337784 % 决策函数中的常数项 b label 0 1 % 类别标签 nr_sv 314 290 % 各类别标签对应的支持向量个数 SV % 以下为支持向量 1 1:-0.963808 2:0.906788 ... 19:-0.197706 20:-0.928853 21:-1 1 1:-0.885128 2:0.768219 ... 19:-0.452573 20:-0.980591 21:-1 ... ... ... 1 1:-0.847359 2:0.485921 ... 19:-0.541457 20:-0.989077 21:-1 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 svm-predict的用法用法：svm-predict [options] test_file model_file output_file 其中 -b probability_estimates，是否需要进行概率估计预测，可选值为 0 或者 1，默认值为 0。 est_file 是要进行预测的数据文件； model_file 是由 svmtrain 产生的模型文件； output_file 是 svmpredict 的输出文件，表示预测的结果值。 svmpredict 没有其它的选项。]]></content>
      <categories>
        <category>SVM</category>
        <category>数学建模</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MATLAB2016b下配置libsvm]]></title>
    <url>%2Fpost%2Fd47ea840.html</url>
    <content type="text"><![CDATA[他人原创自学非转载 1、下载libsvm 3.22，更新日期为2016年12月 https://www.csie.ntu.edu.tw/~cjlin/libsvm/ Download LIBSVMThe current release (Version 3.22, December 2016) of LIBSVM can be obtained by downloading the zip file or tar.gz file. You can also check this github directory. Please e-mail us if you have problems to download the file.The package includes the source code of the library in C++ and Java, and a simple program for scaling training data. A README file with detailed explanation is provided. For MS Windows users, there is a sub-directory in the zip file containing binary executable files. Precompiled Java class archive is also included. Please read the COPYRIGHT notice before using LIBSVM. 2、添加路径 将工具包放到任何地方均可（建议放在D:\\Program Files\\MATLAB\\R2015b\\toolbox\\matlab下），将工具包添加到Matlab的搜索路径，Set Path-&gt;add with subfolders-&gt;save。 备注：保证D:\\Program Files\\MATLAB\\R2016b\\toolbox\\matlab\\libsvm-3.22和D:\\Program Files\\MATLAB\\R2015b\\toolbox\\matlab\\libsvm-3.22\\matlab都在路径下。 3、编译 确保安装有Visual Studio 2015版，matlab当前工作目录切换到D:\\Program Files\\MATLAB\\R2015b\\toolbox\\matlab\\libsvm-3.22下，在matlab命令行窗口下输入： &gt;&gt;mex -setup > mex -setupMEX 配置为使用 ‘Microsoft Visual C++ 2015 Professional (C)’ 以进行 C 语言编译。警告: MATLAB C 和 Fortran API 已更改，现可支持 包含 2^32-1 个以上元素的 MATLAB 变量。不久以后， 您需要更新代码以利用 新的 API。您可以在以下网址找到相关详细信息: http://www.mathworks.com/help/matlab/matlab_external/upgrading-mex-files-to-use-64-bit-api.html。要选择不同的语言，请从以下选项中选择一种命令: mex -setup C++ mex -setup FORTRAN> mex -setup C++MEX 配置为使用 ‘Microsoft Visual C++ 2015 Professional’ 以进行 C++ 语言编译。警告: MATLAB C 和 Fortran API 已更改，现可支持 包含 2^32-1 个以上元素的 MATLAB 变量。不久以后， 您需要更新代码以利用 新的 API。您可以在以下网址找到相关详细信息: http://www.mathworks.com/help/matlab/matlab_external/upgrading-mex-files-to-use-64-bit-api.html。&gt; 4、编译文件 matlab当前工作目录切换到D:\\Program Files\\MATLAB\\R2015b\\toolbox\\matlab\\libsvm-3.22\\matlab目录下，在matlab命令行窗口下输入命令，若显示MEX completed successfully.表示安装成功： &gt;&gt;make 5、测试 在libsvm-3.21可以看到hear_scale 文件，在命令行输入下面几行代码 clear; [label_vector, instance_matrix] =libsvmread(‘heart_scale’); model = svmtrain(label_vector, instance_matrix); [predicted_label, accuracy, prob_estimates] = svmpredict(label_vector, instance_matrix, model, ‘b’); 备注参考： options:-s svm_type : set type of SVM (default 0) 0 — C-SVC 1 — nu-SVC 2 — one-class SVM 3 — epsilon-SVR 4 — nu-SVR-t kernel_type : set type of kernel function (default 2) 0 — linear: u’v 1 — polynomial: (gamma\u’*v + coef0)^degree 2 — radial basis function: exp(-gamma|u-v|^2) 3 — sigmoid: tanh(gamma\u’*v + coef0)-d degree : set degree in kernel function (default 3)-g gamma : set gamma in kernel function (default 1/num_features)-r coef0 : set coef0 in kernel function (default 0)-c cost : set the parameter C of C-SVC, epsilon-SVR, and nu-SVR (default 1)-n nu : set the parameter nu of nu-SVC, one-class SVM, and nu-SVR (default 0.5)-p epsilon : set the epsilon in loss function of epsilon-SVR (default 0.1)-m cachesize : set cache memory size in MB (default 100)-e epsilon : set tolerance of termination criterion (default 0.001)-h shrinking: whether to use the shrinking heuristics, 0 or 1 (default 1)-b probability_estimates: whether to train a SVC or SVR model for probability estimates, 0 or 1 (default 0)-wi weight: set the parameter C of class i to weight*C, for C-SVC (default 1)The k in the -g option means the number of attributes in the input data. 四 使用关于LIBSVM在Matlab中的使用，可以参看软件包中matlab目录下的README文件，这里对里面内容做一个翻译和一些细节的讲解。 1. 训练libsvm函数用于对训练集的数据进行训练，得到训练好的模型。 model = libsvmtrain(training_label_vector, training_instance_matrix [, ‘libsvm_options’]); 这个函数有三个参数，其中 -training_label_vector:训练样本的类标，如果有m个样本，就是m x 1的矩阵（类型必须为double）。这里可以是二分类和多分类，类标是（-1,1）、（1,2,3）或者其他任意用来表示不同的类别的数字，要转成double类型。 -training_instance_matrix:训练样本的特征，如果有m个样本，每个样本特征是n维，则为m x n的矩阵（类型必须为double）。 -libsvm_options:训练的参数，在第3点详细介绍。 2. 预测libpredict函数用于对测试集的数据进行测试，还能对未知样本进行预测。 [predicted_label, accuracy, decision_values/prob_estimates] = libsvmpredict(testing_label_vector, testing_instance_matrix, model [, ‘libsvm_options’]); 这个函数包括四个参数，其中 -testing_label_vector:测试样本的类标，如果有m个样本，就是m x 1的矩阵（类型必须为double）。如果类标未知，可以初始化为任意m x 1的double数组。 -testing_instance_matrix:测试样本的特征，如果有m个样本，每个样本特征是n维，则为m x n的矩阵（类型必须为double）。 -model:使用libsvmtrain返回的模型 -libsvm_options:预测的参数，与训练的参数形式一样。 3. 训练的参数LIBSVM训练时可以选择的参数很多，包括： -s svm类型：SVM设置类型（默认0) 0 — C-SVC； 1 –v-SVC； 2 – 一类SVM； 3 — e-SVR； 4 — v-SVR -t 核函数类型：核函数设置类型（默认2） 0 – 线性核函数：u’v 1 – 多项式核函数：（r*u’v + coef0)^degree 2 – RBF(径向基)核函数：exp(-r|u-v|^2） 3 – sigmoid核函数：tanh(r*u’v + coef0) -d degree：核函数中的degree设置（针对多项式核函数）（默认3） -g r(gamma）：核函数中的gamma函数设置（针对多项式/rbf/sigmoid核函数）（默认1/k，k为总类别数) -r coef0：核函数中的coef0设置（针对多项式/sigmoid核函数）（（默认0) -c cost：设置C-SVC，e -SVR和v-SVR的参数（损失函数）（默认1） -n nu：设置v-SVC，一类SVM和v- SVR的参数（默认0.5） -p p：设置e -SVR 中损失函数p的值（默认0.1） -m cachesize：设置cache内存大小，以MB为单位（默认40） -e eps：设置允许的终止判据（默认0.001） -h shrinking：是否使用启发式，0或1（默认1） -wi weight：设置第几类的参数C为weight*C (C-SVC中的C) （默认1） -v n: n-fold交互检验模式，n为fold的个数，必须大于等于2 以上这些参数设置可以按照SVM的类型和核函数所支持的参数进行任意组合，如果设置的参数在函数或SVM类型中没有也不会产生影响，程序不会接受该参数；如果应有的参数设置不正确，参数将采用默认值。 4. 训练返回的内容libsvmtrain函数返回训练好的SVM分类器模型，可以用来对未知的样本进行预测。这个模型是一个结构体，包含以下成员： -Parameters: 一个5 x 1的矩阵，从上到下依次表示： -s SVM类型（默认0）； -t 核函数类型（默认2） -d 核函数中的degree设置(针对多项式核函数)(默认3)； -g 核函数中的r(gamma）函数设置(针对多项式/rbf/sigmoid核函数) (默认类别数目的倒数)； -r 核函数中的coef0设置(针对多项式/sigmoid核函数)((默认0) -nr_class: 表示数据集中有多少类别，比如二分类时这个值即为2。 -totalSV: 表示支持向量的总数。 -rho: 决策函数wx+b中的常数项的相反数（-b）。 -Label: 表示数据集中类别的标签，比如二分类常见的1和-1。 -ProbA: 使用-b参数时用于概率估计的数值，否则为空。 -ProbB: 使用-b参数时用于概率估计的数值，否则为空。 -nSV: 表示每类样本的支持向量的数目，和Label的类别标签对应。如Label=[1; -1],nSV=[63; 67]，则标签为1的样本有63个支持向量，标签为-1的有67个。 -sv_coef: 表示每个支持向量在决策函数中的系数。 -SVs: 表示所有的支持向量，如果特征是n维的，支持向量一共有m个，则为m x n的稀疏矩阵。 另外，如果在训练中使用了-v参数进行交叉验证时，返回的不是一个模型，而是交叉验证的分类的正确率或者回归的均方根误差。 5. 预测返回的内容libsvmtrain函数有三个返回值，不需要的值在Matlab可以用~进行代替。 -predicted_label：第一个返回值，表示样本的预测类标号。 -accuracy：第二个返回值，一个3 x 1的数组，表示分类的正确率、回归的均方根误差、回归的平方相关系数。 -decision_values/prob_estimates：第三个返回值，一个矩阵包含决策的值或者概率估计。对于n个预测样本、k类的问题，如果指定“-b 1”参数，则n x k的矩阵，每一行表示这个样本分别属于每一个类别的概率；如果没有指定“-b 1”参数，则为n x k*(k-1)/2的矩阵，每一行表示k(k-1)/2个二分类SVM的预测结果。 6. 读取或保存libsvmread函数可以读取以LIBSVM格式存储的数据文件。 [label_vector, instance_matrix] = libsvmread(‘data.txt’); 这个函数输入的是文件的名字，输出为样本的类标和对应的特征。 libsvmwrite函数可以把Matlab的矩阵存储称为LIBSVM格式的文件。 libsvmwrite(‘data.txt’, label_vector, instance_matrix] 这个函数有三个输入，分别为保存的文件名、样本的类标和对应的特征（必须为double类型的稀疏矩阵）。]]></content>
      <categories>
        <category>工具_etc</category>
        <category>数学建模</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数学建模·反思总结_一模]]></title>
    <url>%2Fpost%2F8ea53676.html</url>
    <content type="text"><![CDATA[数学建模·反思总结_一模 &gt;物生有象，象生有数。乘除推阐，物究造化之源者，是为数学。 2017/8/17 10:15:53 首先，对于品性方面要有耐心、细心、善于观察分析要有团队合作精神！ 对于数学建模 要从态度上重视她、接近她、了解他、全方位的剖析她。要坚持下去，优必胜的信心。 还有身体硬件的条件：身体要好。平时不要熬夜、打游戏了。。做好熬夜的准备。 —————我是分割线咳咳，划重点————— 然后，在于论文方面格式大家应该分析的、听得比较详尽。我主要是对于编程与写作方面总结反思下： 1. 基于编程数学软件与模型思想进行算法设计与建模。 2. 搜集相关的软件、模型、程序资料给咱们提供更加有力的保障、更全新的方法、更大胆的想法。 3. 注重论文的写作方面。在论文中运用流程图、算法设计思想、认真优美的格式 一目了然 的说明情况。 4. 同时要注重所学软件、函数的 返回值 。对于数据的输出要 有理有据 。 5. 还有大家在编程或者 命名文件 时统一一下名称：A_815_no1.m(千万不要和系统一样的命名)。 6. 还有把握各个函数的使用度，有些函数或者数据处理并不需要全部写出来。有依据即可、一针见血。 7. 对于相同的符号格式要有想法的进行封装、整合。 8. 符号说明直接、简单明了。 9. 论文写作中要使用通用的符号。编程可以随意但自己要有个度。 10. 对于论文中自己独特的想法要说明清楚。 11. 找准点，不同的想法或者疑问 可以在本子的特殊位置记录下来，避免回过头来找不到了的情况。 ————— 综合素质， - 对于优秀论文以及专业论文文献方法的查找大家还是欠缺的。可以相互学习下。 - 将复杂的实际问题抽象为你知道的数学模型。这里面有一个规律就是怎么样用一个可解析的函数去模拟一堆看似杂乱无章的数据的规律还要进行训练 还要有一个接受的过程。 - 开放思想、先自己思考。然后把自己认为正确的点记录下来，可以深入下去进行研究，但是要有一个度 能使大家信服。 ————— 最后：发放福利哦·他人收集的资料好不容易收集找到的_希望大家不要外泄。 可以查看目录，如果有需要跟我说。我可以批量快速下载。 链接: https://pan.baidu.com/s/1c724CA]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PhpStorm使用手册丶总结]]></title>
    <url>%2Fpost%2Fd01e61bb.html</url>
    <content type="text"><![CDATA[参考：http://www.cnblogs.com/luojianqun/p/4596052.html 罗总说这是php最好的IDE,phpstorm9.02，没有之一。各种功能各种好，罗总此等大神说的肯定是没有错的，好吧，开始玩耍。 一、官网下载http://www.jetbrains.com/phpstorm/ 安装后，罗总给的key是只能8用，同个key还不能同一局域网下使用，所以去百度了一个9可以用的。也适用mac版 username：EMBRACE license： ===== LICENSE BEGIN ===== 43136-12042010 00002UsvSON704l”dILe1PVx3y4”B3 49AU6oSDJrsjE8nMOQh”8HTDJHIUUh gd1BebYc5U”6OxDbVsALB4Eb10PW8” ===== LICENSE END ===== 我等英语残废，自然要汉化啦 百度一堆汉化包。 http://pan.baidu.com/s/1c02UR0O 下载下来 \\PhpStorm 9.0.2\\lib 下 文件已经修改过的，不必做其他操作。复制替换 即可， 不过发现各种快捷失效，改个字体都改不了。所以无奈只能用英文了。 中文乱码解决方法如果打开后显示乱码，请先删除resources_cn.jar，然后打开phpstorm，在菜单上依次选择 File -&gt; Settings -&gt; Appearance&amp;Behavior -&gt; Appearance -&gt; 选中Override default fonts by(not recommended) Name: Microsoft YaHei (选择任意中文字体) 然后将resources_cn.jar 复制到 .\\lib 目录，重新打开phpstorm 就能正常显示中文了。 编辑器文字大小无法修改： http://www.tuicool.com/articles/6ZfmQn 1、设置行号 show line numbers 设置里面搜索这个，可以设置默认显示行号 2、设置自动换行 use soft wraps in editor 3、设置 FTP 搜索 Deployment 快捷键 Shift+Ctrl+Alt+X 1.设置新建文件的编码 File -&gt; Settings -&gt; File Encoding 进行调整，一般为utf-8。 2.对jquery等一些javascript库的一些提示 File -&gt; Settings -&gt; javascript -&gt; Libraries 点击download选择需要下载的js库。 3、取消自动保存 File -&gt;Settings -&gt;System Setting 取消 save files on frame deactivation 。 4、修改的文件标记星星（即*） File -&gt;Settings -&gt;Editor -&gt; Editor Tabs，，勾选mark modified tabs width asterisk选项. 二、**代码快捷键：** ctrl+j 插入活动代码提示 ctrl+alt+t 当前位置插入环绕代码 alt+insert 生成代码菜单 ctrl+q 查看代码注释 ctrl+d 复制当前行 ctrl+y 删除当前行 shift+F6 重命名 ctrl+shift+u 字母大小写转换 ctrl+f 查找 ctrl+r 替换 F4 查看源码 ctrl+shift+i 查看变量或方法定义源 ctrl+g 跳转行 ctrl+alt+F12 跳转至当前文件在磁盘上的位置 alt+down 查看下一个方法 alt+up 查看上一个方法 ctrl+alt+l 重新格式化代码 ctrl+shift+down statement向下移动 ctrl+shift+up statement向上移动 alt+shift+down line向下移动 alt+shift+up line向上移动 ctrl+/ 行注释 ctrl+shift+/ 块注释 ctrl+shift+n 打开工程中的文件 ctrl+b 跳到变量申明处 ctrl+[] 匹配 {}[] ctrl+shift+]/[ 选中块代码.... ctrl+x 剪切行 ctrl+shift+v 复制多个文本 alt+left/right 标签切换 ctrl+p 显示默认参数 Ctrl + Alt + L 格式化代码 alt + ‘7’ 显示当前的函数结构 ctrl + ‘.’ 折叠选中的代码的代码 ctrl + ‘-/+’ 可以折叠项目中的任何代码块，包括htm中的任意nodetype=3的元素，function,或对象直接量等等。它不是选中折叠，而是自动识别折叠 ctrl + F12 可以显示当前文件的结构 三、配置ftp:http://bbs.csdn.net/topics/390677784 http://www.cnblogs.com/jikey/p/3486621.html tools-devloy。。。 还有就是注意在“ 然后在Mappings 选择映射目录分别为本地，发布或web路径。”设置为 “/“ 路径 四、配置svn：http://jingyan.baidu.com/article/c275f6ba240f4ee33c75677f.html 常见svn错误： Can’t use Subversion command line client: https://XXX/xxx _Probably the path to Subversion executable is wrong. Fix it. (show balloon)_ 解决：指定svn命令行 在菜单栏中选择“File”-&gt;“Settings”-&gt;“Subversion”-&gt;“General”打开属性面板。勾选“Use command line client”填写你的TortoiseSVN安装目录如：C:\\Program Files\\TortoiseSVN\\bin\\svn.exe。 我在TortoiseSVN1.9中的目录没找到svn.exe，反倒是在我安装的VisualSVN 服务器端找到了，C:\\Program Files (x86)\\VisualSVN Server\\bin，应用即可。 如果： https://pcdalao/svn/项目 Vis svn给你分配的路径 别人访问不到。 就用https://你的ip/svn/项目 注意要关闭防火墙 五、xdebug调试：任务：我有一个本地配好的Thinkphp项目，正常访问连接是，http://192.168.1.248:94 ,那么我要调试Admin模块Test控制器的index方法， 也就是http://192.168.1.248:94/admin/test/index 准备工作： 1.谷歌浏览器，并下载插件2个插件。JetBrains IDE Support，Xdebug helper 2，web环境，以wampserver为例，打开XDEGUG， 选中3项目 php.ini末尾 ; XDEBUG Extension zend_extension = “F:/wamp/bin/php/php5.5.12/zend_ext/php_xdebug-2.2.5-5.5-vc11-x86_64.dll” ; [xdebug] xdebug.default_enable = on xdebug.remote_host=192.168.1.248 xdebug.remote_port=9000 xdebug.remote_autostart = on xdebug.remote_enable = on xdebug.profiler_enable = On xdebug.profiler_enable_trigger = On xdebug.profiler_output_name = cachegrind.out.%t.%p xdebug.profiler_output_dir = “F:/wamp/tmp” xdebug.show_local_vars=0 重启一下服务器 3，phpstorm设置： 一，php设置解释器File-settings-PHP 二、然后下面的DBGp Proxy 三，项目配置Run-editconfigurations 打开浏览器： 在浏览器扩展里面找到xdebug helper 的设置 ，点进去填一下要调试的项目信息 然后输入要调试的网址，会出现小臭虫的标志，选中debug 这时会自动跳回phpstorm去了 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 时光荏苒，转眼phpstorm10.3，phpstorm2016又冒了出来，身为码农必然好奇，来玩一下 下载mac版的phpstorm2016.1 参考：http://www.oyksoft.com/soft/40722.html?pc=1 phpstorm已经升级到10.0，原注册码失效，10.0注册方法： 注册时选择“License server”输入 http://idea.lanyus.com/ （已被封杀） 或者： http://idea.qinxi1992.cn/ 点击“OK”快速激活JetBrains系列产品 内存调整，处理卡顿 http://www.phperz.com/article/15/1106/167474.html # 用的是 mac osx，编辑 phpstorm 的启动配置文件，其他平台根据情况选择: sudo vim /Applications/PhpStorm.app/Contents /bin/phpstorm.vmoptions # 修改参数，根据具体需要修改即可 -Xms512m -Xmx2048m -XX:MaxPermSize=350m -XX :ReservedCodeCacheSize=240m -XX:+UseCompressedOops ========================================= 使用一段时间后发现 ps1016无法启动 ？bin下的phpstorm64.exe 发现缺少了jdk环境，安装jdk1.8即可 PHPstrom安装Emmet的方法是：点设置，然后在plugins中输入emmet搜索，如果没搜到，点Borwse那个按钮搜，搜到之后install就可以了，应用，确定； 重启一下自己的PHPstrom 就可以实现前端代码快速编写； 具体规则，以及使用教程： http://www.iteye.com/news/27580 同样的，PHPstrom也在某个神秘的时刻支持了 ThinkPHP的框架编写提示；http://www.thinkphp.cn/topic/31578.html 作为拓展，可以在业余时间研究ThinkPHP时，将此插件装入Strom，提升编写速度；]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>工具_etc</category>
        <category>计算机基础--安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【转】[字典类]SQLServer T-SQL函数大全]]></title>
    <url>%2Fpost%2Ff2c82704.html</url>
    <content type="text"><![CDATA[SQLSERVER T-SQL函数大全 聚合函数对一组值计算后返回单个值。除了count(统计项数)函数以外，其他的聚合函数在计算式都会忽略空值(null)。所有的聚合函数均为确定性函数。即任何时候使用一组相同的输入值调用聚合函数执行后的返回值都是相同的，无二义性。 聚合函数通常会在下列场合使用。 1、select语句的选择列表，包括子查询和外部查询。 2、使用compute或compute by产生汇总列时。 3、having子句对分组的数据记录进行条件筛选。 一、常用聚合函数 1、计算平均值AVG AVG函数用于计算精确型或近似型数据类型的平均值，bit类型除外，忽略null值。AVG函数计算时将计算一组数的总和，然后除以为null的个数，得到平均值。 语法结构： _avg( [ all | distinct ] expression ) _ all：为默认值，表示对所用的数据都计算平均值。 distinct：每个值的唯一值计算平均值，不管相同的值出现多次，多个行相同的值仅仅出现一次作为计算。 expression：精确或近似值的表达式。表达式内部不允许使用子查询和其他聚合函数。 示例： select avg(distinct age) from person — 查询person表里的年龄的平均值，相同值只计算一次 2、计算最小值MIN MIN函数用于计算最小值，MIN函数可以适用于numeric、char、varchar或datetime、money或smallmoney列，但不能用于bit列。不允许使用聚合函数和子查 询，忽略null值。 语法结构： _min( [ all | distinct ] expression )_ 示例： select min(age) from person — 查询person表里的年龄的最小值 3、计算最大值MAX MAX函数用于计算最大值，忽略null值。max函数可以使用于numeric、char、varchar、money、smallmoney、或datetime列，但不能用于bit列。不允许使用 聚合函数和子查询。 语法结构： MAX ( [ all | distinct ] expression ) 示例： select max(age) from person — 查询person表里的年龄的最大值 4、计算求和值SUM SUM函数用于求和，只能用于精确或近似数字类型列(bit类型除外)，忽略null值，不允许使用聚合函数和子查询。 1、语法结构 SUM ( [ all | distinct ] expression ) 示例: select sum(age) from person — 查询person表里的年龄的总和 5、计算项数值count(count_big) count函数用于计算满足条件的数据项数，返回int数据类型的值。 1、语法结构 _count( {[[ all | distinct] expression ] | } )_ 这里的表达式是除text、image或ntext以外任何数据类型的表达式。但不允许使用聚合函数和子查询。 2、常见使用方法 count() ： 返回所有的项数，包括null值和重复项。 count(all表达式)：返回非空的项数。 count(distinct表达式)：返回唯一非空的项数 count_big的语法与count完全一样，只不过返回值为bigint数据类型，这样返回的数值范围就可以大大超过count。 注意：count(字段名)，如果字段名为NULL，则count函数不会统计。例如count(name)，如果name为空，则不会统计到结果。 示例： select count(distinct age) from person — 查询person表里的年龄唯一且非空的项数 6、计算标准偏差值STDEV 语法结构： _STDEV( [all | distinct ] expression )_ 这里的expression必须是一个数值表达式，不允许使用聚合函数和子查询。表达式的值是精确或近似数值类型，但不包括bit数据类型。将忽略null值。 标准偏差是高中的东西，忘记干什么用的了，用到的时候再学回来吧。 示例： select stdev(age) from person — 查询person表里的年龄的标准偏差 7、计算方差VAR VAR函数用于计算指定表达式中所有值的方差。 语法结构 VAR( [ all | distinct ] expression ) 这里的expression表达式必须是一个数值表达式，不允许使用聚合函数和子查询。表达式的值是精确或近似数值类型，但不包括bit数据类型，将忽略null值。 方差也是高中学的东西，忘了。 示例： select var(age) from person — 查询person表里的年龄的方差 二、常用日期时间函数 1、获取当前日期getdate getdate函数以datetime数据类型的格式返回当前SQLServer服务器所在计算机的日期和时间。其语法格式为getdate()。返回值舍入到最近的秒小数部分，精度 为.333秒数据库十七偏移量不包含在内。 示例： select getdate() —输出 2013-03-09 15:16:00.570 2、获取年度信息YEAR year函数以int数据类型的格式返回特定日期的年度信息。其语法格式为YEAR(date数据)。其中的date数据时一个可以解析为time、date、smalldatetime、 datetime、datetime2或datetimeoffset值的表达式，列表达式、用户定义的变量或字符串文字。 示例： select year(getdate()) —输出 2013 3、获取月份信息MONTH month函数以int数据类型的格式返回特定日期的月份信息。其语法格式为month(date数据)。其中的date数据时一个可以解析为time、date、smalldatetime、 datetime、datetime2或datetimeoffset值的表达式，列表达式、用户定义的变量或字符串文字。 示例： select month(getdate()) —输出 3 4、获取天数信息day day函数以int数据类型的格式返回特定日期的天数信息。其语法格式为day(date数据)。其中的date数据时一个可以解析为time、date、smalldatetime、 datetime、datetime2或datetimeoffset值的表达式，列表达式、用户定义的变量或字符串文字。 示例: select day(getdate()) —输出 9 5、获取任意时间值DATEPART datepart函数以int数据类型的格式返回某个日期时间数据的指定部分。 1、语法格式 _datepart( datepart , date数据 )_ datepart：特定的要返回的数据的格式代码。 date数据：一个可以解析为time、date、smalldatetime、datetime、datetime2或者datetimeoffset值的表达式、列表表达式、用户定义的变量或字符串文 字。 2、Datepart取值 Datepart部分的取值如下表所示： 说明 取值 返回年度信息 Year、YYYY、YY 返回月份信息 Month、MM、M 返回日期信息 Day、DD、D 返回周信息 Week、WK、WW 返回每周星期几信息 WeekDay、DW 返回季度信息 Quarter、QQ、Q 返回一年中第几天的信息 DayOfYear、DY、Y 返回小时信息 Hour、HH 返回分钟信息 Minute、MI、N 返回秒信息 Second、SS、SS 返回毫秒信息 MillSecond、MS 示例： select datepart(Quarter,getdate()) —输出 1 现在是第几季度 6、日期加法DATEADD dateadd函数将某个日期加上一个特定的时间间隔值后返回datetime数据类型的值。 1、语法格式 dateadd (datepart,numer,date数据) numer：用于与detepart相加的值。如果指定了非整数值，则将舍弃该值的小数部分。 date数据：一个用于解析为time、date、smalldatetime、datetime、datetime2、或datetimeoffset值的表达式、列表达式、用户定义的变量或字符串文字。 datepart：时间部分。上节。 示例： select getdate() —输出 2013-03-09 16:03:59.293 select dateadd(YYYY,10,getdate()) —加了十年 输出2023-03-09 16:04:36.893 7、日期减法DATEDIFF datediff函数将两个特定的日期数据相减，得到的结果可以按照detepart指定的格式返回特定的数据。 1、语法格式 _datediff(datepart,startdate,enddate)_ 执行中将使用enddate减以startdate的值，如果startdate晚于enddate将返回负值。执行结果如果超出整数范围将提示错误。 startdate：一个可以解析为time、date、smalldate、datetime、datetime2或datetimeoffset值的表达式、列表达式、用户定义的变量或字符串文字。 enddate：一个可以解析为time、date、smalldate、datetime、datetime2或datetimeoffset值的表达式、列表达式、用户定义的变量或字符串文字。 datepart：时间部分。 示例： select datediff(YYYY,’2011-11-11’,’2012-12-12’) —输出1 年份相减之后的确是1 select datediff(day,’2011-11-11’,’2012-12-12’) —输出 397 两个日期相差的天数 2013-3-13日补充，用此方法查询当前的记录： select from test where datediff(day,Rq,getdate()) = *0 —其中Rq为日期列，此行代码的意思是什么呢?getdate()减去Rq列的值为0，Rq列的值与今天相减，号数为0 8、SQLServer 2008中新增的日期时间型函数 1、获取系统时间SYSDATETIME sysdatetime函数以datetime2(7)数据类型的格式返回当前系统的日期和时间。其语法格式为sysdatetime()。返回值有七个小数位，但只精确到10毫秒。数 据库偏移量未包含在内。 2、获取当前日期和时间sysdatetimeoffset sysdatetimeoffset函数以datetimeoffset(7)数据类型的格式返回当前系统的日期和时间。其语法格式为sysdatetimeoffset()。返回值有七个小数位，但只 精确到10毫秒。数据库时区偏移量包含在内。 9、判断是否为日期数据ISDATE ISDATE函数可以验证某个输入值是否为有效的日期数据 1、语法结构 _ISDATE(expression)_ 2、返回值 若表达式为有效日期则返回 1 ，否则返回 0 。 示例： select isdate(‘2012-12-12’) — 输出1 select isdate(‘xxxx-12-12’)— 输出0 三、常用字符串函数 在开发T-SQL时，经常会需要对字符串进行各种各样的操作，下面介绍常用的字符串函数。 1、获取字符的ASCII码ASCII ASCII码是对字符的标准编码。要获取字符的ASCII码就可以通过调用ASCII函数来实现。 语法结构： _ASCII(espression)_ 这里的expression是一个返回char或varchar数据类型的表达式，ASCII函数仅对表达式最左侧的字符返回ASCII码值。 返回值：int数据类型。 示例： select ascii(‘f’) —输出 102 注意如果是多个字符的字符串，也只是返回第一个字符的ASCII码值。 2、获取ASCII码对应的字符char 语法结构： _char(integer_expression)_ 返回值类型：char型字符 示例： select char(102) -- 输出f 3、获取字符的unicode编码unicode unicode函数可以获得字符的unicode编码。 语法结构 _unicode(‘ncharacter_expression’)_ 这里的ncharacter_expression是nchar或nvarchar类型的表达式。函数仅会返回第一个字符的unicode编码。 返回值：int类型数据 示例： select unicode(‘飞’) — 输出 39134 4、获取unicode编码对应的字符nchar nchar能够根据unicode标准的定义，返回具有指定的整数代码的unicode字符。 语法结构： _nchar(integer_expression)_ 返回值：unicode字符 示例： select nchar(39134) -- 输出 飞 5、获取字符串第一次出现位置PATINDEX patindex函数返回指定表达式中某模式第一次出现的其实位置；如果在全部有效的文本和字符数据类型中没有找到该模式则返回0。 语法结构： _patindex( ‘%pattenr%’ , expression )_ 参数说明： pattern：一个文本字符串。可以使用通配符，但pattern之前和之后必须有%字符(搜索第一个或自后一个字符时除外)。因为在T-SQL中，%代表模式匹配。 返回值：如果expression的数据类型为varchar(max)或nvarchar(max)，则为bigint，否则int，即pattern指定的字符串在expression中第一次出现的位置。 示例： select patindex(‘%llo%’,’hello world’) —输出3，第一次出现llo是在第3个字符位置 6、生成空格字符串SPACE space函数可以生成任意多个空格组成的字符串。 语法结构： _space ( integer_expression )_ 这里的integer_expression为指示空格个数的正整数。如果要在unicode数据中包含空格或超过8000个以上的空格。需要使用replicate函数。 返回值：char数据类型的字符。 示例： select (‘hello’ + space(5) + ‘world’) —输出 hello world 7、按指定次数重复生成字符串REPLICATE replicate函数可以按照指定的整数次数，重复生成一个字符串形式的表达式，结果为字符串。 语法结构： _replicate( character_expression,integer_expression )_ 参数说明： character_expression：字符数据的字母数字表达式，或者可隐式转换为varchar的数据类型的字母数字表达式。 integer_expression：一个正整数。如果integer_expression为负，则会返回错误。integer_expression可以使bigint类型。 返回值：与character_expression相同数据类型的字符串。 示例： select replicate(‘hello’,5) —输出hellohellohellohellohello 8、截取字符串SUBSTRING substring函数可以对字符串进行字串的截取操作。 语法结构: _substring( expression,start,length)_ 参数说明： expression：是字符串、二进制字符串、文本、图像、列或包含列的表达式，但不要使用包含聚合函数的表达式。 start：指定子字符串开始位置的整数，start可以使bigint类型。 length：一个正整数，指定要返回的expression的字符数或字节数。如果length为负，则会返回错误。length可以使bigint数据类型。 返回值： 如果expression是受支持的字符数据类型，则返回字符数据。 如果expression是受支持的binary数据类型，则返回二进制数据。 示例： select substring(‘hello’,1,2) —输出 he 与C#有点不同，它第一个字符是从1开始的 9、获取字符串长度LEN len函数用于获取字符串的长度(字符数)，但不包括右边的空格。左边的空格和右边的空格计算在内。 语法结构： len( string_expression ) 参数说明： string_expression：要计算长度的字符串。 返回值：expression数据类型为varchar(max)、nvarchar(max)或varbinary(max)，则为bigint。否则为int。 示例： select len(‘天下之大，无奇不有’) — 输出 9 10、替换字符串内容STUFF stuff函数用于在指定的字符串中删除指定长度的字符，并在起点处插入另外一组字符。 语法结构： stuff(source_character_expression，start，length，destination_character_expression) 参数说明： source_character_expression：源字符串。可以是常量、变量，也可以使字符列或二进制数据列。 start：一个整数，指定删除和插入的开始位置。如果start或length为负，则返回空字符串。如果start比第一个character_expression长，则返回空字符串。 start可以是bingint类型。 length：一个赠书，指定要删除的字符个数。如果length比第一个charter_expression长，则最多删除到最后一个character_expression中最后一个字符。 length可以是bigint类型。 destination_character_expression：目的字符串。可以是常量、变量，也可以使字符列或二进制数据列。将在源字符串中执行插入。 示例： select stuff(‘123456789’,5,2,’xyz’) —输出1234xyz780 从第5个字符开始，将第5 6两个字符替换成xyz字符串 11、指定位置搜索字符串中的内容CHARINDEX charindex函数用于在指定的字符串中搜索特定的字符串，并可以指定开始搜索的位置，返回第一次找到目标字符串的字符数。 语法结构： charindex ( expression1 , expression2 [ , start_location] ) 参数说明： expression1：一个字符串数据类型的表达式，其中包含要查找的字符的序列。 expression2：一个字符串数据类型的表达式，通常是一个为指定序列搜索的列。 start_location：开始在expression2中搜索expression1是的字符位置。如果start_location未被指定、是一个负数或零，则将从expression2的开头开始搜索。 start_location可以是bingint类型。 返回值：如果expression2的数据类型为varchar(max)、nvarchar(max)或varbinary(max)，则为bigint，否则为int。 示例： select charindex(‘456’,’123456789’) — 输出 4 从123456789中检索456出现的位置 select charindex(‘456’,’123456789’,4) -- 输出 4 12、生成带分隔符的unicode字符串QUOTENAME QUOTENAME函数用于生成带有分隔符的Unicode字符串。 (1)、分隔符 可以是单引号(‘)、左右方括号([])或者英文双引号(“)。如果不指定，则使用方括号。带有方括号的Unicode字符串如：[hello]。 (2)、语法结构 _quotename( ‘character_string’ [ , ‘quote_character’] )_ 参数说明： character_string：Unicode字符串数据构成的字符串。 quote_character：用做分隔符的单字符字符串。 (3)、返回值 nvarchar(258)，生成带有分隔符的字符串长度不能超过258 示例： select quotename(‘我是一个兵’) — 输出[我是一个兵] select quotename(‘我是一个兵’,’”‘) — 输出”我是一个兵” 13、转换浮点数字为字符串STR str函数用于将浮点数转换为字符串 语法结构： _str(float_expression[,length[,decimal]])_ float_espression：带小数点的近似数字(float)数据类型的表达式。 length：总长度。它包括小数点、符号、数字以及空格。默认值为10. decimal：小数点后的位数。decimal必须小于或等于16.如果decimal大于16，则会截断结果，使其保持为小数点后只有16位。 返回值： char：定长字符串。 示例： select str(123.456789) -- 输出 123 select str(123.456789,7) —输出 123 注意前面的是4个空格，因为不写小数点后保留多少位，所以自动填充空格 select str(123.456789,7,3) -- 输出123.457 最后一位 四舍五入了，总长度为7小数点后保留3位 14、截取左边字符串LEFT left函数用于截取从左边第一个字符开始，指定长度的字符串。其执行效果等于substring(expression,1,length)。 语法结构： _left(character_expression,integer_expression)_ 参数说明： character_expression：字符或二进制表达式，可以是常量、变量或表达式。 integer_expression：正整数，指定返回的字符数。 返回值： varchar或nvarchar，变长字符串。 示例： select left(‘123456789’,3) —输出 123 15、截取右边字符串RIGHT RIGHT函数用于截取从右边第一个字符开始，指定长度的字符串。其执行效果等于SUNSTRING(expression,len(expression)-length+1,length)。 语法结构： _right(character_expression,integer_expression) _ 参数说明： character_expression：字符或二进制表达式，可以是常量、变量或表达式。 integer_expression：正整数，指定返回的字符数。 返回值： varchar或nvarchar，变长字符串。 示例： select right(‘123456789’,3) —输出 789 16、清除左边空格LTRIM 如果字符串的字一个字符为空格，LTRIM函数用于清除连续的左边空格。 语法结构： _ltrim(character_expression)_ character_expression为字符或二进制数据表达式，可以是常量、变量或数据列。 返回值： varchar或nvarchar，变长字符串。 示例： select ltrim(‘ 123456789’) —输出 123456789，注意左边的空格已被删除了，输出字符串左边是没空格的 17、清除右边空格RTRIM RTRIM函数用于清空右边连续的空格。 语法结构： _rtrim(character_expression)_ character_expression为字符或二进制数据表达式，可以是常量、变量或数据列。 返回值： varchar或nvarchar，变长字符串。 示例： select rtrim(‘123456789 ‘) —输出123456789，注意右边的空格已经被清除了 18、转换为小写字符串LOWER lower函数将字符串全部转换为小写字符后返回。 语法结构： _lower(character_expression)_ 返回值： varchar或nvarchar，变长字符串 示例： select lower(‘ABCDEFG’) —输出 abcdefg 已经全部转换为小写了 19、转换为大写字符串UPPER upper函数用于将字符串全部转换为大写字符后返回。 语法结构： _upper(character_expression)_ character_expression为字符或二进制表达式，可以是常量，变量或数据列。 返回值： varchar或nvarchar，变长字符串。 示例： select upper(‘abcdefg’) —输出 ABCDEFG 留意到已经全部转换为大写了 20、反序字符串REVERSE reverse函数用于将字符串内容反序后返回。 语法结构： _reverse(character_expression)_ character_expression：为二进制或二进制数据表达式，可以是常量、变量或数据列。 返回值： varchar或nvarchar，变长字符串 示例： select reverse(‘123456789’) —输出 987654321 注意到顺序已经反转过来了 21、获取字符串字节数DATALENGTH datalength函数用于获取字符串的字节数，而不是字符数。该函数不仅适合字符串数据，还适合文本(text、ntext)、二进制数据(varbinary、binary)和图像 (image)等任意类型的数据。 语法结构： _datalength(expression)_ 返回值： 如果expression数据类型为varchar(max)、nvarchar(max)或varbinary(max)数据类型，则返回bigint；否则返回int。 示例： select datalength(‘我是一个兵’) —输出 10 select len(‘我是一个兵’) —输出 5 select datalength(‘abcde’) —输出5 select len(‘abcde’) —输出5 四、常用文本和图像函数 1、查找特定字符串PATINDEX 语法与字符串的patindex一样。 2、获取文本指针TEXTPTR SQLServer在存储文本类型(ntext、text)和图像数据类型(image)时，默认情况是与常见的基本数据类型(如char、int等)这样的数据时单独存储的，也就是说，如 果一个表中的字段有基本类型和图像文本类型，那么，在输入数据时，基本类型和图像文件数据并不是保存在同一个页面上，而是分离存储的。分离存储后，那么基本 类型数据和文本图像类型数据所在的页面就是通过文本指针建立联系，是一个16字节的二进制类型指针。在基本类型数据页面中存储的就是这些指向数据的指针，这样 在需要的时候通过指针来操作文本和图像数据。Textptr函数就可以用于获得文本和图像数据存储的文本指针，这个指针获得后就可以被操作文本和图像数据的函数 (wrutetext、readtext和updatetext等)进行操作。如果没有有效的指针，文本和图像函数是无法操作数据的。 语法结构： _textptr( column )_ 这里的column就是表中的文本和图像数据列(text、ntext和image)名称。 返回值： varbinary类型16字节指针。 配合使用的函数： 在编写含有TEXTPTR函数的T-SQL代码时，下表所示的函数经常被使用。 格式 说明 patindex(‘%pattern%’,expression) 返回字符串在text或ntext列中的字符位置 datalength(expression) 返回text、ntext和image列中数据的长度 set textsize 返回对select语句所返回的text、ntext或image数据的限制(字节数)。settextsize 0表示不限制。 substring(text_column,start,length) 返回二进制列中又指定的start偏移量和length指定的varchar类型的字符串。字符串的长度硬小于8kb 示例：shit，还不懂。 3、检测文本指针是否有效TEXTVALID textvalid函数用于检测文本指针是否有效。 语法结构： _textvalid( ‘table.column’,text_ptr )_ 参数说明： table：表的名称，必须包含 column：表中的二进制数据列(text、ntext和image)名称 text_ptr：要检测的文本指针 返回值： int，如果指针有效返回1，否则分那会0。 4、读取文本图像列内容READTEXT readtext函数用于读取文本或图像列的内容，按照指定的偏移量开始读取指定字节数。如果是图像列(image)，这样读取的是字节数，而不是现实图像本身。 语法结构： readtext{ table.column text_ptr offset size } [holdlock] 参数说明： table：表名称 column：列名称 text_ptr：有效的文本指针，即16字节的binary数据。 offset：开始读取text、image类型数据之前，要跳过的字节数。读取ntext类型数据之前要跳过的字符数。 size：读取的字节数(使用text或image数据类型时)或字符数(使用ntext数据类型时)。如果size为0，则读取4KB数据。 holdlock：使文本值被锁定以进行读取，直到十五结束为止。其他用户可以读取该值，但不能对其进行修改。 返回值： varchar字符。 示例：以后写 5、写入文本图像列内容WRITETEXT writetext函数用于向文本或图像写入内容，同时可以选择为最小日志记录，这样写入操作产生的日志写的I/O次数少，对数据库性能影响小。 语法结构： writetext{ table.column text_ptr } [ with log ] { data } 参数说明： table：表名称 column：列名称 text_ptr：有效的文本指针，即16字节的binary数据。 with log：由数据库的恢复模式来决定writetext操作产生的日志行为。因为text、ntext、imge类型的数据一般情况下都比较大。比如一幅图片可能上百KB，我们 知道一个数据页面的容量是标准的8KB。所以一幅图片很可能就需要几时个甚至更多的数据页面，所以writetext操作所产生的I/O次数是很多的，而过多的I/O次数将 影响数据库的性能。该参数的引入是交给数据库的恢复模式来决定的writetext操作将产生的日志行为。当数据库公仔在完全恢复模式时，产生的日志最多，因此对数 据库性能的影响也最大。当工作在简单恢复模式时，产生的日志最少。 data：要存储的text、ntext或image类型的数据。writetext以交互方式插入的最大文本长度约为120KB。 示例：以后补上。 6、更新文本图像列内容UPDATETEXT updatetext函数更新文本或图像列中的内容。与writetext的区别在于该函数可以仅更新列中的一部分，而writetext是更新整个列。 语法结构： updatetext{ table.name.dest_column_name dest_text_ptr } { null | insert_offset } { with log } { inserted_data | { table.name.src_column_name src_text_ptr } } 语法中的参数说明如下。 table_name：表名称。 dest_column_name：列名称。 dest_text_ptr：有效的文本指针，即16字节的binary数据。 insert_offset：以0为基础的更新其实位置，对于Text或image列，insert_offset是在插入新数据前要从现有列的起点跳过的字节数。对于ntext列， insert_offset是字符数(每个ntext字符占用2个字节)。从此基数为零的起始点开始的现有text、ntext或image数据向右移，为新数据留出空间。值为0表示将新数据 插入现有数据的开始处。值为null则将新数据追加到享有数据值后。 delete_length：从insert_offset位置开始、要从现有text、ntext、或image列中删除的数据长度。delete_length值对于text和image列用字节指定，对于 ntext列用字符指定。每个ntext字符占用2个字节。值为0表示不删除数据。值为null则删除现有text或image列中从insert_offset位置开始到末尾的所有数据。 withlog：日子记录由数据库的当前模式决定。 inserted_date：要插入现有text、ntext或image列的insert_offset位置的数据。这是单个char、nchar、varchar、nvarchar、binary、varbinary、text、 ntext或image值。inserted_data可以是文字或变量。 table_name.src_column_name：用作插入数据源的表或text、ntext、image列的名称。 src_text_ptr：指向用作插入数据源的text、ntext或image列的文本指针值，通常使用textptr函数获得。 示例：不懂。 五、常用数学函数 1、计算绝对值ABS ABS函数对一个数值表达式结果计算绝对值(bit数据类型除外)，返回整数。 语法结构： _ABS(数值表达式)_ 返回值：与数值表达式类型一致的数据 示例： select abs(-1) —输出 1 2、获取大于等于最小整数值CEILING CEILING函数返回大于等于数值表达式(bit数据类型除外)的最小整数值。俗称天花板函数，尽量往大的取整。 语法结构： _CEILING(数值表达式)_ 返回值：与数值表达式类型一致的数据。 示例： select ceiling(123.1) —输出124 3、获取小于等于最大整数值FLOOR floor函数返回小于等于数值表达式(bit数据类型除外)的最大整数值。俗称地板函数，尽量往小的取整。 语法结构： _floor(数值表达式)_ 返回值： 与数值表达式类型一致的数据。 示例： select floor(123.9999) —输出123 4、获取随机数RAND rand函数返回随机的从0到1之间的浮点数。 语法结构： _rand([ seed ])_ 语法中的seed是种子值，是一个整数类型的表达式(tinyint、smallint、int)，使用指定的种子值反复调用rand将返回相同的结果、。 不指定种子值，rand函数将随机产生结果。 返回值： 0到1之间的浮点数。 示例： select rand() — 输出 0.36925407993302 5、获取指定长度和精度ROUND round函数对数值表达式舍入到指定长度和精度。 语法结构： _round( numeric_expression , length[ , function] )_ 参数说明： numeric_rxpression：精确或近似数值类型的表达式，bit数据类型除外。 length：舍入精度。length必须是tinyint、smallint或int。如果length为整数，则将numeric_expression舍入到length指定的小数位数。如果length为负数，则 将numeric_expression小数点左边部分舍入到length指定的长度。 function：要执行的操作的类型。function必须为tinyint、smallint或int。如果省略function或其值为0(默认值)，则将舍入numeric_expression。如果指定了0以外的值，则将截断numeric_expression。 返回值：与numeric_expression相同类型的数值。 示例： select round(123.456789,3) -- 输出 123.457000 精确到小数点后3位 六、常用元数据函数 1、获取数据库标识符DB_ID DB_ID函数用于获取当前数据库的唯一ID(int数据类型)，数据库ID用于服务器上唯一区分书库。 语法结构： _DB_ID ([‘database_name’]) _ 参数中的database_name是sysname类型的数据库名称，为可选参数。如果没有指定则返回当前工作数据库的ID. 返回值： int数据类型的数据库标识符。 示例： select DB_ID() —输出 8 2、获取数据库名称DB_NAME DB_NAME函数用于红区当前数据库的名称(nvarchar数据类型) 语法结构： _DB_NAME([‘database_id’])_ 参数中的database是int数据类型的数据库标识符，为可选参数。如果没有指定则返回当前工作数据库的名称。 示例： select DB_Name() —输出 NHibernate 3、获取数据库属性DATABASEPROPERTYEX databasepropertyex函数用于获得指定的某个数据库的某个属性的当前设置。执行一次返回一个属性值，若要返回多个属性值，可以查询master系统数据库的 sys.database系统视图。 语法结构： _databasepropertyex(database,property)_ 参数说明： database：表示要为其返回命名属性的信息的数据库名称，nvarchar(128)数据类型 property：表示要返回的数据库属性，数据类型为Varchar(128) 示例： select databasepropertyex(‘NHibernate’,’recovery’) —输出 SIMPLE 这是数据库的恢复模式 Property属性的取值以及说明如下: 属性值 说明 返回值 Collation 排序规则名称 nvarchar(128)、null IsAutoClose 数据库的自动关闭功能是否启用 Int、null IsAutoCreateStatistics 是否自动创建统计信息 Int、null IsAutoShrink 是否定期收缩 Int、null IsAutoUpdateStatistics是否自动能够更新统计信息 Int、null Recovery 数据库的恢复模式 nvarchar(128) Status 数据库的状态 nvarchar(128) Updateability 是否可以修改数据 nvarchar(128) UserAccess 哪些用户可以访问数据库 nvarchar(128) Version 数据库内部版本号 Int 4、获取文件组标识符FILEGROUP_ID filegropy_id函数用于获取文件组的唯一标识符(int数据类型) 语法结构: _filegropy_id( ‘filegropy_name’ )_ 参数中的filegropy_name是sysname类型的数据库名称，可以从sys.filegroups系统视图中查询得到。 返回值： Int数据类型的文件组标识符。 示例： select filegroup_id(‘NHiberna’) —输出 null select filegroup_id(‘PRIMARY’) —输出 1 5、获取文件组名称FILEGROUP_NAME filegroup_name函数用于获取文件组的名称(nvarchar数据类型)。 语法结构： _filegroup_name(filegroup_id)_ 参数中的filegroup_id是int数据类型的文件组标识符，要获得该标识符，可以查询sys.filegroups系统视图 返回值 nvarchar(128)数据类型的文件组名称 示例： select filegroup_name(1) —输出 PRIMARY 6、获取文件组属性值FILEGROUPPROPERTY filegroupproperty函数用于获得指定文件组的指定属性值。 语法结构： _filegroupproperty(filegroupname,property)_ 参数说明： filegroup_name：表示要为其返回属性信息的文件组名称，nvarchar(128)数据类型，可以通过sys.filegroups列获得。 property：表示要返回的属性，数据类型为varchar(128)。 常见的property属性值列表 属性值 说明 返回值 IsReadOnly 文件组是否只读 Int、Null IsUserDefinedEG 是否为用户定义的文件组 Int、Null IsDefault 是否默认的文件组 Int、Null 示例： select filegroupproperty(‘PRIMARY’,’isreadonly’) —输出 0 7、获得文件标识符FILE_ID file_id函数用于获取数据库的文件，包括日志文件和数据文件的标识符。文件标识符用于在数据库中唯一区分。 语法结构： _FILE_ID( file_name )_ 参数中的file_name是sysname类型的文件名称，可以通过查询系统视图sys.database_files中的name列来获得。 返回值： smallint数据类型的文件标识符。 示例： select * from sys.database_files —查出有哪些数据库文件 select file_id(‘NHibernate’) —输出 1 查出NHibernate数据库文件对应的fileid 8、获取文件名称FILE_NAME file_name函数用于获取当前数据库的逻辑名称(nvarchar数据类型)，这里是逻辑名称而不是包含路径的物理名称。 语法结构： _file_name(file_id)_ 参数中的file_id是int数据类型的数据库标识符。可以查询master数据库的sys.master_files系统视图的file_id列获得服务器上所有数据库的文件ID，也可以查询某 个数据库的sys.database_files系统视图的file_id列获得该数据库的文件的ID。 返回值： nvarchar(128)数据类型的逻辑文件名称。 示例： select from sys.database_files —查出有哪些数据库文件 select file_id(‘NHibernate’) —输出 1 查出NHibernate数据库文件对应的fileid select file_name(*1) -- 输出 NHibernate 9、获取文件属性值FILEPROPERTY fileproperty函数用于获得指定文件的指定属性值。 语法结构： _fileproperty ( file_name ,property )_ file_name：表示要为其返回属性信息的文件的逻辑名称，nvarchar(128)数据类型，可以通过sys.database_files系统视图查询name列获得。 property：表示要返回的属性，数据类型为varchar(128)。 常见的property属性值的取值如下： 属性值 说明 返回值 IsReadOnly 文件是否只读 Int 1代表True，0代表False IsPrimaryFile 是否为主要数据文件 Int 1代表True，0代表False IsLogFile 是否为日志文件 Int 1代表True，0代表False SpaceUsed 文件空间的使用量 Int 示例： select fileproperty(‘nhibernate’,’isreadonly’) —输出 0 select fileproperty(‘nhibernate’,’isprimaryfile’)—输出1 select fileproperty(‘nhibernate’,’islogfile’) —输出0 select fileproperty(‘nhibernate’,’spaceused’) —输出184 10、获取数据库对象标识符OBJECT_ID object_id函数用于获取特定数据库、特定架构下特定数据对象的唯一ID(int数据类型)，对象的ID用于在数据库内区分唯一。 语法结构： _ object_id( ‘[database_name . [schema_name] . | schema_name . ]object_name’ [,’object_type’] ‘)_ 参数说明： database_name：数据库名称 schema_name：架构名称 object_name：对象名称 object_type：对象类型 返回值： Int数据类型的对象标识符。 示例：不懂 11、获取数据库对象名称OBJECT_NAME object_name函数用于获取指定数据库、指定架构下的数据对象的逻辑名称。该名称可以通过查询sys.objects系统视图的name列得到。 语法结构： _object_name(object_id)_ 参数中的object_id是int数据类型的对象标识符 返回值 sysname数据类型的逻辑对象名称。 示例：不懂 12、获取文件属性值OBJECTPROPERTY objectproperty函数用于获得指定数据库、指定架构下的指定对象的指定属性的值。 语法结构： objectproperty(id,property) 参数说明： id:表示要为其返回命名属性信息的对象的ID，int数据类型。 property：表示要返回的属性，数据类型为sql_variant，即变体。 常见的property属性值 属性值 说明 返回值 TableHasTextImage 表中是否含有text、image列 Int 1代表True 0代表False TableHasPrimaryKey 表中是否含有主键 Int 1代表True 0代表False TableHasIndex 表中是否含有索引 Int 1代表True 0代表False TableHasForeignKey 表中是否含有外键 Int 1代表True 0代表False SchemaId 对象的架构ID Int OwnerId 对象的所有者 Int IsView 是否视图 Int 1代表True 0代表False IsUserTable 是否用户创建表 Int 1代表True 0代表False IsTable 是否是表 Int 1代表True 0代表False IsSystemTable 是否系统表 Int 1代表True 0代表False IsPrimaryKey 是否主键 Int 1代表True 0代表False 示例：不懂 七、运算符 1、算术运算符 算术运算符 说明 + 加法 _ 减法 乘法 / 除法 % 取模，两个整数相除后的余数 2、位运算符 位运算符 说明 &amp;(与、and) 按位逻辑与运算 |(或、OR) 按位逻辑或运算 ~(非、NOT) 按位逻辑非运算 ^(互斥OR) 按位互斥运算 3、比较运算符 比较运算符 说明 &gt; 大于 = 等于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 &lt;&gt; 不等于 != 不等于 !&gt; 不大于 !&lt; 不小于 4、逻辑运算符 逻辑运算符 说明 AND 对两个布尔表达式进行逻辑与运算 OR 对两个布尔表达式进行逻辑或运算 Not 对两个布尔表达式进行逻辑非运算 BETWEEN 用于测试某一表达式的值是否在某个指定的范围内 LIKE 模式匹配运算符 IN 列表运算符，测试表达式的值在或不在某些列表值内 ALL\\SOME\\ANY 用于判断表达式和子查询之间的值的关系 5、字符串连接运算符 字符串连接运算符形式上个加法运算符”+”是完全一致的。但用于字符串时表示字符串连接。 6、赋值运算符 赋值运算符形式上和”=”是完全一致的，但用于变量时表示赋值。 7、运算符的优先级 在T-SQL程序中包含多种运算符时，需要注意这些运算符的优先级 优先级 运算符 说明 1 () 小括号 2 +、-、~ 正、负、逻辑非 3 、/、% 乘 除 取模 4 +、-、+ 加、减、连接 5 =、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、!&gt;、!&lt; 各种比较运算符 6 ^、&amp;、| 位运算符 7 NOT 逻辑非 8 AND 逻辑与 9 ALL、ANY、BETWEEN、IN、LIKE、OR、SOM 逻辑运算符 10 = 赋值运算符 实用]]></content>
      <categories>
        <category>数据库</category>
        <category>课程设计_12</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【转】T-SQL常用函数]]></title>
    <url>%2Fpost%2Fb37d3c9.html</url>
    <content type="text"><![CDATA[T-SQL之常用函数 数据操作 SELECT —从数据库表中检索数据行和列INSERT —向数据库表添加新数据行DELETE —从数据库表中删除数据行UPDATE —更新数据库表中的数据 数据定义 CREATE TABLE —创建一个数据库表DROP TABLE —从数据库中删除表ALTER TABLE —修改数据库表结构CREATE VIEW —创建一个视图DROP VIEW —从数据库中删除视图CREATE INDEX —为数据库表创建一个索引DROP INDEX —从数据库中删除索引CREATE PROCEDURE —创建一个存储过程DROP PROCEDURE —从数据库中删除存储过程CREATE TRIGGER —创建一个触发器DROP TRIGGER —从数据库中删除触发器CREATE SCHEMA —向数据库添加一个新模式DROP SCHEMA —从数据库中删除一个模式CREATE DOMAIN —创建一个数据值域ALTER DOMAIN —改变域定义DROP DOMAIN —从数据库中删除一个域 数据控制 GRANT —授予用户访问权限DENY —拒绝用户访问REVOKE —解除用户访问权限 事务控制 COMMIT —结束当前事务ROLLBACK —中止当前事务SET TRANSACTION —定义当前事务数据访问特征 程序化SQL DECLARE —为查询设定游标EXPLAN —为查询描述数据访问计划OPEN —检索查询结果打开一个游标FETCH —检索一行查询结果CLOSE —关闭游标PREPARE —为动态执行准备SQL 语句EXECUTE —动态地执行SQL 语句DESCRIBE —描述准备好的查询 局部变量 declare @id char(10)set @id = ‘10010001’select @id = ‘10010001’ 全局变量 必须以@@开头 IF ELSE declare @x int,@y,int @z intselect @x = 1,@y = 2,@z=3if @x &gt; @y print ‘x &gt; y’ —打印字符串’x &gt; y’else if @y &gt; @z print ‘y &gt; z’else print ‘z &gt; y’ CASE use panguupdate employeeset e_wage = case when job_level = ’1’ then e_wage*1.08 when job_level = ’2’ then e_wage*1.07 when job_level = ’3’ then e_wage*1.06 else e_wage*1.05 end WHILE CONTINUE BREAK declare @x int @y int @c intselect @x = 1 @y=1while @x &lt; 3 begin print @x —打印变量x 的值 while @y &lt; 3 begin select @c = 100*@x + @y print @c —打印变量c 的值 select @y = @y + 1 end select @x = @x + 1 select @y = 1 end WAITFOR —例:等待1 小时2 分零3 秒后才执行SELECT 语句waitfor delay ‘00:00:03’select 1—例:等到晚上11 点零8 分后才执行SELECT 语句waitfor time ‘15:03:00’select 2 SELECT select (列名) from table_name(表名) where column_name operator valueex:(宿主)select from stock_information where stockid = str(nid) stockname = ‘str_name’ stockname like ‘% find this %’ stockname like ‘[a-zA-Z]%’ —— ([]指定值的范围) stockname like ‘[^F-M]%’ —— (^排除指定范围) --------- 只能在使用like关键字的where子句中使用通配符) or stockpath = ‘stock_path’ or stocknumber &lt; 1000 and stockindex = 24 not stocksex = ‘man’ stocknumber between 20 and 100 stocknumber in(10,20,30) order by stockid desc(asc) ————- 排序，desc-降序，asc-升序 order by 1,2 --------- by列号 stockname = (select stockname from stock_information where stockid = 4) --------- 子查询 --------- 除非能确保内层select只返回一个行的值，否则应在外层where子句中用一个in限定符select distinct column_name from table_name ————- distinct指定检索独有的列值，不重复select stocknumber ,”stocknumber + 10“ = stocknumber + 10 from table_nameselect stockname , “stocknumber” = count() from table_name group by stockname having count() = 2 --------- group by 将表按行分组,指定列中有相同的值 --------- having选定指定的组select from table1, table2where table1.id = table2.id ———— 左外部连接，table1中有的而table2中没有得以null表示 table1.id =* table2.id ———— 右外部连接select stockname from table1union [all] ——- union合并查询结果集，all-保留重复行select stockname from table2 insert insert into table_name (Stock_name,Stock_number) value (“xxx”,”xxxx”)value (select Stockname , Stocknumber from Stock_table2)—-value为select语句 update update table_name set Stockname = “xxx” [where Stockid = 3] Stockname = default Stockname = null Stocknumber = Stockname + 4 delete delete from table_name where Stockid = 3truncate table_name —————- 删除表中所有行，仍保持表的完整性drop table table_name ———————- 完全删除表 alter table ———— 修改数据库表结构 alter table database.owner.table_name add column_name char(2) null …..sp_help table_name —— 显示表已有特征create table table_name (name char(20), age smallint, lname varchar(30))insert into table_name select ……… ——- 实现插入列的方法（创建新表）alter table table_name drop constraint Stockname_default —— 删除Stockname的default约束 常用函数 ——-统计函数——- AVG —求平均值COUNT —统计数目MAX —求最大值MIN —求最小值SUM —求和 AVG use panguselect avg(e_wage) as dept_avgWagefrom employeegroup by dept_id MAX —求工资最高的员工姓名use panguselect e_name from employee where e_wage = (select max(e_wage) from employee) STDEV() STDEV()函数返回表达式中所有数据的标准差 STDEVP() STDEVP()函数返回总体标准差 VAR() VAR()函数返回表达式中所有值的统计变异数 VARP() VARP()函数返回总体变异数 ——-算术函数——- 三角函数 SIN(float_expression) —返回以弧度表示的角的正弦COS(float_expression) —返回以弧度表示的角的余弦TAN(float_expression) —返回以弧度表示的角的正切COT(float_expression) —返回以弧度表示的角的余切 反三角函数 ASIN(float_expression) —返回正弦是FLOAT 值的以弧度表示的角ACOS(float_expression) —返回余弦是FLOAT 值的以弧度表示的角ATAN(float_expression) —返回正切是FLOAT 值的以弧度表示的角ATAN2(float_expression1,float_expression2) —返回正切是float_expression1 /float_expres-sion2的以弧度表示的角DEGREES(numeric_expression) —把弧度转换为角度返回与表达式相同的数据类型可为INTEGER/MONEY/REAL/FLOAT 类型RADIANS(numeric_expression) —把角度转换为弧度返回与表达式相同的数据类型可为INTEGER/MONEY/REAL/FLOAT 类型EXP(float_expression) —返回表达式的指数值LOG(float_expression) —返回表达式的自然对数值LOG10(float_expression)—返回表达式的以为底的对数值SQRT(float_expression) —返回表达式的平方根 取近似值函数 CEILING(numeric_expression) —返回&gt;=表达式的最小整数返回的数据类型与表达式相同可为INTEGER/MONEY/REAL/FLOAT 类型FLOOR(numeric_expression) —返回&lt;=表达式的最小整数返回的数据类型与表达式相同可为INTEGER/MONEY/REAL/FLOAT 类型ROUND(numeric_expression) —返回以integer_expression 为精度的四舍五入值返回的数据类型与表达式相同可为INTEGER/MONEY/REAL/FLOAT 类型ABS(numeric_expression) —返回表达式的绝对值返回的数据类型与表达式相同可为INTEGER/MONEY/REAL/FLOAT 类型SIGN(numeric_expression) —测试参数的正负号返回零值正数或-1 负数返回的数据类型与表达式相同可为INTEGER/MONEY/REAL/FLOAT 类型PI() —返回值为π即.1415926535897936RAND([integer_expression]) —用任选的[integer_expression]做种子值得出 -1 间的随机浮点数 ——-字符串函数——- ASCII() —函数返回字符表达式最左端字符的ASCII 码值CHAR() —函数用于将ASCII 码转换为字符, 如果没有输入~ 255之间的ASCII 码值CHAR 函数会返回一个NULL 值LOWER() —函数把字符串全部转换为小写UPPER() —函数把字符串全部转换为大写STR() —函数把数值型数据转换为字符型数据LTRIM() —函数把字符串头部的空格去掉RTRIM() —函数把字符串尾部的空格去掉LEFT(),RIGHT(),SUBSTRING() —函数返回部分字符串CHARINDEX(),PATINDEX() —函数返回字符串中某个指定的子串出现的开始位置SOUNDEX() —函数返回一个四位字符码, SOUNDEX函数可用来查找声音相似的字符串但SOUNDEX函数对数字和汉字均只返回值DIFFERENCE() —函数返回由SOUNDEX 函数返回的两个字符表达式的值的差异 —0:两个SOUNDEX 函数返回值的第一个字符不同 —1:两个SOUNDEX 函数返回值的第一个字符相同 —2:两个SOUNDEX 函数返回值的第一二个字符相同 —3:两个SOUNDEX 函数返回值的第一二三个字符相同 —4:两个SOUNDEX 函数返回值完全相同同QUOTENAME() —函数返回被特定字符括起来的字符串 select quotename(‘abc’, ‘{‘),quotename(‘abc’) —运行结果如下: {abc} [abc]REPLICATE() —函数返回一个重复character_expression 指定次数的字符串 select replicate(‘abc’, 3),replicate( ‘abc’, -2) —运行结果如下: abcabcabc NULLREVERSE() —函数将指定的字符串的字符排列顺序颠倒REPLACE() —函数返回被替换了指定子串的字符串 select replace(‘abc123g’, ‘123’, ‘def’) —运行结果如下: abcdefgSPACE() —函数返回一个有指定长度的空白字符串STUFF() —函数用另一子串替换字符串指定位置长度的子串 ——-数据类型转换函数——- CAST() 函数 语法：CAST() ( AS [ length ]) CONVERT() 函数 语法：CONVERT() ([ length ], [, style]) select cast(100+99 as char),convert(varchar(12), getdate())—运行结果如下: 199 10 17 2012 ——-日期函数——- DAY() —函数返回date_expression 中的日期值MONTH() —函数返回date_expression 中的月份值YEAR() —函数返回date_expression 中的年份值DATEADD( , ,) —函数返回指定日期date 加上指定的额外日期间隔number 产生的新日期DATEDIFF( , ,) —函数返回两个指定日期在datepart 方面的不同之处DATENAME( , ) —函数以字符串的形式返回日期的指定部分DATEPART( , ) —函数以整数值的形式返回日期的指定部分GETDATE() —函数以DATETIME 的缺省格式返回系统当前的日期和时间—取某年某月的 第一天和最后一天 以当前日期为例—当月天数select day(dateadd(ms,-3,DATEADD(m, DATEDIFF(m,0,getdate())+1,0)))—-当月第一天select dateadd(d,-day(getdate())+1,getdate())—-当月最后一天select dateadd(d,-day(getdate()),dateadd(m,1,getdate()))—明年上月的最后一天此时select dateadd(d,-day(getdate()),dateadd(m,12,getdate()))—当月第一个星期一SELECT DATEADD(wk, DATEDIFF(wk, ‘’, DATEADD(dd, 6 - DAY(getdate()), getdate())), ‘’) ——-系统函数——- APP_NAME() —函数返回当前执行的应用程序的名称COALESCE() —函数返回众多表达式中第一个非NULL 表达式的值COL_LENGTH(&lt;’table_name’&gt;, &lt;’column_name’&gt;) —函数返回表中指定字段的长度值COL_NAME(, ) —函数返回表中指定字段的名称即列名DATALENGTH() —函数返回数据表达式的数据的实际长度DB_ID([‘database_name’]) —函数返回数据库的编号DB_NAME(database_id) —函数返回数据库的名称HOST_ID() —函数返回服务器端计算机的名称HOST_NAME() —函数返回服务器端计算机的名称IDENTITY([, seed increment]) [AS column_name]) —IDENTITY() 函数只在SELECT INTO 语句中使用用于插入一个identity column列到新表中 select identity(int, 1, 1) as column_name into newtable from oldtableISDATE() —函数判断所给定的表达式是否为合理日期 SELECT ISDATE(GETDATE()) —运行结果为：1ISNULL(, ) —函数将表达式中的NULL 值用指定值替换ISNUMERIC() —函数判断所给定的表达式是否为合理的数值NEWID() —函数返回一个UNIQUEIDENTIFIER 类型的数值 select NEWID() —运行结果为：D9F0E16E-DABF-4170-916F-0660A9B7EAF5NULLIF(, ) —NULLIF 函数在expression1 与expression2 相等时返回NULL 值若不相等时则返回expression1 的值 SELECT NULLIF(‘dsssdsadasdasdd’,’dsssdsadasdasdd’) —运行结果为：NULL]]></content>
      <categories>
        <category>数据库</category>
        <category>课程设计_12</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Datebase丶KS----相信自己，努力走出舒服区|改变时间空间扭曲作用域！]]></title>
    <url>%2Fpost%2Fd648d87d.html</url>
    <content type="text"><![CDATA[引言 tsql 疑问解析 多网页链接 Transact-SQL语言 常用语言及入门函数 sqlserver语言大全 SQL Server为了完善数据库的管理机制，设计了严格的命名规则。用户在创建数据库及数据库对象时必须严格遵守SQL Server的命名规则。 在定义标识符时必须遵守以下规定： （1）标识符的首字符必须是下列字符之一。 þ 统一码（Unicode）2.0标准中所定义的字母，包括拉丁字母a-z和A-Z，以及来自其他语言的字符。下划线“_”、符号“@”或者数字符号“#”。 （2）标识符的后续字符可以是以下3种。 þ 统一码（Unicode）2.0标准中所定义的字母。 来自拉丁字母或其他国家/地区脚本的十进制数字。 “@”符号、美元符号“$”、数字符号“#”或下划线“_”。 （3）标识符不允许是Transact-SQL的保留字。 （4）不允许嵌入空格或其他特殊字符。 SQL Server 2008的数据库对象的名字由1～128个字符组成，不区分大小写。使用标识符也可以作为对象的名称。 SQL Server 2008提供了两种类型的实例：默认实例和命名实例。 通配符：匹配指定范围内或者属于方括号所指定的集合中的任意单个字符。可以在涉及模式匹配的字符串比较（例如，LIKE 和 PATINDEX）中使用这些通配符。 在SQL中通常用LIKE关键字与通配符结合起来实现模糊查询。其中SQL支持的通配符如表所示。 剩下的详见 word！！！我的云盘-数据库T-SQL 8 章 数据语言操作 数据库、数据表、数据、视图 9 查询 10 存储过程和触发器 11索引和数据完整性 12游标 13SQL函数 14SQL事务 项目开发！ SQL Server中,Numric,Decimal,Money三种字段类型的区别 都是精确数据类型， 前两个可以自己定义长度和小数位数， Money的定义相当于Numric(19,4) numeric(10,2) 表示最大可以放10位数，但这10位数里有2位是小数如： 12345678.12 numeric 功能上等同于 decimal。 sql server的 money 类型其实就是小数类型 decimal 。 字节数 长度(小数点前.小数点后) money 8 15位.4位 decimal(19,4) 9 15位.4位(千万亿以下) smallmoney 4 6位.4位 decimal(10,4) 9 6位.4位(百万以下) decimal(9,4) 5 5位.4位(十万以下) decimal与money同样的长度与精度，但decimal占用字节数要比money多1个字节（比smallmoney更是要多5个字节），为了通用与标准，建议直接用decimal，牺牲一点硬盘不算啥。 其他常见类型 整理目前用到的函数1. substring(string,startIndex, length) select substring (‘2013-08-26 14:30:01.543’ ,1 ,10 ) 结果：2013-08-26 2.dateadd(yy/mm/dd年或月或日,日期加减，日期) select dateadd (dd ,-10 ,getdate ()) 结果：2013-08-26 14:37:42.543 3.convert(varchar(50), string, 120) select convert (nvarchar (30 ),’2013-08-26 14:39:53.857’,120) 结果：2013-08-26 14:39:53.857 转换日期和字符串的函数 4. datename(day/month/weekday, 时间) select datename (weekday , getdate()) 结果：Thursday group by 有一个原则, 就是 select 后面的所有列中,没有使用聚合函数的列,必须出现在 group by 后面 sql中char(9) char(10) char(13)分别代表哪个字符 可以直接用语句查 select char(9) ,char(10), char(13) 查出来全是空白~ 那就查ASCII表吧~ char(9) 水平制表符 char(10)换行键 char(13)回车键char(9) :tab char(10) ：换行 char(13)：回车 一般char(10)char(13)连着用，表示0x0A0x0D,即一个完整的回车换行。 sql 执行顺序： from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by -&gt; top 数据库 面向对象 网络编程、思想 界面.业务逻辑 mysql sqlserver 数据库是衡量一个程序员的技术指标！ 标准、服务、产品、项目]]></content>
      <categories>
        <category>数据库</category>
        <category>课程设计_12</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统课程设计_模拟UNIX/Linux 文件系统]]></title>
    <url>%2Fpost%2Fa297ff69.html</url>
    <content type="text"><![CDATA[1.什么是索引节点? 索引节点是一个结构，它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。一个文件系统维护了一个索引节点的数组，每个文件或目录都与索引节点数组中的唯一一个元素对应。系统给每个索引节点分配了一个号码，也就是该节点在数组中的索引号，称为索引节点号。 2. 索引节点与文件的关系 Linux 为每个文件分配一个称为索引节点的号码inode，可以将inode简单理解成一个指针，它永远指向本文件的具体存储位置。_系统是通过索引节点(而不是文件名)来定位每一个文件_。文件系统处理文件所需要的所有信息都放在称为索引节点的数据结构中。文件名可以随时更改，但是索引节点对文件是唯一的，并且随文件的存在而存在。 一个文件系统允许的inode节点数是有限的，如果文件数量太多，即使每个文件都是0字节的空文件，系统最终也会因为_节点空间耗尽_而不能再创建文件。所以当发现不能建立文件时首先要考虑硬盘数据区是否还有空间(可通过du命令)，其次还得检查节点空间。 Linux之所以能支持多种文件系统，其实是由于Linux提供了一个虚拟文件系统VFS，VFS作为实际文件系统的上层软件，掩盖了实际文件系统底层的具体结构差异，为系统访问位于不同文件系统的文件提供了一个统一的接口。实际上许多文件系统并不具备inode结构，其目录结构也和以上的讨论不同，但通过VFS，系统均为其提供了虚拟一致的inode和目录项结构。所以，’ls -il’命令实际显示的inode应该是VFS inode，也就是说，inode是存在于内存中的数据结构，而不一定是实际的硬盘结构。但为Linux量身定做的ext2文件系统具备实际的inode 和连接型目录项结构.有一个inode, 就可以有一个文件, fs中有多少inode,就可以有多少file. inode又有单字节和多字节之分(由文件系统的类型和单个文件的大小决定). inode在建fs时同时开出, 开多少? 这由nbpi(平均每节点管理多大文件)和fs的大小决定. fs建好后,想增加inode,只能扩fs, 而且nbpi无法改变. 反之, 每当扩fs, inode也相应增加.因此, 由于jfs能管理的inode数为16M(2的24次方), 当nbpi确定时, fs的最大值也定了. 关于C语言的文件操作 realRead = fread(buf,item,count,fp) （每次读item大小的数据块，分count次来读。） fread（从文件流读取数据） 表头文件 #include 定义函数 size_t fread(void ptr,size_t size,size_t count,FILE stream); 函数说明 fread()用来从文件流中读取数据。参数stream为已打开的文件指针，参数ptr 指向欲存放读取进来的数据空间，读取的字节数以参数size*count来决定。 Fread()会返回实际读取到的count数目，如果此值比参数count来得小，则代表可能读到了文件尾了或者有错误发生(前者几率大)，这时必须用feof()或ferror()来决定发生什么情况。 返回值 返回实际读取到的count数目。 fread返回的不是字节数， 当且仅当下面这么用的时候，返回值才是字节数（当然因为恰好一个数据块大小为1个字节，相当于realRead*1） char buff[size]; FILE *fp; … realRead = fread(buff, 1, size, fp); … 如果是: fread(buff, size, 1, fp) 返回1表示读取了size字节，返回0表示读取数量不够size字节]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CET6-冲刺刷题计划]]></title>
    <url>%2Fpost%2F9bbc0ae3.html</url>
    <content type="text"><![CDATA[CET6-冲刺刷题计划。 Fire！Record… 1.娱乐度假 aerobics 英 [eəˈrəʊbɪks] 有氧运动 admission price 入场费 artwork catch some rays 晒太阳 highlights of the place 值得一游的地方 package trip 跟团旅游 scenic resort ˈsi:nɪk 旅游胜地 rehearse 英 [rɪˈhɜ:s] 彩排排练 service counter 服务台 2.购物消费 down payment 首付款 catalog ‘kætəlɔ:g 商品目录 fitting room 试衣间 cosmetics kɒz’metɪks 化妆品 free of charge 免费 deliver 送货 deposit 押金 pay by installment 分期付款 refund 退款 stripe 条纹 3.生病看病 allergy ˈælədʒi 过敏 clinic ˈklɪnɪk 诊所 be as fit as a fiddle ˈfɪdl 身体非常好 contagion 英 [kənˈteɪdʒən] 美 [kənˈtedʒən] n. 传染;接触传染;道德败坏;歪风 drowsy 英 [ˈdraʊzi] 美 [ˈdraʊzi] adj. 昏昏欲睡的;沉寂的;催眠的;呆滞的 fracture 英 [ˈfræktʃə(r)] 美 [ˈfræktʃɚ] vt.&amp; vi. （使）折断，破碎 n. 骨折;破裂，断裂 prescription 英 [prɪˈskrɪpʃn] 美 [prɪˈskrɪpʃən] n. 处方药;[医]药方，处方;训令，指示;法规 insomnia 英 [ɪnˈsɒmniə] 美 [ɪnˈsɑ:mniə] n. [医]失眠，失眠症 chill 英 [tʃɪl] 寒冷( chill的名词复数 ); stuffed up nose 英 [stʌft ʌp nəuz] 美 [stʌft ʌp noz] 鼻堵塞 4.选课 assistantship 英 [əˈsɪstəntʃɪp] 助学金 credit course 有学分的课程 commencement 英 [kəˈmensmənt] 美 [kəˈmɛnsmənt] n. 开始;毕业典礼; 开端; 学位授予典礼 required course 必修课 curriculum 课程 course sheet 选课单 credit course 有学分的课程 bachelor’s degree 学士学位 auditor 旁听生 5.学生 freshman 大一学生 sophomore 大二学生 junior student 大三学生 senior student 大四学生 border 住宿生 6.教师 academic 大学教师 lecturer 讲师 coordinator 班主任 director 高中校长 7.考试 make up an exam 补考 brush up 复习 cram for 死记硬背 competitive examinition 答辩考试 make preparations at the last moment 临阵磨枪 8. 求职面试 vacancy 英 [ˈveɪkənsi] 美 [ˈvekənsi] n. 空缺;空位;空白;空虚 handcraft 手艺，技艺 trade 行业 lay-off 裁员 assembly line work 流水线 assembly 英 [əˈsembli] 美 [əˈsɛmbli] n. 装配;集会;议会;立法机构 9.职位职务 public servant 公务员 newscaster 新闻评论人 cashier 出纳 druggist 药剂师 deputy general management deputy 英 [ˈdepjuti] 美 [ˈdɛpjəti] n. 代表;副手;代理人 adj. 副的;代理的 copywriter 撰稿人 business controller 业务主任 10.旅游 outbound tourist 出境游客 backpacker 背包旅行者 excursion 远足 traveler’s cheque 旅行支票 11.住宿 motel 英 [məʊˈtel] 美 [moʊˈtel] n. 汽车旅馆 honeymoon suite 蜜月套房 porter 行李员 trunk 大衣箱 light luggage 轻便行李 advance deposit 定金 receipt 收据 check out 结账离开 12.交通 carriage 车厢 airline operation 航空业务 intersection ˌɪntəˈsekʃn 十字路口 transfer 转车 shuttle 英 [ˈʃʌtl] 美 [ˈʃʌtl] n. 航天飞机 shuttle bus 机场内来来往巴士 visitor terrace 迎送平台 terrace 英 [ˈterəs] 美 [ˈtɛrɪs] return-trip ticket 往返票 safety inspection 安检 landing field 停机坪]]></content>
      <categories>
        <category>日记之家</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汇编语言_简单入门相关_zcylkcsj]]></title>
    <url>%2Fpost%2F305ad71c.html</url>
    <content type="text"><![CDATA[关于汇编语言的CPTH机的一点学习记录 简要复习常用的汇编指令： ·堆栈相关指令 对于指令的详细了解，应该查阅Intel发布的指令手册。但是从头开始阅读那些手册是一件令人望而生畏的事情。读者暂时可以只初步了解，忽略一些细节，当实际用到的时候，再具体查阅相关指令。 push：把一个32位的操作数压入堆栈中。这个操作导致esp被减4。Esp被形象地成为栈顶。我们认为顶部是地址小的区域，那么，压入堆栈的数据越多，这个堆栈也就越堆越高，esp也就越来越小。在32位平台上，esp每次减少4字节。 pop：相反，esp被加4，一个数据出栈。Pop的参数一般是一个寄存器，栈顶的数据被弹出到这个寄存器中。 一般不会把sub、add这样的算术指令，以及call、ret这样的跳转指令归入堆栈相关指令中。但是实际上在函数参数传递过程中，sub和add是最常用来操作堆栈；call和ret对堆栈也有影响。所以这里做特殊处理。 sub：减法。第一个参数是被减数所在的寄存器；第二个参数是减数。（对应的还有add指令。） add：加法。 ret：返回。相当于跳转回调用函数的地方。（对应的call指令来调用函数，返回到call之后的下一条指令。） call：调用函数。 说道这里，有必要详述一些指令对堆栈的影响。某些指令会“自动”地操作堆栈，这就是call和jmp的不同之处。Call指令会把它的下一条指令的地址压入堆栈中，然后跳转到它调用的函数的开头处；而单纯的jmp是不会这样做的。同时，ret会自动地弹出返回地址。 （小提示：call的本质相当于push+jmp。ret的本质相当于pop+jmp） 不但push、pop、call和ret会操作堆栈，sub和add也可以用于操作堆栈。如果我们要一次在堆栈中分配4个4字节长整型空间，那么没有必要4次调用push，很简单地把esp减去44=16即可。当然，也可以同样地用add指令来恢复它。这常常用于分配函数局部变量空间，因为C语言函数的局部变量保存在堆栈里。 ··*数据传送指令 mov：数据移动。第一个参数是目的，第二个参数是来源。在C语言中相当于赋值号。这是最广为人知的指令。 xor：异或。这虽是逻辑运算指令，但是有趣的是，xor eax，eax这样的操作常常用来代替mov eax，0。好处是速度更快，占用字节数更少。 lea：取地址（第二个参数）后放入到前面的寄存器（第一个参数）中。 （小提示：见到xor eax，eax，应该马上明白这是清零操作。） 但是实际上，有时候用lea用来做和mov同样的事情，比如赋值。看下面一条指令： lea dei,[ebp-0cch] 方括弧表示存储器，也就是ebp-0cch这个地址所指向的存储内容。但是lea要求取[ebp-0cch]的地址，那么地址就是ebp-0cch，这个地址将被放入到edi中。换句话说，这等同于： mov dei,ebp-0cch 但是以上mov指令是错误的，因为mov不支持后一个操作数写成寄存器减去数字。但是lea支持，所以可以用lea来代替它。 指令的操作数能采用的运算符号有非常复杂的限制。如果需要使用，应该查询指令手册。 为了讲解stos，下面解说前面提到的代码： mov ecx,30h mov eax,0cccccccch rep stos dword ptr es:[edi] Stos是串存储指令，它的功能是将eax中的数据放入edi所指的地址中，同时，edi会增加4（字节数）。Rep使指令重复执行ecx中填写的次数。方括弧表示存储器，这个地址实际上就是edi的内容所指向的地址。这里的stos其实是对应的stosd，其他还有stosb、stosw，分别对应于处理4、1、2个字节，这里对堆栈中30h4（0c0h）个字节初始化为0cch（也就是int3指令的机器码），这样发生意外时执行堆栈里面的内容会引发调试中断。 *···跳转与比较指令 部分跳转指令如下： jmp：无条件跳转。这也是多年后我依然未忘记的少量指令之一。 jg：顾名思义，大于的时候跳转。通常前面有一条比较指令。 jl：顾名思义，小于的时候跳转。通常前面有一条比较指令。 jge：顾名思义，大于等于的时候跳转。通常前面有一条比较指令。 类似的指令还有一些，这里就不介绍了。 下面介绍一条比较指令。 cmp：顾名思义，比较。往往是jg、jl、jge之类的条件跳转指令的执行条件。 [caption id=”attachment_646” align=”alignnone” width=”607”] 1. 对战说明一般用于：组成原理、操作系统的保护；还用于数据指令。bakke：堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，队列优先,先进先出（FIFO—first in first out）[1] 。栈，先进后出(FILO—First-In/Last-Out)。[/caption] 2. 二进制是b（binary），十六进制是h（hexdecimal）。十进制一般不需标示，特殊情况下需要区分时标注d（decimal）。 3. 补充对于 汇编语言加中括号表示什么 例如ADD AL,［SI］ MOV［20H］,AL还有小括号呢 例如DS＝（SI＋2）一般说来,加方括号 [ ] 表示一种间接的取操作数方式,有点类似于C语言中的指针概念. 第一条指令 ADD AL ,[SI] 中,[SI] 表示寄存器间接寻址. 也就是说,与AL中内容相加的加数,不是SI寄存器的内容,而是以SI的内容作为地址指针的内存操作数. 假设SI的内容是1234H,这条加法指令,不是将1234H加到AL里（也加不了,数据类型不对）,而是以1234H作为地址,从内存的数据段（DS所指）中,段内偏移地址为1234H的那个内存单元中取出一个字节的数据来,加到AL中. 同样的,第二条指令 MOV [20H],AL,是将AL中的内容传送到内存里的一个单元中去.这个单元的有效地址就是[20H]. 这里,加了方括号的20H,不是运算所用的数据,而是数据的地址. ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 对问题补充的回复： AL是不可能加方括号的. 8086汇编中,能加方括号的只有4个寄存器：SI,DI,BX,BP 常数也可以加方括号,比如 [020H] 另外,变量名可以加方括号,但与上面两种情况不同,加了方括号的变量名,意义不变. 至于方括号内,可以出现BX+DI,SI+2这样的表达式,这是一些不同的寻址方式. SI 是寄存器寻址 [SI]是寄存器间接寻址 [SI+2]是相对的寄存器间接寻址,又称直接变址寻址,它也可以写成2[SI]这样的形式 [BX+SI]是基址变址寻址,也可写成[BX][SI] [BX+SI+20H]是相对的基址变址寻址,可以写成20H[BX][SI]之类的形式,将20H换成变量名也可以. mov ax, [bx]；该指令中，bx中存储的值为一个偏移地址，该指令是将bx中存储的数据段偏移地址所对应的存储器中的值传送给ax。mov ax，bx是把bx中存储的值传送给ax不能互换 --- c:\\users\\acanprince\\desktop\\文档_ssd\\2017_春\\zuchengyuanli\\zuchengyuanli\\main.c include int main(){00851680 push ebp00851681 mov ebp,esp00851683 sub esp,108h00851689 push ebx0085168A push esi0085168B push edi0085168C lea edi,[ebp-108h]00851692 mov ecx,42h00851697 mov eax,0CCCCCCCCh0085169C rep stos dword ptr es:[edi] int a[10] = {25,-12,16,38,-22,56,46,109,127,-1};0085169E mov dword ptr [a],19h008516A5 mov dword ptr [ebp-28h],0FFFFFFF4h008516AC mov dword ptr [ebp-24h],10h008516B3 mov dword ptr [ebp-20h],26h008516BA mov dword ptr [ebp-1Ch],0FFFFFFEAh008516C1 mov dword ptr [ebp-18h],38h008516C8 mov dword ptr [ebp-14h],2Eh008516CF mov dword ptr [ebp-10h],6Dh008516D6 mov dword ptr [ebp-0Ch],7Fh008516DD mov dword ptr [ebp-8],0FFFFFFFFh int i = 0,sum = 0;008516E4 mov dword ptr [i],0008516EB mov dword ptr [sum],0 for (; i &lt; 10; i++)008516F2 jmp main+7Dh (08516FDh)008516F4 mov eax,dword ptr [i]008516F7 add eax,1008516FA mov dword ptr [i],eax008516FD cmp dword ptr [i],0Ah00851701 jge main+92h (0851712h) { sum += a[i];00851703 mov eax,dword ptr [i]00851706 mov ecx,dword ptr [sum]00851709 add ecx,dword ptr a[eax*4]0085170D mov dword ptr [sum],ecx }00851710 jmp main+74h (08516F4h) return 0;00851712 xor eax,eax}00851714 push edx00851715 mov ecx,ebp00851717 push eax00851718 lea edx,ds:[85172Ch]0085171E call @_RTC_CheckStackVars@8 (0851244h)00851723 pop eax00851724 pop edx00851725 pop edi00851726 pop esi00851727 pop ebx00851728 mov esp,ebp0085172A pop ebp0085172B ret0085172C add dword ptr [eax],eax0085172E add byte ptr [eax],al00851730 xor al,17h00851732 test dword ptr [eax],eax00851734 aamb 0FFh00851736 ?? ??00851737 jmp fword ptr [eax]00851739 add byte ptr [eax],al0085173B add byte ptr [eax+17h],al0085173E test dword ptr [eax],eax00851740 popad00851741 add ah,cl--- 无源文件 ———————————————————————————————————- 有关于课程设计：1. MOV R2,#0A2. loop: - MOV a,R2 - ADD a,#7F //数据段起始地址 - MOV R3,a - MOV a,@R3 - ADDC a,#80 JC ##; //判断正负 MOV a,@R3 ADD a,R1 MOV R1,a MOV a,#00 ADDC a,R0 MOV R0,a MOV a,R2 SUB a,#01 JZ out; //跳出的 MOV R2,a JMP loop; :MOV a,@R3 SUB a,#80 CPL a ADD a,#1 ADD a,R1 MOV R1,a MOV a,#FF ADDC a,R0 MOV R0,a MOV a,R2 SUB a,#01 JZ out; //跳出的 MOV R2,a JMP loop; 3. out: MOV a,R0 ADD a,#80 JC ###; //THE END :MOV a,R0 CPL a MOV R0,a MOV a,R1 CPL a ADD a,#01 //低位 MOV R1,a MOV a,R0 ADDC a,#80 //+C +符号位 MOV R0,a; //负数取原码 结束 # 题目 10个单字节有符号数的加法，要求数组里面有负数且和的绝对值要大于255D，数据用源码表示，计算过程要求使用补码。# ————-代码段————00 8E //MOV R2, #0A01 0A02 72 //MOV A, R203 1C //ADD A, #7F04 7F05 83 //MOV R3, A06 77 //MOV A, @R307 1C //ADD A, #8008 8009 A0 //JC -&gt; 2610 2611 77 //MOV A, @R312 11 //ADD A, R113 81 //MOV R1, A14 7C //MOV A, #0015 0016 20 //ADDC A, R017 80 //MOV R0, A18 72 //MOV A, R219 3C //SUB A, #0120 0121 A4 //JZ -&gt; 4522 4523 82 //MOV R2, A24 AC //JMP -&gt; 0225 0226 77 //MOV A, @R327 3C //SUB A, #8028 8029 E4 //CPL A30 1C //ADD A, #0131 0132 11 //ADD A, R133 81 //MOV R1, A34 7C //MOV A, #FF35 FF36 20 //ADDC A, R037 80 //MOV R0, A38 72 //MOV A, R239 3C //SUB A, #0140 A4 //JZ -&gt; 4541 4542 82 //MOV R2, A43 AC //JMP -&gt; 0244 0245 70 //MOV A, R046 1C //ADD A, #8047 8048 A0 //JC -&gt; 5249 52505152 70 //MOV A, R053 E4 //CPL A54 80 //MOV R0, A55 71 //MOV A, R156 E4 //CPL A57 1C //ADD A, #0158 0159 81 //MOV R1, A60 70 //MOV A, R061 2C //ADDC A, #8062 8063 80 //MOV R0, A6465# ————-数据段————80 19 //25 0001 100181 8C //-12 1000 110082 10 //16 0001 000083 26 //38 0010 011084 96 //-22 1001 011085 38 // 56 0011 100086 2E //46 0010 111087 A1 //-33 1010 000188 6D //109 0110 110189 21 //33 0010 0001]]></content>
      <categories>
        <category>汇编语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TP5的php think 命令激发的--centos 修改文件及文件夹权限的操作详解。]]></title>
    <url>%2Fpost%2F27ef7655.html</url>
    <content type="text"><![CDATA[注意：对于用系统的命令创建的文件我们只能是 Others。而自己亲手创建的我们就是 user 查看文件权限的语句： 在终端输入: ls -l xxx.xxx （xxx.xxx是文件名） 那么就会出现相类似的信息，主要都是这些： -rw-rw-r— 一共有10位数 其中： 最前面那个 - 代表的是类型 中间那三个 rw- 代表的是所有者（user） 然后那三个 rw- 代表的是组群（group） 最后那三个 r— 代表的是其他人（other） 然后我再解释一下后面那9位数： r 表示文件可以被读（read） w 表示文件可以被写（write） x 表示文件可以被执行（如果它是程序的话） - 表示相应的权限还没有被授予 现在该说说修改文件权限了 在终端输入： chmod o w xxx.xxx 表示给其他人授予写xxx.xxx这个文件的权限 chmod go-rw xxx.xxx 表示删除xxx.xxx中组群和其他人的读和写的权限 其中： u 代表所有者（user） g 代表所有者所在的组群（group） o 代表其他人，但不是u和g （other） a 代表全部的人，也就是包括u，g和o r 表示文件可以被读（read） w 表示文件可以被写（write） x 表示文件可以被执行（如果它是程序的话） 其中：rwx也可以用数字来代替 r ——————4 w —————-2 x ——————1 - ——————0 行动： 表示添加权限 - 表示删除权限 = 表示使之成为唯一的权限 当大家都明白了上面的东西之后，那么我们常见的以下的一些权限就很容易都明白了： -rw———- (600) 只有所有者才有读和写的权限 -rw-r—r— (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限 -rwx——— (700) 只有所有者才有读，写，执行的权限 -rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限 -rwx—x—x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限 -rw-rw-rw- (666) 每个人都有读写的权限 -rwxrwxrwx (777) 每个人都有读写和执行的权限 Linux文件和目录访问权限设置（二） 2009年02月16日 星期一 下午 12:54 五、使用chmod和数字改变文件或目录的访问权限 文件和目录的权限表示，是用rwx这三个字符来代表所有者、用户组和其他用户的权限。有时候，字符似乎过于麻烦，因此还有另外一种方法是以数字来表示权限，而且仅需三个数字。 r: 对应数值4 w: 对应数值2 x：对应数值1 －：对应数值0 数字设定的关键是mode的取值，一开始许多初学者会被搞糊涂，其实很简单，我们将rwx看成二进制数，如果有则有1表示，没有则有0表示，那么rwx r-x r- -则可以表示成为： 111 101 100 再将其每三位转换成为一个十进制数，就是754。 例如，我们想让a.txt这个文件的权限为： 自己 同组用户 其他用户 可读 是 是 是 可写 是 是 可执行 那么，我们先根据上表得到权限串为：rw-rw-r—，那么转换成二进制数就是110 110 100，再每三位转换成为一个十进制数，就得到664，因此我 们执行命令： [root@localhost ~]# chmod 664 a.txt 按照上面的规则，rwx合起来就是4 2 1＝7，一个rwxrwxrwx权限全开放的文件，数值表示为777；而完全不开放权限的文件“－－－－－－－－－”其数字表示为000。下面举几个例子： -rwx———:等于数字表示700。 -rwxr—r—:等于数字表示744。 -rw-rw-r-x:等于数字表示665。 drwx—x—x:等于数字表示711。 drwx———:等于数字表示700。 在文本模式下，可执行chmod命令去改变文件和目录的权限。我们先执行ls -l 看看目录内的情况： [root@localhost ~]# ls -l 总用量 368 -rw-r—r— 1 root root 12172 8月 15 23:18 conkyrc.sample drwxr-xr-x 2 root root 48 9月 4 16:32 Desktop -r—r—r— 1 root root 331844 10月 22 21:08 libfreetype.so.6 drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0 -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1 -rwxr-xr-x 1 root root 512 11月 5 08:08 net.lo drwxr-xr-x 2 root root 48 9月 6 13:06 vmware 可以看到当然文件conkyrc.sample文件的权限是644,然后把这个文件的权限改成777。执行下面命令 [root@localhost ~]# chmod 777 conkyrc.sample 然后ls -l看一下执行后的结果： [root@localhost ~]# ls -l 总用量 368 -rwxrwxrwx 1 root root 12172 8月 15 23:18 conkyrc.sample drwxr-xr-x 2 root root 48 9月 4 16:32 Desktop -r—r—r— 1 root root 331844 10月 22 21:08 libfreetype.so.6 drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0 -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1 -rwxr-xr-x 1 root root 512 11月 5 08:08 net.lo drwxr-xr-x 2 root root 48 9月 6 13:06 vmware 可以看到conkyrc.sample文件的权限已经修改为rwxrwxrwx 如果要加上特殊权限，就必须使用4位数字才能表示。特殊权限的对应数值为： s或 S （SUID）：对应数值4。 s或 S （SGID）：对应数值2。 t或 T ：对应数值1。 用同样的方法修改文件权限就可以了 例如： [root@localhost ~]# chmod 7600 conkyrc.sample [root@localhost ~]# ls -l 总用量 368 -rwS—S—T 1 root root 12172 8月 15 23:18 conkyrc.sample drwxr-xr-x 2 root root 48 9月 4 16:32 Desktop -r—r—r— 1 root root 331844 10月 22 21:08 libfreetype.so.6 drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0 -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1 -rwxr-xr-x 1 root root 512 11月 5 08:08 net.lo drwxr-xr-x 2 root root 48 9月 6 13:06 vmware 加入想一次修改某个目录下所有文件的权限，包括子目录中的文件权限也要修改，要使用参数－R表示启动递归处理。 例如： [root@localhost ~]# chmod 777 /home/user 注：仅把/home/user目录的权限设置为rwxrwxrwx [root@localhost ~]# chmod -R 777 /home/user 注：表示将整个/home/user目录与其中的文件和子目录的权限都设置为rwxrwxrwx 六、使用命令chown改变目录或文件的所有权 文件与目录不仅可以改变权限，其所有权及所属用户组也能修改，和设置权限类似，用户可以通过图形界面来设置，或执行chown命令来修改。 我们先执行ls -l看看目录情况： [root@localhost ~]# ls -l 总用量 368 -rwxrwxrwx 1 root root 12172 8月 15 23:18 conkyrc.sample drwxr-xr-x 2 root root 48 9月 4 16:32 Desktop -r—r—r— 1 root root 331844 10月 22 21:08 libfreetype.so.6 drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0 -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1 -rwxr-xr-x 1 root root 512 11月 5 08:08 net.lo drwxr-xr-x 2 root root 48 9月 6 13:06 vmware 可以看到conkyrc.sample文件的所属用户组为root，所有者为root。 执行下面命令，把conkyrc.sample文件的所有权转移到用户user: [root@localhost ~]# chown user conkyrc.sample [root@localhost ~]# ls -l 总用量 368 -rwxrwxrwx 1 user root 12172 8月 15 23:18 conkyrc.sample drwxr-xr-x 2 root root 48 9月 4 16:32 Desktop -r—r—r— 1 root root 331844 10月 22 21:08 libfreetype.so.6 drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0 -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1 -rwxr-xr-x 1 root root 512 11月 5 08:08 net.lo drwxr-xr-x 2 root root 48 9月 6 13:06 vmware 要改变所属组，可使用下面命令： [root@localhost ~]# chown :users conkyrc.sample [root@localhost ~]# ls -l 总用量 368 -rwxrwxrwx 1 user users 12172 8月 15 23:18 conkyrc.sample drwxr-xr-x 2 root root 48 9月 4 16:32 Desktop -r—r—r— 1 root root 331844 10月 22 21:08 libfreetype.so.6 drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0 -rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1 -rwxr-xr-x 1 root root 512 11月 5 08:08 net.lo drwxr-xr-x 2 root root 48 9月 6 13:06 vmware 要修改目录的权限，使用－R参数就可以了，方法和前面一样 【转自】Centos修改文件及文件夹权限]]></content>
      <categories>
        <category>CentOS</category>
        <category>ThinkPHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Toolbar + DrawerLayout快速实现高大上菜单侧滑]]></title>
    <url>%2Fpost%2F531e0109.html</url>
    <content type="text"><![CDATA[原文地址：《使用Toolbar + DrawerLayout实现高大上菜单侧滑》 如果你有在关注一些遵循最新的Material Design设计规范的应用的话（如果没有，假设你有！），也许会发现有很多使用了看起来很舒服、很高大上的侧滑菜单动画效果，示例如下（via 参考2）： 今天就来使用官方支持库来快速实现这类效果，需要使用到Toolbar和DrawerLayout，详细步骤如下：（如果你还不知道这两个Widget，先自己Google吧~） 1.首先需要添加appcompat-v7支持 如果是在Android Studio 1.0 RC4上创建的项目，默认已经添加了appcompat-v7支持了，如果不是最新版AS则需要在build.gradle中添加如下代码： dependencies { …//其他代码 compile ‘com.android.support:appcompat-v7:22.2.0’ } 添加完成后需要同步一下gradle 2.添加Toolbar 由于Toolbar是继承自View，所以可以像其他标准控件一样直接主布局文件添加Toolbar，但是为了提高Toolbar的重用效率，可以在layout创建一个custom_toolbar.xml代码如下： &lt;?xml version=”1.0” encoding=”utf-8”?&gt; &lt;android.support.v7.widget.Toolbarxmlns:android=”http://schemas.android.com/apk/res/android“ xmlns:app=”http://schemas.android.com/apk/res-auto“ android:id=”@+id/tl_custom” android:layout_width=”match_parent” android:layout_height=”wrap_content” android:background=”?attr/colorPrimary” android:minHeight=”?attr/actionBarSize” android:popupTheme=”@style/ThemeOverlay.AppCompat.Light” app:theme=”@style/ThemeOverlay.AppCompat.ActionBar”&gt; &lt;/android.support.v7.widget.Toolbar&gt; 说明： android.support.v7.widget.Toolbar - 当然如果只在Lollipop中可以直接使用Toolbar而不需要加上v7支持 xmlns:app - 自定义xml命名控件，在AS中可以直接指定res-auto而不需要使用完整包名 android:background 和 android:minHeight 均可以在styles.xml中声明 2.添加DrawerLayout 和Toolbar类似，为了提高代码重用效率，可以在layout中创建一个custom_drawerlayout.xml代码如下: &lt;?xml version=”1.0” encoding=”utf-8”?&gt; &lt;android.support.v4.widget.DrawerLayoutxmlns:android=”http://schemas.android.com/apk/res/android“ android:id=”@+id/dl_left” android:layout_width=”match_parent” android:layout_height=”match_parent”&gt; &lt;LinearLayout android:layout_width=”match_parent” android:layout_height=”match_parent”&gt; &lt;ImageView android:id=”@+id/iv_main” android:layout_width=”100dp” android:layout_height=”100dp”/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=”match_parent” android:layout_height=”match_parent” android:background=”#fff” android:layout_gravity=”start”&gt; &lt;ListView android:id=”@+id/lv_left_menu” android:layout_width=”match_parent” android:layout_height=”match_parent” android:divider=”@null” android:text=”DrawerLayout”/&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; Drawerlayout标签中有两个子节点，一个是左边菜单，一个是主布局，另外需要在左边菜单起始位置设置为android:layout_gravity=”start” 3.实现activity_main.xml &lt;LinearLayoutxmlns:android=”http://schemas.android.com/apk/res/android“ xmlns:tools=”http://schemas.android.com/tools“ android:layout_width=”match_parent” android:layout_height=”match_parent” android:orientation=”vertical” tools:context=”.MainActivity”&gt; &#105;&#x6e;&#x63;&#x6c;&#x75;&#100;&#101;&#x6c;&#x61;&#x79;&#x6f;&#x75;&#116;&#61;&#x22;&#x40;&#x6c;&#97;&#121;&#111;&#117;&#x74;&#x2f;&#99;&#117;&#x73;&#x74;&#111;&#x6d;&#x5f;&#x74;&#111;&#111;&#x6c;&#98;&#x61;&#x72;&#34;&#47; &#x69;&#x6e;&#x63;&#x6c;&#x75;&#x64;&#x65;&#108;&#97;&#121;&#111;&#117;&#x74;&#61;&#34;&#64;&#x6c;&#x61;&#121;&#x6f;&#117;&#116;&#47;&#x63;&#x75;&#115;&#x74;&#x6f;&#x6d;&#x5f;&#x64;&#x72;&#x61;&#119;&#x65;&#114;&#x6c;&#x61;&#x79;&#111;&#x75;&#x74;&#34;&#47; &lt;/LinearLayout&gt; 直接使用include标签，简洁明了 4.完善Java代码 publicclassMainActivityextendsActionBarActivity{ //声明相关变量 privateToolbar toolbar; privateDrawerLayout mDrawerLayout; privateActionBarDrawerToggle mDrawerToggle; privateListView lvLeftMenu; privateString[] lvs ={“List Item 01”,”List Item 02”,”List Item 03”,”List Item 04”}; privateArrayAdapter arrayAdapter; privateImageView ivRunningMan; privateAnimationDrawable mAnimationDrawable; @Override protectedvoid onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViews();//获取控件 //京东RunningMan动画效果，和本次Toolbar无关 mAnimationDrawable =(AnimationDrawable) ivRunningMan.getBackground(); mAnimationDrawable.start(); toolbar.setTitle(“Toolbar”);//设置Toolbar标题 toolbar.setTitleTextColor(Color.parseColor(“#ffffff”));//设置标题颜色 setSupportActionBar(toolbar); getSupportActionBar().setHomeButtonEnabled(true);//设置返回键可用 getSupportActionBar().setDisplayHomeAsUpEnabled(true); //创建返回键，并实现打开关/闭监听 mDrawerToggle =newActionBarDrawerToggle(this, mDrawerLayout, toolbar, R.string.open, R.string.close){ @Override publicvoid onDrawerOpened(View drawerView){ super.onDrawerOpened(drawerView); mAnimationDrawable.stop(); } @Override publicvoid onDrawerClosed(View drawerView){ super.onDrawerClosed(drawerView); mAnimationDrawable.start(); } }; mDrawerToggle.syncState(); mDrawerLayout.setDrawerListener(mDrawerToggle); //设置菜单列表 arrayAdapter =newArrayAdapter(this, android.R.layout.simple_list_item_1, lvs); lvLeftMenu.setAdapter(arrayAdapter); } privatevoid findViews(){ ivRunningMan =(ImageView) findViewById(R.id.iv_main); toolbar =(Toolbar) findViewById(R.id.tl_custom); mDrawerLayout =(DrawerLayout) findViewById(R.id.dl_left); lvLeftMenu =(ListView) findViewById(R.id.lv_left_menu); } } 5.当然比较重要还有styles.xml和colors.xml，具体如下 @color/Indigo_colorPrimaryDark&lt;/item&gt; @color/Indigo_colorPrimary&lt;/item&gt; @style/AppTheme.DrawerArrowToggle&lt;/item&gt; &lt;/style&gt; @android:color/white&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; &lt;?xml version=”1.0” encoding=”utf-8”?&gt; #303f9f&lt;/color&gt; #3f51b5&lt;/color&gt; #4675FF&lt;/color&gt; &lt;/resources&gt; 到此就实现了高大上菜单侧滑，最终效果如下（注：在Yosemite上貌似直接Record手机屏幕貌似不起作用，而且动画由于帧率原因无法实时，就先这样看吧~）]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017_6_1.也许真的，也许是真的]]></title>
    <url>%2Fpost%2F41eb85fa.html</url>
    <content type="text"><![CDATA[我们曾经 那么的勇敢。做什么也没有顾虑！现在，一个个的项目，却！ 做的畏手畏脚的，而且一旦交给你个 未知的事情，你却低估了自己！！ 还有就是 对于做事的过程中。没有掌握 自律！没有破釜沉舟！没有 断了后路！太”懦弱”了！ 吸取教训——总结经验！fighting!!!!!!!! 希望你 这学期末，能够发现自己的价值！发现自己的方向，知道自己 真正的价值观、真正该静下心来学习了！！！]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内存编址和关于按字寻址和按字节寻址的理解]]></title>
    <url>%2Fpost%2Ff76d9004.html</url>
    <content type="text"><![CDATA[字 word 字节 byte 位 bit 字长是指字的长度 1字=2字节(1 word = 2 byte) 如果是16位机器是可以这样说的， 1字节=8位(1 byte = 8bit) 一个字的字长为16 一个字节的字长是8 我们先从一道简单的问题说起！ 设有一个1MB容量的存储器，字长32位，问：按字节编址，字编址的寻址范围以及各自的寻址范围大小? 如果按字节编址，则 1MB = 2^20B 1字节=1B=8bit 2^20B/1B = 2^20 地址范围为0~(2^20)-1,也就是说需要二十根地址线才能完成对1MB空间的编码，所以地址寄存器为20位,寻址范围大小为2^20=1M 如果按字编址，则 1MB=2^20B 1字=32bit=4B 2^20B/4B = 2^18 地址范围为0~2^18-1，也就是说我们至少要用18根地址线才能完成对1MB空间的编码。因此按字编址的寻址范围是2^18 以上题目注意几点： 1.区分寻址空间与寻址范围两个不同的概念，寻址范围仅仅是一个数字范围，不带有单位 而寻址范围的大小很明显是一个数，指寻址区间的大小 而寻址空间指能够寻址最大容量，单位一般用MB、B来表示；本题中寻址范围为0~(2^20)-1,寻址空间为1MB。 2.按字节寻址，指的是存储空间的最小编址单位是字节，按字编址，是指存储空间的最小编址单位是字，以上题为例，总的存储器容量是一定的，按字编址和按字节编址所需要的编码数量是不同的，按字编址由于编址单位比较大（1字=32bit=4B），从而编码较少，而按字节编址由于编码单位较小（1字节=1B=8bit），从而编码较多。 3.区别M和MB。 M为数量单位。1024=1K，1024K=1M MB指容量大小。1024B=1KB，1024KB=1MB. 转自 http://blog.csdn.net/lishuhuakai/article/details/8934540 2. 内存编址 前面我们知道了DRAM颗粒以及内存模块是如何扩展字长和容量的。一个内存可能是8位，也可能是64位，容量可能是1M，也可能是1G。那么内存是如何编地的呢？和地址总线，计算机字长之间又有什么关系呢？ 2.1 字长 计算机在同一时间内处理的一组二进制数称为一个计算机的“字”，而这组二进制数的位数就是“字长”。。通常称处理字长为8位数据的CPU叫8位CPU，32位CPU就是在同一时间内处理字长为32位的二进制数据。 所以这里的字并不是我们理解的双字节（Word）而是和硬件相关的一个概念。一般来说计算机的数据线的位数和字长是相同的。这样从内存获取数据后，只需要一次就能把数据全部传送给CPU。 2.2 地址总线 前面我们已经介绍过地址总线的功能。地址总线的数量决定了他最大的寻址范围。就目前来说一般地址总线先字长相同。比如32位计算机拥有32为数据线和32为地线，最大寻址范围是4G（0x00000000 ~ 0xFFFFFFFF）。当然也有例外，Intel的8086是16为字长的CPU，采用了16位数据线和20位数据线。 2.3 内存编址 从前面我们知道一个内存的大小和它芯片扩展方式有关。比如我们内存模块是采用 16M*8bit的内存颗粒，那么我们使用4个颗粒进行位扩展，成为16M*32bit，使用4个颗粒进行字容量扩展变为64M*32bit。那么我们内存模块使用了16个内存颗粒，实际大小是256MB。 我们需要对这个256M的内存进行编址以便CPU能够使用它，通常我们多种编址方式： 按字编址： 对于这个256M内存来说，它的寻址范围是64M，而每个内存地址可以存储32bit数据。 按半字编址：对于这个256M内存来说，它的寻址范围是128M，而每个内存地址可以存储16bit数据。 按字节编址：对于这个256M内存来说，它的寻址范围是256M，而每个内存地址可以存储8bit数据。 对于我们现在的计算机来说，主要都是采用按字节编址的方式。所以我们可以把内存简单的看成一个线性数组，数组每个元素的大小为8bit，我们称为一个存储单元。这一点很重要，因为后面讨论的所有问题内存都是以按字节编址的方式。 这也是为什么对于32位计算机来说，能使用的最多容量的内存为4GB。如果我们按字编地址，能使用的最大内存容量就是16GB了。 于是很容易想到一个问题，为什么我们要采用字节编址的方式呢？关于这个问题，我在网上基本没有找到答案，甚至都找不到问这个问题的。所以这里没法给出答案，为什么为什么呢？ 麻烦知道的朋友告诉我哈。 另一方面的问题是，内存编址方式和DRAM芯片是否有关呢？ 我认为还是有一定关系。比如我DRAM的芯片是8M*8bit，那么芯片最小的存储单位就是8bit，那么我们内存编址就不能按照半个字节来编址。否则内存取出8bit，根本不知道你要那4bit传给CPU。也有一种说法是现在的DRAM芯片cell都是8bit，所以采用按字节编址。另一方面应该也和数据总线位宽有关。 字 word 字节 byte 位 bit 字长是指字的长度 1字=2字节(1 word = 2 byte) 如果是16位机器是可以这样说的， 1字节=8位(1 byte = 8bit) 一个字的字长为16 一个字节的字长是8 bps 是 bits per second 的简称。一般数据机及网络通讯的传输速率都是以「bps」为单位。如56Kbps、100.0Mbps 等等。 Bps即是Byte per second 的简称。而电脑一般都以Bps 显示速度，如1Mbps 大约等同 128 KBps。 bit 电脑记忆体中最小的单位，在二进位电脑系统中，每一bit 可以代表0 或 1 的数位讯号。 Byte一个Byte由8 bits 所组成，可代表一个字元(A~Z)、数字(0~9)、或符号(,.?!%&amp;+-*/)，是记忆体储存资料的基本单位，至於每个中文字则须要两Bytes。当记忆体容量过大时，位元组这个单位就不够用，因此就有千位元组的单位KB出现，以下乃个记忆体计算单位之间的相关性： 1 Byte = 8 Bits 1 KB = 1024 Bytes 1 MB = 1024 KB 1 GB = 1024 MB usb2.0标准接口传输速率。许多人都将“480mbps”误解为480兆/秒。其实，这是错误的，事实上“480mbps”应为“480兆比特/秒”或“480兆位/秒”，它等于“60兆字节/秒”，大家看到差距了吧。 这要从bit和byte说起：bit和byte同译为”比特”，都是数据量度单位，bit=“比特”或“位”。 byte=字节即1byte=8bits,两者换算是1：8的关系。 mbps=mega bits per second(兆位/秒)是速率单位，所以正确的说法应该是说usb2.0的传输速度是480兆位/秒,即480mbps。 mb=mega bytes(兆比、兆字节)是量单位，1mb/s（兆字节/秒）=8mbps（兆位/秒）。 我们所说的硬盘容量是40gb、80gb、100gb，这里的b指是的byte也就是“字节”。 1 kb = 1024 bytes =2^10 bytes 1 mb = 1024 kb = 2^20 bytes 1 gb = 1024 mb = 2^30 bytes 比如以前所谓的56kb的modem换算过来56kbps除以8也就是7kbyte，所以真正从网上下载文件存在硬盘上的速度也就是每秒7kbyte。 也就是说与传输速度有关的b一般指的是bit。 与容量有关的b一般指的是byte。 最后再说一点: usb2.0 480mbps=60mb/s的传输速率还只是理论值，它还要受到系统环境的制约（cpu、硬盘和内存等），其实际读、取写入硬盘的速度约在11～16mb/s。但这也比usb1.1的12mbps(1.5m/s)快了近10倍。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio_DayLearn]]></title>
    <url>%2Fpost%2Fc34d900e.html</url>
    <content type="text"><![CDATA[Installation failed with message INSTALL_FAILED_USER_RESTRICTED 出现这个错误是在我用魅族手机测试AS编写的代码时候出现的，我发现我新建一个项目之后还是会出现这个错误，然后换手机测试就不会出现这个错误了，那么就是手机的缘故了，然后就在网上查，发现别人也出现过这样的错误。 解决办法：打开手机管家—点击权限管理—点击USB安装管理—关闭USB安装管理，这样就不会再报错了。 小米手机出现类似的错误，也安装不上应用程序。 解决办法：打开开发者选项—-打开USB安装(允许通过USB安装应用) —- 运行一个开源的项目出现“minSdk(API 21) &gt; deviceSdk(API 17)”的提示，因为我用的是手机是sdk(API17)的，而项目要求是最低版本是minSdk(API 21)，在我的测试机上面是不能运行的 解决： 一、也就是最低版本是sdk17及以下，点开了build.gradle，将里面的minSdk改成17或者小于17即可。 注意点： 如果项目中用到了API 21及以上的东西，那么在运行的时候还是会报错的，提示你找不到资源，你只有这台测试机，你可以将使用到的地方做注释，也就是忽略使用api21那部分内容，项目就可以运行了，但如果你要看到完整项目效果，那么你只能找个其他手机，下面的方法。 二、那只能找一个API 21及以上的手机了，这个主要是项目中使用android5.0及以上特性。 只用用android5.0及以上的手机，你才能看到效果。 第三章 android studio 设备调试及Logcat查看 关于 R类错误问题——见书本第P75！ 如仍存在资源相关问题或其他问题，建议仔细阅读错误提示并检查布局文件。慌乱时往往会 找不出问题。休息冷静一下，再重新查看Android Lint报告的错误和警告，或许就能找出代码错 误或拼写输入错误。 如果上述操作无法解决问题，或是遇到Android Studio的使用问题，还可以访问网站 http://stackoverflow.com或本书论坛 http://forums.bignerdranch.com寻求帮助。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS3基础第一篇（圆角，阴影，渐变，选择器）]]></title>
    <url>%2Fpost%2F7800fc84.html</url>
    <content type="text"><![CDATA[CSS3基础第一篇（圆角，阴影，渐变，选择器）http://www.qdfuns.com/notes/31677/ded54ee5c37c534efa026f8f12c0ae2d:storey-3.html 彩色渐变 转自：CSS之弧形阴影 简述网页上经常会出现一些弧形的阴影效果，看起来很漂亮，下面我们来讲述下如何用CSS来实现一个弧形阴影。 简述 阴影 效果 注释 标题 效果 源码 合并 效果 源码 阴影效果 首先实现一个简单的阴影效果 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style type=&#39;text/css&#39;&gt; div { background: green; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); border-radius: 150px/10px; height: 20px; width: 400px; z-index: -1; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 注释box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5) 表示一个带外阴影的元素，阴影位置x轴偏移0，y轴偏移4px，模糊范围10px，阴影颜色rgba(0, 0, 0, 0.5) border-radius: 150px/10px 表示水平方向的半径和垂直方向的半径分别为150px、10px z-index: -1 z-index属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 拥有更低的优先级，可用于将在一个元素放置于另一元素之后。 注释：z-index 仅能在定位元素上奏效（例如 position:absolute;）！ 标题效果 源码设置背景色、字体、位置、行高等。下边框为蓝色部分可以暂时忽略，后面我们需要进行阴影显示用的。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style type=&#39;text/css&#39;&gt; body { /* 外边距：24像素 */ margin: 24px; } h1 { /* 背景色 */ background: #139573; /* 下边框：高4像素 实线 蓝色 */ border-bottom: 4px solid blue; /* 文本色：白色 */ color: #fff; /* 字体风格 */ font-family: sans-serif; /* 字体大小：24像素 */ font-size: 24px; /* 文本粗细：正常 */ font-weight: normal; /* 行高：80像素 */ line-height: 80px; margin: 0; /* 文本位置：相对定位 */ position: relative; /* 文本对齐方式：居中 */ text-align: center; } h1 strong { font-weight: bold; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; &lt;strong&gt;弧形阴影&lt;/strong&gt; - 这是一个简单的弧形阴影 &lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 合并效果 源码这里我们将阴影的背景变为透明色，然后设置位置和大小来实现我们的效果。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style type=&#39;text/css&#39;&gt; body { margin: 24px; } h1 { background: #139573; border-bottom: 4px solid #fff; color: #fff; font-family: sans-serif; font-size: 24px; font-weight: normal; line-height: 80px; margin: 0; position: relative; text-align: center; } h1 strong { font-weight: bold; } h1::before { background: transparent; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); border-radius: 800px/10px; bottom: -2px; content: &quot;&quot;; height: 8px; left: 2%; position: absolute; width: 96%; z-index: -1; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; &lt;strong&gt;弧形阴影&lt;/strong&gt; - 这是一个简单的弧形阴影 &lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; CSS中存在两个伪类:before 和 :after，它们特有的属性content ，用于在 CSS 渲染中向元素逻辑上的头部或尾部添加内容。注意这些添加不会改变文档内容，不会出现在 DOM 中，不可复制，仅仅是在 CSS 渲染层加入。 所以，我们只需要配合position: absolute ，就可以将其当成容器，拼合成弧形阴影效果。]]></content>
      <categories>
        <category>HTML+CSS_etc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[html+css—自适应webapp]]></title>
    <url>%2Fpost%2F4ff3f5dd.html</url>
    <content type="text"><![CDATA[代码学习到： 基础知识固然重要：视频、书、课上，之后线下查找 文档、博客；常练习，才不易忘。 自适应 class=“clear-float”，padding多次嵌套 宽度大体上用 百分比，别固定值。有的如图片的比例：用JS计算出来！ div 加 background: url(“/Uploads/2017-05-17/1494991746VGQE1.jpg”);background-size: 100%; commodityIntroduction .money {height: 1.9em; background: url(&quot;/static/images/index/RMB.svg&quot;) no-repeat **bottom left**; padding-left: 1.4em; background-size: 1.2em 1.2em; width: 70%; float: left; }这个进行了 一个div同时含有 图片和文字。 line-height: 1.9em;font-size: 1.5em; combos .options {/\*margin-top: 10px;\*/ }combos .options .option {width: 26%; height: 30px; float: left; padding: 15px 3.33% 0 3.33%; }combos .options .option .optionDetail {text-align: center; line-height: 30px; border: 1px solid grey; border-radius: 4px; font-size: 14px; } 先用一个container 确定width大小然后 photographerInfo .avatorContainer {width: 20%; /*与#photographerInfo的高度保持一致*/ height: 80px; float: left; } photographerInfo .avatorContainer .avator {height: 50px; width: 50px; float: right; background: url(&quot;/Uploads/2017-05-18/1495109515m3LRQ.jpeg&quot;) no-repeat; background-size: cover; border-radius: 25px; margin-top: 15px; } 转化 tabs switchContainer {margin-top: 4px; background-color: white; height: 46px; } switchContainer .details {/*与#switchContainer高度一致*/ height: 46px; width: 50%; float: left; -moz-box-sizing: border-box; /\*Firefox3.5+\*/ -webkit-box-sizing: border-box; /\*Safari3.2+\*/ -o-box-sizing: border-box; /\*Opera9.6\*/ -ms-box-sizing: border-box; /\*IE8\*/ box-sizing: border-box; border-right: 1px solid rgb(230, 230, 230); border-bottom: 1px solid rgb(230, 230, 230); line-height: 46px; text-align: center; font-size: 14px; } switchContainer .comments {/*与#switchContainer高度一致*/ height: 46px; width: 50%; float: left; _-moz-box-sizing: border-box; /*Firefox3.5+*/_ _-webkit-box-sizing: border-box; /*Safari3.2+*/_ _-o-box-sizing: border-box; /*Opera9.6*/_ _-ms-box-sizing: border-box; /*IE8*/_ _box-sizing: border-box;_ _border-bottom: 1px solid rgb(230, 230, 230);_ _line-height: 46px;_ _text-align: center;_ _font-size: 14px;_} switchContainer .active {border-top: 2px solid #fbd34f; line-height: 42px; } bottomContainer {width: 200%; position: relative; }]]></content>
      <categories>
        <category>HTML+CSS_etc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bootstrap_primary]]></title>
    <url>%2Fpost%2F727d5f13.html</url>
    <content type="text"><![CDATA[.text-muted：提示，使用浅灰色（#999） .text-primary：主要，使用蓝色（#428bca） .text-success：成功，使用浅绿色(#3c763d) .text-info：通知信息，使用浅蓝色（#31708f） .text-warning：警告，使用黄色（#8a6d3b） .text-danger：危险，使用褐色（#a94442） .text-left：左对齐☑ .text-center：居中对齐☑ .text-right：右对齐☑ .text-justify：两端对齐 选择器： CSS 选择器参考手册 CSS3 选择器在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。 “CSS” 列指示该属性是在哪个 CSS 版本中定义的。（CSS1、CSS2 还是 CSS3。） 选择器 例子 例子描述 CSS ._class_ .intro 选择 class=”intro” 的所有元素。 1 #_id_ firstname选择 id=”firstname” 的所有元素。 1 * * 选择所有元素。 2 _element_ p 选择所有 元素。 1 _element_,_element_ div,p 选择所有 元素和所有 元素。 1 _element_ _element_ div p 选择 元素内部的所有 元素。 1 _element_&gt;_element_ div&gt;p 选择父元素为 元素的所有 元素。 2 _element_+_element_ div+p 选择紧接在 元素之后的所有 元素。 2 [_attribute_] [target] 选择带有 target 属性所有元素。 2 [_attribute_=_value_] [target=_blank] 选择 target=”_blank” 的所有元素。 2 [_attribute_~=_value_] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 2 [_attribute_|=_value_] [lang|=en] 选择 lang 属性值以 “en” 开头的所有元素。 2 :link a:link 选择所有未被访问的链接。 1 :visited a:visited 选择所有已被访问的链接。 1 :active a:active 选择活动链接。 1 :hover a:hover 选择鼠标指针位于其上的链接。 1 :focus input:focus 选择获得焦点的 input 元素。 2 :first-letter p:first-letter 选择每个 元素的首字母。 1 :first-line p:first-line 选择每个 元素的首行。 1 :first-child p:first-child 选择属于父元素的第一个子元素的每个 元素。 2 :before p:before 在每个 元素的内容之前插入内容。 2 :after p:after 在每个 元素的内容之后插入内容。 2 :lang(_language_) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 元素。 2 _element1_~_element2_ p~ul 选择前面有 元素的每个 元素。 3 [_attribute_^=_value_] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 元素。 3 [_attribute_$=_value_] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 元素。 3 [_attribute_*=_value_] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 元素。 3 :first-of-type p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 3 :last-of-type p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 3 :only-of-type p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 3 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 元素。 3 :nth-child(_n_) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 3 :nth-last-child(_n_) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 3 :nth-of-type(_n_) p:nth-of-type(2) 选择属于其父元素第二个 元素的每个 元素。 3 :nth-last-of-type(_n_) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 3 :last-child p:last-child 选择属于其父元素最后一个子元素每个 元素。 3 :root :root 选择文档的根元素。 3 :empty p:empty 选择没有子元素的每个 元素（包括文本节点）。 3 :target news:target选择当前活动的 #news 元素。 3 :enabled input:enabled 选择每个启用的 元素。 3 :disabled input:disabled 选择每个禁用的 元素 3 :checked input:checked 选择每个被选中的 元素。 3 :not(_selector_) :not(p) 选择非 元素的每个元素。 3 ::selection ::selection 选择被用户选取的元素部分。 3 选择器： 属性选择器 伪选择器： 1.伪类选择器： CSS 伪类 属性 描述 CSS :active 向被激活的元素添加样式。 1 :focus 向拥有键盘输入焦点的元素添加样式。 2 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 1 :link 向未被访问的链接添加样式。 1 :visited 向已被访问的链接添加样式。 1 :first-child 向元素的第一个子元素添加样式。 2 :lang 向带有指定 lang 属性的元素添加样式。 2 2.伪元素选择器： CSS 伪元素 属性 描述 CSS :first-letter 向文本的第一个字母添加特殊样式。 1 :first-line 向文本的首行添加特殊样式。 1 :before 在元素之前添加内容。 2 :after 在元素之后添加内容。 2]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MaxHeap_KnapsackofBranchandBound]]></title>
    <url>%2Fpost%2Fb7004b30.html</url>
    <content type="text"><![CDATA[BB_Knapsack： （一） 1、分支限界法介绍 分支限界法类似于回溯法，也是在问题的解空间上搜索问题解的算法。一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出解空间中满足约束条件的所有解；而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 由于求解目标不同，导致分支限界法与回溯法对解空间的搜索方式也不相同。回溯法以深度优先的方式搜索解空间，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间。 分支限界法的搜索策略是，在扩展结点处，先生成其所有的儿子结点(分支)，然后再从当前的活结点表中选择下一扩展结点。为了有效地选择下一扩展结点，加速搜索的进程，在每一个活结点处，计算一个函数值(限界)，并根据函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间上有最优解的分支推进，以便尽快地找出一个最优解。这种方式称为分支限界法。人们已经用分支限界法解决了大量离散最优化的问题。 2、常见的两种分支限界法 队列式（FIFO）分支限界法：按照先进先出原则选取下一个节点为扩展节点。 活结点表是先进先出队列。LIFO分支限界法：活结点表是堆栈。 LC（least cost）分支限界法（优先队列式分支限界法）：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。 活结点表是优先权队列，LC分支限界法将选取具有最高优先级的活结点出队列，成为新的E-结点。 FIFO分支限界法搜索策略： §一开始，根结点是唯一的活结点，根结点入队。 §从活结点队中取出根结点后，作为当前扩展结点。 §对当前扩展结点，先从左到右地产生它的所有儿子，用约束条件检查，把所有满足约束函数的儿子加入活结点队列中。 §再从活结点表中取出队首结点（队中最先进来的结点）为当前扩展结点，……，直到找到一个解或活结点队列为空为止。 优先队列式分支限界法搜索策略： §对每一活结点计算一个优先级（某些信息的函数值）； §根据这些优先级从当前活结点表中优先选择一个优先级最高（最有利）的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。 §再从活结点表中下一个优先级别最高的结点为当前扩展结点，……，直到找到一个解或活结点队列为空为止。 3、解决01背包问题算法的思想 01背包问题状态空间树 （二） _问题描述_ 给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问:应如何选择装入背包的物品，使得装入背包中物品的总价值最大? 形式化描述：给定c &gt;0, wi &gt;0, vi &gt;0 , 1≤i≤n.要求找一n元向量(x1,x2,…,xn,), xi∈{0,1}, ∋ ∑ wi xi≤c,且∑ vi xi达最大.即一个特殊的整数规划问题。 _ 2. 算法设计_ 首先，要对输入数据进行预处理，将各物品依其_单位重量价值从大到小进行排列_。在优先队列分支限界法中，节点的优先级由已装袋的物品价值加上剩下的最大单位重量价值的物品装满剩余容量的价值和。 算法首先检查当前扩展结点的左儿子结点的可行性。如果该左儿子结点是可行结点，则将它直接加入到子集树和活结点优先队列中。当前扩展结点的右儿子结点一定是可行结点，仅当右儿子结点 满足上界约束时才将它加入子集树和活结点优先队列。当扩展到叶节点时为问题的最优值。 例如：0-1背包问题，当n=3时，w={16,15,15}, p={45,25,25}, c=30。优先队列式分支限界法：处理法则:价值大者优先。{}—&gt;{A}—&gt;{B,C}—&gt;{C，D，E}—&gt;{C，E}—&gt;{C，J，K}—&gt;{C}—&gt;{F，G}—&gt;{G，L，M}—&gt;{G，M}—&gt;{G}—&gt;{N，O}—&gt;{O}—&gt;{} 最大树的概念最大树是每个节点的值都要大于或等于其子节点的值的树。 而最大堆就是最大的完全二叉树。 因为最大堆是完全二叉树，所以拥有n个元素的堆的高度为[log2(n+1)]。 因此如果可以在O(height)的时间内完成插入和删除操作，则其复杂度为O(log2n)。 TIPS: 如将一棵有**_n_个结点的完全二叉树自顶向下，同一层自左向右连续给结点编号1, 2, …, _n_**，则有以下关系： 若**_i_ _=_ 1, 则 _i_ 无双亲** 若**_i_ > 1, 则 _i_ 的双亲为ë_i_／2**û 若**2*_i_ &lt;= _n_**, 则 _i_ 的左子女为 2*_i_**， 若**2*_i_**+1 &lt;= _n_**, 则 _i_ 的右子女为2*_i_**+1 若 _i_ 为奇数**, 且**_i_ != 1, 则其左兄弟为**_i_-1**, 若 若 _i_ 为偶数**, 且**_i_ != _n_**, 则其右兄弟为_i_+1** 下面是一个最大堆的图例。这里的第一层和第二层是标记第几层子节点，并不是树的第几层。 1.最大堆的插入：先来举个栗子说明最大堆的插入问题。 这是一个有五个元素的最大堆。 如果要插入一个元素，那么插入完成后的结构应该是这样才能保证依旧是完全二叉树： 如果插入的元素是1，那很简单，直接作为第二层的元素2的左孩子节点插入即可。 但是如果插入的元素是5，也就是比该插入位置的父节点大的话，就需要做一定的调整了。 应该把元素2下移为左孩子，同时在判断5能否占据元素2的位置。 因为520，不满足我们最大堆的要求，所以我们要做的事情和上次一样， 先将20移下一层： 再将25插入即可。插入完成： 下面来总结一下插入的操作。 插入算法首先要知道插入完成后的二叉树结构，然后再把要插入的元素一次调整到正确的位置。 插入策略从根到叶只有单一路径，每一层的工作耗时O(1)， 因此实现插入操作的时间复杂性为O(height)=O(log2n)。 2.最大堆的删除从最大堆中删除一个元素的时候，该元素从堆的根部移出。 以下图为例： 如果要从中删除元素21也就是移除堆顶元素。 必须移动最后的一个元素，也就是元素2，才能保证它依旧是一个完全二叉树。 这样确保它依旧是完全二叉树，但是元素2还没有放入堆中。 而根据堆的结构特性，2是不能直接插入根节点的， 可以先假设把元素二放在根节点： 则需要作一定的调整以便让它保持最大堆的特性。 因为根应当是堆的所有数据中最大的那个数， 也就是说，根元素应该是元素2，根的左孩子，根的右孩子三者中的最大者。 为什么呢？ 因为本来根的左孩子或右孩子应该是是堆中的第二大元素。 移除根之后必有一个是最大的元素，也就是根元素的合适人选。 现在再来看看栗子。 三者中的最大值是20，所以把它移到了根节点。 此时在20的原位置，也就是按次序编号的3位置形成一个空位， 由于该位置没有孩子节点，所以元素2可以插入。最后形成了删除完毕的最大堆： 下面再来举个栗子，在上面的最大堆里删除元素20。 删除之后的结构应该是这样的： 所以先把元素10移除。 如果直接把10放在根节点并不能形成最大堆。 所以把根节点的两个孩子15和2中较大的一个移到根节点。 移动完之后发现10还是不能插入，所以再把14往上移一层： 这样便会发现元素10可以插入了， 于是最终的最大堆如下图所示： 下面来总结一下删除的操作。 删除算法需要了解删除完成后的完全二叉树结构， 先移除最后一个节点，把要删除位置的两个孩子挑选最大的移动到根节点。 如果最后一个节点元素能插入则插入，否则重复上述操作直到能插入为止。 插入策略从根到叶只有单一路径，每一层的工作耗时O(1)， 因此实现插入操作的时间复杂性为O(height)=O(log2n)。 3.最大堆的初始化很多情况下我们是已经获取了一个有n个元素的无序数组，需要进行最大堆的初始化操作。 如果用一次插入的方法，构建非空最大堆，插入操作的总时间为O(log2n)。 下面介绍一下利用不同的策略在O(n)的时间里完成堆的初始化。 假设开始数组a[1:10]的关键值分别为[20，12，35，15，10，80，30，17，2，1]。&lt;详情见最上面的TIPS性质！&gt; 这些数值可以通过逐层输入的方法构成一棵完全二叉树： 接下来做的便是从下往上依次调整。 先来说一下大体思路。 为了将完全二叉树转化成最大堆，先从第一个具有孩子的节点下手（从下往上从后往前看 i为数组编号也是二叉树的顺序排序编号，根据这个性质即 是从数组找数组中的元素！）。 从图中来看就是节点10。这个元素在数组中的位置为i=[n/2]。 如果以此元素为根的子树已经是最大堆，则不需调整，否则必须调整使其成堆。 随后依次检查以i-1，i-2等节点为根的子树，直到检测到整个二叉树的根节点。 下面来看这个栗子。 第一次调整检验，i=5的时候： 此时这棵子树是满足最大堆的要求的，所以我们不用调整它。 接下来检查下一个节点，也就是i=4的情况： 因为15&lt;17，所以这棵子树不满足最大堆的条件。 为了把它变身成为最大堆，可以把子节点中最大的数与根节点元素交换， 也就是可用15与17交换，得到的树效果如下： 此时i=4的位置已经是最大堆了。接下来便是i=3的情况， 和前面几次一样，将35与其孩子节点中最大的元素交换即可： 如此这般，i=3便也解决了。那么当i=2的时候， 首先执行一次交换，确保了i=3为根的子树的前两层是最大堆： 下一步，将元素12与位置为4的节点的两个孩子中较大的一个元素进行比较。 由于12&lt;15，所以15被移到了位置4，12暂时移入了位置8。 因为8位置没有子节点，所以将12插入，完成这一步调整。 最后还剩i=1的情况： 当i=1时，此刻以i=2和i=3为根节点的子树们均已经是最大堆。 然后20&lt;(max[35,30]),所以把80作为最大根，把80移入1位置： 位置3空出，因为20&lt;(max[35,30])，所以元素35插入位置3，元素20插入元素6。 最终形成的最大堆如图所示： 总结一下初始化最大堆的过程， 大致就是从下往上依次检测所有子树是否为最大堆， 如果不是把他们调整成最大堆，并将子树的根节点放置到合适的位置不影响下面的子树的最大堆结构。 下面附上源码以供加深理解： ifndef MAXHEAP_Hdefine MAXHEAP_Hinclude include using namespace std;const int DefaultSize=50;template class MaxHeap{ // K为关键码的数据类型，E为记录的结构类型public: MaxHeap(int sz = DefaultSize);//构造函数：建立空堆 MaxHeap(E arr[], int n); //构造函数：通过一个数组建堆 ~MaxHeap() { delete []heap; } bool Insert(const E &amp;x); bool RemoveMax(E &amp;x); bool IsEmpty()const{ return currentSize == 0; } bool IsFull()const{ return currentSize == maxHeapSize; } void MakeEmpty(){ currentSize = 0; } void Swap(int i, int j){ E tmp = heap[i]; heap[i] = heap[j]; heap[j] = tmp; } void output(){//自定义函数，顺序输出最大堆元素 for(int i = 0; i]]></content>
      <categories>
        <category>D.S.</category>
        <category>D.S. &amp;amp;&amp;amp; Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sublime & Markdown & Cloud synchronization（Sublime + Evernote 印象笔记，Dropbox）]]></title>
    <url>%2Fpost%2F75e31a6e.html</url>
    <content type="text"><![CDATA[MORE.安装问题请点击 这. 本文章转载自：dukecui 出现的一些问题及解决方法： markdown 的omnimarkupview 404 错误时： 我用了第一种解决了问题。 Sublime Text &gt; Preferences &gt; Package Settings &gt; OmniMarkupPreviewer &gt; Settings - User 复制粘贴下面代码保存。 { &quot;renderer_options-MarkdownRenderer&quot;: { &quot;extensions&quot;: [&quot;tables&quot;, &quot;fenced_code&quot;, &quot;codehilite&quot;] } } 2. 保存的后缀名要为 .md 3. 快捷键：（最快： ctrl+shift+P 进行相应的插件搜索、操作） About OmniMarkupPreviwer &amp; markdownpreviewer1. OmniMarkupPreviewer 插件的使用命令如下： Ctrl+Alt+O: Preview Markup in Browser. Ctrl+Alt+X: Export Markup as HTML. Ctrl+Alt+C: Copy Markup as HTML.2. MarkdownPreview的编译指令为 Ctrl + B之后会在同样的文件夹下生成html的文件，打开即可预览效果。如果更改了文章，需要再次编译，打开才能看到更改的效果。3.以上两者之间的区别主要有这几个方面：前者可以进行实时的预览，后者不可以，后者需要先进行编译生成HTML文件，再查看。前者很多语法格式无效果，后者均有，例如，目录的生成，参考角标的生成，待办事项的显示等等。总结，前者可以实现文本的实时更新，后者可以更加完整有效的显示Markdown的语法格式。 便捷方法 结合配置文件注释，来一起看下让 OmniMarkupPreviewer 更好用的诸多选项: &quot;server_host&quot;: &quot;192.168.1.100&quot;, 开启预览服务的 IP 地址, 默认为 localhost.此处建议设置为本机固定 IP. 其好处在于：从局域网内的任意一台设备均可访问，可多设备同时在线，实现 一处编辑、多端预览 的效果。你完全可以在 Mac 上编辑 Markdown 文档，而把 iPad 当作外接显示器来实时预览。 http://blog.leanote.com/post/54bfa17b8404f03097000000 http://www.jianshu.com/p/31d284b009ae “为什么会写这样的一个主题，最主要的痛点来自于以下两个方面。首先，立志经常写博客的我，希望能拥有优雅地写作体验和得心应手的编辑环境，而对于经常码代码的我来说最喜欢的编辑器莫过于Sublime，这个在业界被赞誉无数皇冠加冕的神器，让你遇见就会产生恨晚的感觉，那么自然而然就需要建立一个基于Sublime的舒畅的Markdown编辑环境。再者，我需要在多终端编辑自己的博客，例如我在公司的PC上写了一篇博客，当我回到家的时候，仍然希望继续完成刚才的那篇博客，而如果每次都需要用硬盘来回复制粘贴拷贝，那简直如同回到了石器时代一样low的不得了，这时就需要一个舒适好用便捷的云同步的解决方案来搞定它。基于此，我花了一些时间解决了这些问题，也应运而生了这篇文章。 至于为什么要用Markdown来编辑，网上已经有无数关于Markdown的介绍和赞誉，同时对于经常混迹于全球最大同性交友网站GitHub的码农，Markdown是必不可少的技能。而且Hexo天生集成了Markdown，因此我们可以采用这样的语法来编写博客。Markdown简单的语法易用的规则，可以使我们更加专注于内容的编写，同时自动生成极为美观的排版，总之，带给我们良好的编辑体验。当然，Markdown的编辑器有很多很多，对于纯码字的文字工作者而言，大可选择更为简单方便的编辑器，这里有一篇文章可供参考（好用的Markdown编辑器一览），但是对于程序员而言，最好的就是Sublime！ 构建基于Sublime的良好的Markdown编辑环境1. Sublime主题的选择选择一款自己喜欢的主题配色可以让我们工作的时候更加的愉悦，效率也更高。我自己选择的主题是Material Theme, 这个在GitHub上获得6000+Star的精品，它的大概配色如下图所示（官方配图） 一开始选择Material Theme这个主题，完全是因为它的名字，因为我是一名Android开发者，所以对Google的Material Design有一种不能抗拒的感觉，虽然这两者之间似乎除了名字相同之外没有任何关系，但我还是喜欢上了它。 前人种树，后人乘凉，这里有一篇关于Sublime 主题推荐的文章：Sublime插件：主题篇 2. 插件的安装Sublime 拥有非常好的扩展性，因为使用之广泛，因此全球有很多的开发者为其开发了大量优秀的第三方插件，而如何安装卸载和管理第三方的插件，就需要 Package Control 这款插件，安装的方法如下链接：Package Control Install。 之后就可以进行第三方插件的安装了，Ctrl+Shift+P 之后打开命令板，输入 Package Control：Install Package，选择确认之后，就可以打开选择安装第三方库的面板，例如要安装上面的 Material Theme 主题，输入 Material Theme 之后选择即可安装。 3. Markdown编辑环境插件：Markdown EditingMarkdown Editing 是一款侧重于Markdown语法编辑的插件，它主要有以下的一些特点: 更好的句法理解， 更好的着色方案以及代码高亮 实用的Markdown编辑特性，即对插入图片，链接，角标，引用，标题等等，有快捷键的实现 支持 Standard Markdown, GitHub flavored Markdown, MultiMarkdown 三种语法 官方给的配图是这样子的 但是偏白色的背景让我感觉很别扭，与刚才设定的主题相差太大了，不能忍啊~ 好在这个也是可以修改自定的，在 Sublime 菜单栏打开 Preferences &gt; Package Settings &gt; Markdown Editing &gt; Markdown GFM settings - User 添加以下的代码，设置成我们自己喜欢的主题配色 { &quot;color_scheme&quot;: &quot;Packages/Material Theme/schemes/OLD/Material-Theme.tmTheme&quot;, } 4. Markdown预览插件：主要有两个 OmniMarkupPreviwer 和 MarkdownPreview通常我们还有需要预览用Markdown语法编写的文章的最终排版的需求，以上提到的两个插件实现了这样的功能。OmniMarkupPreviewer 插件的使用命令如下： Ctrl+Alt+O: Preview Markup in Browser. Ctrl+Alt+X: Export Markup as HTML. Ctrl+Alt+C: Copy Markup as HTML. MarkdownPreview的编译指令为 Ctrl + B 之后会在同样的文件夹下生成html的文件，打开即可预览效果。如果更改了文章，需要再次编译，打开才能看到更改的效果。 以上两者之间的区别主要有这几个方面： 前者可以进行实时的预览，后者不可以，后者需要先进行编译生成HTML文件，再查看。 前者很多语法格式无效果，后者均有，例如，目录的生成，参考角标的生成，待办事项的显示等等。 总结，前者可以实现文本的实时更新，后者可以更加完整有效的显示Markdown的语法格式。 至此，基于Sublime的Markdown的编辑环境已经搭建完成。 文档云端自动同步的方案关于云端同步，我的核心需求是，可以无需去操心所有的要同步的操作，当我在一个终端编辑好之后，不再需要做任何别的事情，文件会自动同步到我的另一个终端，而比如百度云盘则需要手动上传下载。这也正是我上面提到的需要在公司和家里都编辑同一份博客的需求。这里有以下的两种解决方案 一、DropboxDropbox 是最实用的文件同步工具，能够将存储在本地的文件自动同步到云端的服务器。但是令人遗憾的是，这款软件的服务在国内无法使用，必须要科学上网才行。而作为程序员需要经常的科学上网，所以这对我来说是可以接受的。Dropbox需要申请一个个人账号，之后安装相应的客户端，如Windows端，Dropbox会创建在 $env:userprofile\\Dropbox 路径下的一个文件夹，而你需要把希望同步到云端的所有文件，放在这个文件夹中，并保持处于科学上网的状态下，即可自动同步到Dropbox云端。同时，在另一台终端登录相同的Dropbox账号，即可自动将云端的文件同步到本地。 1. 同步Sublime的配置首先碰到的一个问题是，要在多终端使用Sublime，但是又希望我们在一个电脑上更改的配置能自动同步到另一台电脑。这时便可以采用Dropbox的方案，具体实现如下。在 Sublime 菜单栏打开 Preferences &gt; Browse Packages… 打开Sublime的文件夹，将Users的文件夹剪切到Dropbox目录（如Windows平台的$env:userprofile\\Dropbox）下，再在刚才的Sublime文件夹下创建一个User的文件夹，符号链接到Dropbox下的User文件夹，其中Windows下创建符号链接的命令如下： cmd /c mklink /D 带链接符号的文件夹 目标文件夹 比如，先命令行进入刚才打开的Sublime文件夹下，然后创建符号链接的命令如下： cmd /c mklink /D User $env:userprofile\Dropbox\User 这是一种值得借鉴的方式，你想同步的任何软件的任何配置文件，都可以采用符号链接的方式进行，将真正的文件存储在Dropbox文件夹下，再在它原来需要出现的位置，创建符号链接指向Dropbox下的相应的文件，即可实现文件的自动云端同步。 2. Hexo博客博文的云端同步借鉴以上创建符号链接的方式，在Hexo博客的根目录下，将source文件夹放在Dropbox目录下，再在原Hexo博客根目录下创建source文件夹到Dropbox文件夹下source文件夹的符号链接，即可实现云端自动同步博客所有资源的方案。从此便可随心所欲的在公司和家里操作编辑同样一份博文喽。 符号链接 同时，Dropbox在移动端也有相应的产品，我在我的Android手机安装了Dropbox的客户端，这样就可以在随时随地查看我编辑的博文，而博文是Markdown文件，可以下载MarkdownX的一款App，这是一款在移动端非常棒的可以查看预览编辑Markdown文件的应用，最重要的是，它可以和Dropbox联动！！！ 云端同步的全套解决方案搭建完成。 二、Sublime + Evernote（印象笔记）云端同步的另一个方案的出发点是这样的。我习惯每日会写工作日报，包括自己当天的工作计划，工作总结，学到的内容，一些感悟等等。我希望可以在 Sublime 中编辑它，而且它能够自动同步到移动端和另一台电脑，使我可以随时随地的查看和编辑。当然使用第一种方案也是可以的。但是这个需求的核心是我需要的是笔记的同步，而不需要同步文件，因此我更喜欢用专业的云端笔记产品。而在国内知名度很高的有道云笔记，我之所以没有选择它，是因为没有和Sublime联动的插件可以供我使用，我无法在Sublime中去编辑我的工作日报，只能在有道云笔记的客户端编辑，而且客户端暂不支持Markdown编辑，因此还要考虑排版云云，啊，简直不能忍！选择印象笔记就是因为这款在Sublime上的插件：Evernote。这使得我可以直接在Sublime中创建一个新的工作日报，并且以Markdownd的语法去编写，之后同步到印象笔记，自动生成排版，体验实在太棒啦！下面就来看如何搭建这套方案 1. 安装 Evernote 插件在Sublime中按 Ctrl+Shift+P 打开命令板，输入 Package Control:Install Package 打开下载仓库，输入 Evernote 下载安装。 2. 连接Sublime到你的印象笔记账号第一次使用Evernote需要连接你的账号，访问该网站 https://app.yinxiang.com/api/DeveloperToken.action 获取到你的账号对应的Token，这个Token就是你的账号的认证标志，所以要切记保密，任何人拿到这个Token就如同拿到你的密码一样，可以进行你印象笔记中的任何操作。获取到Token之后，打开 Sublime 菜单栏中 Preferences &gt; Package Settings &gt; Evernote &gt; Settings-User 键入上述网页所显示的 noteStoreUrl 和 token 字段。保存，并重新启动 Sublime ，完成账号的关联。 { &quot;noteStoreUrl&quot;: &quot;your noteStoreurl XXX&quot;, &quot;token&quot;: &quot;your token XXX&quot;, } 3. 使用 Evernote可以通过 Ctrl+Shift+P 打开命令板，键入 Evernote 就会出现所有的关于Evernote插件的指令，常用的指令包括 Command Palette &gt; Evernote: New empty note Command Palette &gt; Evernote: Open Evernote Note Command Palette &gt; Evernote: Send to Evernote Command Palette &gt; Evernote: Update Evernote Note 以上指令的详细解释，可参照 Evernote 的官方 GitHub：Evernote 当然，我们可以直接设置快捷键完成相应的操作。在Sublime的菜单栏中打开 Preferences &gt; Key Bindings - User 键入以下的设置 [ { &quot;keys&quot;: [&quot;ctrl+e&quot;, &quot;ctrl+p&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: {&quot;overlay&quot;: &quot;command_palette&quot;, &quot;text&quot;: &quot;Evernote: &quot;} }, { &quot;keys&quot;: [&quot;ctrl+e&quot;, &quot;ctrl+o&quot;], &quot;command&quot;: &quot;open_evernote_note&quot; }, { &quot;keys&quot;: [&quot;ctrl+s&quot;], &quot;command&quot;: &quot;save_evernote_note&quot;, &quot;context&quot;: [{&quot;key&quot;: &quot;evernote_note&quot;}, {&quot;key&quot;: &quot;evernote_has_guid&quot;}] }, { &quot;keys&quot;: [&quot;ctrl+s&quot;], &quot;command&quot;: &quot;send_to_evernote&quot;, &quot;context&quot;: [{&quot;key&quot;: &quot;evernote_note&quot;}, {&quot;key&quot;: &quot;evernote_has_guid&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: false}] }, ] 以上快捷键的解释，第二个设置表示，连续按 “ctrl+e”, “ctrl+o” 会在Sublime中打开云端的印象笔记，可以进行相应的文件夹和文件的选择，确认即可打开。第三个设置表示，在打开的是一个印象笔记文本的情况下，按”ctrl+s”可以直接保存到云端。第四个设置表示，如果是一个新建的笔记（例如通过 Command Palette &gt; Evernote: New empty note 命令在 Sublime 中新建的一个笔记），还没有在云端，按”ctrl+s”可以将此笔记发送到云端。 4. 建立模板每次新建一个文件，我们可能需要一些模板，这是可以实现的。在 Sublime 的菜单栏打开 Preferences &gt; Package Settings &gt; Evernote &gt; Settings-User 键入以下的字段 &quot;default_template&quot;: &quot;Packages/User/EvernoteNote.md&quot;, 然后打开 Preferences &gt; Browse Packages… 打开User文件夹，新建一个EvernoteNote.md文件作为一个模板，需要注意的是，需要把这个文件转换为UNIX格式，才能正常的使用。 5. 注意事项在印象笔记的如上使用过程中，发现一个非常严重的问题，就是如果我本地的一个 Markdown 在 Sublime 中打开编辑，之后发送到云端，如果直接在打开的这个文件继续编辑保存，是可以继续上传到云端的，而假如我此时在 Sublime 中关闭这个本地的文件，再次打开，此时系统将无法确认这个文件是和云端的印象笔记的某个文件是关联的，也就是说，这个时候，你无法再将新的更改添加到刚才的那个云端笔记中，只能重新发送一个相当于新的笔记到云端。这是一个非常不好的体验和痛点，我也在开发这款插件的作者的Github中看到了有关这个问题的讨论，可能因为确实十分棘手，作者最终并没有给出解决方案。 而我们可以通过改变我们的使用方式来绕开以上的痛点。使用流程如下，先通过 Command Palette &gt; Evernote: New empty note 新建一个笔记，定义好我们笔记的文件名和所在的文件夹，保存这个笔记，相当于发送到云端，这时我们就可以编辑了，当编辑完成关闭之后，下次通过 Command Palette &gt; Evernote: Open Evernote Note 命令直接打开云端的一个笔记进行修改和编辑，这很好的解决了本地文件与云端文件的关联问题。 总之，核心的思想就是，不在本地进行编辑，只编辑云端。Sublime只是一个用来编辑云端笔记的编辑器，真正的存储位置就是在云端。 以上的所有关于 Evernote 的设置可以参考 Evernote 的GitHub主页。 至此，Sublime + Evernote 的云端同步方案搭建完成，可以享受畅爽的多端同步笔记了。在公司电脑写的工作日报，可以直接在家里PC和手机端进行查看和编辑，从此走向人生巅峰~~~]]></content>
      <categories>
        <category>thinkphpALi</category>
        <category>工具_etc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown: Basics （快速入门）]]></title>
    <url>%2Fpost%2F88c3f6f7.html</url>
    <content type="text"><![CDATA[声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里查看它的源文件。「繁体中文版的原始文件可以查看这里」—By @riku注： 本项目托管于 GitCafe上，请通过”派生”和”合并请求”来帮忙改进本项目。 Getting the Gist of Markdown’s Formatting Syntax此页提供了 Markdown 的简单概念， 语法说明 页提供了完整详细的文档，说明了每项功能。但是 Markdown 其实很简单就可以上手，此页文档提供了一些范例，并且每个范例都会提供输出的 HTML 结果。 其实直接试试看也是一个很不错的方法， Dingus 是一个网页应用程序，你可以把自已编写的 Markdown 文档转成 XHTML。 段落和换行一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 如果你_确实_想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 ！&lt;文字颜色、字体、字号 CSDN扩展请看这里。&gt;注意：以下是我自行添加入内容及总结方法。Markdown语法会忽略首行开头的空格，如果要体现出首行开头空两个的效果，可以使用 全角符号下的空格 ，windows下使用 shift+空格 切换。-删除线—说明使用 ~~ 表示删除线。—示例~~这是一条删除线~~ 这是一条删除线—注意 注意 ~~ 和 要添加删除线的文字之间不能有空格。 我常使用在显示的告诉自己这行文字是要删除的。 -注脚—说明使用 [^footer] 表示注脚。—示例`这是一个注脚测试footer1。 footer1. 这是一个测试，用来阐释注脚。` &#8617; 这是一个注脚测试[^footer1]。 表格说明 具体使用方式请看示例。 ------: 为右对齐。 :------ 为左对齐。 :------: 为居中对齐。 ------- 为使用默认居中对齐。 示例 | 序号 | 交易名 | 交易说明 | 备注 | | ------: | :-------: | :--------- | ------ | | 1 | prfcfg | 菜单配置 | 可以通过此交易查询到所有交易码和菜单的对应关系 | | 2 | gentmo | 编译所有交易 | | | 100000 | sysdba | 数据库表模型汇总 | | 序号 交易名 交易说明 备注 1 prfcfg 菜单配置 可以通过此交易查询到所有交易码和菜单的对应关系 2 gentmo 编译所有交易 100000 sysdba 数据库表模型汇总 注意 每个Markdown解析器都不一样，可能左右居中对齐方式的表示方式不一样。 注意 我常在需要解释一个名词，或者一本书，或者一个人时使用脚注标记。 段落、标题、区块代码一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。 Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 区块引用则使用 email 形式的 ‘&gt;‘ 角括号。 Markdown 语法: A First Level Header ==================== A Second Level Header --------------------- Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog&#39;s back. ### Header 3 &gt; This is a blockquote. &gt; &gt; This is the second paragraph in the blockquote. &gt; &gt; ## This is an H2 in a blockquote 输出 HTML 为：`A First Level Header A Second Level Header Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog's back. Header 3 This is a blockquote. This is the second paragraph in the blockquote. This is an H2 in a blockquote ` * 如果 `>` 和 `>>` 嵌套使用的话，从 `>>` 退到 `>` 时，必须之间要加一个空格或者 `>` 作为过渡，否则默认为下一行和上一行是同一级别的引用。如示例所示。 * 引用标记里可以使用其他标记，如：有序列表或无序列表标记，代码标记等。 ### 修辞和强调 Markdown 使用星号和底线来标记需要强调的区段。 Markdown 语法: Some of these words *are emphasized*. Some of these words _are emphasized also_. Use two asterisks for **strong emphasis**. Or, if you prefer, __use two underscores instead__. 输出 HTML 为: Some of these words are emphasized. Some of these words are emphasized also. Use two asterisks for strong emphasis. Or, if you prefer, use two underscores instead. 列表无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号： * Candy. * Gum. * Booze. 加号： + Candy. + Gum. + Booze. 和减号 - Candy. - Gum. - Booze. 都会输出 HTML 为： &lt;ul&gt; &lt;li&gt;Candy.&lt;/li&gt; &lt;li&gt;Gum.&lt;/li&gt; &lt;li&gt;Booze.&lt;/li&gt; &lt;/ul&gt; 有序的列表则是使用一般的数字接着一个英文句点作为项目标记： 1. Red 2. Green 3. Blue 输出 HTML 为： &lt;ol&gt; &lt;li&gt;Red&lt;/li&gt; &lt;li&gt;Green&lt;/li&gt; &lt;li&gt;Blue&lt;/li&gt; &lt;/ol&gt; 如果你在项目之间插入空行，那项目的内容会用 &lt;p&gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。 * A list item. With multiple paragraphs. * Another item in the list. 输出 HTML 为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;A list item.&lt;/p&gt; &lt;p&gt;With multiple paragraphs.&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Another item in the list.&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 注意： 无序列表或有序列表标记和后面的文字之间要有一个空格隔开。 有序列表标记不是按照你写的数字进行显示的，而是根据当前有序列表标记所在位置显示的，如示例1所示。 无序列表的项目符号是按照实心圆、空心圆、实心方格的层级关系递进的，如例2所示。通常情况下，同一层级使用同一种标记表示，便于自己查看和管理。 无序列表和有序列表标记的使用场景也很明了，故不多说。 链接Markdown 支援两种形式的链接语法： _行内_ 和 _参考_ 两种形式，两种都是使用角括号来把文字转成连结。 行内形式是直接在后面用括号直接接上链接： This is an [example link](http://example.com/). 输出 HTML 为： &lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot;&gt; example link&lt;/a&gt;.&lt;/p&gt; 你也可以选择性的加上 title 属性： This is an [example link](http://example.com/ &quot;With a Title&quot;). 输出 HTML 为： &lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&gt; example link&lt;/a&gt;.&lt;/p&gt; 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容： I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 输出 HTML 为： &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写： I start my morning with a cup of coffee and [The New York Times][NY Times]. [ny times]: http://www.nytimes.com/ 输出 HTML 为： &lt;p&gt;I start my morning with a cup of coffee and &lt;a href=&quot;http://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt; 图片图片的语法和链接很像。 行内形式（title 是选择性的）： ![alt text](/path/to/img.jpg &quot;Title&quot;) 参考形式： ![alt text][id] [id]: /path/to/img.jpg &quot;Title&quot; 上面两种方法都会输出 HTML 为： &lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt; 代码在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码： I strongly recommend against using any `&lt;blink&gt;` tags. I wish SmartyPants used named entities like `&amp;mdash;` instead of decimal-encoded entites like `&amp;#8212;`. 输出 HTML 为： &lt;p&gt;I strongly recommend against using any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; &lt;p&gt;I wish SmartyPants used named entities like &lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encoded entites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt; 如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。 Markdown 语法: If you want your page to validate under XHTML 1.0 Strict, you&#39;ve got to put paragraph tags in your blockquotes: &lt;blockquote&gt; &lt;p&gt;For example.&lt;/p&gt; &lt;/blockquote&gt; 输出 HTML 为： &lt;p&gt;If you want your page to validate under XHTML 1.0 Strict, you&#39;ve got to put paragraph tags in your blockquotes:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt; &amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt; &amp;lt;/blockquote&amp;gt; &lt;/code&gt;&lt;/pre&gt; 转义说明 使用 \ 表示反斜杠。在你不想显示Markdown标记时可以使用反斜杠。 示例 \*这里不会显示斜体\* 这里不会显示斜体 -其它不常用标记3.1 实现页内跳转3.1.1 说明 使用html代码实现页内跳转。在要跳转到的位置定义个锚 &lt;span id = &quot;jump&quot;&gt;hehe&lt;/span&gt; ，然后使用 [你好](#jump) 将 你好 设置为一单击即跳转到 hehe 所在位置的效果。 3.1.2 示例 [你好](#jump) &lt;span id = &quot;jump&quot;&gt;hehe&lt;/span&gt; 你好 hehe 3.1.3 注意 无。 4. 专项使用标记4.1 流程图 以后在总结吧，现在的我完全没有使用上，没有需求就先不总结了。 4.2 LaTeX公式 以后在总结吧，现在的我完全没有使用上，没有需求就先不总结了。 有关于文字的操作。再markdown上并没有可以直接利用的语言。所以CSDN为我们进行了扩展： 换行： 方法1: 连续两个以上空格+回车 方法2：使用html语言换行标签：&lt;br&gt; 首行缩进两个字符：(每个表示一个空格，连续使用两个即可） &amp;ensp; 半角的空格 &amp;emsp; 全角的空格 字体、字号与颜色:Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！ CSDN-markdown编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、内嵌HTML等等）！对，就是内嵌HTML，接下来要讲的功能就需要使用内嵌HTML的方法来实现。 字体，字号和颜色编辑如下代码 &lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt; &lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt; &lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt; &lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt; &lt;font color=gray size=72&gt;color=gray&lt;/font&gt; Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 具体颜色分类及标记请参照：[各种颜色](http://blog.csdn.net/testcs_dn/article/details/45719357/) 背景色: Markdown本身不支持背景色设置，需要采用内置html的方式实现：借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。举例如下： &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果如下： 背景色是：orange 2015/12/19 16:04:07 分割线：你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线 链接：链接文字都是用 [方括号] 来标记,在方块括号后面紧接着圆括号并插入网址链接即可:可参照 [This link](http://example[.NET](http://lib.csdn.net/base/dotnet &quot;.NET知识库&quot;)/) has no title attribute. 代码块： 代码块：用2个以上TAB键起始的段落，会被认为是代码块（效果如下）： struct { int year; int month; int day; }bdate; * 如果在一个行内需要引用代码，只要用反引号`引起来就好(Esc健） * 代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个反引号“`”，同时第一行反引号后面表面代码块所使用的语言 插入互联网上图片： ![这里写图片描述](http://img3.douban.com/mpic/s1108264.jpg) 使用LaTex数学公式: 行内公式：使用两个”$”符号引用公式: 公式 行间公式：使用两对“$$”符号引用公式： $$$公式$$$ 具体：详见参考颜色值]]></content>
      <categories>
        <category>工具_etc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Algorithms——MacCormick_2012_改变未来的九大算法_管策_译_2013]]></title>
    <url>%2Fpost%2F87e5f5a3.html</url>
    <content type="text"><![CDATA[—-大头 ——关于文件操作的etc http://blog.csdn.net/k76853/article/details/50440182 一步一步 http://www.cnblogs.com/likebeta/archive/2012/06/16/2551662.html 可以当做字典样式 —-C++ 关于随机数【伪随机】【范围随机以及种子数的描述】 http://www.cnblogs.com/kaituorensheng/archive/2013/03/05/2944008.html —-KMeans相关参考： http://blog.csdn.net/qll125596718/article/details/8243404/ 具体的一些知识性可以参照代码注释比较完善http://blog.csdn.net/k76853/article/details/50440182 vector利用的比较好。自己的封装思想，还有数据结构的运用还有待加强！ 还有一些 小问题（关于VS）在此不再赘述.]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu16.04LTS+MapReduce+Eclipse]]></title>
    <url>%2Fpost%2Faca78707.html</url>
    <content type="text"><![CDATA[注意：新MapReduces——yarm！！！ `YARN总体上仍然是Master/Slave结构，在整个资源管理框架中，ResourceManager为Master，NodeManager为Slave,ResourceManager负责对各个NodeManager上的资源进行统一管理和调度。当用户提交一个应用程序时，需要提供一个用以跟踪和管理这个程序的ApplicationMaster，它负责向ResourceManager申请资源，并要求NodeManager启动可以占用一定资源的任务。 三天以来配置hadoop start-dfs.sh 不可以多次format.具体参考`本链接 ./bin/hdfs dfs -rm -r output # 删除 output 文件夹 学会查看日志文件，自己排查错误.查看HDFS文件系统数据的三种方法 source 使配置生效.PATH自己设置 MapReduce+Eclipse使用Eclipse编译运行MapReduce程序_Hadoop2.6.0_Ubuntu/CentOS 本教程介绍的是如何在 Ubuntu/CentOS 中使用 Eclipse 来开发 MapReduce 程序，在 Hadoop 2.6.0 下验证通过。虽然我们可以使用命令行编译打包运行自己的MapReduce程序，但毕竟编写代码不方便。使用 Eclipse，我们可以直接对 HDFS 中的文件进行操作，可以直接运行代码，省去许多繁琐的命令。 环境本教程在 Hadoop 2.6.0 下验证通过，适用于 Ubuntu/CentOS 系统，理论上可用于任何原生 Hadoop 2 版本，如 Hadoop 2.4.1，Hadoop 2.7.1。 本教程主要测试环境： Ubuntu 14.04 Hadoop 2.6.0（伪分布式） Eclipse 3.8 此外，本教材在 CentOS 6.4 系统中也验证通过，对 Ubuntu 与 CentOS 的不同配置之处有作出了注明。 安装 Eclipse在 Ubuntu 和 CentOS 中安装 Eclipse 的方式有所不同，但之后的配置和使用是一样的。 在 Ubuntu 中安装 Eclipse，可从 Ubuntu 的软件中心直接搜索安装，在桌面左侧任务栏，点击“Ubuntu软件中心”。 Ubuntu软件中心 在右上角搜索栏中搜索 eclipse，在搜索结果中单击 eclipse，并点击安装。 安装Eclipse 等待安装完成即可，Eclipse 的默认安装目录为：/usr/lib/eclipse。 在 CentOS 中安装 Eclipse，需要下载安装程序，我们选择 Eclipse IDE for Java Developers 版： 32位: http://eclipse.bluemix.net/packages/mars.1/?JAVA-LINUX32 64位: http://eclipse.bluemix.net/packages/mars.1/?JAVA-LINUX64 下载后执行如下命令，将 Eclipse 安装至 /usr/lib 目录中： sudo tar -zxf ~/下载/eclipse-java-mars-1-linux-gtk*.tar.gz -C /usr/lib Shell 命令 解压后即可使用。在 CentOS 中可以为程序创建桌面快捷方式，如下图所示，点击桌面右键，选择创建启动器，填写名称和程序位置（/usr/lib/eclipse/eclipse）： 安装Eclipse 安装 Hadoop-Eclipse-Plugin要在 Eclipse 上编译和运行 MapReduce 程序，需要安装 hadoop-eclipse-plugin，可下载 Github 上的 hadoop2x-eclipse-plugin（备用下载地址：http://pan.baidu.com/s/1i4ikIoP）。 下载后，将 release 中的 hadoop-eclipse-kepler-plugin-2.6.0.jar （还提供了 2.2.0 和 2.4.1 版本）复制到 Eclipse 安装目录的 plugins 文件夹中，运行 eclipse -clean 重启 Eclipse 即可（添加插件后只需要运行一次该命令，以后按照正常方式启动就行了）。 unzip -qo ~/下载/hadoop2x-eclipse-plugin-master.zip -d ~/下载 # 解压到 ~/下载 中 sudo cp ~/下载/hadoop2x-eclipse-plugin-master/release/hadoop-eclipse-plugin-2.6.0.jar /usr/lib/eclipse/plugins/ # 复制到 eclipse 安装目录的 plugins 目录下 /usr/lib/eclipse/eclipse -clean # 添加插件后需要用这种方式使插件生效 Shell 命令 配置 Hadoop-Eclipse-Plugin在继续配置前请确保已经开启了 Hadoop。 启动 Eclipse 后就可以在左侧的Project Explorer中看到 DFS Locations（若看到的是 welcome 界面，点击左上角的 x 关闭就可以看到了。CentOS 需要切换 Perspective 后才能看到，即接下来配置步骤的第二步）。 安装好Hadoop-Eclipse-Plugin插件后的效果 插件需要进一步的配置。 第一步：选择 Window 菜单下的 Preference。 打开Preference 此时会弹出一个窗体，窗体的左侧会多出 Hadoop Map/Reduce 选项，点击此选项，选择 Hadoop 的安装目录（如/usr/local/hadoop，Ubuntu不好选择目录，直接输入就行）。 选择 Hadoop 的安装目录 第二步：切换 Map/Reduce 开发视图，选择 Window 菜单下选择 Open Perspective -&gt; Other（CentOS 是 Window -&gt; Perspective -&gt; Open Perspective -&gt; Other），弹出一个窗体，从中选择 Map/Reduce 选项即可进行切换。 切换 Map/Reduce 开发视图 第三步：建立与 Hadoop 集群的连接，点击 Eclipse软件右下角的 Map/Reduce Locations 面板，在面板中单击右键，选择 New Hadoop Location。 建立与 Hadoop 集群的连接 在弹出来的 General 选项面板中，General 的设置要与 Hadoop 的配置一致。一般两个 Host 值是一样的，如果是伪分布式，填写 localhost 即可，另外我使用的Hadoop伪分布式配置，设置 fs.defaultFS 为 hdfs://localhost:9000，则 DFS Master 的 Port 要改为 9000。Map/Reduce(V2) Master 的 Port 用默认的即可，Location Name 随意填写。 最后的设置如下图所示： Hadoop Location 的设置 Advanced parameters 选项面板是对 Hadoop 参数进行配置，实际上就是填写 Hadoop 的配置项(/usr/local/hadoop/etc/hadoop中的配置文件)，如我配置了 hadoop.tmp.dir ，就要进行相应的修改。但修改起来会比较繁琐，我们可以通过复制配置文件的方式解决（下面会说到）。 总之，我们只要配置 General 就行了，点击 finish，Map/Reduce Location 就创建好了。 在 Eclipse 中操作 HDFS 中的文件配置好后，点击左侧 Project Explorer 中的 MapReduce Location （点击三角形展开）就能直接查看 HDFS 中的文件列表了（HDFS 中要有文件，如下图是 WordCount 的输出结果），双击可以查看内容，右键点击可以上传、下载、删除 HDFS 中的文件，无需再通过繁琐的 hdfs dfs -ls 等命令进行操作了。 以下output/part-r-00000文件记录了输出结果。点击查看HDFS文件系统数据的三种方法可进行扩展学习。 使用Eclipse查看HDFS中的文件内容 如果无法查看，可右键点击 Location 尝试 Reconnect 或重启 Eclipse。 _Tips_HDFS 中的内容变动后，Eclipse 不会同步刷新，需要右键点击 Project Explorer中的 MapReduce Location，选择 Refresh，才能看到变动后的文件。 在 Eclipse 中创建 MapReduce 项目点击 File 菜单，选择 New -&gt; Project…: 创建Project 选择 Map/Reduce Project，点击 Next。 创建MapReduce项目 填写 Project name 为 WordCount 即可，点击 Finish 就创建好了项目。 填写项目名 此时在左侧的 Project Explorer 就能看到刚才建立的项目了。 项目创建完成 接着右键点击刚创建的 WordCount 项目，选择 New -&gt; Class 新建Class 需要填写两个地方：在 Package 处填写 org.apache.hadoop.examples；在 Name 处填写 WordCount。 填写Class信息 创建 Class 完成后，在 Project 的 src 中就能看到 WordCount.java 这个文件。将如下 WordCount 的代码复制到该文件中。 package org.apache.hadoop.examples; import java.io.IOException; import java.util.Iterator; import java.util.StringTokenizer; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.Reducer; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; import org.apache.hadoop.util.GenericOptionsParser; public class WordCount { public WordCount() { } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); String[] otherArgs = (new GenericOptionsParser(conf, args)).getRemainingArgs(); if(otherArgs.length &lt; 2) { System.err.println(“Usage: wordcount […] “); System.exit(2); } Job job = Job.getInstance(conf, “word count”); job.setJarByClass(WordCount.class); job.setMapperClass(WordCount.TokenizerMapper.class); job.setCombinerClass(WordCount.IntSumReducer.class); job.setReducerClass(WordCount.IntSumReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); for(int i = 0; i &lt; otherArgs.length - 1; ++i) { FileInputFormat.addInputPath(job, new Path(otherArgs[i])); } FileOutputFormat.setOutputPath(job, new Path(otherArgs[otherArgs.length - 1])); System.exit(job.waitForCompletion(true)?0:1); } public static class IntSumReducer extends Reducer { private IntWritable result = new IntWritable(); public IntSumReducer() { } public void reduce(Text key, Iterable values, Reducer.Context context) throws IOException, InterruptedException { int sum = 0; IntWritable val; for(Iterator i$ = values.iterator(); i$.hasNext(); sum += val.get()) { val = (IntWritable)i$.next(); } this.result.set(sum); context.write(key, this.result); } } public static class TokenizerMapper extends Mapper { private static final IntWritable one = new IntWritable(1); private Text word = new Text(); public TokenizerMapper() { } public void map(Object key, Text value, Mapper.Context context) throws IOException, InterruptedException { StringTokenizer itr = new StringTokenizer(value.toString()); while(itr.hasMoreTokens()) { this.word.set(itr.nextToken()); context.write(this.word, one); } } } } Java 通过 Eclipse 运行 MapReduce在运行 MapReduce 程序前，还需要执行一项重要操作（也就是上面提到的通过复制配置文件解决参数设置问题）：将 /usr/local/hadoop/etc/hadoop 中将有修改过的配置文件（如伪分布式需要 core-site.xml 和 hdfs-site.xml），以及 log4j.properties 复制到 WordCount 项目下的 src 文件夹（~/workspace/WordCount/src）中： cp /usr/local/hadoop/etc/hadoop/core-site.xml ~/workspace/WordCount/src cp /usr/local/hadoop/etc/hadoop/hdfs-site.xml ~/workspace/WordCount/src cp /usr/local/hadoop/etc/hadoop/log4j.properties ~/workspace/WordCount/src Shell 命令 没有复制这些文件的话程序将无法正确运行，本教程最后再解释为什么需要复制这些文件。 复制完成后，务必右键点击 WordCount 选择 refresh 进行刷新（不会自动刷新，需要手动刷新），可以看到文件结构如下所示： WordCount项目文件结构 点击工具栏中的 Run 图标，或者右键点击 Project Explorer 中的 WordCount.java，选择 Run As -&gt; Run on Hadoop，就可以运行 MapReduce 程序了。不过由于没有指定参数，运行时会提示 “Usage: wordcount “，需要通过Eclipse设定一下运行参数。 右键点击刚创建的 WordCount.java，选择 Run As -&gt; Run Configurations，在此处可以设置运行时的相关参数（如果 Java Application 下面没有 WordCount，那么需要先双击 Java Application）。切换到 “Arguments” 栏，在 Program arguments 处填写 “input output” 就可以了。 设置程序运行参数 或者也可以直接在代码中设置好输入参数。可将代码 main() 函数的 String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs(); 改为： // String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs(); String[] otherArgs=new String[]{“input”,”output”}; /* 直接设置输入参数 */ Java 设定参数后，再次运行程序，可以看到运行成功的提示，刷新 DFS Location 后也能看到输出的 output 文件夹。 WordCount 运行结果 至此，你就可以使用 Eclipse 方便的进行 MapReduce程序的开发了。 在 Eclipse 中运行 MapReduce 程序会遇到的问题在使用 Eclipse 运行 MapReduce 程序时，会读取 Hadoop-Eclipse-Plugin 的 Advanced parameters 作为 Hadoop 运行参数，如果我们未进行修改，则默认的参数其实就是单机（非分布式）参数，因此程序运行时是读取本地目录而不是 HDFS 目录，就会提示 Input 路径不存在。 Exception in thread &quot;main&quot; org.apache.hadoop.mapreduce.lib.input.InvalidInputException: Input path does not exist: file:/home/hadoop/workspace/WordCountProject/input 所以我们需要将配置文件复制到项目中的 src 目录，来覆盖这些参数。让程序能够正确运行。 log4j 用于记录程序的输出日记，需要 log4j.properties 这个配置文件，如果没有复制该文件到项目中，运行程序后在 Console 面板中会出现警告提示： log4j:WARN No appenders could be found for logger (org.apache.hadoop.metrics2.lib.MutableMetricsFactory). log4j:WARN Please initialize the log4j system properly. log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. 虽然不影响程序的正确运行的，但程序运行时无法看到任何提示消息（只能看到出错信息）。 参考资料 http://www.cnblogs.com/xia520pi/archive/2012/05/20/2510723.html http://www.blogjava.net/LittleRain/archive/2006/12/31/91165.html 你有多渴望，你有多付出 http://dblab.xmu.edu.cn/blog/hadoop-build-project-using-eclipse/ 大数据Hadoop, MapReduce 相关文章 Hadoop 2.4.1单机版 自定义实现类以及编译运行 使用命令行编译打包运行自己的MapReduce程序 Hadoop2.6.0 Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04 Hadoop集群安装配置教程_Hadoop2.6.0_Ubuntu/CentOS Hadoop安装教程_伪分布式配置_CentOS6.4/Hadoop2.6.0 Linux安装hadoop-2.7.1 --------------------Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu16.04LTS当开始着手实践 Hadoop 时，安装 Hadoop 往往会成为新手的一道门槛。尽管安装其实很简单，书上有写到，官方网站也有 Hadoop 安装配置教程，但由于对 Linux 环境不熟悉，书上跟官网上简略的安装步骤新手往往 Hold 不住。加上网上不少教程也甚是坑，导致新手折腾老几天愣是没装好，很是打击学习热情。本教程由厦门大学数据库实验室 / 给力星出品，转载请注明。本教程适合于原生 Hadoop 2，包括 Hadoop 2.6.0, Hadoop 2.7.1 等版本，主要参考了官方安装教程，步骤详细，辅以适当说明，相信按照步骤来，都能顺利安装并运行Hadoop。另外有Hadoop安装配置简略版方便有基础的读者快速完成安装。此外，希望读者们能多去了解一些 Linux 的知识，以后出现问题时才能自行解决。 为了方便学习本教程，请读者们利用Linux系统中自带的firefox浏览器打开本指南进行学习。 环境本教程使用 Ubuntu 14.04 64位 作为系统环境（Ubuntu 12.04 也行，32位、64位均可），请自行安装系统（可参考使用VirtualBox安装Ubuntu）。 如果用的是 CentOS/RedHat 系统，请查看相应的CentOS安装Hadoop教程_单机伪分布式配置。 本教程基于原生 Hadoop 2，在 Hadoop 2.6.0 (stable) 版本下验证通过，可适合任何 Hadoop 2.x.y 版本，如 Hadoop 2.7.1、2.6.3、2.4.1等。 使用本教程请确保系统处于联网状态下，部分高校使用星网锐捷连接网络，可能导致虚拟机无法联网，那么建议您使用双系统安装ubuntu,然后再使用本教程！ Hadoop版本Hadoop 有两个主要版本，Hadoop 1.x.y 和 Hadoop 2.x.y 系列，比较老的教材上用的可能是 0.20 这样的版本。Hadoop 2.x 版本在不断更新，本教程均可适用。如果需安装 0.20，1.2.1这样的版本，本教程也可以作为参考，主要差别在于配置项，配置请参考官网教程或其他教程。 新版是兼容旧版的，书上旧版本的代码应该能够正常运行（我自己没验证，欢迎验证反馈）。 装好了 Ubuntu 系统之后，在安装 Hadoop 前还需要做一些必备工作。 创建hadoop用户如果你安装 Ubuntu 的时候不是用的 “hadoop” 用户，那么需要增加一个名为 hadoop 的用户。 首先按 ctrl+alt+t 打开终端窗口，输入如下命令创建新用户 : sudo useradd -m hadoop -s /bin/bash Shell 命令 这条命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shell。 sudo命令本文中会大量使用到sudo命令。sudo是ubuntu中一种权限管理机制，管理员可以授权给一些普通用户去执行一些需要root权限执行的操作。当使用sudo命令时，就需要输入您当前用户的密码. 密码在Linux的终端中输入密码，终端是不会显示任何你当前输入的密码，也不会提示你已经输入了多少字符密码。而在windows系统中,输入密码一般都会以“*”表示你输入的密码字符 输入法中英文切换ubuntu中终端输入的命令一般都是使用英文输入。linux中英文的切换方式是使用键盘“shift”键来切换，也可以点击顶部菜单的输入法按钮进行切换。ubuntu自带的Sunpinyin中文输入法已经足够读者使用。 Ubuntu终端复制粘贴快捷键在Ubuntu终端窗口中，复制粘贴的快捷键需要加上 shift，即粘贴是 ctrl+shift+v。 接着使用如下命令设置密码，可简单设置为 hadoop，按提示输入两次密码： sudo passwd hadoop Shell 命令 可为 hadoop 用户增加管理员权限，方便部署，避免一些对新手来说比较棘手的权限问题： sudo adduser hadoop sudo Shell 命令 最后注销当前用户（点击屏幕右上角的齿轮，选择注销），返回登陆界面。在登陆界面中选择刚创建的 hadoop 用户进行登陆。 更新apt用 hadoop 用户登录后，我们先更新一下 apt，后续我们使用 apt 安装软件，如果没更新可能有一些软件安装不了。按 ctrl+alt+t 打开终端窗口，执行如下命令： sudo apt-get update Shell 命令 若出现如下 “Hash校验和不符” 的提示，可通过更改软件源来解决。若没有该问题，则不需要更改。从软件源下载某些软件的过程中，可能由于网络方面的原因出现没法下载的情况，那么建议更改软件源。在学习Hadoop过程中，即使出现“Hash校验和不符”的提示，也不会影响Hadoop的安装。 Ubuntu更新软件源时遇到Hash校验和不符的问题 点击查看：如何更改软件源 后续需要更改一些配置文件，我比较喜欢用的是 vim（vi增强版，基本用法相同），建议安装一下（如果你实在还不会用 vi/vim 的，请将后面用到 vim 的地方改为 gedit，这样可以使用文本编辑器进行修改，并且每次文件更改完成后请关闭整个 gedit 程序，否则会占用终端）： sudo apt-get install vim Shell 命令 安装软件时若需要确认，在提示处输入 y 即可。 通过命令行安装软件 点击查看：vim简单操作指南 安装SSH、配置SSH无密码登陆集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令），Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server： sudo apt-get install openssh-server Shell 命令 安装后，可以使用如下命令登陆本机： ssh localhost Shell 命令 此时会有如下提示(SSH首次登陆提示)，输入 yes 。然后按提示输入密码 hadoop，这样就登陆到本机了。 SSH首次登陆提示 但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。 首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中： exit # 退出刚才的 ssh localhost cd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhost ssh-keygen -t rsa # 会有提示，都按回车就可以 cat ./id_rsa.pub &gt;&gt; ./authorized_keys # 加入授权 Shell 命令 ~的含义在 Linux 系统中，~ 代表的是用户的主文件夹，即 “/home/用户名” 这个目录，如你的用户名为 hadoop，则 ~ 就代表 “/home/hadoop/“。 此外，命令中的 # 后面的文字是注释，只需要输入前面命令即可。 此时再用 ssh localhost 命令，无需输入密码就可以直接登陆了，如下图所示。 SSH无密码登录 安装Java环境Java环境可选择 Oracle 的 JDK，或是 OpenJDK，按中说的，新版本在 OpenJDK 1.7 下是没问题的。为图方便，这边直接通过命令安装 OpenJDK 7。 sudo apt-get install openjdk-7-jre openjdk-7-jdk Shell 命令 安装好 OpenJDK 后，需要找到相应的安装路径，这个路径是用于配置 JAVA_HOME 环境变量的。执行如下命令： dpkg -L openjdk-7-jdk | grep ‘/bin/javac’ Shell 命令 该命令会输出一个路径，除去路径末尾的 “/bin/javac”，剩下的就是正确的路径了。如输出路径为 /usr/lib/jvm/java-7-openjdk-amd64/bin/javac，则我们需要的路径为 /usr/lib/jvm/java-7-openjdk-amd64。 接着需要配置一下 JAVA_HOME 环境变量，为方便，我们在 ~/.bashrc 中进行设置（扩展阅读: 设置Linux环境变量的方法和区别）： vim ~/.bashrc Shell 命令 在文件最前面添加如下单独一行（注意 = 号前后不能有空格），将“JDK安装路径”改为上述命令得到的路径，并保存： export JAVA_HOME=JDK安装路径 Shell 如下图所示（该文件原本可能不存在，内容为空，这不影响）： 配置JAVA_HOME变量 接着还需要让该环境变量生效，执行如下代码： source ~/.bashrc # 使变量设置生效 Shell 命令 设置好后我们来检验一下是否设置正确： echo $JAVA_HOME # 检验变量值 java -version $JAVA_HOME/bin/java -version # 与直接执行 java -version 一样 Shell 命令 如果设置正确的话，$JAVA_HOME/bin/java -version 会输出 java 的版本信息，且和 java -version 的输出结果一样，如下图所示： 成功配置JAVA_HOME变量 这样，Hadoop 所需的 Java 运行环境就安装好了。 安装 Hadoop 2Hadoop 2 可以通过 http://mirror.bit.edu.cn/apache/hadoop/common/ 或者 http://mirrors.cnnic.cn/apache/hadoop/common/ 下载，一般选择下载最新的稳定版本，即下载 “stable” 下的 hadoop-2.x.y.tar.gz 这个格式的文件，这是编译好的，另一个包含 src 的则是 Hadoop 源代码，需要进行编译才可使用。 截止到2015年12月9日，Hadoop官方网站已经更新到2.7.1版本。对于2.6.0以上版本的Hadoop，仍可以参照此教程学习，可放心下载官网最新版本的Hadoop。 如果读者是使用虚拟机方式安装Ubuntu系统的用户，请用虚拟机中的Ubuntu自带firefox浏览器访问本指南，再点击下面的地址，才能把hadoop文件下载虚拟机ubuntu中。请不要使用Windows系统下的浏览器下载，文件会被下载到Windows系统中，虚拟机中的Ubuntu无法访问外部Windows系统的文件，造成不必要的麻烦。 如果读者是使用双系统方式安装Ubuntu系统的用户，请进去Ubuntu系统，在Ubuntu系统打开firefox浏览器访问本指南，再点击下面的地址下载：hadoop-2.7.1下载地址 下载完 Hadoop 文件后一般就可以直接使用。但是如果网络不好，可能会导致下载的文件缺失，可以使用 md5 等检测工具可以校验文件是否完整。 点击查看：如何校验下载的文件是否完整 我们选择将 Hadoop 安装至 /usr/local/ 中： sudo tar -zxf ~/下载/hadoop-2.6.0.tar.gz -C /usr/local # 解压到/usr/local中 cd /usr/local/ sudo mv ./hadoop-2.6.0/ ./hadoop # 将文件夹名改为hadoop sudo chown -R hadoop ./hadoop # 修改文件权限 Shell 命令 Hadoop 解压后即可使用。输入如下命令来检查 Hadoop 是否可用，成功则会显示 Hadoop 版本信息： cd /usr/local/hadoop ./bin/hadoop version Shell 命令 相对路径与绝对路径请务必注意命令中的相对路径与绝对路径，本文后续出现的 ./bin/...，./etc/... 等包含 ./ 的路径，均为相对路径，以 /usr/local/hadoop 为当前目录。例如在 /usr/local/hadoop 目录中执行 ./bin/hadoop version 等同于执行 /usr/local/hadoop/bin/hadoop version。可以将相对路径改成绝对路径来执行，但如果你是在主文件夹 ~ 中执行 ./bin/hadoop version，执行的会是 /home/hadoop/bin/hadoop version，就不是我们所想要的了。 Hadoop单机配置(非分布式)Hadoop 默认模式为非分布式模式（本地模式），无需进行其他配置即可运行。非分布式即单 Java 进程，方便进行调试。 现在我们可以执行例子来感受下 Hadoop 的运行。Hadoop 附带了丰富的例子（运行 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar 可以看到所有例子），包括 wordcount、terasort、join、grep 等。 在此我们选择运行 grep 例子，我们将 input 文件夹中的所有文件作为输入，筛选当中符合正则表达式 dfs[a-z.]+ 的单词并统计出现的次数，最后输出结果到 output 文件夹中。 cd /usr/local/hadoop mkdir ./input cp ./etc/hadoop/*.xml ./input # 将配置文件作为输入文件 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output ‘dfs[a-z.]+’ cat ./output/* # 查看运行结果 Shell 命令 执行成功后如下所示，输出了作业的相关信息，输出的结果是符合正则的单词 dfsadmin 出现了1次 Hadoop单机模式运行grep的输出结果 注意，Hadoop 默认不会覆盖结果文件，因此再次运行上面实例会提示出错，需要先将 ./output 删除。 rm -r ./output Shell 命令 Hadoop伪分布式配置Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。 Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。 修改配置文件 core-site.xml (通过 gedit 编辑会比较方便: gedit ./etc/hadoop/core-site.xml)，将当中的 &lt;/configuration&gt; XML 修改为下面配置： hadoop.tmp.dir file:/usr/local/hadoop/tmp Abase for other temporary directories. &lt;/property&gt; fs.defaultFS hdfs://localhost:9000 &lt;/property&gt; &lt;/configuration&gt; XML 同样的，修改配置文件 hdfs-site.xml： dfs.replication 1 &lt;/property&gt; dfs.namenode.name.dir file:/usr/local/hadoop/tmp/dfs/name &lt;/property&gt; dfs.datanode.data.dir file:/usr/local/hadoop/tmp/dfs/data &lt;/property&gt; &lt;/configuration&gt; XML _Hadoop配置文件说明_Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回非分布式模式，需要删除 core-site.xml 中的配置项。 此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（官方教程如此），不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。 配置完成后，执行 NameNode 的格式化: ./bin/hdfs namenode -format Shell 命令 成功的话，会看到 “successfully formatted” 和 “Exitting with status 0” 的提示，若为 “Exitting with status 1” 则是出错。 执行namenode格式化 如果在这一步时提示 Error: JAVA_HOME is not set and could not be found. 的错误，则说明之前设置 JAVA_HOME 环境变量那边就没设置好，请按教程先设置好 JAVA_HOME 变量，否则后面的过程都是进行不下去的。 接着开启 NameNode 和 DataNode 守护进程。 ./sbin/start-dfs.sh #start-dfs.sh是个完整的可执行文件，中间没有空格 Shell 命令 若出现如下SSH提示，输入yes即可。 启动Hadoop时的SSH提示 启动时可能会出现如下 WARN 提示：WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable WARN 提示可以忽略，并不会影响正常使用。 _启动 Hadoop 时提示 Could not resolve hostname_如果启动 Hadoop 时遇到输出非常多“ssh: Could not resolve hostname xxx”的异常情况，如下图所示： 启动Hadoop时的异常提示 这个并不是 ssh 的问题，可通过设置 Hadoop 环境变量来解决。首先按键盘的 ctrl + c 中断启动，然后在 ~/.bashrc 中，增加如下两行内容（设置过程与 JAVA_HOME 变量一样，其中 HADOOP_HOME 为 Hadoop 的安装目录）： export HADOOP_HOME=/usr/local/hadoop export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native Shell 保存后，务必执行 source ~/.bashrc 使变量设置生效，然后再次执行 ./sbin/start-dfs.sh 启动 Hadoop。 启动完成后，可以通过命令 jps 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode”（如果 SecondaryNameNode 没有启动，请运行 sbin/stop-dfs.sh 关闭进程，然后再次尝试启动尝试）。如果没有 NameNode 或 DataNode ，那就是配置不成功，请仔细检查之前步骤，或通过查看启动日志排查原因。 通过jps查看启动的Hadoop进程 Hadoop无法正常启动的解决方法一般可以查看启动日志来排查原因，注意几点： 启动时会提示形如 “DBLab-XMU: starting namenode, logging to /usr/local/hadoop/logs/hadoop-hadoop-namenode-DBLab-XMU.out”，其中 DBLab-XMU 对应你的机器名，但其实启动日志信息是记录在 /usr/local/hadoop/logs/hadoop-hadoop-namenode-DBLab-XMU.log 中，所以应该查看这个后缀为 .log 的文件； 每一次的启动日志都是追加在日志文件之后，所以得拉到最后面看，对比下记录的时间就知道了。 一般出错的提示在最后面，通常是写着 Fatal、Error、Warning 或者 Java Exception 的地方。 可以在网上搜索一下出错信息，看能否找到一些相关的解决方法。 此外，若是 DataNode 没有启动，可尝试如下的方法（注意这会删除 HDFS 中原有的所有数据，如果原有的数据很重要请不要这样做）： # 针对 DataNode 没法启动的解决方法 ./sbin/stop-dfs.sh # 关闭 rm -r ./tmp # 删除 tmp 文件，注意这会删除 HDFS 中原有的所有数据 ./bin/hdfs namenode -format # 重新格式化 NameNode ./sbin/start-dfs.sh # 重启 Shell 命令 成功启动后，可以访问 Web 界面 http://localhost:50070 查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。 Hadoop的Web界面 运行Hadoop伪分布式实例上面的单机模式，grep 例子读取的是本地数据，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要在 HDFS 中创建用户目录： ./bin/hdfs dfs -mkdir -p /user/hadoop Shell 命令 _注意_教材《大数据技术原理与应用》的命令是以”./bin/hadoop dfs”开头的Shell命令方式，实际上有三种shell命令方式。 1. hadoop fs 2. hadoop dfs 3. hdfs dfs hadoop fs适用于任何不同的文件系统，比如本地文件系统和HDFS文件系统 hadoop dfs只能适用于HDFS文件系统 hdfs dfs跟hadoop dfs的命令作用一样，也只能适用于HDFS文件系统 接着将 ./etc/hadoop 中的 xml 文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/hadoop/input 中。我们使用的是 hadoop 用户，并且已创建相应的用户目录 /user/hadoop ，因此在命令中就可以使用相对路径如 input，其对应的绝对路径就是 /user/hadoop/input: ./bin/hdfs dfs -mkdir input ./bin/hdfs dfs -put ./etc/hadoop/*.xml input Shell 命令 复制完成后，可以通过如下命令查看文件列表： ./bin/hdfs dfs -ls input Shell 命令 伪分布式运行 MapReduce 作业的方式跟单机模式相同，区别在于伪分布式读取的是HDFS中的文件（可以将单机步骤中创建的本地 input 文件夹，输出结果 output 文件夹都删掉来验证这一点）。 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output ‘dfs[a-z.]+’ Shell 命令 查看运行结果的命令（查看的是位于 HDFS 中的输出结果）： ./bin/hdfs dfs -cat output/* Shell 命令 结果如下，注意到刚才我们已经更改了配置文件，所以运行结果不同。 Hadoop伪分布式运行grep结果 我们也可以将运行结果取回到本地： rm -r ./output # 先删除本地的 output 文件夹（如果存在） ./bin/hdfs dfs -get output ./output # 将 HDFS 上的 output 文件夹拷贝到本机 cat ./output/* Shell 命令 Hadoop 运行程序时，输出目录不能存在，否则会提示错误 “org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:9000/user/hadoop/output already exists” ，因此若要再次执行，需要执行如下命令删除 output 文件夹: ./bin/hdfs dfs -rm -r output # 删除 output 文件夹 Shell 命令 _运行程序时，输出目录不能存在_运行 Hadoop 程序时，为了防止覆盖结果，程序指定的输出目录（如 output）不能存在，否则会提示错误，因此运行前需要先删除输出目录。在实际开发应用程序时，可考虑在程序中加上如下代码，能在每次运行时自动删除输出目录，避免繁琐的命令行操作： Configuration conf = new Configuration(); Job job = new Job(conf); /* 删除输出目录 */ Path outputPath = new Path(args[1]); outputPath.getFileSystem(conf).delete(outputPath, true); Java 若要关闭 Hadoop，则运行 ./sbin/stop-dfs.sh Shell 命令 _注意_下次启动 hadoop 时，无需进行 NameNode 的初始化，只需要运行 ./sbin/start-dfs.sh 就可以！ YARNYARN 是 Hadoop 2.x 中的内容，使用林子雨编写的大数据技术原理与应用教材的读者，可不用学习YARN内容。 如果对这方便的内容感兴趣，可点击下方查看。 点击查看：启动YARN 自此，你已经掌握 Hadoop 的配置和基本使用了。安装好的Hadoop项目中已经包含了第三章的HDFS，继续学习第3章HDFS文件系统，请参考如下学习指南：大数据技术原理与应用 第三章 学习指南 附加教程: 配置PATH环境变量在这里额外讲一下 PATH 这个环境变量（可执行 echo $PATH 查看，当中包含了多个目录）。例如我们在主文件夹 ~ 中执行 ls 这个命令时，实际执行的是 /bin/ls 这个程序，而不是 ~/ls 这个程序。系统是根据 PATH 这个环境变量中包含的目录位置，逐一进行查找，直至在这些目录位置下找到匹配的程序（若没有匹配的则提示该命令不存在）。 上面的教程中，我们都是先进入到 /usr/local/hadoop 目录中，再执行 sbin/hadoop，实际上等同于运行 /usr/local/hadoop/sbin/hadoop。我们可以将 Hadoop 命令的相关目录加入到 PATH 环境变量中，这样就可以直接通过 start-dfs.sh 开启 Hadoop，也可以直接通过 hdfs 访问 HDFS 的内容，方便平时的操作。 同样我们选择在 ~/.bashrc 中进行设置（vim ~/.bashrc，与 JAVA_HOME 的设置相似），在文件最前面加入如下单独一行: export PATH=$PATH:/usr/local/hadoop/sbin:/usr/local/hadoop/bin 添加后执行 source ~/.bashrc 使设置生效，生效后，在任意目录中，都可以直接使用 hdfs 等命令了，读者不妨现在就执行 hdfs dfs -ls input 查看 HDFS 文件试试看。 安装Hadoop集群在平时的学习中，我们使用伪分布式就足够了。如果需要安装 Hadoop 集群，请查看Hadoop集群安装配置教程。 相关教程 使用Eclipse编译运行MapReduce程序: 使用 Eclipse 可以方便的开发、运行 MapReduce 程序，还可以直接管理 HDFS 中的文件。 使用命令行编译打包运行自己的MapReduce程序: 有时候需要直接通过命令来编译、打包 MapReduce 程序。 参考资料 http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html http://www.cnblogs.com/xia520pi/archive/2012/05/16/2503949.html http://www.micmiu.com/bigdata/hadoop/hadoop-2x-ubuntu-build/]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>Ubuntu16.04</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hadoop_ABOUT_linziyu]]></title>
    <url>%2Fpost%2F5f7bb5ba.html</url>
    <content type="text"><![CDATA[-3.15- 接下来我们利用 HDFS提供的一套API接口，用户可以实现类似于Unix系统的命令来操作文件系统上的文件和目录。&lt;注意：此处为API接口命令-此处我们并不用于进行XFTP的显示表示。！！！&gt; 其中：在解决 JAVA_HOME不能显示时，重新配置了 hdfs-env.sh 将jdk改为绝对路径。 再来就是 经常出现的namenode崩坏！————启用了新的格式化namenode的方法： ./bin/hadoop namenode -format ·芝士： 再来关于jps 出的都是JAVA进程！我们只有一台主机和一个伪分布式方式的【DataNode】所以在 hdfs-site.xml中设置value为1 集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令）【即本地主机!】 遇到的问题 重大问题：1.打开不了 secondarynode ： 防火墙暂时关闭&lt;暂时不用&gt; 2.打开不了 namenode datanode：http://www.powerxing.com/linux-environment-variable/设置的环境变量出了问题 3.打开了 namenode 未打开datanode。通过查看logs 发现 java.io.IOException: Incompatible clusterIDs in /usr/local/hadoop/hdfs/data: namenode clusterID = CID-af6f15aa-efdd-479b-bf55-77270058e4f7; datanode clusterID = CID-736d1968-8fd1-4bc4-afef-5c72354c39ce 错误 从日志中可以看出，原因是因为datanode的clusterID 和 namenode的clusterID 不匹配。 打开hdfs-site.xml里配置的datanode和namenode对应的目录，分别打开current文件夹里的VERSION，可以看到clusterID项正如日志里记录的一样，确实不一致，修改datanode里VERSION文件的clusterID 与namenode里的一致，再重新启动dfs（执行start-dfs.sh）再执行jps命令可以看到datanode已正常启动。 原因:每次namenode format会重新创建一个namenodeId,而tmp/dfs/data下包含了上次format下的id,namenode format清空了namenode下的数据,但是没有晴空datanode下的数据,导致启动时失败,所要做的就是每次fotmat前,清空tmp一下的所有目录. 4.重启服务 reboot 完成！！！访问：http://123.206.69.206:50070/ -PS:扩展阅读：深入理解 NameNode 和 DataNode 主要原因 ：我们重复./bin/hdfs namenode -format 还有dfs.namenode.data.dir 的源头 ·localhost: Warning: Permanently added ‘localhost’ (RSA) to the list of known hosts ·gedit ·如何你的centos显示中文乱码，只要修改字符编码使centos支持中文就可以了，没有这个文件可以创建它，下面是修改步骤 一、中文支持 安装中文语言包： 复制代码 代码如下: yum groupinstall chinese-support 修改字符编码配置，没有这个文件就创建它： 复制代码 代码如下: vim /etc/sysconfig/i18n 修改后内容如下： 复制代码 代码如下: LANG=”zh_CN.GB18030″ SUPPORTED=”zh_CN.UTF-8:zh_CN:zh:en_US.UTF-8:en_US:en” SYSFONT=”latarcyrheb-sun16″ i18n文件是用来设置系统语言，比如：zh_CN.UTF-8、zh_CN.GB18030、zh_TW.Big5、en_US.UTF-8等。 i18n中三个环境变量： LANG变量，设置系统语言。 SUPPORTED变量决定系统支持的语言，即系统能够显示的语言。 SYSFONT变量表示系统字体。 最后重启服务器： 复制代码 代码如下: reboot 这样在字符界面命令交互中就会出现中文了，但是有些翻译的不全。 使用locale命令查看系统语言设置： 复制代码 代码如下: locale&lt;/p&gt; LANG=zh_CN.GB18030 LC_CTYPE=”zh_CN.GB18030″ LC_NUMERIC=”zh_CN.GB18030″ LC_TIME=”zh_CN.GB18030″ LC_COLLATE=”zh_CN.GB18030″ LC_MONETARY=”zh_CN.GB18030″ LC_MESSAGES=”zh_CN.GB18030″ LC_PAPER=”zh_CN.GB18030″ LC_NAME=”zh_CN.GB18030″ LC_ADDRESS=”zh_CN.GB18030″ LC_TELEPHONE=”zh_CN.GB18030″ LC_MEASUREMENT=”zh_CN.GB18030″ LC_IDENTIFICATION=”zh_CN.GB18030″ LC_ALL= 默认语言为en_US.UTF-8或POSIX，设置后为zh_CN.GB18030。 二、vim显示中文 安装中文包后还要编辑vim的配置文件vimrc： vim /etc/vimrc 在最后加入以下内容： 复制代码 代码如下: set fileencoding=utf-8 set fileencodings=utf-8,gb18030,gbk,big5 PS：让Linux VPS支持中文主要为了方便查看如wordpress、discuz程序的备注及注释等，都是中文版的嘛。PS2：这样设置后系统和vim可以显示简体中文了，但是繁体中文还是不能显示，不知道哪里设错了啊？？我的理解是系统语言有中文，vim是个文字编辑器，设置为utf-8编码格式，所有utf-8编码的文字都能显示？还是没有相应的字库所以就显示乱码了，那么安装的中文包里没有繁体中文的字库？PS3：试了多次发现i18n文件中LANG设为zh_CN.gb18030、zh_CN.gbk、zh_CN.gb2312都能正常显示简体中文，但是设为zh_CN.utf-8，就会乱码。 Hadoop安装教程_伪分布式配置_CentOS6.4/Hadoop2.6.0本 Hadoop 教程由厦门大学数据库实验室出品，转载请注明。本教程适合于在 CentOS 6.x 系统中安装原生 Hadoop 2，适用于Hadoop 2.7.1, Hadoop 2.6.0 等版本，主要参考了官方安装教程，步骤详细，辅以适当说明，相信按照步骤来，都能顺利在 CentOS 中安装并运行 Hadoop。 环境本教程使用 CentOS 6.4 32位 作为系统环境，请自行安装系统（可参考使用VirtualBox安装CentOS）。如果用的是 Ubuntu 系统，请查看相应的 Ubuntu安装Hadoop教程。 本教程基于原生 Hadoop 2，在 Hadoop 2.6.0 (stable) 版本下验证通过，可适合任何 Hadoop 2.x.y 版本，例如 Hadoop 2.7.1, Hadoop 2.4.1等。 Hadoop版本Hadoop 有两个主要版本，Hadoop 1.x.y 和 Hadoop 2.x.y 系列，比较老的教材上用的可能是 0.20 这样的版本。Hadoop 2.x 版本在不断更新，本教程均可适用。如果需安装 0.20，1.2.1这样的版本，本教程也可以作为参考，主要差别在于配置项，配置请参考官网教程或其他教程。 新版是兼容旧版的，书上旧版本的代码应该能够正常运行（我自己没验证，欢迎验证反馈）。 装好了 CentOS 系统之后，在安装 Hadoop 前还需要做一些必备工作。 创建hadoop用户如果你安装 CentOS 的时候不是用的 “hadoop” 用户，那么需要增加一个名为 hadoop 的用户。 首先点击左上角的 “应用程序” -&gt; “系统工具” -&gt; “终端”，首先在终端中输入 su ，按回车，输入 root 密码以 root 用户登录，接着执行命令创建新用户 hadoop: su # 上述提到的以 root 用户登录 useradd -m hadoop -s /bin/bash # 创建新用户hadoop Shell 命令 如下图所示，这条命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为shell。 CentOS创建hadoop用户 接着使用如下命令修改密码，按提示输入两次密码，可简单的设为 “hadoop”（密码随意指定，若提示“无效的密码，过于简单”则再次输入确认就行）: passwd hadoop Shell 命令 可为 hadoop 用户增加管理员权限，方便部署，避免一些对新手来说比较棘手的权限问题，执行： visudo Shell 命令 如下图，找到 root ALL=(ALL) ALL 这行（应该在第98行，可以先按一下键盘上的 ESC 键，然后输入 :98 (按一下冒号，接着输入98，再按回车键)，可以直接跳到第98行 ），然后在这行下面增加一行内容：hadoop ALL=(ALL) ALL （当中的间隔为tab），如下图所示： 为hadoop增加sudo权限 添加上一行内容后，先按一下键盘上的 ESC 键，然后输入 :wq (输入冒号还有wq，这是vi/vim编辑器的保存方法)，再按回车键保存退出就可以了。 最后注销当前用户(点击屏幕右上角的用户名，选择退出-&gt;注销)，在登陆界面使用刚创建的 hadoop 用户进行登陆。（如果已经是 hadoop 用户，且在终端中使用 su 登录了 root 用户，那么需要执行 exit 退出 root 用户状态） 准备工作使用 hadoop 用户登录后，还需要安装几个软件才能安装 Hadoop。 CentOS 使用 yum 来安装软件，需要联网环境，首先应检查一下是否连上了网络。如下图所示，桌面右上角的网络图标若显示红叉，则表明还未联网，应点击选择可用网络。 检查是否联网 连接网络后，需要安装 SSH 和 Java。 安装SSH、配置SSH无密码登陆集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令），一般情况下，CentOS 默认已安装了 SSH client、SSH server，打开终端执行如下命令进行检验： rpm -qa | grep ssh Shell 命令 如果返回的结果如下图所示，包含了 SSH client 跟 SSH server，则不需要再安装。 检查是否安装了SSH 若需要安装，则可以通过 yum 进行安装（安装过程中会让你输入 [y/N]，输入 y 即可）： sudo yum install openssh-clients sudo yum install openssh-server Shell 命令 接着执行如下命令测试一下 SSH 是否可用： ssh localhost Shell 命令 此时会有如下提示(SSH首次登陆提示)，输入 yes 。然后按提示输入密码 hadoop，这样就登陆到本机了。 测试SSH是否可用 但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。 首先输入 exit 退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中： exit # 退出刚才的 ssh localhost cd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhost ssh-keygen -t rsa # 会有提示，都按回车就可以 cat id_rsa.pub &gt;&gt; authorized_keys # 加入授权 chmod 600 ./authorized_keys # 修改文件权限 Shell 命令 ~的含义在 Linux 系统中，~ 代表的是用户的主文件夹，即 “/home/用户名” 这个目录，如你的用户名为 hadoop，则 ~ 就代表 “/home/hadoop/“。 此外，命令中的 # 后面的文字是注释。 此时再用 ssh localhost 命令，无需输入密码就可以直接登陆了，如下图所示。 SSH无密码登录 安装Java环境Java 环境可选择 Oracle 的 JDK，或是 OpenJDK，现在一般 Linux 系统默认安装的基本是 OpenJDK，如 CentOS 6.4 就默认安装了 OpenJDK 1.7。按 http://wiki.apache.org/hadoop/HadoopJavaVersions 中说的，Hadoop 在 OpenJDK 1.7 下运行是没问题的。需要注意的是，CentOS 6.4 中默认安装的只是 Java JRE，而不是 JDK，为了开发方便，我们还是需要通过 yum 进行安装 JDK，安装过程中会让输入 [y/N]，输入 y 即可： sudo yum install java-1.7.0-openjdk java-1.7.0-openjdk-devel Shell 命令 通过上述命令安装 OpenJDK，默认安装位置为 /usr/lib/jvm/java-1.7.0-openjdk（该路径可以通过执行 rpm -ql java-1.7.0-openjdk-devel | grep &#39;/bin/javac&#39; 命令确定，执行后会输出一个路径，除去路径末尾的 “/bin/javac”，剩下的就是正确的路径了）。OpenJDK 安装后就可以直接使用 java、javac 等命令了。 接着需要配置一下 JAVA_HOME 环境变量，为方便，我们在 ~/.bashrc 中进行设置（扩展阅读: 设置Linux环境变量的方法和区别）： vim ~/.bashrc Shell 命令 在文件最后面添加如下单独一行（指向 JDK 的安装位置），并保存： export JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk Shell 如下图所示： 设置JAVA_HOME环境变量 接着还需要让该环境变量生效，执行如下代码： source ~/.bashrc # 使变量设置生效 Shell 命令 设置好后我们来检验一下是否设置正确： echo $JAVA_HOME # 检验变量值 java -version $JAVA_HOME/bin/java -version # 与直接执行 java -version 一样 Shell 命令 如果设置正确的话，$JAVA_HOME/bin/java -version 会输出 java 的版本信息，且和 java -version 的输出结果一样，如下图所示： 成功设置JAVA_HOME环境变量 这样，Hadoop 所需的 Java 运行环境就安装好了。 安装 Hadoop 2Hadoop 2 可以通过 http://mirror.bit.edu.cn/apache/hadoop/common/ 或者 http://mirrors.cnnic.cn/apache/hadoop/common/ 下载，本教程选择的是 2.6.0 版本，下载时请下载 hadoop-2.x.y.tar.gz 这个格式的文件，这是编译好的，另一个包含 src 的则是 Hadoop 源代码，需要进行编译才可使用。 下载时强烈建议也下载 hadoop-2.x.y.tar.gz.mds 这个文件，该文件包含了检验值可用于检查 hadoop-2.x.y.tar.gz 的完整性，否则若文件发生了损坏或下载不完整，Hadoop 将无法正常运行。 本文涉及的文件均通过浏览器下载，默认保存在 “下载” 目录中（若不是请自行更改 tar 命令的相应目录）。另外，如果你用的不是 2.6.0 版本，则将所有命令中出现的 2.6.0 更改为你所使用的版本。 cat ~/下载/hadoop-2.6.0.tar.gz.mds | grep ‘MD5’ # 列出md5检验值 # head -n 6 ~/下载/hadoop-2.7.1.tar.gz.mds # 2.7.1版本格式变了，可以用这种方式输出 md5sum ~/下载/hadoop-2.6.0.tar.gz | tr “a-z” “A-Z” # 计算md5值，并转化为大写，方便比较 Shell 命令 若文件不完整则这两个值一般差别很大，可以简单对比下前几个字符跟后几个字符是否相等即可，如下图所示，如果两个值不一样，请务必重新下载。 检验文件完整性 我们选择将 Hadoop 安装至 /usr/local/ 中： sudo tar -zxf ~/下载/hadoop-2.6.0.tar.gz -C /usr/local # 解压到/usr/local中 cd /usr/local/ sudo mv ./hadoop-2.6.0/ ./hadoop # 将文件夹名改为hadoop sudo chown -R hadoop:hadoop ./hadoop # 修改文件权限 Shell 命令 Hadoop 解压后即可使用。输入如下命令来检查 Hadoop 是否可用，成功则会显示 Hadoop 版本信息： cd /usr/local/hadoop ./bin/hadoop version Shell 命令 相对路径与绝对路径请务必注意命令中的相对路径与绝对路径，本文后续出现的 ./bin/...，./etc/... 等包含 ./ 的路径，均为相对路径，以 /usr/local/hadoop 为当前目录。例如在 /usr/local/hadoop 目录中执行 ./bin/hadoop version 等同于执行 /usr/local/hadoop/bin/hadoop version。可以将相对路径改成绝对路径来执行，但如果你是在主文件夹 ~ 中执行 ./bin/hadoop version，执行的会是 /home/hadoop/bin/hadoop version，就不是我们所想要的了。 Hadoop单机配置(非分布式)Hadoop 默认模式为非分布式模式，无需进行其他配置即可运行。非分布式即单 Java 进程，方便进行调试。 现在我们可以执行例子来感受下 Hadoop 的运行。Hadoop 附带了丰富的例子（运行 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar 可以看到所有例子），包括 wordcount、terasort、join、grep 等。 在此我们选择运行 grep 例子，我们将 input 文件夹中的所有文件作为输入，筛选当中符合正则表达式 dfs[a-z.]+ 的单词并统计出现的次数，最后输出结果到 output 文件夹中。 cd /usr/local/hadoop mkdir ./input cp ./etc/hadoop/*.xml ./input # 将配置文件作为输入文件 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output ‘dfs[a-z.]+’ cat ./output/* # 查看运行结果 Shell 命令 若运行出错，如出现如下图提示： 运行Hadoop实例时可能会报错 若出现提示 “WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable”，该 WARN 提示可以忽略，不会影响 Hadoop 正常运行（可通过编译 Hadoop 源码解决，解决方法请自行搜索）&lt;原因即为 32位编译了lib！ 而你用的centos64位系统！&gt;。 若出现提示 “INFO metrics.MetricsUtil: Unable to obtain hostName java.net.UnknowHostException”，这需要执行如下命令修改 hosts 文件，为你的主机名增加IP映射： sudo vim /etc/hosts Shell 命令 主机名在终端窗口标题里可以看到，或执行命令 hostname 查看，如下图所示，在最后面增加一行 “127.0.0.1 dblab”： 设置主机名的IP映射 保存文件后，重新运行 hadoop 实例，若执行成功的话会输出很多作业的相关信息，最后的输出信息如下图所示。作业的结果会输出在指定的 output 文件夹中，通过命令 cat ./output/* 查看结果，符合正则的单词 dfsadmin 出现了1次： Hadoop例子输出结果 注意，Hadoop 默认不会覆盖结果文件，因此再次运行上面实例会提示出错，需要先将 ./output 删除。 rm -r ./output Shell 命令 Hadoop伪分布式配置Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。 在设置 Hadoop 伪分布式配置前，我们还需要设置 HADOOP 环境变量，执行如下命令在 ~/.bashrc 中设置： gedit ~/.bashrc Shell 命令 这次我们选择用 gedit 而不是 vim 来编辑。gedit 是文本编辑器，类似于 Windows 中的记事本，会比较方便。保存后记得关掉整个 gedit 程序，否则会占用终端。在文件最后面增加如下内容： # Hadoop Environment Variables export HADOOP_HOME=/usr/local/hadoop export HADOOP_INSTALL=$HADOOP_HOME export HADOOP_MAPRED_HOME=$HADOOP_HOME export HADOOP_COMMON_HOME=$HADOOP_HOME export HADOOP_HDFS_HOME=$HADOOP_HOME export YARN_HOME=$HADOOP_HOME export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin Shell &lt;注意我是用的 source /etc/profile 配置的jdk和hadoop home注意看开头那篇文档&gt; 保存后，不要忘记执行如下命令使配置生效： source ~/.bashrc Shell 命令 这些变量在启动 Hadoop 进程时需要用到，不设置的话可能会报错（这些变量也可以通过修改 ./etc/hadoop/hadoop-env.sh 实现）。 Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。 修改配置文件 core-site.xml (通过 gedit 编辑会比较方便: gedit ./etc/hadoop/core-site.xml)，将当中的 &lt;/configuration&gt; XML 修改为下面配置： hadoop.tmp.dir file:/usr/local/hadoop/tmp Abase for other temporary directories. &lt;/property&gt; fs.defaultFS hdfs://localhost:9000 &lt;/property&gt; &lt;/configuration&gt; XML 同样的，修改配置文件 hdfs-site.xml： dfs.replication 1 &lt;/property&gt; dfs.namenode.name.dir file:/usr/local/hadoop/tmp/dfs/name &lt;/property&gt; dfs.datanode.data.dir file:/usr/local/hadoop/tmp/dfs/data &lt;/property&gt; &lt;/configuration&gt; XML 配置完成后，执行 NameNode 的格式化: ./bin/hdfs namenode -format Shell 命令 成功的话，会看到 “successfully formatted” 和 “Exitting with status 0” 的提示，若为 “Exitting with status 1” 则是出错。 执行NameNode格式化 接着开启 NaneNode 和 DataNode 守护进程： ./sbin/start-dfs.sh Shell 命令 若出现如下 SSH 的提示 “Are you sure you want to continue connecting”，输入 yes 即可。 首次启动Hadoop时的SSH提示 启动时可能会有 WARN 提示 “WARN util.NativeCodeLoader…” 如前面提到的，这个提示不会影响正常使用。 启动完成后，可以通过命令 jps 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode”和SecondaryNameNode（如果 SecondaryNameNode 没有启动，请运行 sbin/stop-dfs.sh 关闭进程，然后再次尝试启动尝试）。如果没有 NameNode 或 DataNode ，那就是配置不成功，请仔细检查之前步骤，或通过查看启动日志排查原因。 通过jps查看启动的Hadoop进程 _通过查看启动日志分析启动失败原因_有时 Hadoop 无法正确启动，如 NameNode 进程没有顺利启动，这时可以查看启动日志来排查原因，注意几点： 启动时会提示形如 “dblab: starting namenode, logging to /usr/local/hadoop/logs/hadoop-hadoop-namenode-dblab.out”，其中 dblab 对应你的主机名，但启动的日志信息是记录在 /usr/local/hadoop/logs/hadoop-hadoop-namenode-dblab.log 中，所以应该查看这个后缀为 .log 的文件； 每一次的启动日志都是追加在日志文件之后，所以得拉到最后面看，看下记录的时间就知道了。 一般出错的提示在最后面，也就是写着 Fatal、Error 或者 Java Exception 的地方。 可以在网上搜索一下出错信息，看能否找到一些相关的解决方法。 成功启动后，可以访问 Web 界面 http://localhost:50070 查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。 Hadopp的Web界面 运行Hadoop伪分布式实例上面的单机模式，grep 例子读取的是本地数据，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要在 HDFS 中创建用户目录： ./bin/hdfs dfs -mkdir -p /user/hadoop Shell 命令 接着将 ./etc/hadoop 中的 xml 文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/hadoop/input 中。我们使用的是 hadoop 用户，并且已创建相应的用户目录 /user/hadoop ，因此在命令中就可以使用相对路径如 input，其对应的绝对路径就是 /user/hadoop/input: ./bin/hdfs dfs -mkdir input ./bin/hdfs dfs -put ./etc/hadoop/*.xml input Shell 命令 复制完成后，可以通过如下命令查看 HDFS 中的文件列表： ./bin/hdfs dfs -ls input Shell 命令 伪分布式运行 MapReduce 作业的方式跟单机模式相同，区别在于伪分布式读取的是HDFS中的文件（可以将单机步骤中创建的本地 input 文件夹，输出结果 output 文件夹都删掉来验证这一点）。 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output ‘dfs[a-z.]+’ Shell 命令 查看运行结果的命令（查看的是位于 HDFS 中的输出结果）： ./bin/hdfs dfs -cat output/* Shell 命令 结果如下，注意到刚才我们已经更改了配置文件，所以运行结果不同。 Hadoop伪分布式运行grep的结果 我们也可以将运行结果取回到本地： rm -r ./output # 先删除本地的 output 文件夹（如果存在） ./bin/hdfs dfs -get output ./output # 将 HDFS 上的 output 文件夹拷贝到本机 cat ./output/* Shell 命令 Hadoop 运行程序时，输出目录不能存在，否则会提示错误 “org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:9000/user/hadoop/output already exists” ，因此若要再次执行，需要执行如下命令删除 output 文件夹: ./bin/hdfs dfs -rm -r output # 删除 output 文件夹 Shell 命令 _运行程序时，输出目录不能存在_运行 Hadoop 程序时，为了防止覆盖结果，程序指定的输出目录（如 output）不能存在，否则会提示错误，因此运行前需要先删除输出目录。在实际开发应用程序时，可考虑在程序中加上如下代码，能在每次运行时自动删除输出目录，避免繁琐的命令行操作： Configuration conf = new Configuration(); Job job = new Job(conf); /* 删除输出目录 */ Path outputPath = new Path(args[1]); outputPath.getFileSystem(conf).delete(outputPath, true); Java 若要关闭 Hadoop，则运行 ./sbin/stop-dfs.sh Shell 命令 _注意_下次启动 hadoop 时，无需进行 NameNode 的初始化，只需要运行 ./sbin/start-dfs.sh 就可以！ 启动YARN（伪分布式不启动 YARN 也可以，一般不会影响程序执行） 有的读者可能会疑惑，怎么启动 Hadoop 后，见不到书上所说的 JobTracker 和 TaskTracker，这是因为新版的 Hadoop 使用了新的 MapReduce 框架（MapReduce V2，也称为 YARN，Yet Another Resource Negotiator）。 YARN 是从 MapReduce 中分离出来的，负责资源管理与任务调度。YARN 运行于 MapReduce 之上，提供了高可用性、高扩展性，YARN 的更多介绍在此不展开，有兴趣的可查阅相关资料。 上述通过 ./sbin/start-dfs.sh 启动 Hadoop，仅仅是启动了 MapReduce 环境，我们可以启动 YARN ，让 YARN 来负责资源管理与任务调度。 首先修改配置文件 mapred-site.xml，这边需要先进行重命名： mv ./etc/hadoop/mapred-site.xml.template ./etc/hadoop/mapred-site.xml Shell 命令 然后再进行编辑，同样使用 gedit 编辑会比较方便些 gedit ./etc/hadoop/mapred-site.xml ： mapreduce.framework.name yarn &lt;/property&gt; &lt;/configuration&gt; XML 接着修改配置文件 yarn-site.xml： yarn.nodemanager.aux-services mapreduce_shuffle &lt;/property&gt; &lt;/configuration&gt; XML 然后就可以启动 YARN 了（需要先执行过 ./sbin/start-dfs.sh）： ./sbin/start-yarn.sh $ 启动YARN ./sbin/mr-jobhistory-daemon.sh start historyserver # 开启历史服务器，才能在Web中查看任务运行情况 Shell 命令 开启后通过 jps 查看，可以看到多了 NodeManager 和 ResourceManager 两个后台进程，如下图所示。 开启YARN 启动 YARN 之后，运行实例的方法还是一样的，仅仅是资源管理方式、任务调度不同。观察日志信息可以发现，不启用 YARN 时，是 “mapred.LocalJobRunner” 在跑任务，启用 YARN 之后，是 “mapred.YARNRunner” 在跑任务。启动 YARN 有个好处是可以通过 Web 界面查看任务的运行情况：http://localhost:8088/cluster，如下图所示。 开启YARN后可以查看任务运行信息 但 YARN 主要是为集群提供更好的资源管理与任务调度，然而这在单机上体现不出价值，反而会使程序跑得稍慢些。因此在单机上是否开启 YARN 就看实际情况了。 不启动 YARN 需重命名 mapred-site.xml如果不想启动 YARN，务必把配置文件 mapred-site.xml 重命名，改成 mapred-site.xml.template，需要用时改回来就行。否则在该配置文件存在，而未开启 YARN 的情况下，运行程序会提示 “Retrying connect to server: 0.0.0.0/0.0.0.0:8032” 的错误，这也是为何该配置文件初始文件名为 mapred-site.xml.template。 同样的，关闭 YARN 的脚本如下： ./sbin/stop-yarn.sh ./sbin/mr-jobhistory-daemon.sh stop historyserver Shell 命令 自此，你已经掌握 Hadoop 的配置和基本使用了。 附加教程: 配置PATH环境变量在这里额外讲一下 PATH 这个环境变量（可执行 echo $PATH 查看，当中包含了多个目录）。例如我们在主文件夹 ~ 中执行 ls 这个命令时，实际执行的是 /bin/ls 这个程序，而不是 ~/ls 这个程序。系统是根据 PATH 这个环境变量中包含的目录位置，逐一进行查找，直至在这些目录位置下找到匹配的程序（若没有匹配的则提示该命令不存在）。 上面的教程中，我们都是先进入到 /usr/local/hadoop 目录中，再执行 ./sbin/hadoop，实际上等同于运行 /usr/local/hadoop/sbin/hadoop。我们可以将 Hadoop 命令的相关目录加入到 PATH 环境变量中，这样就可以直接通过 start-dfs.sh 开启 Hadoop，也可以直接通过 hdfs 访问 HDFS 的内容，方便平时的操作。 在前面我们设置 HADOOP 环境变量时，我们已经顺便设置了 PATH 变量（即 “export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin”），那么以后我们在任意目录中都可以直接通过执行 start-dfs.sh 来启动 Hadoop 或者执行 hdfs dfs -ls input 查看 HDFS 文件了，读者不妨现在就执行 hdfs dfs -ls input 试试看。 安装Hadoop集群在平时的学习中，我们使用伪分布式就足够了。如果需要安装 Hadoop 集群，请查看Hadoop集群安装配置教程。 相关教程 使用Eclipse编译运行MapReduce程序: 用文本编辑器写 Java 程序是不靠谱的，还是用 Eclipse 比较方便。 使用命令行编译打包运行自己的MapReduce程序: 有时候需要直接通过命令来编译 MapReduce 程序。 参考资料 Hadoop: Setting up a Single Node Cluster How to Setup Hadoop 2.7.1 on CentOS, Ubuntu &amp; LinuxMint Yarn简单介绍及内存配置]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP与MySQL程序设计（ac）]]></title>
    <url>%2Fpost%2Fb1445283.html</url>
    <content type="text"><![CDATA[TEST： 30+50+5+100=185 需求分析和原型设计 数据库的操作 登录的判断和分帧使用 Ajax应用和自定义标签驱动 —AI 4 照着笔记做！00 课表收集-ppt。srt —3.2—- 平时多学习下 style SS 样式 //注意一定要加上结束标签 代码重构中我们才 优化结构 ;;;;Jquery learing! Session 的学习！ 退出效果 ———— —-Tips:函数phpinfo() 找到相应的配置位置！http://blog.csdn.net/meegomeego/article/details/25704645 Configuration File (php.ini) Path /usr/local/php-5.6/etc Loaded Configuration File /home/wwwroot/thinkphp3/etc/amh-php.ini phpinfo();函数是了解安装PHP的一个绝佳途径，因为他会提供有关服务器、操作系统 环境以及可用扩展包的大量信息！ Tips:如果构建过程中并没有看到有明显的错误，原因可能是P14 造成。 利用 phpDocumentor生成高级文档，开始就要注意其中的语法规则！ -php.ini -httpd.conf ] 都是 相应的 全局配置文件！&lt;; 代表注释。Off 设置&gt; P17 php.ini相关配置！ P32 也就是说咱们也可以在网页的引号中使用 html的方法！ 并不是某件事可以使用就理所当然的应该使用！]]></content>
      <categories>
        <category>PHP&amp;amp;MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android假期学习中...自更新中...配置版本参数]]></title>
    <url>%2Fpost%2F699043a1.html</url>
    <content type="text"><![CDATA[安卓开发eclipse中AVD（android虚拟设备） ADT（Android Develop Tool） SDK(Software Development Kit) JRE以及模拟器之间关系——————* jre： java runtime enviroment 提供java运行时环境，做java开发的基础环境，eclipse运行时也需要 avd：android virtual device 安卓模拟器，就是一个虚拟的安卓系统 adt： android develop toolkit 安卓开发工具链，是eclipse的一个插件 SDK：Software Develop Kit 提供不同版本的api 在eclipse上做android开发时用到SDK+ADT来配置基本开发环境，AVD来运行调试App 不喜欢探究原理、机制的程序员不是好程序员！ 第一章 Android应用和环境开发P9-P10 AVD（android虚拟设备|SDK P18 Monitor调试| ADB（Adroid Debug Bridge）完成模拟器文件与电脑文件的相互复制，也可安装APK应用。甚至可以直接切换到Android系统中执行Linux命令！ [caption id=”attachment_537” align=”aligncenter” width=”561”] 自动生成的R.java相关说明！[/caption] R.java 可以理解为Android应用的资源字典。。res中可以方便的让AAPT工具来扫描对应的资源文件，并为他们生成对应的资源清单类：R.java。 P31 权限添加！ SDK-Develop-API Guides(开发指南)。H:\\Android\\SDK\\docs 然而一旦被R 定义之后，就可以允许在java、XML 中使用了。 &lt;&gt;测试删除线_测试斜体__123_ 有的时候 意志不坚定（差不多先生），真的会迷失了自己的理想、方向！牢记自己的方向! 小计划：每天来看一看自己的博客！ 更好的自己！GO！ 2017.1.20 人不会因为自己的梦想而受伤 第二章 Android应用的界面编程P41 View类的XML属性、相关方法及说明！ 3.7 aboutAndroid 在Android工程中，每添加一个资源，就会在gen目录下的R.Java中自动生成一个新的静态整型变量来指向这个资源。程序文件中调用资源的时候，先在R.java中找到变量名，然后根据变量值查找资源。 可以直接在工程的\\res\\drawable文件夹里拷贝一个图片文件过去。然后在eclipse里右键点工程-&gt;刷新。在 res – drawable 标签下就会多出来你添加的图片。R.java中也会自动添加一个以图片文件名为变量名的整型变量。 注意：文件名必须全为小写。如果有大写的话，R.java中不会生成新的变量，这样程序里也就没办法调用。 我这里就是因为文件名中有大写字母导致生成R.java中变量不成功！ PS：C:\\Users\\acanprince\.gradle\\wrapper\\dists\\gradle-2.2.1-all\\c64ydeuardnfqctvr1gm30w53http://www.tuicool.com/articles/eqAbQ3ehttp://www.bubuko.com/infodetail-1008155.htmlAPI211.修改-H:\\TableLayoutTest\\gradle\\wrapperdistributionUrl=https\\://services.gradle.org/distributions/gradle-2.14.1-all.zip2.直接放置在工程根目录下”build.gradle”-&gt; dependencies{} 下面直接粘贴-》classpath ‘com.android.tools.build:gradle:2.2.2’3.apply plugin: ‘com.android.application’android { compileSdkVersion 25 buildToolsVersion “25.0.2” defaultConfig { applicationId “org.crazyit.ui” minSdkVersion 21 targetSdkVersion 25 versionCode 1 versionName “1.0” } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’ } }}dependencies { compile fileTree(dir: ‘libs’, include: [‘*.jar’])}//in H:\\TableLayoutTest\\app\\build.gradlehttp://download.csdn.net/album/detail/2265代码关于解决AndroidStudio导入项目在 Building gradle project info 一直卡住 最近在加了 Android-M，更新API配置，使计划类APP 能够运用Google更加强大的services API261.修改-H:\\TableLayoutTest\\gradle\\wrapperdistributionUrl=https\\://services.gradle.org/distributions/gradle-3.3-all.zip2.直接放置在工程根目录下”build.gradle”-&gt; dependencies{} 下面直接粘贴-》classpath ‘com.android.tools.build:gradle:2.3.3’3.apply plugin: ‘com.android.application’android { compileSdkVersion 26 buildToolsVersion “26.0.1” dexOptions { preDexLibraries true dexInProcess true maxProcessCount 8 threadCount 8 } defaultConfig { applicationId “io.ipoli.android” multiDexEnabled true minSdkVersion 21 targetSdkVersion 26 versionCode 228 versionName “1.16.9” }dependencies { compile fileTree(dir: ‘libs’, include: [‘*.jar’])}//in H:\\TableLayoutTest\\app\\build.gradle ——3.8 instant run applied code changes and restarted the app 即时运行应用代码更改并重新启动应用程序 ——3.9 ——5.13 注意：quartus安装路径：不可以有中文、也不可以有空格！]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHPKJ_S05]]></title>
    <url>%2Fpost%2F8df09641.html</url>
    <content type="text"><![CDATA[123456789101112131415161718**PHP 脚本在服务器上执行，然后向浏览器发送回纯 HTML 结果。** PHP 文件的默认文件扩展名是 &quot;.php&quot;。 PHP 文件通常包含 HTML 标签以及一些 PHP 脚本代码。 1.在 PHP 中，所有用户定义的函数、类和关键词（例如 if、else、echo 等等）都对大小写不敏感。 不过在 PHP 中，所有变量都对大小写敏感。 在下面的例子中，只有第一条语句会显示 $color 变量的值（这是因为 $color、$COLOR 以及 $coLOR 被视作三个不同的变量）： 2.注释相关&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;?php// 这是单行注释\# 这也是单行注释/*这是多行注释块它横跨了多行*/?&gt;&lt;/body&gt;&lt;/html&gt;3.]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[THINKPHP26--30]]></title>
    <url>%2Fpost%2F3b6f518d.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920T喵的。今天ECS欠费了。 [https://help.aliyun.com/knowledge_detail/40653.html 具体是按照流出流量来计费的&lt;ECS 出走的&gt;](https://help.aliyun.com/knowledge_detail/40653.html) 流量计算公式 服务器入网出网带宽都是以服务器角度来说的。 **入网带宽**：流入服务器的带宽 从服务器内部下载外部网络资源，或者从客户端FTP等方式上传资源到服务器都是入网带宽，ECS服务器入带宽不限制。 **出网带宽**：流出服务器的带宽 从服务器对外提供访问，或者从客户端FTP等方式下载服务器内部资源都是出网带宽，ECS服务器出带宽就是购买的带宽值。 \[caption id=&quot;attachment_525&quot; align=&quot;alignnone&quot; width=&quot;300&quot;\]![](http://123.206.69.206/wp-content/uploads/2017/01/流量计算公式-300x292.jpg) 流量计算公式ECS\[/caption\] ---30讲 关联模型与分页效果 第三大自动-6.17 自动完成 6.24 关系模型 ---多个数据库（MODEL 模型里面进行对应！） 字符戳 更改 &lt;&#123;$vo.time|date=&apos;Y m d H:m:s&apos;,###&#125;&gt;&lt;br/&gt; 19.6 分页！ 自动完成机制---md5加密 的Login的设置！！！！！！ www.lampbrother.net www.thinphp0cn --29讲 自动创建数据 6.10（手册） 自动验证 - 对于html中的JS 只是用于提示&lt;君子&gt;用户名重复了！ 咱们还需要太多的后台进行扫重验证！ &lt;正则表达式 learning&gt; 文件上传 处理 杂项-文件处理 --28讲 script Ajax 对于 &apos;?&apos; 传值的使用！ .get ? var ? 此讲 一定多多注意 单双引号的冲突性！ --29讲权限判断和三大自动！ 手册 - 13.3 Action类提供了一个初始化方法_initialize接口！！！可以来进行相应的判断 CommonAction 里面进行 ini接口的 声明！ 其它的使用ini 方法的直接继承自他即可！ * * *自我规划： 这个世界上值得热爱的东西太多，等我们发现这一点，就不会畏惧痛苦和失去。别害怕孤单，你要学会，对热爱的东西不遗余力。* * * 很多问题自己可以查看 完全开发手册：关于URL路由：统一网站的入口，方便程序在应用环境初始变量方面的初始化工作，使网站更安全。统一的入口会对URL进行解析，初始化环境神马的，然后分配不同的工作，有点像路由器。这样可以美化URL，便于用户记忆，优化搜索引擎收录。统一处理请求的地址，根据请求的地址参数，分别执行不同程序，这在[MVC模式](https://www.baidu.com/s?wd=MVC%E6%A8%A1%E5%BC%8F&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YYuj9Wm1fLrHRdujR1PW6s0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHcdPH0zrjn4)构架的项目里是很常见的，比如：请求地址是[http://demo.com/index.php?m=news&amp;c=article&amp;a=list](http://demo.com/index.php?m=news&amp;c=article&amp;a=list)所有的请求都走index.php，然后在index.php里面接受三个参数分别是new，article，list，根据这三个参数去找要执行的程序，比如这里要执行news模块下的acticle控制器里的list方法，这只是一个典型例子而以，当然情况多变，根据你的需求来]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读书计划_中文_英文]]></title>
    <url>%2Fpost%2Fa018b06e.html</url>
    <content type="text"><![CDATA[精进阅读相关————笔记: （一）时间之尺，我们应该怎样对待时间”时间之尺&lt;一种思维工具&gt;——一个人如何对待时间，决定了他将是一个什么样的人！ 使远期未来的目标更加具体化、情景化和可实施； 降低近期未来中的“非期望行为的便利性”，主动增加挑战的难度； 积极地过去视角、当下轻乐视角和未来具象计划思想。 现代社会的快节奏、碎片化和功利性等特点，使得我们容易陷入:1.选择无能；2.执行无能。法则： 尽量少做“短半衰期”得事情！&lt;只要这个事情对于你长期的益处 你仍然可以去做！收益可以累加且不是短半衰期就去做吧！&gt; 具体长半衰期： 积累可信的知识 训练实践技能 构建新的思维模式 提升审美品味 反思和总结个人经历 保持和促进健康 建立和维持相互信任的关系 寻找和获得稀缺性的资源 探索、提出独创性的构思或发明 获得高峰体验 方法、技能以及稀缺性和具有核心竞争力提高的属性。 清醒的意识到我们在做什么、要追求什么， 才能做出让自己不后悔的选择！ 正如采铜老师所说：一部经典的作品必然包含了某种接近“事物本质”的东西，也就是某种根源性的东西，所以世间千殊百异的人、事、物，最后都可能和这个根源性的东西发生共振。因此一部经典作品就像是一道特殊的光源，不同时代的读者去赏析他时，都会被这道光源照见内心不增被照亮的部分，即便是同一个人，在不同的人生阶段去读它，也会因为想法和境遇的改变而被照亮内心中不同的地方。而且在表象的最后，是更深刻和稳定的中长尺度的丈量之尺发挥的原因！ 从原本追求“即时兴奋”的信息模式切换到追求“长久受益”的信息模式——把“信息噪音”辨析出来、并且过滤掉。用更多的时间和精力去寻找和领会哪些真正有价值的信息。&lt;不为潮流所动、偏执地发现自己的才能（兴趣热情）并且向他们似的走一条自主选择并且可以一往无前的道路&gt; ”把握好做事的节奏，区分“求快”的事件和“求慢”的事件。快慢之间的转化。”提升时间使用的“深度”，减少被动式休闲的比例，保持至少一项长期的爱好。 P31关键，改变态度、勇敢前行。 （二）寻找心中的“巴拿马”&lt;选择&gt;”从终极问题出发。&lt;以人生最高目标作为第一原则&gt; 必须擅长说“不”，以便于去做那些真正特别的事情！——比尔盖茨学习巴菲特。 一人生最高目标作为第一原则！ 一个成熟的人，他的标准来自于他的内心。 价值之尺————最高目标为原则！《感受。。。。。。》 P38 P44 P50 P69 P73 300页计划。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C#相关 与D.S.实现！]]></title>
    <url>%2Fpost%2F54f3d29a.html</url>
    <content type="text"><![CDATA[C# 中没有全局变量或全局函数，取而代之的是通过静态函数和静态变量完成的。 和 C++ 要求用户显示创建 delete 运算符不一样，它们使用新运算符创建，且没有 delete 运算符。 在 C# 中它们自动由垃圾回收系统回收。 C# 提供了一种更加便捷、简单而又直接的属性访问方式。 所以上面的类应该写成这样： 代码: using System; class Date { public int Day{ get { return day; } set { day = value; } } int day; public int Month{ get { return month; } set { month = value; } } int month; public int Year{ get { return year; } set { year = value; } } int year; public bool IsLeapYear(int year) { return year%4== 0 ? true: false; } public void SetDate (int day, int month, int year) { this.day = day; this.month = month; this.year = year; } } 这里是你 get 和 set 属性的方法： 代码: class User { public static void Main() { Date date = new Date(); date.Day = 27; date.Month = 6; date.Year = 2003; Console.WriteLine (“Date: {0}/{1}/{2}”, date.Day, date.Month, date.Year); } } 修饰符 你必须知道 C++ 中常用的 public、private 和 protected 修饰符。 我将在这里讨论一些 C# 引入的新的修饰符。 readonly readonly 修饰符仅用于修饰类的数据成员。 正如其名 字说的，一旦它们已经进行了写操作、直接初始化或在构造函数中对其进行了赋值， readonly 数据成员就只能对其进行读取。 readonly 和 const 数据成员不同之处在于 const 要求你在声明时进行直接初始化。 看下面的例程： 代码: class MyClass { const int constInt = 100; //直接进行 readonly int myInt = 5; //直接进行 readonly int myInt2; public MyClass() { myInt2 = 8; //间接进行 } public Func() { myInt = 7; //非法 Console.WriteLine(myInt2.ToString()); } } sealed 带有 sealed 修饰符的类不允许你从它继承任何类。所以如果你不想一个类被继承， 你可以对该类使用 sealed 关键字。 代码: sealed class CanNotbeTheParent { int a = 5; } unsafe 你可以使用 unsafe 修饰符在 C# 中定义一个不安全上下文。 在不安全上下文中，你可以插入不安全代码，如 C++ 的指针等。参见以下代码： 代码: public unsafe MyFunction( int pInt, double pDouble) { int* pAnotherInt = new int; *pAnotherInt = 10; pInt = pAnotherInt; … *pDouble = 8.9; } 接口 如果你有 COM 的思想，你马上就知道我在说什么了。接口是只包含函数签名而在子类中实现的抽象基类。 在 C# 中，你可以用 interface 关键字声明这样的接口类。 .NET 就是基于这样的接口的。 C# 中你不能对类进行多重继承——这在 C++ 中是允许的。 通过接口，多重继承的精髓得以实现。即你的子类可以实现多重接口。（译注：由此可以实现多重继承） 代码: using System; interface myDrawing { int originx { get; set; } int originy { get; set; } void Draw(object shape); } class Shape: myDrawing { int OriX; int OriY; public int originx { get{ return OriX; } set{ OriX = value; } } public int originy { get{ return OriY; } set{ OriY = value; } } public void Draw(object shape) { … // 做要做的事 } // 类自身的方法 public void MoveShape(int newX, int newY) { ….. } } （类似于引用的传递方法）http://www.cnblogs.com/gsk99/archive/2010/12/13/1904557.html 拆箱和装箱：int i=1 //声明一个值类型的变量 object o=i; //装箱，在堆上开辟一块内存，复制i的值到此内存块，公布一个地址，o引用它，o则为已装箱值类型(引用类型)，会发生内存复制的操作。 int b=(int)o; //拆箱，通过o查找到托管堆上的内存快，提领这个内存快中值的地址，然后然后给b赋值，，事实上在给b赋值这一步不能算拆箱的一步，所以拆箱比装箱廉价得多 待于解决： 组在 C# 中比 C++ 中要高级很多。数组分配于堆中，所以是引用类型的。]]></content>
      <categories>
        <category>C#</category>
        <category>D.S.</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D.S._课程设计_查阅（参考）]]></title>
    <url>%2Fpost%2F451c1701.html</url>
    <content type="text"><![CDATA[&amp;*Edge:0x942af8 &amp;Edge: 0x6afee4 &amp;**Edge: 0x946310 &amp;Edge[0][0]: 0x946310 &amp;Edge[0]: 0x942af8 Edge: 0x942af8 Edge[0]: 0x946310 Edge[0][0]: 9725544 Edge: 0x942af8 *Edge: 0x946310 **Edge: 9725544 可以查看 双语版C++ P214！！！ //图因此无法以数据元素在内存中的物理位置来表示元素之间的关系！ //用多重链表 会使得产生巨大浪费（度太多的话） //邻接矩阵存储的图的类定义（无向图） //对于无向图考虑到 图是由顶点和边（或弧）组成且 顶点部分大小、主次。 //一维数组存储 点。二维数组存储边。//或者用指针也一样9 //—关于邻接表 //相对于 树 一样 而言如果存储的少。可以避免很多浪费 用邻接表————即数组和 链表结合 // 1.最小生成树树的代价唯一 （对）II. 权值最小的边一定会出现在所有的最小生成树中 （错）III. 用普里姆（Prim）算法从不同顶点开始得到的最小生成树一定相同（错） IV. 普里姆算法和克鲁斯卡尔（Kruskal）算法得到的最小生成树总不相同（错）]]></content>
      <categories>
        <category>D.S.</category>
        <category>课程设计_12</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决genymotion+AS无法安装APK_神奇的事情又再一次发生了！！！]]></title>
    <url>%2Fpost%2Fa64bbbd9.html</url>
    <content type="text"><![CDATA[第一次使用Android Studio的程序员应该做的事： 【墙裂推荐！】http://www.cnblogs.com/smyhvae/p/4390905.html “神TM”坑相关： and打开USB调试 and 第一个对勾取消！ 还有人说SDK版本高了：http://www.bubuko.com/infodetail-1008155.html 链接上相关芝士~ 下载：1.先注册 2.再进入 www.genymotion.com/download （注意 或者在 resource-&gt; fun zoom）]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android:前端开发&&设计_12_24_开题]]></title>
    <url>%2Fpost%2F2ee7607e.html</url>
    <content type="text"><![CDATA[开题必须深入分析需求、提出设计方案， 最好放出原型图！ 演讲时注意一定要 避免空洞！紧扣主题！抓重点来讲！ 要有眼界——从ios10看待设计的新趋势。 http://www.mobileui.cn/ios-10-design-guidelines-change.html Material Design Ghost in the Shell http://www.uisdc.com/soul-in-the-chatbots 。同时结合问卷调查中的各领域偏好，建立个性化推荐机制，增加用户粘性，为产品创造更大的价值。 我们对页面的整体风格设计方向的定位是个性、简约。个性——让用户更有效的把注意力集中在内容上，在期间不断的进行对设计的探索和研究，简约——让用户在使用我们产品时能够跟轻便和舒适的获取所需。最终呈现出了全新的百度wise产品体验。 http://www.uisdc.com/baidu-home-page-design-flow 产品分析 改版设计思路，将围绕着“解决女性用户的痛点，传达时尚的感知体验”展开。表达和呈现内容 在UI设计上，针对每个具体模块，去剖析每个业务的运营策略，深度理解需要传达的信息和传递的氛围等，根据不同的内容设计不同的承载样式，最终形成完整统一的内容流。 同一个页面不同的内容模块之间，主要考虑： （1）不同的业务模块通过不同样式的组合设计，准确地传达信息内容，同时使页面丰富动感，摆脱单调； （2）突出重点运营的优质内容：如目前的“红人穿搭”，“精选专题”等模块，在设计手法上，通过图片内容、布局、面积、位置等各种因素的综合设计，最终呈现出的结果使用户能快速有效地捕捉到最重要的信息点 新版app在短短的一个多月内，完成了从方向调整到开发上线的全过程，而设计在其中仅仅只占一周多，这也是互联网公司面临的共性难题。为了配合产品小步快跑的策略，我们采用敏捷设计的方法：快速地进行竞品分析，根据低保真原型一边进行业务细化和方案讨论，一边进行视觉风格的设计。 到第一版上线时，仍有若干页面尚未调整完毕，也有诸多细节尚存缺陷，但身处这个快速发展的时代，设计必须快节奏高效率，让我们产品的新切入点、新的创意、新的想法能尽快地去和用户接触，获得更多更真实的反馈。 所有的改变都伴随着风险，但作为一个还在路上的创业公司，不改变就不会比昨天更好。 所幸，新版App上线后，收获了很多女孩子的好评和关注，随之活跃度和转化率数据也走出了一个漂亮的上扬曲线。 我们，一直在路上，为设计更好的产品…… http://www.uisdc.com/mogujie-app-redesign-workflow http://www.uisdc.com/full-ui-design-process UI干活分析 全流程！ 另外：扁平化分析2.0： http://www.uisdc.com/6-fresh-flat-style-design 2017年不容错过的最佳UX设计工具及教程资源整理http://www.mobileui.cn/2017-the-best-ux-design-tools.html 什么是视觉设计:我们到底需要到达什么程度？: http://www.mobileui.cn/how-to-learn-visual-design.html 看了这三点，就知道UX设计师该如何起步 http://www.mobileui.cn/ux-designer-how-to-start.html 实战经验： http://www.woshipm.com/pmd/510851.html 产品经理能力和职责要求： www.woshipm.com/pmd/516218.html 高级产品经理的思考：思维：http://www.woshipm.com/pmd/530350.html 核桃APP设计以及规范：www.woshipm.com/ucd/524061.html 快速学习产品基础必备技能： http://www.woshipm.com/pmd/518852.html 发布会、、武大相信梦想的力量！ http://www.mobileui.cn/eight-ted-speech.html About : 设计之网易公开课！ fkandroid使用前见： Android Studio 使用Genymotion http://daoshud1.iteye.com/blog/2275232]]></content>
      <categories>
        <category>日记之家</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针Review]]></title>
    <url>%2Fpost%2F2abbd0bd.html</url>
    <content type="text"><![CDATA[！区分好 ： 1:&amp;p 2:p 3:*p 4:&amp;*p!!!!int *p; 不要再钻牛角尖啦！！！！！！http://blog.sina.com.cn/s/blog_59c804b60102vzcf.html《即只有 类、结构体的 对象具有浅拷贝和深拷贝！operate》 结构体的浅拷贝！ 注意 必看： /缺省拷贝构造函数在拷贝过程中是按字节复制的，对于指针型成员变量只复制指针本身，而不复制指针所指向的目标—浅拷贝。 只是 一一复制 p指向的地址！ 其中 当中的 stu【i】 = P260 可以看 自己复制内容进去！ / C语言指针的初始化和赋值1、指针的初始化 指针初始化时，“=”的右操作数必须为内存中数据的地址，不可以是变量，也不可以直接用整型地址值(但是int*p=0;除外，该语句表示指针为空)。此时，*p只是表示定义的是个指针变量，并没有间接取值的意思。 例如：int a = 25; int *ptr = &a; int b[10]; int *point = b; int *p = &amp;b[0]; 如果：int *p; *p = 7; 则编译器（vs2008）会提示The variable ‘p’ is being used without being initialized.即使用了未初始化的变量p。 因为p是指向7所在的地址，*p = 7给p所指向的内存赋值，p没有赋值，所以p所指向的内存位置是随机的，没有初始化的。 int k; int *p; p = &k; //给p赋值 *p = 7; //给p所指向的内存赋值，即k= 7 2、指针的赋值 int *p; int a; int b[1]; p = &a; p = b; 指针的赋值，“=”的左操作数可以是*p，也可以是p。 当“=”的左操作数是*p时，改变的是p所指向的地址存放的数据； 当“=”的左操作数是p时，改变的是p所指向的地址。 数组的变量名b表示该数组的首地址，因此p=b；也是正确的 同类型的指针赋值： int val1 = 18,val2 = 19; int *p1,*p2; p1 = &val1; p2 = &val2; p1 = p2; //注意啦，p1指向了val2，而没有指向val1 备注：字符串与指针的初始化和赋值 初始化： char cp = “abcdefg”; //这个初始化过程，是将指针cp指向字符串的首地址，而并不是传递字符串的值。因为，在C语言里面，没有整体处理一个字符串的机制 赋值： cp = “abcdefg”; \cp=”abcdefg” ;//错误！字符串常量传递的是它的首地址，不可以通过*cp修改该字符串的值，因为该字符串为常量，而它只是简单的将指针指向该字符串常量 3、指针常量 在C语言中没有一种内建（built-in）的方法去表示指针常量，所以当我们使用它的时候通常先写成整型常量的形式，然后再通过强制类型转换把它转换成相应的类型，如：int , double , char 等。 所以后面所示的做法是不行的： int \p = 0x12345678 ; 正确的方式应为：int *p = (int ) 0x12345678; 要注意指针中只能存放地址，不能将一个非0值整型常量表达式或者其他非地址类型的数据赋给一个指针，原因就在此。在大多数计算机中，内存地址确实是以无符号整型数来表示的，而且多以16进制表示，但我们在C语言中不能用整型数去表示地址，只能用指针常量来表示，因为它是被用来赋给一个指针的。 对于这个赋值问题还可以换一个角度去理解，在C语言中，使用赋值操作符时，赋值操作符左边和右边的表达式类型应该是相同的，如果不是，赋值操作符将试图把右边表达式的值转换为左边的类型。所以如果写出int \p = 0x12345678 ; 这条语句编译器会报错：’=’ : cannot convert from ‘ const int ‘ to ‘ int * ‘ ，因为赋值操作符左边和右边的表达式的类型应该相同，而0x12345678是int型常量，p是一个指向int型的指针，两者类型不同，所以正确的方式是：int *p = (int *) 0x12345678 ; 4、指针初始化补充 ANSI C定义了零指针常量的概念：一个具有0值的整形常量表达式，或者此类表达式被强制转换为void 类型，则称为空指针常量，它可以用来初始化或赋给任何类型的指针。也就是说，我们可以将0、0L、’/0’、2–2、0\5以及(void *)0赋给一个任何类型的指针，此后这个指针就成为一个空指针，由系统保证空指针不指向任何对象或函数。 ANSI C还定义了一个宏NULL，用来表示空指针常量。大多数C语言的实现中NULL是采用后面这种方式定义的：#define NULL ((void )0)。 对指针进行初始化时常用的有以下几种方式： 1.采用NULL或空指针常量，如：int \p = NULL;或 char *p = 2-2; 或float *p = 0; 2.取一个对象的地址然后赋给一个指针，如：int i = 3; int *ip = &amp;i； 3.将一个指针常量赋给一个指针，如：long *p = (long *)0xfffffff0; 4.将一个T类型数组的名字赋给一个相同类型的指针，如：char ary[100]; char *cp = ary; 5.将一个指针的地址赋给一个指针，如：int i = 3; int *ip = &amp;i；int **pp = &ip; 6.将一个字符串常量赋给一个字符指针，如：char *cp = “abcdefg”; 对指针进行初始化或赋值的实质是将一个地址或同类型(或相兼容的类型)的指针赋给它，而不管这个地址是怎么取得的。要注意的是：对于一个不确定要指向何种类型的指针，在定义它之后最好把它初始化为NULL，并在解引用这个指针时对它进行检验，防止解引用空指针。另外，为程序中任何新创建的变量提供一个合法的初始值是一个好习惯，它可以帮你避免一些不必要的麻烦。 5、void *型指针 ANSI C定义了一种void 型指针，表示定义一个指针，但不指定它指向何种类型的数据。void 型指针作为一种通用的指针，可以和其它任何类型的指针(函数指针除外)相互转化而不需要类型强制转换，但不能对它进行解引用及下标操作。C语言中的malloc函数的返回值就是一个void 型指针，我们可以把它直接赋给一个其他类型的指针，但从安全的编程风格角度以及兼容性上讲，最好还是将返回的指针强制转换为所需的类型，另外，malloc在无法满足请求时会通过返回一个空指针来作为“内存分配失败”的信号，所以要注意返回值指针的判空。 6、指向指针的指针 在指针初始化的第5种方式中提到了用一个指针的地址来初始化一个指针。回忆一下上一讲的内容：指针是一种变量，它也有自己的地址，所以它本身也是可用指针指向的对象。我们可以将指针的地址存放在另一个指针中，如： int i = 5000; int \pi = &i; int **ppi = &pi; 此时的ppi即是一个指向指针的指针,下图表示了这些对象： i的地址为108，pi的内容就是i的地址，而pi的地址为104，ppi的内容即是pi的地址。对ppi解引用照常会得到ppi所指的对象，所获得的对象是指向int型变量的指针pi。想要真正地访问到i.，必须对ppi进行两次解引用，如下面代码所示： printf(“%d”, i ); printf(“%d”, *pi ); printf(“%d”, **ppi ); 以上三条语句的输出均为5000 彻底搞定C语言指针详解-完整版-时候初学者-必备 1.语言中变量的实质 要理解C指针，我认为一定要理解C中“变量”的存储实质， 所以我就从“变量”这个东西开始讲起吧！ 先来理解理解内存空间吧！请看下图： 内存地址→ 6 7 8 9 10 11 12 13 ————————————————————————————————- 。。。 | | | | | | | |.。 ———————————————- ————————————————— 如图所示，内存只不过是一个存放数据的空间，就好像我 的看电影时的电影院中的座位一样。每个座位都要编号，我们的内存要存放各种各样的数据，当然我们 要知道我们的这些数据存放在什么位置吧！所以内存也要象座位一样进行编号了，这就是我们所说的内 存编址。座位可以是按一个座位一个号码的从一号开始编号，内存则是按一个字节一个字节进行编址， 如上图所示。每个字节都有个编号，我们称之为内存地址。好了，我说了这么多，现在你能理解内存空 间这个概念吗？ 我们继续看看以下的C、C++语言变量申明： int I； char a； 每次我们要使用某变量时都要事先这样申明它，它其实是内存中申请了一个名为i的整型变量宽 度的空间（DOS下的16位编程中其宽度为二个字节），和一个名为a的字符型变量宽度的空间（占一个字 节）。 我们又如何来理解变量是如何存在的呢。当我们如下申明变量时： int I； char a； 内存中的映象可能如下图： 内存地址→ 6 7 8 9 10 11 12 13 ———————————- —————————————————————- 。。。| | | | | | | |.。 ————————————————————————————————— 变量名|→i ←|→a ←| 图中可看出，i在内存起始地址为6上申请了 两个字节的空间（我这里假设了int的宽度为16位，不同系统中int的宽度是可能不一样的），并命名为 i. a在内存地址为8上申请了一字节的空间，并命名为a.这样我们就有两个不同类型的变量了。 2.赋值给变量 再看下面赋值： i=30 a=‘t’ 你当然知 道个两个语句是将30存入i变量的内存空间中，将‘t’字符存入a变量的内存空间中。我们可 以这样的形象理解啦： 内存地址→ 6 7 8 9 10 11 12 13 ———————————————————————— ———————————- 。。。 | 30 | ‘t’ | | | | |.。 —————————————————————————————————— —- |→i ←|→a ←| 3.变量在哪里？（即我想知道变量的地 址） 好了，接下来我们来看看&amp;i是什么意思？ 是取i变量所在的地址编号嘛！我们可 以这样读它：返回i变量的地址编号。你记住了吗？ 我要在屏幕上显示变量的地址值的话，可以 写如下代码： printf（“%d”，&amp;i）； 以上图的内存映象所例，屏幕上 显示的不是i值30，而是显示i的内存地址编号6了。当然实际你操作的时，i变量的地址值不会是这个数 了。 这就是我认为作为初学者们所应想象的变量存储实质了。请这样理解吧！ 最后总结代码如下： int main() { int i=39; printf(“%d\\n”,i); //① printf(“%d\\n”, &amp;i); //② } 现在你可知道 ①、②两个printf分别在屏幕上输出的是i的什么东西啊？ 好啦！下面我们就开始真正进入指针 的学习了。 二、指针是什么东西 想说弄懂你不容易啊！我们许多初学指针的人都要这样的感慨。我常常在思索它，为什么呢？其实生活中处处都有指针。我们也处处在使用它。有了它我们的生活才更加方便 了。没有指针，那生活才不方便。不信？你看下面的例子。 这是一个生活中的例子：比如说你要 我借给你一本书，我到了你宿舍，但是你人不在宿舍，于是我把书放在你的2层3号的书架上，并写了一 张纸条放在你的桌上。纸条上写着：你要的书在第2层3号的书架上。当你回来时，看到这张纸条。你就 知道了我借与你的书放在哪了。你想想看，这张纸条的作用，纸条本身不是书，它上面也没有放着书。 那么你又如何知道书的位置呢？因为纸条上写着书的位置嘛！其实这张纸条就是一个指针了。它上面的 内容不是书本身，而是书的地址，你通过纸条这个指针找到了我借给你的本书。 那么我们C，C++ 中的指针又是什么呢？请继续跟我来吧，看下面看一个申明一整型指针变量的语句如下： int pi； pi是一个指针，当然我们知道啦，但是这样说，你就以为pi一定是个多么特别的东西了。其 实，它也只过是一个变量而已。与上一篇中说的变量并没有实质的区别。不信你看下面图。 内存 地址→6 7 8 9 10 11 12 13 14 ——————————————————————————————— …| 30 | ‘t’ | | | | | | |…… —————————————————————————- —————- 变量 |→i ←|→a ←| |→ pi ←| （说明：这里我假设了指针只占2个字节宽度，实际上在32位系统中，指针的宽度 是4个字节宽的，即32位。）由图示中可以看出，我们使用int \Pi申明指针变量； 其实是在内存的某处 申明一个一定宽度的内存空间，并把它命名为Pi.你能在图中看出pi与前面的i，a 变量有什么本质区别 吗，没有，当然没有！pi也只不过是一个变量而已嘛！那么它又为什么会被称为指针？关键是我们要让 这个变量所存储的内容是什么。现在我要让pi成为真正有意义上的指针。请接着看下面语句： pi=&amp;i； 你应该知道 &amp;i是什么意思吧！再次提醒你啦：这是返回i变量的地址编 号。整句的意思就是把i地址的编号赋值给pi，也就是你在pi上写上i的地址编号。结果如下图所示： 内存地址→6 7 8 9 10 11 12 13 14 ————————————————————————————————— …| 30 | ‘t’ | | | 6 | | |…… ———————————————————————- —————————- 变量 |→i ←|→a ←| |→ pi ←| 你看，执行完pi=&amp;i；后，在图示中的系统中，pi的值是6.这 个6就是i变量的地址编号，这样pi就指向了变量i了。你看，pi与那张纸条有什么区别？pi不就是那张纸 条嘛！上面写着i的地址，而i就是那个本书。你现在看懂了吗？因此，我们就把pi称为指针。所以你要 记住，指针变量所存的内容就是内存的地址编号！好了，现在我们就可以通过这个指针pi来访问到i这个 变量了，不是吗？。看下面语句： printf（“%d”，*pi）； 那么pi什么意 思呢？你只要这样读它：pi内容所指的地址的内容（嘻嘻，看上去好像在绕口令了），就pi这张“ 纸条”上所写的位置上的那本 “书”——i .你看，Pi内容是6，也就是说 pi指向内存编号为6的地址。\pi嘛！就是它所指地址的内容，即地址编号6上的内容了。当然就是30的值 了。所以这条语句会在屏幕上显示30.也就是说printf（“%d”，*pi）；语句等价于printf （ “%d”， i ） ，请结合上图好好体会吧！ 到此为止，你掌握了类似&amp;i ， *pi写法的含义和相关操作吗。总的一句话 ，我们的纸条就是我们的指针，同样我们的pi也就是我们的纸条！剩下的就是我们如何应用这张纸条了 。最后我给你一道题： 程序如下 char a,*pa a=10 pa=&amp;a *pa=20 printf( “%d”, a) 你能直接看出输出的结果是什么吗？如 果你能，我想本篇的目的就达到了。好了，就说到这了。Happy to Study！在下篇中我将谈谈“指 针的指针”即对int * ppa；中ppa 的理解。 1.数组元素 看下面代码 int i,a[]={3,4,5,6,7,3,7,4,4,6}; for (i=0;i&lt;=9;i++) { printf ( “%d”, a[i] ); } 很显然，它是显示a 数组的各元素值。 我们还可以这样访问元素，如下 int i,a[]={3,4,5,6,7,3,7,4,4,6}; for (i=0;i&lt;=9;i++) { printf ( “%d”, (a+i) ); } 它的结果和作用完全一样 2. 通过指针访问数组元素 int i,*pa,a[]={3,4,5,6,7,3,7,4,4,6}; pa =a ;//请注意数组名a直接赋值给指针 pa for (i=0;i&lt;=9;i++) { printf ( “%d”, pa[i] ); } 很显然，它也是显示a 数组的各元素值。 另外与数组名一样也可如下： int i,*pa,a[]={3,4,5,6,7,3,7,4,4,6}; pa =a; for (i=0;i&lt;=9;i++) { printf ( “%d”, (pa+i) ); } 看pa=a即数组名赋值给指针，以及通过数组名、指针对元素的访问形式看，它们并没有什么区别，从 这里可以看出数组名其实也就是指针。难道它们没有任何区别？有，请继续。 3. 数组名与指针变量的区别 请看下面的代码： int i,\pa,a[]={3,4,5,6,7,3,7,4,4,6}; pa =a; for (i=0;i&lt;=9;i++) { printf ( “%d”, *pa ); pa++ ; //注意这里，指针值被修改 } 可以看出，这段代码也是将数组各元素值输出。不过，你把{}中的pa改成a试试。你会发现程序编译 出错，不能成功。看来指针和数组名还是不同的。其实上面的指针是指针变量，而数组名只是一个指针 常量。这个代码与上面的代码不同的是，指针pa在整个循环中，其值是不断递增的，即指针值被修改了 。数组名是指针常量，其值是不能修改的，因此不能类似这样操作：a++.前面4，5节中pa[i]，（pa+i ）处，指针pa的值是使终没有改变。所以变量指针pa与数组名a可以互换。 4. 申明指针常量 再请看下面的代码： int i, a[]={3,4,5,6,7,3,7,4,4,6}; int const pa=a;//注意const的位置：不是 const int pa， for (i=0;i&lt;=9;i++) { printf ( “%d”, \pa ); pa++ ; //注意这里，指针值被修改 } 这时候的代码能成功编译吗？不能。因为pa指针被定义为常量指针了。这时与数组名a已经没有不同 。这更说明了数组名就是常量指针。但是… int * const a={3，4，5，6，7，3，7，4，4，6}；//不行 int a[]={3，4，5，6，7，3，7，4，4，6}；//可以，所以初始化数组时必定要这样。 以上都是在VC6.0上实验。 1 int i 说起 你知道我们申明一个变量时象这样int i ；这个i是可能在它处重新变赋值的。 如下： int i=0； //… i=20；//这里重新赋值了 不过有一天我的程 序可能需要这样一个变量（暂且称它变量），在申明时就赋一个初始值。之后我的程序在其它任何处都 不会再去重新对它赋值。那我又应该怎么办呢？用const . //** const int ic =20； //… ic=40；//这样是不可以的，编译时是无法通过，因为我们不能对 const 修饰的ic重新赋值的。 //这样我们的程序就会更早更容易发现问题了。 //** 有了const修饰的ic 我们不称它为变量，而称符号常量，代表着20这 个数。这就是const 的作用。ic是不能在它处重新赋新值了。 认识了const 作用之后，另外，我 们还要知道格式的写法。有两种：const int ic=20；与int const ic=20；。它们是完全相同的。这一 点我们是要清楚。总之，你务必要记住const 与int哪个写前都不影响语义。有了这个概念后，我们来看 这两个家伙：const int pi与int const pi ，按你的逻辑看，它们的语义有不同吗？呵呵，你只要 记住一点，int 与const 哪个放前哪个放后都是一样的，就好比const int ic；与int const ic；一样 。也就是说，它们是相同的。 好了，我们现在已经搞定一个“双包胎”的问题。那么 int const pi与前两个式子又有什么不同呢？我下面就来具体分析它们的格式与语义吧！ 2 const int pi的语义 我先来说说const int pi是什么作用 （当然int const pi也是一样 的，前面我们说过，它们实际是一样的）。看下面的例子： //*代码开始 * int i1=30; int i2=40; const int pi=&i1; pi=&i2; //4.注意这里，pi可以在任意时候重新赋值一个新内存地址 i2=80; //5.想想看：这里能用\pi=80;来代替吗？当然不能 printf( “%d”, *pi ) ; //6. 输出是80 //*代码结束* 语义分析： 看出来了 没有啊，pi的值是可以被修改的。即它可以重新指向另一个地址的，但是，不能通过pi来修改i2的值。 这个规则符合我们前面所讲的逻辑吗？当然符合了！ 首先const 修饰的是整个pi（注意，我 写的是*pi而不是pi）。所以*pi是常量，是不能被赋值的（虽然pi所指的i2是变量，不是常量）。 其次，pi前并没有用const 修饰，所以pi是指针变量，能被赋值重新指向另一内存地址的。你可 能会疑问：那我又如何用const 来修饰pi呢？其实，你注意到int const pi中const 的位置就大概可 以明白了。请记住，通过格式看语义。哈哈，你可能已经看出了规律吧？那下面的一节也就没必要看下 去了。不过我还得继续我的战斗！ 3 再看int const pi 确实，int const pi与前面 的int const pi会很容易给混淆的。注意：前面一句的const 是写在pi前和号后的，而不是写在\pi 前的。很显然，它是修饰限定pi的。我先让你看例子： //*************代码开始 * int i1=30; int i2=40; int const pi=&i1; //pi=&i2; 4.注意这里，pi不能再这样重新赋值了，即不能再指向另一个新地址。 //所以我已经注释了它。 i1=80; //5.想想看：这里能用pi=80;来代替吗？可以，这 里可以通过*pi修改i1的值。 //请自行与前面一个例子比较。 printf( “% d”, *pi ) ; //6.输出是80 //*代码结束 * 语义分析： 看了这段代码，你明白了什么？有没有发现 pi值是不能重新赋值修改了。它只能永远指向初始化时的内存地址了。相反，这次你可以通过*pi来修改 i1的值了。与前一个例子对照一下吧！看以下的两点分析 1）pi因为有了const 的修饰，所以只 是一个指针常量：也就是说pi值是不可修改的（即pi不可以重新指向i2这个变量了）（看第4行）。 2）整个*pi的前面没有const 的修饰。也就是说，*pi是变量而不是常量，所以我们可以通过 *pi来修改它所指内存i1的值（看5行的注释） 总之一句话，这次的pi是一个指向int变量类型数 据的指针常量。 我最后总结两句： 1) 如果const 修饰在*pi前则不能改的是*pi（即不能 类似这样：*pi=50；赋值）而不是指pi. 2) 如果const 是直接写在pi前则pi不能改（即不能类似 这样：pi=&amp;i；赋值）。 请你务必先记住这两点，相信你一定不会再被它们给搞糊了。现在 再看这两个申明语句int const *pi和int * const pi时，呵呵，你会头昏脑胀还是很轻松惬意？它们各 自申明的pi分别能修改什么，不能修改什么？再问问自己！ 3) 补充三种情况。这里， 我再补充以下三种情况。其实只要上面的语义搞清楚了，这三种情况也就已经被包含了。不过作为三种 具体的形式，我还是简单提一下吧！ 情况一：int pi指针指向const int i常量的情况 //\*********begin***************** const int i1=40; int *pi; pi=&i1; //这样可以吗？不行，VC下是编译错。 //const int 类型的i1的地址 是不能赋值给指向int 类型地址的指针pi的。否则pi岂不是能修改i1的值了吗！ pi=(int* ) &i1; // 这样可以吗？强制类型转换可是C所支持的。 //ＶＣ下编译通过，但是仍 不能通过*pi=80来修改i1的值。去试试吧！看看具体的怎样。 //***********end* 情况二：const int pi指针指向const int i1的 情况 //\********begin**************** const int i1=40; const int pi; pi=&i1;//两个类型相同，可以这样赋值。很显然，i1的值无论是通过pi还是i1都不能修 改的。 //\********end***************** 情况三：用const int const pi申明 的指针 //\**********begin**************** int i const int const pi=&i;//你能想象pi能够作什么操作吗？pi值不能改，也不能通过pi修改i的值。因为不管是\pi还 是pi都是const的。 //************end** 下篇预告：函数参数的 指针传递，值传递，引用传递 迷惑（以为a，b已经代替了x，y，对x，y的操作就是对a，b的操作了，这 是一个错误的观点啊！）。 一、三道考题 开讲之前，我先请你做三道题目。（嘿嘿，得先把你的头脑搞昏才行 ……唉呀，谁扔我鸡蛋？） 1.考题一：程序代码如下： void Exchg1(int x, int y) { int tmp; tmp=x; x=y; y=tmp; printf (“x=%d,y=%d\\n”,x,y) } void main() { int a=4,b=6; Exchg1 (a,b) ; printf(“a=%d,b=%d\\n”,a,b) } 输出的结果 ： x=， y= a=， b= 问下划线的部分应是什么，请完成。 2.考题二：代码如下。 Exchg2(int *px, int *py) { int tmp=*px; *px=*py; *py=tmp; print(“*px=%d,*py=%d\\n”,*px,*py); } main() { int a=4; int b=6; Exchg2( &amp;a,&amp;b); Print (“a=%d,b=%d\\n”, a, b); } 输出的结果为： *px=， *py= a=， b= 问下划线的部分应是什么，请完成。 3.考题三： Exchg2(int &amp;x, int &amp;y) { int tmp=x; x=y; y=tmp; print(“x=%d,y=%d\\n”,x,y); } main() { int a=4; int b=6; Exchg2(a,b); Print(“a=%d,b=%d\\n”, a, b); } 输 出的结果： x=， y= a=， b= 问下划线的部分输出的应是什么， 请完成。 你不在机子上试，能作出来吗？你对你写出的答案有多大的把握？ 正确的答案 ，想知道吗？（呵呵，让我慢慢地告诉你吧！） 好，废话少说，继续我们的探索之旅了。 我们都知道：C语言中函数参数的传递有：值传递，地址传递，引用传递这三种形式。题一为值 传递，题二为地址传递，题三为引用传递。不过，正是这几种参数传递的形式，曾把我给搞得晕头转向 。我相信也有很多人与我有同感吧？ 下面请让我逐个地谈谈这三种传递形式。 二、函数 参数传递方式之一：值传递 1.值传递的一个错误认识 先看题一中Exchg1函数的定义： void Exchg1(int x, int y) //定义中的x,y变量被称为Exchg1函数的形式参数 { int tmp; tmp=x; x=y; y=tmp; printf(“x=%d,y=% d\\n”,x,y) } 问：你认为这个函数是在做什么呀？ 答：好像是对参数 x，y的值对调吧？ 请往下看，我想利用这个函数来完成对a，b两个变量值的对调，程序如下： void main() { int a=4,b=6; Exchg1 (a,b) //a,b变量为 Exchg1函数的实际参数。 / printf(“a=%d,b=%d\\n”,a,b) } 我问：Exchg1 （）里头的 printf（“x=%d，y=%d\\n”，x，y）语句会输出什么啊？ 我再问：Exchg1 （）后的 printf（“a=%d，b=%d\\n”，a，b）语句输出的是什么 ？ 程序输出的结果是： x=6 ， y=4 a=4 ， b=6 //为什么不是a=6，b=4呢？ 奇怪，明明我把a，b分别代入了x，y中，并在函数里完成了两个变量值的交换，为什么a，b变量 值还是没有交换（仍然是a==4，b==6，而不是a==6，b==4）？如果你也会有这个疑问，那是因为你跟本 就不知实参a，b与形参x，y的关系了。 2.一个预备的常识 为了说明这个问题，我先给出 一个代码： int a=4； int x； x=a； x=x+3； 看好了没，现在我问 你：最终a值是多少，x值是多少？ （怎么搞的，给我这个小儿科的问题。还不简单，不就是a==4 x==7嘛！） 在这个代码中，你要明白一个东西：虽然a值赋给了x，但是a变量并不是x变量哦 。我们对x任何的修改，都不会改变a变量。呵呵！虽然简单，并且一看就理所当然，不过可是一个很重 要的认识喔。 3.理解值传递的形式 看调用Exch1函数的代码： main() { int a=4,b=6; Exchg1(a,b) //这里调用了Exchg1函数 printf(“a=% d,b=%d”,a,b) } Exchg1(a,b)时所完成的操作代码如下所示。 int x=a;//← int y=b;//←注意这里，头两行是调用函数时的隐含操作 int tmp; tmp=x; x=y; y=tmp; 请注意在调用执行Exchg1函数的操作中我人为地加上 了头两句： int x=a； int y=b； 这是调用函数时的两个隐含动作。它确实存在， 现在我只不过把它显式地写了出来而已。问题一下就清晰起来啦。（看到这里，现在你认为函数里面交 换操作的是a，b变量或者只是x，y变量呢？） 原来 ，其实函数在调用时是隐含地把实参a，b 的 值分别赋值给了x，y，之后在你写的Exchg1函数体内再也没有对a，b进行任何的操作了。交换的只是x， y变量。并不是a，b.当然a，b的值没有改变啦！函数只是把a，b的值通过赋值传递给了x，y，函数里头 操作的只是x，y的值并不是a，b的值。这就是所谓的参数的值传递了。 哈哈，终于明白了，正是 因为它隐含了那两个的赋值操作，才让我们产生了前述的迷惑（以为a，b已经代替了x，y，对x，y的操 作就是对a，b的操作了，这是一个错误的观点啊！）。 指向另一指针的指针 一、针概念： 早在本系列第二篇中我就对指针的实质进行了阐述 。今天我们又要学习一个叫做指向另一指针地址的指针。让我们先回顾一下指针的概念吧！ 当我 们程序如下申明变量： short int i； char a； short int pi； 程序会 在内存某地址空间上为各变量开辟空间，如下图所示。 内存地址→6 7 8 9 10 11 12 13 14 15 —————————- ————————————————————————————————— … | | | | | | | | | | ———————————————————- ——————————————————————— |short int i |char a| |short int pi| 图中所示中可看出： i 变量在内存地址5的位置，占两个字节。 a变量在内存 地址7的位置，占一个字节。 pi变量在内存地址9的位置，占两个字节。（注：pi 是指针，我这 里指针的宽度只有两个字节，32位系统是四个字节） 接下来如下赋值： i=50； pi=&amp;i； 经过上在两句的赋值，变量的内存映象如下： 内存地址→6 7 8 9 10 11 12 13 14 15 ——- ————————————————————————————————————————- … | 50 | | | 6 | | | | —————- —————————————————————————————————————- |short int i |char a| |short int pi| 看到没有：短整型指针变量pi的值为6，它就是I变量的内 存起始地址。所以，这时当我们对\pi进行读写操作时，其实就是对i变量的读写操作。如： *pi=5； //就是等价于I=5； 你可以回看本系列的第二篇，那里有更加详细的解说。 二、指针的地址与指向另一指针地址的指针 在上一节中，我们看到，指针变量本身与其 它变量一样也是在某个内存地址中的，如pi的内存起始地址是10.同样的，我们也可能让某个指针指向这 个地址。 看下面代码： short int ppi； //这是一个指向指针的指针，注意 有两个号 ppi=π 第一句：short int ppi；——申明了一个指针变量 ppi，这个ppi是用来存储（或称指向）一个short int 类型指针变量的地址。 第二句： &amp;pi那就是取pi的地址，ppi=π就是把pi的地址赋给了ppi.即将地址值10赋值给ppi.如下图： 内存地址→6 7 8 9 10 11 12 13 14 15 ———————————————————————————————————— —————— … | 50 | | | 6 | 10 | | ————————————————————————————————————————— — |short int i|char a| |short int pi|short int ** ppi| 从图中看出，指针变 量ppi的内容就是指针变量pi的起始地址。于是…… ppi的值是多少呢？ ——10. ppi的值是多少呢？——6，即pi的值。 **ppi的值是多少 呢？——50，即I的值，也是*pi的值。 呵呵！不用我说太多了，我相信你应明白这种 指针了吧！ 三、一个应用实例 1. 设计一个函数：void find1（char array[]， char search， char pi） 要求：这个函数参数中的数组array是以0值为结束的字符串，要求在字符 串array中查找字符是参数search里的字符。如果找到，函数通过第三个参数（pa）返回值为array字符 串中第一个找到的字符的地址。如果没找到，则为pa为0. 设计：依题意，实现代码如下 void find1(char [] array, char search, char pa) { int i; for (i=0;(array+i)!=0;i++) { if ((array+i)==search) { pa=array+i break; } else if ((array+i)==0) { pa=0; break; } } } 你觉得这个函数能实现所要求的功能吗？ 调试： 我下面调用这个函数 试试。 void main() { char str[]={“afsdfsdfdf\\0”}; //待 查找的字符串 char a=’d’; //设置要查找的字符 char p=0; //如果 查找到后指针p将指向字符串中查找到的第一个字符的地址。 find1(str,a,p); //调用函数以实 现所要操作。 if (0==p ) { printf (“没找到！\\n”);//1.如果没找到则 输出此句 } else { printf(“找到了，p=%d”,p); //如果找到则 输出此句 } } 分析： 上面代码，你认为会是输出什么呢？ 运 行试试。 唉！怎么输出的是：没有找到！ 而不是：找到了，……。 明明a值为‘d’，而str字符串的第四个字符是‘d’，应该找得到呀！ 再 看函数定义处：void find1（char [] array， char search， char pa） 看调用处：find1（ str，a，p）； 依我在第五篇的分析方法，函数调用时会对每一个参数进行一个隐含的赋值操作 。 整个调用如下： array=str; search=a; pa=p; //请注意：以 上三句是调用时隐含的动作。 int i; for (i=0;(array+i)!=0;i++) { if ( (array+i)==search) { pa=array+i break; } else if ((array+i)==0) { pa=0; break; } } 哦！参数pa与参数search的传递并没 有什么不同，都是值传递嘛（小语：地址传递其实就是地址值传递嘛）！所以对形参变量pa值（当然值 是一个地址值）的修改并不会改变实参变量p值，因此p的值并没有改变（即p的指向并没有被改变）。 （如果还有疑问，再看一看《第五篇：函数参数的传递》了。） 修正： void find2(char [] array, char search, char * ppa) { int i; for (i=0;(array+i)!=0;i++) { if ((array+i)==search) { \ppa=array+i break; } else if (*(array+i)==0) { *ppa=0; break; } } } 主函数的调用处改如下： find2（str，a， &amp;p）； //调用函数以实现所要操作。 再分析： 这样调用函数时的整个操作变成如 下： array=str; search=a; ppa=&p; //请注意：以上三句是调用 时隐含的动作。 int i; for (i=0;*(array+i)!=0;i++) { if ((array+i) ==search) { \ppa=array+i break; } else if (*(array+i)==0) { *ppa=0; break; } } 看明白了吗？ ppa指向指针p的地址 。 对*ppa的修改就是对p值的修改。 你自行去调试。 经过修改后的程序就可以完 成所要的功能了。 看懂了这个例子，也就达到了本篇所要求的目的。 函数名与函数指针 一 数调用 一个通常的函数调用的例子： //自行包含 头文件 void MyFun(int x); //此处的申明也可写成：void MyFun( int ); int main(int argc, char argv[]) { MyFun(10); //这里是调用MyFun(10);函数 return 0; } void MyFun(int x) //这里定义一个MyFun函数 { printf (“%dn”,x); } 这个MyFun函数是一个无返回值的函数，它并不完成什 么事情。这种调用函数的格式你应该是很熟悉的吧！看主函数中调用MyFun函数的书写格式： MyFun（10）； 我们一开始只是从功能上或者说从数学意义上理解MyFun这个函数，知道 MyFun函数名代表的是一个功能（或是说一段代码）。 直到—— 学习到函数指 针概念时。我才不得不在思考：函数名到底又是什么东西呢？ （不要以为这是没有什么意义的事 噢！呵呵，继续往下看你就知道了。） 二 函数指针变量的申明 就象某一数据变量的内存 地址可以存储在相应的指针变量中一样，函数的首地址也以存储在某个函数指针变量里的。这样，我就 可以通过这个函数指针变量来调用所指向的函数了。 在C系列语言中，任何一个变量，总是要先 申明，之后才能使用的。那么，函数指针变量也应该要先申明吧？那又是如何来申明呢？以上面的例子 为例，我来申明一个可以指向MyFun函数的函数指针变量FunP.下面就是申明FunP变量的方法： void （\FunP）（int） ； //也可写成void （*FunP）（int x）； 你看，整个函 数指针变量的申明格式如同函数MyFun的申明处一样，只不过——我们把MyFun改成（*FunP） 而已，这样就有了一个能指向MyFun函数的指针FunP了。（当然，这个FunP指针变量也可以指向所有其它 具有相同参数及返回值的函数了。） 三 通过函数指针变量调用函数 有了FunP指针变量后 ，我们就可以对它赋值指向MyFun，然后通过FunP来调用MyFun函数了。看我如何通过FunP指针变量来调 用MyFun函数的： //自行包含头文件 void MyFun(int x); //这个申明也可写 成：void MyFun( int ); void (*FunP)(int ); //也可申明成void(*FunP)(int x)，但习惯 上一般不这样。 int main(int argc, char* argv[]) { MyFun(10); //这是 直接调用MyFun函数 FunP=&MyFun; //将MyFun函数的地址赋给FunP变量 (*FunP)(20); //这是通过函数指针变量FunP来调用MyFun函数的。 } void MyFun(int x) //这里 定义一个MyFun函数 { printf(“%dn”,x); } 请看黑体字部 分的代码及注释。 运行看看。嗯，不错，程序运行得很好。 哦，我的感觉是：MyFun与 FunP的类型关系类似于int 与int *的关系。函数MyFun好像是一个如int的变量（或常量），而FunP则像 一个如int 一样的指针变量。 int i，\pi； pi=&amp;i； //与FunP=&amp;MyFun 比较。 （你的感觉呢？） 呵呵，其实不然—— 四 调用函数的其它书 写格式 函数指针也可如下使用，来完成同样的事情： //自行包含头文件 void MyFun(int x); void (*FunP)(int ); //申明一个用以指向同样参数，返回值函数 的指针变量。 int main(int argc, char argv[]) { MyFun(10); //这里是 调用MyFun(10);函数 FunP=MyFun; //将MyFun函数的地址赋给FunP变量 FunP(20); //这是通过函数指针变量来调用MyFun函数的。 return 0; } void MyFun(int x) // 这里定义一个MyFun函数 { printf(“%dn”,x); } 我改了黑 体字部分（请自行与之前的代码比较一下）。 运行试试，啊！一样地成功。 咦？ FunP=MyFun； 可以这样将MyFun值同赋值给FunP，难道MyFun与FunP是同一数据类型（即 如同的int 与int的关系），而不是如同int 与int的关系了？（有没有一点点的糊涂了？） 看 来与之前的代码有点矛盾了，是吧！所以我说嘛！ 请容许我暂不给你解释，继续看以下几种情况 （这些可都是可以正确运行的代码哟！）： 代码之三： int main(int argc, char argv[]) { MyFun(10); //这里是调用MyFun(10);函数 FunP=&MyFun; //将MyFun函数的地址赋给FunP变量 FunP(20); //这是通过函数指 针变量来调用MyFun函数的。 return 0; } 代码之四： int main(int argc, char argv[]) { MyFun(10); //这里是调用MyFun(10);函数 FunP=MyFun; //将MyFun函数的地址赋给FunP变量 (*FunP)(20); //这是通过函数指针 变量来调用MyFun函数的。 return 0; } 真的是可以这样的噢！ （哇 ！真是要晕倒了！） 还有呐！看—— int main(int argc, char* argv[]) { （*MyFun）(10); //看，函数名MyFun也可以有这样的调用格式 return 0; } 你也许第一次见到吧：函数名调用也可以是这样写的啊！（只不过 我们平常没有这样书写罢了。） 那么，这些又说明了什么呢？ 呵呵！依据以往的知识和 经验来推理本篇的“新发现”，我想就连“福尔摩斯”也必定会由此分析并推断 出以下的结论： 1. 其实，MyFun的函数名与FunP函数指针都是一样的，即都是函数指针。MyFun 函数名是一个函数指针常量，而FunP是一个函数数指针变量，这是它们的关系。 2. 但函数名调 用如果都得如（*MyFun）（10）；这样，那书写与读起来都是不方便和不习惯的。所以C语言的设计者们 才会设计成又可允许MyFun（10）；这种形式地调用（这样方便多了并与数学中的函数形式一样，不是吗 ？）。 3. 为统一起见，FunP函数指针变量也可以FunP（10）的形式来调用。 4. 赋值时 ，即可FunP=&amp;MyFun形式，也可FunP=MyFun. 上述代码的写法，随便你爱怎么着！ 请 这样理解吧！这可是有助于你对函数指针的应用喽！ 最后—— 补充说明一点 ：在函数的申明处： void MyFun（int ）； //不能写成void （*MyFun）（int ）。 void （*FunP）（int ）； //不能写成void FunP（int ）。 （请看注释）这一点 是要注意的。 五 定义某一函数的指针类型： 就像自定义数据类型一样，我们也可以先定 义一个函数指针类型，然后再用这个类型来申明函数指针变量。 我先给你一个自定义数据类型的 例子。 typedef int PINT; //为int 类型定义了一个PINT的别名 int main() { int x; PINT px=&x; //与int px=&x;是等价的。PINT类型其 实就是int 类型 *px=10; //px就是int*类型的变量 return 0; } 根据注释，应该不难看懂吧！（虽然你可能很少这样定义使用，但以后学习Win32编程时会经常见到的。 ） 下面我们来看一下函数指针类型的定义及使用：（请与上对照！） //自行包含 头文件 void MyFun(int x); //此处的申明也可写成：void MyFun( int ); typedef void (*FunType)(int ); //这样只是定义一个函数指针类型 FunType FunP; //然后 用FunType类型来申明全局FunP变量 int main(int argc, char* argv[]) { //FunType FunP; //函数指针变量当然也是可以是局部的 ，那就请在这里申明了。 MyFun(10); FunP=&MyFun; (*FunP)(20); return 0; } void MyFun(int x) { printf(“%dn”,x); } 看黑体部分： 首先，在void （*FunType）（int ）； 前加了一个typedef .这样只是定义一个名为FunType函数指针类型，而不是一 个FunType变量。 然后，FunType FunP； 这句就如PINT px；一样地申明一个FunP变量。 其它相同。整个程序完成了相同的事。 这样做法的好处是： 有了FunType类型后 ，我们就可以同样地、很方便地用FunType类型来申明多个同类型的函数指针变量了。如下： FunType FunP2； FunType FunP3； //…… 六 函数指针作为某个函数的参数 既然函数指针变量是一个变量，当然也可以作为某个函数的参数来使用的。所以 ，你还应知道函数指针是如何作为某个函数的参数来传递使用的。 给你一个实例： 要求 ：我要设计一个CallMyFun函数，这个函数可以通过参数中的函数指针值不同来分别调用MyFun1、MyFun2 、MyFun3这三个函数（注：这三个函数的定义格式应相同）。 实现：代码如下： //自行包含头文件 void MyFun1(int x); void MyFun2(int x); void MyFun3(int x); typedef void (*FunType)(int ); //②. 定义一个函数指针类型FunType,与①函 数类型一至 void CallMyFun(FunType fp,int x); int main(int argc, char* argv[]) { CallMyFun(MyFun1,10); //⑤. 通过CallMyFun函数分别调用三个不同的函数 CallMyFun(MyFun2,20); CallMyFun(MyFun3,30); } void CallMyFun(FunType fp,int x) //③. 参数fp的类型是FunType。 { fp(x);//④. 通过fp的指针执行传递进来的 函数，注意fp所指的函数是有一个参数的 } void MyFun1(int x) // ①. 这是个有一个参数 的函数，以下两个函数也相同 { printf(“函数MyFun1中输出：%dn”,x); } void MyFun2(int x) { printf(“函数MyFun2中输出：%dn”,x); } void MyFun3(int x) { printf(“函数MyFun3中输出：%dn”,x); } 输出结果：略 分析：（看我写的注释。你可按我注释的①②③④⑤顺序自行 分析。） 拷贝构造函数：http://blog.csdn.net/lwbeyond/article/details/6202256 C++指针传递内存：http://www.cnblogs.com/kaituorensheng/p/3246900.html 临时变量和副本：https://zhidao.baidu.com/question/496856248.html C++指针详解：http://www.cnblogs.com/ggjucheng/archive/2011/12/13/2286391.html C指针入门：http://www.cnblogs.com/ggjucheng/archive/2011/12/13/2286391.html 堆栈相关：http://blog.csdn.net/hairetz/article/details/4141043 C++指针分配小细节 char *pc = NULL; pc = new char[0]; pc[0] = ‘1’; 相信初学者看见上面这段代码，都会觉得奇怪，new char[n]中的n指定给指针变量分配多少内存空间，而n=0时代表什么呢？ 其实上面的程序编译、运行都是正确的。因为编译器识别到指定大小为0时，会自动为其分配1BYTE的内存空间。 尝试过的小伙伴会发现，给p[1]赋值也不会报错，原因留到后面讲*1。 但是，此时若想用delete [] p; 去释放内存空间就会报错，程序强制中断，因为编译器并没有真正意义上内指针变量分配内存，去释放肯定是不行的。 这就像对一个成功分配内存的指针变量，连续释放两次造成的错误，例子见后面2。 好了，马上看一下成功分配内存的情况是怎么样的。 char \pc = NULL; pc = new char[5]; pc[0] = ‘1’; 这里的n=5，意味着给指针变量分配5个BYTE内存空间（因类型为char），当然不管是什么类型，指针变量本身均占4BYTE。 先来看上面遗留的第一个问题*1：此时不但可以给p[0]到p[4]赋值，还可以给后面的地址赋值，如p[5],p[10]等。 这就是C/C++完美之余的一个历史遗留缺陷，不进行越界检查。 导致编译没有任何问题，运行阶段有时一不小心也察觉不出，这就要求程序员养成良好的习惯：new后面必出现delete。 若我们在给p[5]或之后的地址赋过值，在运行到delete [] p;语句时，会报错，程序强制中断。错误原因如提示的信息：damage:after normal block。 这就是上面遗留的第二个问题*2：对同一个指针变量指向的内存释放两次，与释放一个没有成功分配内存或引用越界的指针变量类似，都是不允许的。 还有一个值得注意的地方：若new时n&gt;0，delete后只是释放了原来内存地址中对应的值，指针变量仍然指向该内存地址，即： 仍可以赋值、取值进行运算，只是若没有重新赋值，取出的值为不确定值，换句话说就是，p成了传说中的野指针。 所以，这又是一个要求养成良好习惯的地方，看文章开头的地方，声明一个指针但未分配内存空间时，最好将其置为NULL。 这样做有两个好处：1、方便后面进行判断，if(!P){…}表示无内存分配，若当初没有将其置为NULL，则!p为真也代表不了什么； 2、在delete后，重新分配内存之前，将其置回为NULL，避免其成为野指针。 而对于malloc与free，情况类似，有兴趣的小伙伴可以尝试下。 刚开始学习这一块，有哪里不对的地方欢迎大家指出，谢谢！]]></content>
      <categories>
        <category>C++</category>
        <category>D.S.</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C_confidence、helloc、hcc、clanguage、 concept、courage_MAXC_PLAN_12.16_X]]></title>
    <url>%2Fpost%2Fe897f956.html</url>
    <content type="text"><![CDATA[”梦想有多重要？ 我33岁第一次到美国，走在硅谷的大街上，我就在想：为什么中国人那么勤奋，取得的成功却不如天天跑步度假的美国人？为什么那些做出伟大创新的公司却诞生在美国？ 我发现，差别在于：美国人很小就有自己的梦想。他们坚信梦想，拥有梦想，见识过梦想改变世界的力量。而大多数中国人，不。 这里有思维模式的差异，我认为，本质是教育。我们从小受到的教育就是听父母的话，考试得100分，书山有路勤为径，学海无涯苦作舟，而不是——梦想教育。 我们不敢相信梦想。于是，等到成年，我们又会给自己很多借口：比如我过去也有过梦想，但是，但是。“但是”这个词，又和另外一个最可怕的短语连着，“如果我当初…”。 你不敢去追求梦想。你害怕自己看起来像个疯子。你不敢尝试。你害怕失败。 可你，却不知——_梦想，是你此生热爱与天赋的最高形式表达。你的梦想有多大，你就有多强大。_ 这是雷总2015年在母校_武汉大学_毕业典礼上的一段演讲，很真挚，创业人一定都能感同身受，分享给你们。 在互联网里，做什么都不如做一个产品改变世界来得彻底。——周鸿祎 什么职位是未来创业做CEO最好的”预科”？我的回答是：产品经理——李开复 在小米，雷军的第一定位不是CEO，而是首席产品经理。——雷军 产品经理的主流应该是服务于未来。——张小龙 你想用卖糖水来度过余生，还是想要一个机会来改变世界？——乔布斯（Steve Jobs） 得产品经理得天下。——雷军 成功的企业一定是靠产品、服务的完整体系。——马云 产品经理最重要的能力是把自己变傻瓜。——马化腾 把用户的贪嗔痴变成产品。——史玉柱 每日一句1.9: 微信小程序 想要什么————连接一切！场景化 人与物！挖掘线下流量！最短路径——相较于app 小程序的优点之处。 小程序是一个生态，链接更多的线下场景————阶段： 摸索与搬迁阶段————开发者摸索与互联网公司搬迁为主。&lt;小程序的获得应该都是场景化的?&gt; 工具阶段————在微信里未被满足的能用小程序满足的需求。 场景化阶段————场景化和本地化，线下的力流量在这个阶段次啊可能被真正的激活被真正的连接起来！ 每日天给自己一个交代！ 你就是·梦想“＋”！ _2017 立下一个flag！————————QQ空间内的一篇文章。_ 具体，精通JAVA，Web前端、Android全栈！ 英语备选。无力的时候多想想，多看看。自己还很弱。但——行则降至！ 鸡年必然是一个值得纪念的 一年！！！ 行则将至！ 一步一步眼前事情做好！ 假期不在家中，有事请电联 或者 邮件。：D 让编程改变世界，让梦想创造奇迹！铭记自己当年的梦想！君子爱财，取之有道！07 梦想的确立！计划： 1:卸下耳机 + senior 3 TED演讲（英语提升加产品认知）——————修炼本心 2:拓宽眼界！————————寻找方向，学会思考 3:开启行动！————————行则将至 ——— 行动‘+’:UPUP！ 适当拓宽自己圈子（方格）、找回自信！ 自信（适当的自卑是好的（明确是为了更加的努力奋斗））！ 是去相信、锻炼、自己去想象、认真去做出来的。 默默地去做。流露。 C——confidence、helloc、hcc、clanguage、 concept、courage！ 同学们大家好，站在这里话，我的心情和大家一样激动，因为24年前我也和大家一样，带着小板凳，坐在这个小操场，参加毕业庆典，所以我特别能理解大家的心情。 大家参加毕业典礼，即将迎来人生新的征程，一定是有一点点紧张、一点点迷茫，但是更多的是激动是兴奋，是对未来美好生活的憧憬。所以在这个时刻，我能跟大家讲点什么呢?昨天我想了一晚上，也没怎么睡好觉。我在想，我比大家年长24岁，早24届，作为一个学长，面对这么多学弟学妹即将开始人生征程的关键时刻，我能讲点什么呢?说实话，千言万语，真的不知道应该从哪讲起，而且讲太多是不是真的对大家有帮助，这是我昨天晚上觉得压力巨大的地方。我后来想，我们只讲两点。 1、要永远相信梦想的力量为什么在这里谈梦想，这是因为回顾我过去走过的路，在我的人生中，我最难忘的就是武汉大学，因为武汉大学在我的人生历程中起着不可磨灭的作用。那还是我18岁的时候，大学一年级，一个非常偶然的机会，我在图书馆里看了一本书。这本书在我的人生里起到决定性的作用。 书名我非常清楚地记得，叫_《硅谷之火》_，这本书大概是2块1毛4，1987年出版，那本书讲述的是乔布斯这些硅谷英雄创业的故事。看着这本书后，我的内心像是有熊熊火焰在燃烧，激动得好几个晚上没睡着觉。接着我就在旁边的体育场上走了一遍又一遍，很难让我的心情平静下来。 在武大操场一遍又一遍地走的过程中，我奠定了人生的梦想——日后一定要干些惊天动地的事情。天生我材必有用，日后自己一定要做个伟大的人。当然，建立梦想是很容易的，我相信每位同学都有很伟大的梦想，但是有梦想之后你是否去实践了？所以在我在大学一年级的时候告诉自己，咱光有梦想是不行的，咱得脚踏实地地真正做几件不一样的事情。 我给自己定的第一个目标是两年修完大学所有的课程。很感谢武汉大学的学分制，从那天开始，我真的修了两倍的学分。我记得去年参加学校校友会的时候，大屏幕上还显示了我当年的学分卡。当我有这个梦想后我真的去试了，我发现其实也不难。至少我觉得当年在计算机学院，两年足以学完学院的所有课程。 当然，在大学的里后来还有第二个第三个目标，后来我都一一完成了。我在想，在那个年代，绝对不是我比别人更聪明更勤奋。我觉得最大的不一样是我比他们更早地确立了人生的梦想，并且付出了实践。这就是我给大家的第一个建议，要永远相信梦想的力量。 今天，大家即将走上人生的征程，尽早地确立梦想和目标，并且尽早地去付诸行动，我觉得这是成功的开始。 2、要永远相信坚持梦想的力量有梦想很容易，去实践梦想也很容易，但是坚持梦想很难。你今天能坚持，五年后还能坚持吗，十年后二十年后还能坚持吗？刚才主持人介绍了一下我办小米的成绩，小米我就不展开介绍了，我要给大家介绍的是什么呢，力量让我创办了小米公司。小米是五年前创办的，发布手机是三年半前，小米仅仅用了两年半的时间就在全球竞争最激烈的行业和市场，前有苹果三星，后有华为联想，干到了中国市场第一，全球市场第五。 这个成绩真的能算是全球商业市场的奇迹。这个奇迹的背后是什么呢？我参与创办的第一家公司是金山软件，我觉得金山软件行业的竞争也很不容易。做到2007年，金山上市后我就退休了，我应该实现了在座很多人的梦想，三十岁就能退休。上市了一家公司、卖了几家公司、投资了几十家公司，退休了以后我主要的工作就是投资，人生也算非常的圆满。 是怎样的动力让我愿意在创业呢？你们可能对创业充满了非常多的好奇，充满了非常多的羡慕，而且我也相信在座的各位未来也一定会出现伟大的企业家。在这个时刻我想和大家多说一句，创业绝对不是人干的活，是阿猫阿狗干的活。如果没有钢铁般的意志，你是绝对干不了的，我觉得创业并不好玩。所以在今天这个大众创业万众创新的时代，我提醒一下大家，如果真的要创业，要做好准备。 我自己参与了金山软件的创办，深知创业的艰难，那是什么样的勇气，让我退休以后再创业的呢？是在我在快40岁的时候，有天晚上做梦醒来，觉得自己好像离梦想渐行渐远，我问我自己是否有勇气再来一回。其实这个问题很难回答，我想了半年多的时间才下定决心，不管这次创业成与败，我不能让人生充满遗憾。我一定要去试一下，看自己能不能创办一家世界级的技术公司，做一件造福世界上每一个人的事情，所以我下定决心要做这件事情。 做了这个决定以后，我自己还有很多很多的顾虑。为什么呢，因为如果干砸了，我就晚节不保。所以当时我说服自己，在刚开始的一两年的时间里，要极其低调，高度保密，脚踏实地，直到把产品做得差不多了，我们再站出来讲。我觉得这样成效会大一点。我用各种方法客服了我对再次创业的恐惧、对再次创业失败的恐惧，然后创办了小米。 今天站在这里，我想跟大家说，我相信在座的每一个人都有梦想，我相信你们为了梦想都付诸了行动。我要问的是，五年后十年后，二十四年、二十五年后，你们还有没有坚持梦想的勇气和决心，而且相不相信坚持梦想的力量。这就是此时此刻我给大家的两条建议。 最后，大家马上就要毕业了，祝福大家前程似锦，事业成功，万事顺利。更重要的一条是，大家开开心心就好。谢谢大家。 本文内容为小米公司CEO雷军在母校武汉大学2015毕业典礼上的演讲。 迭代算法是用计算机处理问题的一种基本方法。它利用计算机运算速度快、适合做重复性操做的特点，让计算机对一组指令(或一定步骤)进行重复执行，在每次执行这组指令(或这些步骤)时，都从变量的原值推出它的一个新值。 利用迭代算法处理问题，需要做好以下三个方面的工做： 一、确定迭代变量。在能够用迭代算法处理的问题中，至少具有一个间接或间接地不断由旧值递推出新值的变量，这个变量就是迭代变量。 二、建立迭代关系式。所谓迭代关系式，指如何从变量的前一个值推出其下一个值的公式(或关系)。迭代关系式的建立是处理迭代问题的关键，通常能够使用递推或倒推的方法来完成。 三、对迭代过程进行控制。在什么时候结束迭代过程?这是编写迭代程序必须考虑的问题。不能让迭代过程无休止地重复执行下去。迭代过程的控制通常可分为两种情况：一种是所需的迭代次数是个确定的值，能够计算出来;另一种是所需的迭代次数无法确定。对于前一种情况，能够建立一个固定次数的循环来实现对迭代过程的控制;对于后一种情况，需要进一步分析出用来结束迭代过程的条件。 来源：www.va1314.com/bc 例 1 ： 一个豢养场引进一只刚出生的新品种兔子，这种兔子从出生的下一个月开始，每月重生一只兔子，重生的兔子也如此繁殖。如果所有的兔子都不死去，问到第 12 个月时，该豢养场共有兔子多少只? 分析： 这是一个典型的递推问题。我们不妨假设第 1 个月时兔子的只数为 u 1 ，第 2 个月时兔子的只数为 u 2 ，第 3 个月时兔子的只数为 u 3 ，……根据题意，“这种兔子从出生的下一个月开始，每月重生一只兔子”，则有 以下是引用片段： u1=1，u2=u1+u1×1=2，u3=u2+u2×1=4，…… 根据这个规律，能够归纳出下面的递推公式： 以下是引用片段： un=un-1×2(n≥2) 对应 u n 和 u n - 1 ，定义两个迭代变量 y 和 x ，可将上面的递推公式转换成如下迭代关系： 以下是引用片段： y=x*2 x=y 让计算机对这个迭代关系重复执行 11 次，就能够算出第 12 个月时的兔子数。参考程序如下： 以下是引用片段： cls x=1 fori=2to12 y=x*2 x=y nexti printy end 例 2 ： 阿米巴用简单分裂的方式繁殖，它每分裂一次要用 3 分钟。将若干个阿米巴放在一个盛满营养参液的容器内， 45 分钟后容器内充满了阿米巴。已知容器最多能够装阿米巴 2 20 个。试问，开始的时候往容器内放了多少个阿米巴?请编程序算出。 分析： 根据题意，阿米巴每 3 分钟分裂一次，那么从开始的时候将阿米巴放入容器里面，到 45 分钟后充满容器，需要分裂 45/3=15 次。而“容器最多能够装阿米巴 2 20 个”，即阿米巴分裂 15 次以后得到的个数是 2 20 。题目要求我们计算分裂之前的阿米巴数，不妨使用倒推的方法，从第 15 次分裂之后的 2 20 个，倒推出第 15 次分裂之前(即第 14 次分裂之后)的个数，再进一步倒推出第 13 次分裂之后、第 12 次分裂之后、……第 1 次分裂之前的个数。 设第 1 次分裂之前的个数为 x 0 、第 1 次分裂之后的个数为 x 1 、第 2 次分裂之后的个数为 x 2 、……第 15 次分裂之后的个数为 x 15 ，则有 以下是引用片段： x14=x15/2、x13=x14/2、……xn-1=xn/2(n≥1) 因为第 15 次分裂之后的个数 x 15 是已知的，如果定义迭代变量为 x ，则能够将上面的倒推公式转换成如下的迭代公式： x=x/2 ( x 的初值为第 15 次分裂之后的个数 2 20 ) 让这个迭代公式重复执行 15 次，就能够倒推出第 1 次分裂之前的阿米巴个数。因为所需的迭代次数是个确定的值，我们能够使用一个固定次数的循环来实现对迭代过程的控制。参考程序如下： 以下是引用片段： cls x=2^20 fori=1to15 x=x/2 nexti printx end 例 3 ： 验证谷角猜想。日本数学家谷角静夫在研究天然数时发觉了一个奇怪现象：对于任意一个天然数 n ，若 n 为偶数，则将其除以 2 ;若 n 为奇数，则将其乘以 3 ，然后再加 1 。如此经过有限次运算后，分能够得到天然数 1 。人们把谷角静夫的这一发觉叫做“谷角猜想”。 要求：编写一个程序，由键盘输入一个天然数 n ，把 n 经过有限次运算后，最终变成天然数 1 的全过程打印出来。 分析： 定义迭代变量为 n ，按照谷角猜想的内容，能够得到两种情况下的迭代关系式：当 n 为偶数时， n=n/2 ;当 n 为奇数时， n=n*3+1 。用 QBASIC 语言把它描述出来就是： 以下是引用片段： ifn为偶数then n=n/2 else n=n*3+1 endif 这就是需要计算机重复执行的迭代过程。这个迭代过程需要重复执行多少次，才能使迭代变量 n 最终变成天然数 1 ，这是我们无法计算出来的。因而，还需进一步确定用来结束迭代过程的条件。仔细分析题目要求，不难看出，对任意给定的一个天然数 n ，只需经过有限次运算后，能够得到天然数 1 ，就已经完成了验证工做。因而，用来结束迭代过程的条件能够定义为： n=1 。参考程序如下： 以下是引用片段： cls input”Pleaseinputn=”;n dountiln=1 ifnmod2=0then rem如果n为偶数，则调用迭代公式n=n/2 n=n/2 print”—“;n; else n=n*3+1 print”—“;n; endif loop end]]></content>
      <categories>
        <category>日记之家</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[D.S.REVIEW_ALL_2016_12_15]]></title>
    <url>%2Fpost%2Fafc30e32.html</url>
    <content type="text"><![CDATA[/* author:JiahaoZhang time: 2016_12_15_Revise method:About : 05顺序表（Sequential list）是线性表（Linear List）基于数组的存储形式！ 01）Yan 02）Yin 03）Weiss — 06为链式存储方式（Linked List） 01）Yin 02）Weiss More:In ch03_Stack_Queue_heap———-heap ch04_Array\\Stribg\\GenList—————-&gt;GenList ch05_Tree———————————————&gt;DM ch06_Set————————————————UFSet ch07_Search—————————————-BST ch08_Graph——————————————MST!prim&amp;&amp;kruskal ch09_Sort———————————————Shell\\Quick\\Merge / /\ Methid : C++ learning !文件和流！模板！template */ 以下转义序列。在复制到输出流时，这些序列导致它们的相关操作在有此功能的设备上显示： \\\ 反斜杠 \\a 警告 \\b 退格 \\f 换页 \\n 换行 \\r 回车 \\t 跳格 \\v 垂直跳格 \\ddd ddd 是 1、2 或 3 位八进制数字。这些转义序列作为由八进制数指定的具有数字值的字节显示。 ——-文件和流 C++ 文件和流 到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。 本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型： 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。 打开文件在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法： ofstream outfile; outfile.open(“file.dat”, ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法： fstream afile; afile.open(“file.dat”, ios::out | ios::in ); 关闭文件当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void close(); 写入文件在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 读取文件在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 读取 &amp; 写入实例下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上： include include using namespace std;int main (){ char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open(“afile.dat”); cout &lt;&lt; “Writing to the file” &lt;&lt; endl; cout &lt;&lt; “Enter your name: “; cin.getline(data, 100); // 向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; “Enter your age: “; cin &gt;&gt; data; cin.ignore(); // 再次向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open(“afile.dat”); cout &lt;&lt; “Reading from the file” &lt;&lt; endl; infile &gt;&gt; data; // 在屏幕上写入数据 cout &lt;&lt; data &lt;&lt; endl; // 再次从文件读取数据，并显示它 infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 infile.close(); return 0;} 当上面的代码被编译和执行时，它会产生下列输入和输出： $./a.outWriting to the file Enter your name: ZaraEnter your age: 9Reading from the file Zara9 上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。 以上可以通过，输入输出 对象流来进行（例如 time24_03作业的，通过磁盘已经重载的运算符进行 代替相应的键盘和屏幕的输入和输出！！！ ） 文件位置指针istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。 seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例： // 定位到 fileObject 的第 n 个字节（假设是 ios::beg） fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节 fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节 fileObject.seekg( n, ios::end );// 定位到 fileObject 的末尾 fileObject.seekg( 0, ios::end ); 这样可以对一个文件进行输入输出的综合使用！《即所谓的随机存取！Random access》 文件出错检查ios- ifstream ofstream 有成员函数（ios类中的，所以其子类中也会有！if的对象 也可以使用这些成员函数） fail（）如果操作失败（设备上没有空间、或者要读取的文件不存在)return true; Eg:if( out.fail() ){cerr&lt;&lt;””&lt;&lt;endl;return 1;// main 函数里} end（） 如果到文件末尾，则true Single character I/O and detecting the end of a file(单字符的I/O和文件末尾的检测！)in.get(c);count = 1;while( !in.enf() ){ out.put(c); in.put(c); count++;}in.close();out.close(); ——-异常处理动态断言assert assert宏的原型定义在中，其作用是如果它的条件返回错误，则终止程序执行，原型定义： #include void assert( int expression ); assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息， 然后通过调用 abort 来终止程序运行。[cpp] view plain copy print? include include void test(int p){assert(p != NULL);printf(“%d\\n”, p);}int main(void){test(NULL);}关闭动态断言 ，必须放在#include前面[cpp] view plain copyprint? define NDEBUG——-STLhttp://www.cplusplus.com/reference/vector/vector/operator%5b%5d/ http://www.runoob.com/cplusplus/cpp-stl-tutorial.html cerr与cout的主要区分就是，cout输出的信息可以重定向，而cerr只能输出到标准输出（显示器）上。 运行结果是：在生成的cout.txt文件中输出了”hello world—-cout”同时在显示器上输出了”hello world—-cerr”也就是说cout的输出可以重定向到一个文件中，而cerr必须输出在显示器上。cout是标准输出流,与cerr的区别在于cerr不经过缓冲区,直接向显示器输出信息,而cout中的信息存放在缓冲区,缓冲区满或者遇到endl时才输出.对于为什么有cerr和cout比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归）。你说，你到什么地方借内存，存放你的错误信息？所以有了cerr。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持。缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）。 参考资料： http://baike.baidu.com/view/2254717.htm]]></content>
      <categories>
        <category>C++</category>
        <category>D.S.</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[D.S.Graph_In12.12_Bound&UnboundFriendTemplate_InYin||PrimerPlusStruct]]></title>
    <url>%2Fpost%2F7bf874a4.html</url>
    <content type="text"><![CDATA[C++中模板类使用友元模板函数 问题始于学习数据结构，自己编写一个单链表，其中用到了重载输出运算符&lt;&lt;，我写的大约这样： template class List{ friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os,const List&amp; slist); //…… };用vs2008可编译，但无法链接：无法解析的外部符号…… 后来上网查改为template class List{ friend std::ostream&amp; operator &lt;&lt; &lt;&gt;(std::ostream&amp; os,const List&amp; slist); //…… }; 就可以了。不知所以然，查了下《C++ Primer》才弄明白。 好了，进入正题： 在类模板中可以出现三种友元声明： （1）普通非模板类或函数的友元声明，将友元关系授予明确指定的类或函数。 （2）类模板或函数模板的友元声明，授予对友元所有实例的访问权。 （3）只授予对类模板或函数模板的特定实例的访问权的友元声明。 要注意的是，友元函数并非成员函数，是改变了它对类成员的访问权限。 （1）没有什么好说的，如： template class A{ friend void fun(); //… }; 此例中fun可访问A任意类实例中的私有和保护成员 （2） template class A{ template friend void fun(T u); //… }; 这时友元使用与类不同的模板形参，T可以是任意合法标志符，友元函数可以访问A类的任何类实例的数据，即不论A的形参是int，double或其他都可以。 （3） template class A{ friend void fun(T u); //… }; 此时fun只有访问类中特定实例的数据。换句话说，此时具有相同模板实参的fun函数与A类才是友元关系。即假如调用fun时其模板实参为int，则它只具有A的访问权限。当然friend void fun(T u);中&lt;&gt;中的T可以是任意类型，比如int，double等 回到原问题，按（3）可改为： template class List{ friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os,const List&amp; slist); //…… }; 按（2）可改为： template class List{ template friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os,const List&amp; slist); //…… }; 在这里其实两者实现的最终效果一样的，因为调用输出运算符时需要访问的类实例的对象是它本身，所以形参T在第一种改法中一定匹配。 对类建立友元函数很容易。但是迁移到模板上却容易出现让人摸不着头脑的连接错误。 层次不够，不做分析，单纯介绍两种为类模板定义友元函数的方法 １ 封闭型 template&lt; typename T &gt; class MyClass { friend void function( MyClass&lt; T &gt; &amp;arg ) { } }; 要点：友元函数定义在模板体内。 ２ 开放型 template&lt; typename T &gt; class MyClass { template&lt; typename C &gt; friend void function( MyClass&lt; C &gt; &amp;arg ); }; template&lt; typename C &gt; void function( MyClass&lt; C &gt; &amp;arg ) { } 要点：模板体内要另建模板。 3 告诉编译器声明的设个是模板 #include using namespace std; template &lt; typename T &gt; class A { friend ostream &amp;operator&lt;&lt; &lt; T &gt;( ostream &amp;, const A&lt; T &gt; &amp; ); }; template &lt; typename T &gt; ostream &amp;operator&lt;&lt; ( ostream &amp;output, const A&lt; T &gt; &amp;a ) { output &lt;&lt; “重载成功” &lt;&lt; endl; return output; } int main() { A&lt; int &gt; a; cout &lt;&lt; a; } 要点：显示地在重载的运算符或者函数后面加上模板声明&lt; T &gt;，告诉编译器友元函数是一个类型一致的模板。 建议： 如果希望使用函数与模板特化的类型相对应，则使用方法3（模板显示声明） 如果希望使用函数与模板特化的类型相独立，则使用方法2（二重模板） 简短的内联函数使用方法1 本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/squarereal/archive/2009/09/23/4579950.aspx C/C++ 中访问结构体成员的方法 先看例子： 1#include 2void main(){ 3 typedef struct { 4 int int_field; 5 char char_field; 6 } my_struct; 7 my_struct my_s; 8 my_s.int_field=3; //结构运算符访问结构成员 9 my_struct *s; 10 s=(my_struct *)malloc (sizeof(my_struct)); 11 s-&gt;int_field=4; 12 s-&gt;char_field=’a’; 13 (*s).int_field=6; 14 } 访问结构体成员的运算符有两种，一种是“.”即结构运算符，另一种是“-&gt;”即结构指针运算符。 结构运算符是通过结构变量名访问结构体成员的（例如例子的第8行），而结构指针运算符是通过指向结构的指针访问结构成员的（例如第11及12行）。 还可以用指针和结构运算符来访问结构（如第13行），其中(*s)中的圆括号不可以省去 平时看简单例子看惯的缘故，本来以为很简单的知识。可是正到了项目上遇到了就有中把握不住的感觉，还是由于看的少的原因，所以不要只停留在理论的基础上。还是看项目源代码： 。。。。 。。。。 1. enum { LIGHT_INDEX_BACKLIGHT = 0, LIGHT_INDEX_KEYBOARD = 1, LIGHT_INDEX_BUTTONS = 2, LIGHT_INDEX_BATTERY = 3, LIGHT_INDEX_NOTIFICATIONS = 4, LIGHT_INDEX_ATTENTION = 5, LIGHT_INDEX_BLUETOOTH = 6, LIGHT_INDEX_WIFI = 7, LIGHT_COUNT }; 2. struct Devices { light_device_t lights[LIGHT_COUNT]; }; 。 。 。 。 。 。 static jint init_native(JNIEnv \env, jobject clazz) { int err; hw_module_t* module; Devices devices; devices = (Devices)malloc(sizeof(Devices)); err = hw_get_module(LIGHTS_HARDWARE_MODULE_ID, (hw_module_t const**)&amp;module); if (err == 0) { 3. devices-&gt;lights[LIGHT_INDEX_BACKLIGHT] = get_device(module, LIGHT_ID_BACKLIGHT); devices-&gt;lights[LIGHT_INDEX_KEYBOARD] = get_device(module, LIGHT_ID_KEYBOARD); devices-&gt;lights[LIGHT_INDEX_BUTTONS] = get_device(module, LIGHT_ID_BUTTONS); 。 。 。 。 。 。 } } 其中1 2 两处在上一篇 “C 中枚举（项目里遇到的）例子“ 中介绍过了。 3处 devices 是一个指向Devices型（结构体）的指针，devices-&gt;lights[LIGHT_INDEX_BACKLIGHT]即是访问到了Devices成员lights的第一个元素。 也无非就这么三种用法，熟悉了以后项目再遇到就很简单！ ————-C++中结构体与类的区别（struct与class的区别）{z} C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。 struct能包含成员函数吗？ 能！ struct能继承吗？ 能！！ struct能实现多态吗？ 能！！！ 既然这些它都能实现，那它和class还能有什么区别？ 最本质的一个区别就是默认的访问控制： 默认的继承访问权限 struct是public的，class是private的。 你可以写如下的代码： struct A { char a; }； struct B : A { char b; }； 这个时候B是public继承A的。 如果都将上面的struct改成class，那么B是private继承A的。这就是默认的继承访问权限。 所以我们在平时写类继承的时候，通常会这样写： class B : public A 就是为了指明是public继承，而不是用默认的private继承。 当然，到底默认是public继承还是private继承，取决于子类而不是基类。 我的意思是，struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。如下： struct A{}；class B : A{}; //private继承 struct C : B{}； //public继承 struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的 我依旧强调struct是一种数据结构的实现体，虽然它是可以像class一样的用。我依旧将struct里的变量叫数据，class内的变量叫成员，虽然它们并无区别。 到底是用struct还是class，完全看个人的喜好，你可以将程序里所有的class全部替换成struct，它依旧可以很正常的运行。但我给出的最好建议，还是：当你觉得你要做的更像是一种数据结构的话，那么用struct，如果你要做的更像是一种对象的话，那么用class。 当然，我在这里还要强调一点的就是，对于访问控制，应该在程序里明确的指出，而不是依靠默认，这是一个良好的习惯，也让你的代码更具可读性。 说到这里，很多了解的人或许都认为这个话题可以结束了，因为他们知道struct和class的“唯一”区别就是访问控制。很多文献上也确实只提到这一个区别。 但我上面却没有用“唯一”，而是说的“最本质”，那是因为，它们确实还有另一个区别，虽然那个区别我们平时可能很少涉及。 那就是：“class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。这一点在Stanley B.Lippman写的Inside the C++ Object Model有过说明。 问题讨论到这里，基本上应该可以结束了。但有人曾说过，他还发现过其他的“区别”，那么，让我们来看看，这到底是不是又一个区别。还是上面所说的，C++中的struct是对C中的struct的扩充，既然是扩充，那么它就要兼容过去C中struct应有的所有特性。例如你可以这样写： struct A //定义一个struct { char c1; int n2; double db3; }; A a={‘p’, 7, 3.1415926}; //定义时直接赋值 也就是说struct可以在定义的时候用{}赋初值。那么问题来了，class行不行呢？将上面的struct改成class，试试看。报错！噢~于是那人跳出来说，他又找到了一个区别。我们仔细看看，这真的又是一个区别吗？ 你试着向上面的struct中加入一个构造函数（或虚函数），你会发现什么？ 对，struct也不能用{}赋初值了 的确，以{}的方式来赋初值，只是用一个初始化列表来对数据进行按顺序的初始化，如上面如果写成A a={‘p’,7};则c1,n2被初始化，而db3没有。这样简单的copy操作，只能发生在简单的数据结构上，而不应该放在对象上。加入一个构造函数或是一个虚函数会使struct更体现出一种对象的特性，而使此{}操作不再有效。 事实上，是因为加入这样的函数，使得类的内部结构发生了变化。而加入一个普通的成员函数呢？你会发现{}依旧可用。其实你可以将普通的函数理解成对数据结构的一种算法，这并不打破它数据结构的特性。 那么，看到这里，我们发现即使是struct想用{}来赋初值，它也必须满足很多的约束条件，这些条件实际上就是让struct更体现出一种数据机构而不是类的特性。 那为什么我们在上面仅仅将struct改成class，{}就不能用了呢？ 其实问题恰巧是我们之前所讲的——访问控制！你看看，我们忘记了什么？对，将struct改成class的时候，访问控制由public变为private了，那当然就不能用{}来赋初值了。加上一个public，你会发现，class也是能用{}的，和struct毫无区别！！！ 做个总结，从上面的区别，我们可以看出，struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。 [转]声明/感谢： http://blog.sina.com.cn/s/blog_7c2c21230100svc3.html — http://blog.csdn.net/gengyichao/article/details/6542233 http://blog.csdn.net/xocoder/article/details/8484890]]></content>
      <categories>
        <category>C++_YinRK</category>
        <category>D.S.</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA结课_12.08+英语口语_12.12结课考试有感]]></title>
    <url>%2Fpost%2Fa992dee6.html</url>
    <content type="text"><![CDATA[注意:自己去搞（计算机专业性）。有计划，有意识去做！多去修改完善，UP！ 自己要有意识知道这个是干什么的！底层机制，自己去搞。 不放弃、不着急、多去练.alizi well！ 一：主干：（整理咨询骨干）《想讲的点子》《切入点、基础架构！》1.我在济大（学生） 2.我的家 （学生 ） 4.我有话说 （学生）5. 等你长大（家长/学校） 3.老师来了（走访经过！） 6.工作感言（老师 比重大！）（主要以老师为主！ 注意颜色温暖，字体规矩！是给领导看的！）1.！2. 二、图像（圆形 流程）的力量之大！（潜意识 温暖！ 照片先行、满版鲜血）三、美与简单的事物 总能让我们看见真相！《快速切入排版《简而美》》留白、色调、字体、比例《一致性、对比性》四、动书效果 自然且生动----------------总结： 1.学习 了简报和PPT一些资源模板（PPT的强大设计之处！）2.一定可以养成 每天保存各个网站（各5张图片的习惯！）所以说目前素材还是个大问题啊！3.还书（两本PS。一本huofa） 面壁十年图破壁，难酬滔海亦英雄！ 革命真的尚未成功！同志这的需更多的努力！ ————————致梦想之家！ 另外！接下来真的风暴出现: 英语口语在图书馆角落里读书的感觉！希望你一辈子不要忘记！ _希望你能够真正的 寻找到自己的方向。技术。真正的能够为之努力奋进！_ _一个人的学识，并不是由他人教出来。而是由自己的想象、自己为之实验努力而得出来的！！！_ 【激发】’Unleashed your potential.电路仿真完成 周四：【周二Android】开题！！！课件！ 周五：打一下代码！！queue list 周日周一！！！！！！！ 电焊周六】！ 周日加每晚的实践思考设计！！！ 英语四级— 周二 、 周二 刷单词 + 选词填空+刷阅读理解、周三刷听力+翻译、周五刷 翻译+作文！ 数据结构,结束！！！ 完成算法 今天完成 graph+ ufset+kru算法 23点上床睡觉 周二早起 linear 栈队堆、复习周四上午 开题报告（答辩！），电路设计：下载预习、复习！！！英语！ 电路 multisim 、数据结构、web 、PSusr！学习正则表达式！JAVA 已完成：PS过！_90！加口语考试。]]></content>
      <categories>
        <category>日记之家</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[域名基础]]></title>
    <url>%2Fpost%2Ff655c3a5.html</url>
    <content type="text"><![CDATA[你应该用你绑定的域名访问。不是用IP。IP访问只能访问到一个站点的。（最优先的那个）哪个网站有问题，在你网站根目录， 新建一个test.php &lt;?php phpinfo(); ?&gt; 浏览test.php看访问是正常的吗？ 其实一级域名就是顶级域名，这只是同一种域名的两种叫法，很多朋友认为zzidc.com这样的是顶级域名，www.zzidc.com这样的是一级域名，其实这是错误的认识，zzidc.com是顶级域名，也是一级域名。 注册一级域名的时候是需要付费的，而二级域名、三级域名是基于一级域名延伸出来的，在域名服务器支持的情况下（一般都支持），修改域名的NS服务器地址为空间商的，然后在空间控制面板附加域名，以后的解析记录和二级域名窗机需要在空间商哪里进行操作。 当然，二级域名和三级域名是免费的，只是大多服务器会限制二级域名的数量，一面造成泛解析，二级域名的具体形式主要为www为前缀类似www.zzidc.com这样的域名，以及根据自身需求自定义前缀例如 host.zzidc.com这样的二级域名。www.zzidc.com和host.zzidc.com同为二级域名，两者是平等关系，只是人们习惯使用www为前缀的二级域名作为网站的主域名入口，这样也更方便大家记忆罢了。 http://baike.baidu.com/link?url=xMIcSTOAX1RRxooP5qs36y0qh8xnTkuyRvCyGxLOXC-ito0TbVB4nD8\_iDOQkZQrTTn8TMpXytJtwrLxsXKcu9UCmikpde8a1PDOP2eOgMFieP9eVQn0xbyNIygydlpD http://blog.csdn.net/esther\_heesch/article/details/51646614 http://jingyan.baidu.com/article/ceb9fb10ed6ef08cad2ba08f.html]]></content>
      <categories>
        <category>ThinkphpPri</category>
        <category>计算机基础--安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA扩展关于在JTextField限制输入字符长度]]></title>
    <url>%2Fpost%2Fc6157e91.html</url>
    <content type="text"><![CDATA[无法从静态上下文中引用非静态方法”这个问题怎么解决？No1:项目启动时候先加载静态的东西，你静态的方法中要调用静态的，同一个类中没有实例化当然不行，你在不同类中是实例化以后调用当然就不报错 。 No2：楼主，你好。因为静态方法的调用不是通过实例对象进行的，所以在静态方法中没有this指针，不能访问所属类的非静态变量和方法，只能访问方法体内的局部变量、自己的参数和静态变量。所以你在在static的主函数里调用非static的方法时肯定报错。所以你把方法放到另一个类，创建对象再调用，不会出错，因为你这个方法不是静态的，即不是属于类的，而是属于具体的一个实例对象的，用对象调用那当然不会错咯！ 只要记住这一点： 用statci修饰的成员是属于类的，在static的方法里可以用类名直接调用； 不用statci修饰的成员是属于具体实例对象的，需要用对象名调用，且在static的方法里不可以调用。 No3: 用static修饰的方法称为静态方法，修饰变量则为静态变量，又分别叫做类方法或者类变量。静态方法中不能直接调用非静态方法。因为非静态方法不是独立存在的，它是依附于对象存在——即只有申明了对象，才能通过对象调用。而静态方法则可以直接通过类名调用，而不需要申明对象。因此直接引用非静态方法就会出错。比如常见的main方法都是静态的，必须由static修饰，因此在main方法里调用类的其他非静态方法，都是需要先申明对象，才能用。否则就会出现引用非静态方法的错误。要解决这个问题，可以去除一般方法的static关键字（如果是main方法，则不能去掉static）。另外一种方法就是把需要引用的方法也设置成静态方法。 方法一：重写 JTextField中的Document / To change this license header, choose License Headers in Project Properties. To change this template file, choose Tools | Templates and open the template in the editor. / /** @author z2829 / import javax.swing.; import java.awt.; import java.awt.event.; import javax.swing.text.; import javax.swing.event.; class MyDocument extends PlainDocument{ int maxLength =10; public MyDocument(int newMaxLength){ super(); maxLength = newMaxLength; } public MyDocument(){ this(10); } //重载父类的insertString函数 public void insertString(int offset,String str,AttributeSet a)throws BadLocationException{ if(getLength()+str.length()&gt;maxLength){//这里假定你的限制长度为10 return; } else{ super.insertString(offset,str,a); } } } public class DocumentTest extends JFrame { final static int docLength = 3;//表示可输入文本的最大长度 // public void insertString(int offs, String str, AttributeSet a) throws BadLocationException { // if (a == null) { // int allowCount = docLength - getLength(); // if (allowCount &gt; 0) { // if (allowCount &lt; str.length()) // str = str.substring(0, allowCount); // } else // return; // } // super.insertString(offs, str, a); // } public DocumentTest() { super(“DocumentTest”); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Dimension d = Toolkit.getDefaultToolkit().getScreenSize(); setBounds((d.width-570)/2,(d.height-215)/2,570,215); Document doc = new DefaultStyledDocument(); doc.addDocumentListener(new DocumentListener(){ public void insertUpdate(DocumentEvent e) { final Document document = e.getDocument(); if (document.getLength()&gt;docLength) { try { new Thread(new Thread(){ public void run() { try { document.remove(1,document.getLength()-1); } catch (Exception exp) { System.out.println(“Error: “+ exp.toString()); } } }).start(); } catch (Exception ex) { System.out.println(“Error: “+ ex.toString()); } } } public void removeUpdate(DocumentEvent e) {} public void changedUpdate(DocumentEvent e) {} }); //JTextArea area1 = new JTextArea(doc,””,30,40); JTextField jTextField1 = new JTextField(20); jTextField1.setDocument(new MyDocument(10)); JPanel pane = new JPanel(); pane.add(jTextField1); setContentPane(pane); setVisible(true); } public static void main(String [] args) { new DocumentTest(); } } 方法二：添加一个监视器 / To change this license header, choose License Headers in Project Properties. To change this template file, choose Tools | Templates and open the template in the editor. / /* @author z2829 / import java.awt.Dimension; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import javax.swing.JFrame; import javax.swing.JTextField; public class Test1 extends JFrame { public Test1() { this.setLayout(null); this.setSize(new Dimension(400, 200)); final JTextField txt = new JTextField(); txt.addKeyListener(new KeyAdapter() { public void keyTyped(KeyEvent e) { char c = e.getKeyChar(); if (Character.isDigit(c) &amp;&amp; txt.getText().trim().length() &lt; 10)//只允许数字，且长度不大于10 return; e.consume(); } }); txt.setBounds(50, 50, 120, 20); this.add(txt); this.setVisible(true); } public static void main(String args[]) { new Test1(); } } js 正则表达式 http://leagion.iteye.com/blog/616815 https://zhidao.baidu.com/question/1112876975114106779.html?qbl=relate\_question\_0&amp;word=swing%CF%DE%D6%C6%B5%C7%C2%BD%CE%BB%CA%FD http://www.cnblogs.com/trytocatch/archive/2012/11/30/2795940.html http://bbs.csdn.net/topics/300018193]]></content>
      <categories>
        <category>Java</category>
        <category>JavaClass</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[THINKPHP21_22/23_24/25]]></title>
    <url>%2Fpost%2F9c9b12ab.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/usr/local/apache-2.4/conf/extra httpd.conf # # ThinkPHP 3.1.2 控制器的模块和操作 # 讲师：赵桐正 微博：http://weibo.com/zhaotongzheng 本节课大纲： //可以查看咱们的 thinkphp3 一、空模块和空操作 1、空操作//空方法！ function \_empty($name)&#123; $this-&gt;show(&quot;$name 不存在 &lt;a href=&apos;\_\_APP__/Index/index&apos;&gt;返回首页&lt;/a&gt;&quot;); &#125; 2.空模块 class EmptyAction extends Action&#123; function index()&#123; $m = M(&apos;City&apos;); $arr = $m -&gt;select(); $this -&gt; assign( &apos;list&apos;,$arr ); $name = MODULE\_NAME;//可以去查看常量参考！thinkphp手册！20附录里面！ $this -&gt; display(&quot;City:$name&quot;) ; //e1 用的双引号！只是单纯的访问下，不进入 方法操作！ &#125; &#125; 二、前置操作和后置操作 1、前置操作： \_before_操作名 2、后置操作： \_after\_操作名* * *23--24 开发手册 3.1.2 注意 5.控制器当就有！！！ # # ThinkPHP 3.1.2 URL # 讲师：赵桐正 微博：http://weibo.com/zhaotongzheng 本节课大纲： 一、URL规则 1、默认是区分大小写的 2、如果我们不想区分大小写可以改配置文件 &apos;URL\_CASE\_INSENSITIVE&apos;=&gt;true,//url不区分大小写 3、如果模块名为 UserGroupAction 那么url找模块就必要要写成 http://localhost/thinkphp4/index.php/user_group/index 4、如果&apos;URL\_CASE\_INSENSITIVE&apos;=&gt;false 那么url也可以写为 http://localhost/thinkphp4/index.php/UserGroup/index 二、URL伪静态 URL伪静态// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt;ThinkPHP支持伪静态URL设置，可以通过设置URL\_HTML\_SUFFIX参数随意在URL的最后增加你想要的静态后缀，而不会影响当前操作的正常执行。例如，我们设置1. &apos;URL\_HTML\_SUFFIX&apos;=&gt;&apos;shtml&apos;的话，我们可以把下面的URL1. http://serverName/Blog/read/id/1变成1. http://serverName/Blog/read/id/1.shtml后者更具有静态页面的URL特征，但是具有和前面的URL相同的执行效果，并且不会影响原来参数的使用。 注意：伪静态后缀设置时可以不包含后缀中的“.”。URL伪静态// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt;3.1版本开始，默认情况下，可以支持所有的静态后缀，并且会记录当前的伪静态后缀到常量\_\_EXT\_\_，但不会影响正常的页面访问。所以要想限制的话就要： &apos;URL\_HTML\_SUFFIX&apos;=&gt;&apos;html|shtml|xml&apos;,//限制伪静态的后缀 三、URL路由（注意必须是pathinfo模式的，而且按照下面的开启路由支持！） 1、启动路由 要在配置文件中开启路由支持 2、使用路由 1.规则表达式配置路由 &apos;my&apos;=&gt;&apos;Index/index&apos;,//静态地址路由 &apos;:id/:num&apos;=&gt;&apos;Index/index&apos;,//动态地址路由 &apos;year/:year/:month/:date&apos;=&gt;&apos;Index/index&apos;,//动态和静态混合地址路由 &apos;year/:year\\d/:month\\d/:date\\d&apos;=&gt;&apos;Index/index&apos;,//动态和静态混合地址路由 加上 \\d代表类型只能是数字 &apos;my/:id$&apos;=&gt;&apos;Index/index&apos;,// 加上$说明地址中只能是 my/1000 后面不能有其他内容了 2.正则表达式配置路由 &apos;/^year\\/(\\d&#123;4&#125;)\\/(\\d&#123;2&#125;)\\/(\\d&#123;2&#125;)/&apos;=&gt;&apos;Index/index?year=:1&amp;month=:2&amp;date=:3&apos; 3、注意事项： 1.越复杂的路由越往前面放 &apos;URL\_ROUTE\_RULES&apos;=&gt;array( &apos;my/:year/:month:/:day&apos;=&gt;&apos;Index/day&apos;, &apos;my/:id\\d&apos;=&gt;&apos;Index/index&apos;, &apos;my/:name&apos;=&gt;&apos;Index/index&apos;, ) 2.可以使用$作为完全匹配的路由规则 &apos;URL\_ROUTE\_RULES&apos;=&gt;array( &apos;my/:id\\d$&apos;=&gt;&apos;Index/index&apos;, &apos;my/:name$&apos;=&gt;&apos;Index/index&apos;, &apos;my/:year/:month:/:day$&apos;=&gt;&apos;Index/day&apos;, ), 3.用正则匹配的方式 &apos;URL\_ROUTE\_RULES&apos;=&gt;array( &apos;/^my\\/(\\d+)$/&apos;=&gt;&apos;Index/index?id=:1&apos;, &apos;/^my\\/(\\w+)$/&apos;=&gt;&apos;Index/index?name=:1&apos;, &apos;/^my\\/(\\d&#123;4&#125;)\\/(\\d&#123;2&#125;)\\/(\\d&#123;2&#125;)$/&apos;=&gt;&apos;Index/day?year=:1&amp;month=:2&amp;day=:3&apos;, ), 四、URL重写 URL重写// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt;通常的URL里面含有index.php，为了达到更好的SEO效果可能需要去掉URL里面的index.php ，通过URL重写的方式可以达到这种效果，通常需要服务器开启URL\_REWRITE模块才能支持。 下面是Apache的配置过程，可以参考下： 1、httpd.conf配置文件中加载了mod\_rewrite.so模块 2、AllowOverride None 将None改为 All 3、确保URL_MODEL设置为2 4、把下面的内容保存为.htaccess文件放到入口文件的同级目录下1. &lt;IfModulemod_rewrite.c&gt;2. RewriteEngine on3. RewriteCond %&#123;REQUEST_FILENAME&#125; !-d4. RewriteCond %&#123;REQUEST_FILENAME&#125; !-f5. RewriteRule ^(.*)$ index.php/$1 \[QSA,PT,L\]6. &lt;/IfModule&gt;五、URL生成 URL重写// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt;通常的URL里面含有index.php，为了达到更好的SEO效果可能需要去掉URL里面的index.php ，通过URL重写的方式可以达到这种效果，通常需要服务器开启URL\_REWRITE模块才能支持。 下面是Apache的配置过程，可以参考下： 1、httpd.conf配置文件中加载了mod\_rewrite.so模块 2、AllowOverride None 将None改为 All 3、确保URL_MODEL设置为2 4、把下面的内容保存为.htaccess文件放到入口文件的同级目录下1. &lt;IfModulemod_rewrite.c&gt;2. RewriteEngine on3. RewriteCond %&#123;REQUEST_FILENAME&#125; !-d4. RewriteCond %&#123;REQUEST_FILENAME&#125; !-f5. RewriteRule ^(.*)$ index.php/$1 \[QSA,PT,L\]6. &lt;/IfModule&gt;URL生成// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt;如果不定义项目和模块的话 就表示当前项目和模块名称，下面是一些简单的例子：1. U(&apos;User/add&apos;) // 生成User模块的add操作的URL地址2. U(&apos;Blog/read?id=1&apos;) // 生成Blog模块的read操作 并且id为1的URL地址3. U(&apos;Admin/User/select&apos;) // 生成Admin分组的User模块的select操作的URL地址具体查看-----3.1.2！！！！！！！！！！* * *25 # # ThinkPHP 3.1.2 URL # 讲师：赵桐正 微博：http://weibo.com/zhaotongzheng 本节课大纲： 一、多应用配置技巧 二、使用分组 5.6 模块分组 三、页面跳转 $this-&gt;success(&apos;查询成功&apos;,U(&apos;User/test&apos;)); $this-&gt;redirect(&apos;User/test&apos;,&apos;&apos;,5,&apos;页面正在跳&apos;); 参考手册 5.14页面跳转// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt;1. //默认错误跳转对应的模板文件2. &apos;TMPL\_ACTION\_ERROR&apos; =&gt; THINK_PATH . &apos;Tpl/dispatch_jump.tpl&apos;;3. //默认成功跳转对应的模板文件4. &apos;TMPL\_ACTION\_SUCCESS&apos; =&gt; THINK_PATH . &apos;Tpl/dispatch_jump.tpl&apos;;四、Ajax技巧 5.19AJAX返回// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt;1. $data\[&apos;status&apos;\] = 1;2. $data\[&apos;info&apos;\] = &apos;info&apos;;3. $data\[&apos;size&apos;\] = 9;4. $data\[&apos;url&apos;\] = $url;5. $this-&gt;ajaxReturn($data,&apos;JSON&apos;); AJAX返回// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt;1. $data\[&apos;status&apos;\] = 1;2. $data\[&apos;info&apos;\] = &apos;info&apos;;3. $data\[&apos;size&apos;\] = 9;4. $data\[&apos;url&apos;\] = $url;5. $this-&gt;ajaxReturn($data,&apos;JSON&apos;);]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[THINKPHP19_20]]></title>
    <url>%2Fpost%2F12febcaa.html</url>
    <content type="text"><![CDATA[1--jishang 为什么要修改左右定界符 -- 因为很容易和js，css冲突的！ ！！ # # ThinkPHP 3.1.2 模板的使用技巧 # 讲师：赵桐正 微博：http://weibo.com/zhaotongzheng 本节课大纲： 一、模板包含 &lt;include file=&quot;完整模板文件名&quot; /&gt; &lt;include file=&quot;./Tpl/default/Public/header.html&quot; /&gt; &lt;include file=&quot;read&quot; /&gt; &lt;include file=&quot;Public:header&quot; /&gt; &lt;include file=&quot;blue:User:read&quot; /&gt; &lt;include file=&quot;$tplName&quot; /&gt; &lt;include file=&quot;header&quot; title=&quot;ThinkPHP框架&quot;keywords=&quot;开源WEB开发框架&quot;/&gt; 在模板中变量用\[变量\]接受 &lt;include file=&apos;file1,file2&apos; /&gt; 二、模板渲染 1、自动开启模板渲染 设置配置文件 &apos;LAYOUT\_ON&apos;=&gt;true,//开启模板渲染 准备一个模板渲染页面，在页面中使用&#123;\_\_CONTENT__&#125;接受具体模板页面的内容 如果在摸一个具体模板中不希望使用渲染模板，可以在页首添加&#123;\_\_NOCONTENT\_\_&#125; &#123;\_\_NOLAYOUT\_\_&#125; 2、不开启自动模板渲染可以在每一个具体页面的页首添加 &lt;layout name=&apos;layout&apos;/&gt; 会自动组装成一个 完整的页面！~~ 3.使用技巧 在渲染模板文件中也可以使用其他模板文件的内容 &lt;include file=&apos;Public:header&apos;/&gt; &lt;body&gt; &lt;p&gt;这里是渲染页面！！！&lt;/p&gt; &#123;\_\_CONTENT\_\_&#125; &lt;/body&gt; &lt;/html&gt; 三、模板的继承 &lt;block name = &apos;body&apos; &gt; &lt;/block&gt; 模板继承// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt; 在当前子模板中，只能定义区块而不能定义其他的模板内容，否则将会直接忽略，并且只能定义基础模板中已经定义的区块。例如，如果采用下面的定义：12341. &lt;blockname=&quot;title&quot;&gt;&lt;title&gt;&#123;$title&#125;&lt;/title&gt;&lt;/block&gt;2. &lt;ahref=&quot;/&quot;&gt;首页&lt;/a&gt;3. &lt;ahref=&quot;/info/&quot;&gt;资讯&lt;/a&gt;4. &lt;ahref=&quot;/bbs/&quot;&gt;论坛&lt;/a&gt; 导航部分将是无效的，不会显示在模板中。在子模板中，可以对基础模板中的区块进行重载定义，如果没有重新定义的话，则表示沿用基础模板中的区块定义，如果定义了一个空的区块，则表示删除基础模板中的该区块内容。上面的例子，我们就把left区块的内容删除了，其他的区块都进行了重载。子模板中的区块定义顺序是随意的，模板继承的用法关键在于基础模板如何布局和设计规划了，如果结合原来的布局功能，则会更加灵活。 123456789101112131415161718192021222324252627282930模板继承// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var _this = $(this); if(index % 2 == 0)&#123; _this.addClass(&apos;add&apos;); &#125; else &#123; _this.addClass(&apos;even&apos;); &#125; _this.hover( function()&#123;_this.addClass(&apos;hover&apos;)&#125;, function()&#123;_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125;// \]\]&gt; 一个模板中可以定义任意多个名称标识不重复的区块，例如下面定义了一个base.html基础模板：123456789101112131. &lt;html&gt;2. &lt;head&gt;3. &lt;metahttp-equiv=&quot;Content-Type&quot;content=&quot;text/html; charset=utf-8&quot;&gt;4. &lt;blockname=&quot;title&quot;&gt;&lt;title&gt;标题&lt;/title&gt;&lt;/block&gt;5. &lt;/head&gt;6. &lt;body&gt;7. &lt;blockname=&quot;menu&quot;&gt;菜单&lt;/block&gt;8. &lt;blockname=&quot;left&quot;&gt;左边分栏&lt;/block&gt;9. &lt;blockname=&quot;main&quot;&gt;主内容&lt;/block&gt;10. &lt;blockname=&quot;right&quot;&gt;右边分栏&lt;/block&gt;11. &lt;blockname=&quot;footer&quot;&gt;底部&lt;/block&gt;12. &lt;/body&gt;13. &lt;/html&gt; 然后我们在子模板（其实是当前操作的入口模板）中使用继承：12345678910111213141516171819202122231. &lt;extendname=&quot;base&quot;/&gt;2. &lt;blockname=&quot;title&quot;&gt;&lt;title&gt;&#123;$title&#125;&lt;/title&gt;&lt;/block&gt;3. &lt;blockname=&quot;menu&quot;&gt;4. &lt;ahref=&quot;/&quot;&gt;首页&lt;/a&gt;5. &lt;ahref=&quot;/info/&quot;&gt;资讯&lt;/a&gt;6. &lt;ahref=&quot;/bbs/&quot;&gt;论坛&lt;/a&gt;7. &lt;/block&gt;8. &lt;blockname=&quot;left&quot;&gt;&lt;/block&gt;9. &lt;blockname=&quot;content&quot;&gt;10. &lt;volistname=&quot;list&quot;id=&quot;vo&quot;&gt;11. &lt;ahref=&quot;/new/&#123;$vo.id&#125;&quot;&gt;&#123;$vo.title&#125;&lt;/a&gt;&lt;br/&gt;12. &#123;$vo.content&#125;13. &lt;/volist&gt;14. &lt;/block&gt;15. &lt;blockname=&quot;right&quot;&gt;16. 最新资讯：17. &lt;volistname=&quot;news&quot;id=&quot;new&quot;&gt;18. &lt;ahref=&quot;/new/&#123;$new.id&#125;&quot;&gt;&#123;$new.title&#125;&lt;/a&gt;&lt;br/&gt;19. &lt;/volist&gt;20. &lt;/block&gt;21. &lt;blockname=&quot;footer&quot;&gt;22. @ThinkPHP2012 版权所有23. &lt;/block&gt;]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP16 && 17 && 18模板中的基本语法]]></title>
    <url>%2Fpost%2Fa454a6b8.html</url>
    <content type="text"><![CDATA[# # ThinkPHP 3.1.2 模板中的基本语法 # 讲师：赵桐正 微博：http://weibo.com/zhaotongzheng 本节课大纲： 一、导入CSS和JS文件 1、css link js scr 2.import //导入Public文件夹下面的Js目录中的test.js文件，import标签可以省略type属性，默认就是js的 //可以更改默认文件夹 设置basepath属性 3.load //方法可以自动检测导入的文件类型 二、分支结构 1、if 男人是泥巴做的 女人是水做的 未成年 青春年少 成年 &gt; gt &lt; lt == eq &lt;= elt &gt;= egt != neqr === heq //恒等于 !== nheq //恒不等于 注意这里没有 $ 符号！！！case 是双标签的运算符！ 注意 不可以在里面写 html的注释！因为在解析到 php中的时候会出错的Runtime—Cache 一个和尚挑水吃 两个和尚台水吃 三个和尚没水吃 这里是默认值 三、循环结构 1.for {$j}abc 2.volist {$v.username} 3.foreach {$k}———-{$v} 四、特殊标签(其中的变量不用加变量符 1、比较标签 eq或者 equal 等于 neq 或者notequal 不等于 gt 大于 egt 大于等于 lt 小于 elt 小于等于 heq 恒等于 nheq 不恒等于 又一次输出了10又一次没有输出10 相当于for的简单用法 2.范围标签 in 在这些数字里面不在这些数字的范围内 在这些数字里面不在这些数字的范围内&lt;/in&gt; between {$n}在1-10之间{$n}不在1到10之间&lt;/between&gt; egt elt 范围!下面的这些了解即可！ 3.present 标签来判断模板变量是否已经赋值， m有赋值m没有赋值 4.Empty empty标签判断模板变量是否为空， n为空赋值n有值 5.Defined 判断常量是否已经定义 6.Define 在模板中定义常量 7.Assing 模板中变量赋值Assign标签// &lt;![CDATA[$(function(){ $(window).resize(function(){ $(‘.book-content’).css(‘min-height’, $(window).height() - 130); }).resize(); //表格隔行变色 $(‘table’).TableColor(); //代码高亮 prettyPrint(); }); //表格隔行变色插件 $.fn.TableColor = function(){ return $(this).each(function(){ if(this.nodeName.toLowerCase() != ‘table’) return; var self = $(this); self.find(‘tr’).each(function(index) { var _this = $(this); if(index % 2 == 0){ _this.addClass(‘add’); } else { _this.addClass(‘even’); } _this.hover( function(){_this.addClass(‘hover’)}, function(){_this.removeClass(‘hover’)} ); }); }); }// ]]&gt; 五、其他标签使用 最好不要直接在模板中 使用php标签！！！因为这里是框架开发！一定要注意！ 使用PHP代码// &lt;![CDATA[ $(function(){ $(window).resize(function(){ $(‘.book-content’).css(‘min-height’, $(window).height() - 130); }).resize(); //表格隔行变色 $(‘table’).TableColor(); //代码高亮 prettyPrint(); }); //表格隔行变色插件 $.fn.TableColor = function(){ return $(this).each(function(){ if(this.nodeName.toLowerCase() != ‘table’) return; var self = $(this); self.find(‘tr’).each(function(index) { var _this = $(this); if(index % 2 == 0){ _this.addClass(‘add’); } else { _this.addClass(‘even’); } _this.hover( function(){_this.addClass(‘hover’)}, function(){_this.removeClass(‘hover’)} ); }); }); } // ]]&gt; 简而言之，在PHP标签里面不能再使用PHP本身不支持的代码！！！ 如果设置了TMPL_DENY_PHP参数为true，就不能在模板中使用原生的PHP代码，但是仍然支持PHP标签输出！（了解） 1、在模板中直接使用PHP代码 echo “我是赵桐正” 2、建议更改左右定界符 在配置文件中改变 ‘TMPL_L_DELIM’=&gt;’&lt;{‘, //修改左定界符 ‘TMPL_R_DELIM’=&gt;’}&gt;’, //修改右定界符]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP15模板变量]]></title>
    <url>%2Fpost%2F75f66f7d.html</url>
    <content type="text"><![CDATA[1注意第三方文件要在外部引用的！系统变量输出 手册查找 注意！！！ &lt;&#123;$Think.version&#125;&gt; &lt;&#123;$Think.const.APP_NAME&#125;&gt; &lt;&#123;$Think.get.name&#125;&gt; # # ThinkPHP 3.1.2 模板中的变量 # 讲师：赵桐正 微博：http://weibo.com/zhaotongzheng 本节课大纲： 一、变量输出 （重点） 1.标量输出 2.数组输出 &#123;$name\[1\]&#125; &#123;$name\[&apos;k2&apos;\]&#125; &#123;$name.k1&#125; 3.对象输出 &#123;$name:k&#125; &#123;$name-&gt;k&#125; 二、系统变量 &#123;$Think.get.id&#125; 三、使用函数 &#123;$name|strtoupper&#125; 生成的编译后文件是 &lt;?php echo (strtoupper($name)); ?&gt; 在 runtime cache下 可以看出 模板下可以使用php函数 &#123;$name|date=&apos;Y m d H:i:s&apos;,###&#125; //-- &#123;date = （Y m d H:i:s ，$name ）&#125; 所以 ### 是占位符 -》 ￥name 四、默认值 &#123;$name|default=&apos;这里是默认值&apos;&#125; 五、运算符 + - * / % ++ -- 都可以！！ &#123;$name++&#125; //配置项相关 &apos;URL\_PATHINFO\_DEPR&apos;=&gt;&apos;-&apos;,//修改URL的分隔符 &apos;TMPL\_L\_DELIM&apos;=&gt;&apos;&lt;&#123;&apos;, //修改左定界符 &apos;TMPL\_R\_DELIM&apos;=&gt;&apos;&#125;&gt;&apos;, //修改右定界符 &apos;DB\_TYPE&apos;=&gt;&apos;mysql&apos;, //设置数据库类型 &apos;DB\_HOST&apos;=&gt;&apos;localhost&apos;,//设置主机 &apos;DB\_NAME&apos;=&gt;&apos;thinkphp&apos;,//设置数据库名 &apos;DB\_USER&apos;=&gt;&apos;root&apos;, //设置用户名 &apos;DB\_PWD&apos;=&gt;&apos;&apos;, //设置密码 &apos;DB\_PORT&apos;=&gt;&apos;3306&apos;, //设置端口号 &apos;DB\_PREFIX&apos;=&gt;&apos;tp\_&apos;, //设置表前缀 &apos;DB\_DSN&apos;=&gt;&apos;mysql://root:@localhost:3306/thinkphp&apos;,//使用DSN方式配置数据库信息 &apos;SHOW\_PAGE\_TRACE&apos;=&gt;true,//开启页面Trace &apos;TMPL\_TEMPLATE\_SUFFIX&apos;=&gt;&apos;.html&apos;,//更改模板文件后缀名 &apos;TMPL\_FILE\_DEPR&apos;=&gt;&apos;\_&apos;,//修改模板文件目录层次 &apos;TMPL\_DETECT\_THEME&apos;=&gt;true,//自动侦测模板主题 &apos;THEME\_LIST&apos;=&gt;&apos;your,my&apos;,//支持的模板主题列表 &apos;TMPL\_PARSE\_STRING&apos;=&gt;array( //添加自己的模板变量规则 &apos;\_\_CSS__&apos;=&gt;\_\_ROOT\_\_.&apos;/Public/Css&apos;, &apos;\_\_JS\_\_&apos;=&gt;\_\_ROOT\_\_.&apos;/Public/Js&apos;, ),]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sublime SFTP && FTPSync]]></title>
    <url>%2Fpost%2Fd049fa6e.html</url>
    <content type="text"><![CDATA[Sublime Text 2 本身并不强大，但是它方便使用插件扩展功能，所以变得很强大。今天介绍一个很实用的插件 SFTP ，可以大大提高前端工作效率。 常见的工作流程有时候修改一些网站上的文件，通常是下面这样的流程：使用 FTP/SFTP 连接到远程服务器 -&gt; 下载要修改的文件 -&gt; 使用 ST2 修改文件 -&gt; 保存然后拖进 FTP 中 -&gt; 刷新网站。 很明显这样的工作流程效率很低，特别是你修改一句代码的时候，为了即时生效，也需要重复切换几个窗口重复这个过程。于是就有了 SFTP 这个插件。 它主要功能就是通过 FTP/SFTP 连接远程服务器并获取文件列表，可以选择下载编辑、重命名、删除等等操作，点下载编辑之后，可以打开这个文件进行修改。修改完成之后，保存一下会自动上传到远程的服务器上面。 使用这个插件之后，工作流程就变成了：使用 SFTP 插件打开文件 -&gt; 使用 ST2 编辑修改文件 -&gt; 保存文件 -&gt; 刷新页面。效率提升了至少一倍以上，下面就来介绍一下具体的使用方法。 SFTP 安装和使用方法先要安装这个插件，打开 Sublime Text 2 ，摁下 shift + ctrl + p 键，呼出面板，使用 Package Control 这个插件安装。输入 “pci” 敲击回车，再输入 “sftp” 即可安装这个插件。安装完之后，就要开始配置服务器使用了。 第一步：配置 FTP/SFTP 服务器信息安装完插件之后，找到 “文件” 菜单，找到 “SFTP/FTP” 选项，点击配置： 点击之后，会弹出一个新的窗口，这是一个配置文件 一般就是配置一下我箭头所指的四个参数，包括连接方式、服务器地址、用户名、密码等。如果你的服务器还有其他配置，你也可以对照注释设置一下。一般为了方便，还会设置一下“路径”，这样直接可以看到想要修改的文件列表。 配置完成之后，我们保存，然后输入一个名字作为标识。 第二步：连接服务器获取文件列表还是点击 “文件” 选择 “SFTP/FTP” 中的查看服务器列表 会弹出刚刚配置好的服务器，我们可以点击需要连接的 FTP 服务器，这时候就链接上了并且弹出文件列表 这时候点击一个文件，就可以弹出一些选项 就可以根据你自己的需要，对文件编辑、重命名什么的了。点击编辑之后，会在本地打开，然后可以修改。摁下 ctrl + s 保存文件的时候，就会自动上传文件。 如果需要查看服务器上的别的文件，或者需要更多的功能，可以直接在当前文件中右击，选择 “SFTP/FTP” 就会弹出更多选项可以使用，没法截图所以不再赘述。更多的功能，就交给你自己探索了！ [Sublime Text] 连接FTP, 安装及使用 FTPSync 图文步驟我们开始利用package control安装FTPSync安裝 FTPSync打开工具列 Preferences → Package Control 输入 install Package 按 ENTER 再输入 FTPSync 按 ENTER 安裝 设置、执行 FTPSync : [1] 建立一个文件夹，举例的我就建立在桌面上： 建立一个文件夹 建立一个文件夹 2、打开sublime，菜单中打开 Project - Add Folder to Project Project - Add Folder to Project 3、选择您刚刚建立的文件夹 选择您刚刚建立的文件夹 4、在左侧出现的文件夹上右键选择FTPSync -&gt;Setup FTPSync in this folder，如果出现不能选择的情况，请重新启动sublime，即可选择： Setup FTPSync in this folder 5、这时候会出现一个ftpsync.settings，然后将该文件设置正确，即可实现功能了，可以对你刚加入的 Project 上按右鍵 FTPSync → Download 下载 FTP上的程序文件 ftpsync.settings 6、下载： FTPSync → Download 参考配置文件： { // HELP / INFO moved to bottom // Remove “//“ to uncomment settings directive “default”: { “host”: “ftp.example.com”, //这里需要设置 “username”: “your_login”, // or null for anonymous login 这里需要设置 “password”: “your_password”, //这里需要设置 “path”: “/“, “upload_on_save”: true // set *false* if you do not want to upload on save! // “port”: 21, // “tls”: false, // “timeout”: 30, // [seconds] // “passive”: true, // “download_on_open”: false, // “overwrite_newer_prevention”: true, // “default_folder_permissions”: “755”, // “default_upload_permissions”: null, // null = no action taken // “time_offset”: 0, // [seconds] // “always_sync_local_permissions”: true, // Value “auto” = use UTF-8 if availible (FEAT: UTF8), otherwise use local // “encoding”: “auto”, // Trade small performance impact for more stable and secure transfer (old file is intact until the download is finished) // “use_tempfile”: true, // Regular expression, recommending using \\b in general and /…/ for folders to avoid matching substrings // “ignore”: “”, // Can be used for increase of performance or to allow build scripts to finish // “upload_delay”: 0, // [seconds] // Only if the server has MFMT extension installed // “set_remote_lastmodified”: true, // Chmod value for files newly downloaded by FTPSync // “auto” = same as on server // null = no action taken // “0644” = example for direct value // “default_local_permissions”: “auto”, // List of lists with pathnames and filenames to folders to be watched for change in between delay (upload_delay) // example: after_save_watch: [ [ “code/assets/css”, “.css” ], [ “code/assets/“, “.jpg, .png, .gif” ] ] // used only in conjunction with upload_on_save and upload_delay // For more info see https://github.com/NoxArt/SublimeText2-FTPSync/wiki/Why-and-how-to-use-afterwatch // “after_save_watch”: [] } // ——— INFO ——————————————————————————————————— // Index page // —- https://github.com/NoxArt/SublimeText2-FTPSync/ // For settings description see: // —- https://github.com/NoxArt/SublimeText2-FTPSync/wiki/All-settings // For more info see: // —- https://github.com/NoxArt/SublimeText2-FTPSync/wiki/_pages // Want to ask? Report a bug? // —- Hit: https://github.com/NoxArt/SublimeText2-FTPSync/issues/new // Commas // Don’t forget about commas -&gt; each entry needs a comma at the end of line EXCEPT the last (uncommented) entry // For precise info see http://www.json.org // Also try http://jsonlint.com // Comments ** // The “//“ are so called “comments”, all text after it is ignored, // they are used for notes or deactivating an entry // Non-basic settings are deactivated and default options specified in the global settings file, // that is $packages$/FTPSync/ftpsync.sublime-settings (where $packages$ is a path where Sublime // keeps packages in your Operating System) accessible via Preferences &gt; Package Settings &gt; FTPSync // Use Settings - User to override the global defaults // More info about Sublime Text 2 settings on http://www.sublimetext.com/docs/2/settings.html } 常见问题： 如果 FTPSync 沒反应请关闭 sublime 再开启！ 要注意你的 ftpsync.settings 最后一参数不能有逗号！ 【转】【学】： http://blog.wpjam.com/m/sublime-text-2-sftp/ http://chenxuehu.com/article/2014/05/2360.html]]></content>
      <categories>
        <category>测试</category>
        <category>计算机基础--安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA主窗体静态界面设计]]></title>
    <url>%2Fpost%2Fea0f6e03.html</url>
    <content type="text"><![CDATA[Netbeans中大话——Swing控件属性相关： jTextAreaDescription jTextArea**（那种类型）Description(干什么的 右击控件更改变量名！！！ 标签、标签化窗格、面板（选择题切换标签 列表、文本、复选框（shift可以连续拖拽多个 JFram 标题栏 菜单栏** JMenuBar组件并将其拖进窗体中，默认有“File”和“Edit”两个菜单，分别改为“操作(O)”和“帮助(H)”，并设置mnemnoic（助记的，用于通过键盘操作执行相应的功能）属性分别为“O”和“H”。 使用“从组件面板上添加”是另一种比较方便的添加组件的方式。 图标和快捷键的设置都可以采用直接双击设计区的相应位置来进行。对于图标，需要事先收集一些图标文件，然后在设置图标的过程中将其导入到项目中。对于快捷键，则采用直接键盘按键的方式进行设置。 工具栏 icon; horizontalTextPosition 状态栏设计 首先需要说明的是：在目前的JDK类库中，不像菜单栏和工具栏那样，它们都有现成的组件类可以使用，JDK并没有提供对状态栏进行封装的组件类，我们需要按照系统的具体要求自行设计状态栏。 一般说来，状态栏可以使用一个面板容器进行设计，将需要显示的状态信息以标签、文本字段、进度条、分割条等形式进行展示，然后将这些组件添加到一个面板容器中即可。 opaque用于设置组件不透明属性，默认值为false，这时为该组件设置的背景色是看不到的，需要将该属性设置为true，即组件是不透明的。BeforeP236]]></content>
      <categories>
        <category>Java</category>
        <category>JavaClass</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHPMVC开发实战]]></title>
    <url>%2Fpost%2F94d48dc.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156视图中数据循环输出：==========一、Volist标签==========Volist标签主要用于在模板中循环输出数据集或者多维数组。volist标签（循环输出数据）闭合非闭合标签属性name（必须）：要输出的数据模板变量 id（必须）：循环变量//临时变量 offset（可选）：要输出数据的offset，起始数据序列 length（可选）：输出数据的长度 key（可选）：循环的key变量，默认值为i mod（可选）：对key值取模，默认为2 empty（可选）：如果数据为空显示的字符串通常模型的select方法返回的结果是一个二维数组，可以直接使用volist标签进行输出。 在Action中首先对模版赋值：1. $User = M(&apos;User&apos;);2. $list = $User-&gt;select();3. $this-&gt;assign(&apos;list&apos;,$list);在模版定义如下，循环输出用户的编号和姓名：1. &lt;volistname=&quot;list&quot;id=&quot;vo&quot;&gt;2. &#123;$vo.id&#125;3. &#123;$vo.name&#125;4. &lt;/volist&gt;Volist标签的name属性表示模板赋值的变量名称，因此不可随意在模板文件中改变。id表示当前的循环变量，可以随意指定，但确保不要和name属性冲突，例如：1. &lt;volistname=&quot;list&quot;id=&quot;data&quot;&gt;2. &#123;$data.id&#125;3. &#123;$data.name&#125;4. &lt;/volist&gt;支持输出部分数据，例如输出其中的第5～15条记录1. &lt;volistname=&quot;list&quot;id=&quot;vo&quot;offset=&quot;5&quot;length=&apos;10&apos;&gt;2. &#123;$vo.name&#125;3. &lt;/volist&gt;输出偶数记录1. &lt;volistname=&quot;list&quot;id=&quot;vo&quot;mod=&quot;2&quot;&gt;2. &lt;eqname=&quot;mod&quot;value=&quot;1&quot;&gt;&#123;$vo.name&#125;&lt;/eq&gt;3. &lt;/volist&gt;Mod属性还用于控制一定记录的换行，例如：1. &lt;volistname=&quot;list&quot;id=&quot;vo&quot;mod=&quot;5&quot;&gt;2. &#123;$vo.name&#125;3. &lt;eqname=&quot;mod&quot;value=&quot;4&quot;&gt;&lt;br/&gt;&lt;/eq&gt;4. &lt;/volist&gt;为空的时候输出提示：1. &lt;volistname=&quot;list&quot;id=&quot;vo&quot;empty=&quot;暂时没有数据&quot;&gt;2. &#123;$vo.id&#125;|&#123;$vo.name&#125;3. &lt;/volist&gt;empty属性不支持直接传入html语法，但可以支持变量输出，例如：1. $this-&gt;assign(&apos;empty&apos;,&apos;&lt;span class=&quot;empty&quot;&gt;没有数据&lt;/span&gt;&apos;);2. $this-&gt;assign(&apos;list&apos;,$list);然后在模板中使用：1. &lt;volistname=&quot;list&quot;id=&quot;vo&quot;empty=&quot;$empty&quot;&gt;2. &#123;$vo.id&#125;|&#123;$vo.name&#125;3. &lt;/volist&gt;输出循环变量1. &lt;volistname=&quot;list&quot;id=&quot;vo&quot;key=&quot;k&quot;&gt;2. &#123;$k&#125;.&#123;$vo.name&#125;3. &lt;/volist&gt;如果没有指定key属性的话，默认使用循环变量i，例如：1. &lt;volistname=&quot;list&quot;id=&quot;vo&quot;&gt;2. &#123;$i&#125;.&#123;$vo.name&#125;3. &lt;/volist&gt;如果要输出数组的索引，可以直接使用key变量，和循环变量不同的是，这个key是由数据本身决定，而不是循环控制的，例如：1. &lt;volistname=&quot;list&quot;id=&quot;vo&quot;&gt;2. &#123;$key&#125;.&#123;$vo.name&#125;3. &lt;/volist&gt;从2.1版开始允许在模板中直接使用函数设定数据集，而不需要在控制器中给模板变量赋值传入数据集变量，如：1. &lt;volistname=&quot;:fun(&apos;arg&apos;)&quot;id=&quot;vo&quot;&gt;&#123;$vo.name&#125;&lt;/volist&gt;二、Foreach标签// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt;Foreach标签=========foreach标签也是用于循环输出foreach标签（循环输出数据）闭合非闭合标签属性name（必须）：要输出的数据模板变量 item（必须）：循环单元变量 key（可选）：循环的key变量，默认值为key示例：1. &lt;foreachname=&quot;list&quot;item=&quot;vo&quot;&gt;2. &#123;$vo.id&#125;3. &#123;$vo.name&#125;4. &lt;/foreach&gt;Foreach标签相对比volist标签简洁，没有volist标签那么多的功能。优势是可以对对象进行遍历输出，而volist标签通常是用于输出数组。三、For标签// &lt;!\[CDATA\[ $(function()&#123; $(window).resize(function()&#123; $(&apos;.book-content&apos;).css(&apos;min-height&apos;, $(window).height() - 130); &#125;).resize(); //表格隔行变色 $(&apos;table&apos;).TableColor(); //代码高亮 prettyPrint(); &#125;); //表格隔行变色插件 $.fn.TableColor = function()&#123; return $(this).each(function()&#123; if(this.nodeName.toLowerCase() != &apos;table&apos;) return; var self = $(this); self.find(&apos;tr&apos;).each(function(index) &#123; var \_this = $(this); if(index % 2 == 0)&#123; \_this.addClass(&apos;add&apos;); &#125; else &#123; \_this.addClass(&apos;even&apos;); &#125; \_this.hover( function()&#123;\_this.addClass(&apos;hover&apos;)&#125;, function()&#123;\_this.removeClass(&apos;hover&apos;)&#125; ); &#125;); &#125;); &#125; // \]\]&gt;For标签=====For标签用于实现for循环，格式为：for标签（循环输出数据）闭合非闭合标签属性start（必须）：循环变量开始值 end（必须）：循环变量结束值 name（可选）：循环变量名，默认值为i step（可选）：步进值，默认值为1 comparison（可选）：判断条件，默认为lt用法：1. &lt;forstart=&quot;开始值&quot;end=&quot;结束值&quot;comparison=&quot;&quot;step=&quot;步进值&quot;name=&quot;循环变量名&quot;&gt;2. &lt;/for&gt;开始值、结束值、步进值和循环变量都可以支持变量，开始值和结束值是必须，其他是可选。comparison 的默认值是lt;；name的默认值是i，步进值的默认值是1，举例如下：1. &lt;forstart=&quot;1&quot;end=&quot;100&quot;&gt;2. &#123;$i&#125;3. &lt;/for&gt;解析后的代码是1. for ($i=1;$i&lt;100;$i+=1)&#123;2. echo $i;3. &#125;]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>thinkphpALi</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[谨记、每日一句！HCC!!!]]></title>
    <url>%2Fpost%2F8a338a49.html</url>
    <content type="text"><![CDATA[zjh现在真的要给你一 一细数：6+1+10+200 = 217！！！全新思维，全新眼界。出发，fighting！ 提高自己的思想境界！勤学加苦练 年复一年！ Study and practice. Years of it. 学习真的是自己的事情！是由自己发自内心的去学习，去变成一个更好的人而奋斗的想法、执行力！为爱而战，为未来而战！加油！！！不要总是去听信“差不多”先生，或者“一次就弄好”女士。因为有些事情，真的是在你竭尽全力之后才会愿意说：无悔、顺其自然的！！！ RUN！往者不可谏来者犹可追！ 心态，choice！ 没有什么事到不了的。其实和高中刷题的作用类似、熟能生巧，多多练习 代码，加油！ 未过科目二。回头看来，发现我确实是有很多的失败之处！ No.1 小学曾经我的观念只是为了别人而活，太虚荣、总是为了攀比。&lt;所以有了我们 要绅士.要找准目标.是要为了自己的目标、梦想而战. 不知从什么时候起（或许就是在这样的教育、温室、期盼中）我变得迷失了自我。想要去为了gg为目标战斗、带头冲锋。 No.2 初中不知为何 我会去选择连续担任几乎全部的班委，不知为何我会顶住压力 不惜一切的为了0912这个班级去努力让它变得更好，又不知为何我会为了一个目标 郁闷、疯狂、抑郁、发了疯的往前冲！不知为何每个寒暑假 我都会得上一场病… 零分、数落、 No.3 高中忽然发现我有连续当了许多的班委职务。&lt;或者说我总是在许多的事情上 尽心尽力、为了他人着想，许许多多的事情都是敢为人先。从军训开始班规 每次的考试秩序 万有引力协会 直至最后。虽说我也有许许多多的不足、不会。但是那时 什么也敢去做，什么也敢于去努力争取，总是想要让一切变得更加美好。让大家遇见更好的自己！ 希望之星分班后 或者是被一种“差不多先生”的魔咒所萦…每每总是在说为了学习 当借口！不去努力 害怕出错 害怕失败！我说你有什么好值得骄傲的？？？说啥都不如大家的一些方面。别太虚荣，别太急进，匠心精神，不断积蓄自我。不怕失败，不太焦虑！精心努力，敢为人先！神兵直前，愈挫愈勇！ END这真的不是一句玩笑话！行动力 毅力。追逐吧！！！！！！男人不能说不能，但是要有取舍！ 11,15 AMH安装路径:/usr/local/apache-2.4/conf在咱们的AMH面板下面有一个ampathinfo，安装-开启-重启apache服务即可。 A函数、R函数（Control） Hash、Priority Queue (Heap) 堆（优先队）、sortDisjoint sets Graph 数据结构、英语、PS HTML、PHP\CSS申请域名一定要·自己学好编程开发好项目！！！HCCACAN 信仰 行动 自己 家人 3wmale！ 赏心悦目，只在aclear.]]></content>
      <categories>
        <category>页面</category>
      </categories>
      <tags>
        <tag>正能量</tag>
        <tag>少年初心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sort相关]]></title>
    <url>%2Fpost%2Fac5bea0.html</url>
    <content type="text"><![CDATA[——D.S.数据结构InWeissP296 1.Insertion 2.Bubble 3.Selection 4.QuickSort 5.BST中序遍历 6.HeapSort 7.MergeSort 8.ShellSort]]></content>
      <categories>
        <category>C++11.11</category>
        <category>D.S.</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java对话框静态界面设计]]></title>
    <url>%2Fpost%2F72263aa3.html</url>
    <content type="text"><![CDATA[JDialog： text 显示文本 toolTipText 提示文本（鼠标放到上面有提示） foreground 前景色 background 背景色 border 边框 font 字体 enabled 有效（可能会变成灰色） horizontalAlignment 水平对齐（CENTER..） verticalAlignment 垂直对齐 jTextAreaNotes： editable false（是否可以输入） font … foreground … lineWrap true（是否可以换行） wrapStyleWord true（是否单词整个下排） columns 65 rows 8 MVC模式： JList（列表框） JTable（二维表格）]]></content>
      <categories>
        <category>Java</category>
        <category>JavaClass</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java界面设计基础]]></title>
    <url>%2Fpost%2F9cd339a4.html</url>
    <content type="text"><![CDATA[1. JFrame窗体需要用户进行设置的属性不多，通常有： defaultCloseOperation：HIDE、EXIT_ON_CLOSE（默认设置）、DO_NOTHING、DISPOSE。若要在窗体关闭前实现用户的自定义操作，则需要设置为DO_NOTHING，但此时点击“关闭”按钮就不能关闭窗体了，需要自己添加相应的代码实现。 title：窗体的标题，默认没有。此处可设为自己喜欢的标题。 resizable：窗体尺寸是否可调整，默认为true。 2.Swing容器，比较常用的共同属性有：background、border，对于工具栏，还有floatable、orientation(方向）可以设置，而其他一些容器，则有一些特有的属性可以设置. 拆分窗格（JSplitPane）：一、在netbeans中新建拆分窗格，设置orientation属性为VERTICAL_SPLIT上下拆分。二、右击拆分窗格，选择从组件面板中添加，选择自己需要添加的组件，设置完表属性后继续添加第二个。三、设置拆分窗格属性：dividerlocation属性为上窗格的大小，dividerSize为中间的拆分条宽度，continuousLayout设置是否可以拖动拆分条，oneTouchExpandable设置拆分窗格是否可以展开或收起，resizeWeight按比例调整两个窗格的大小(主意先调整resizeWeight再把dividerLocation设为-1，否则无效) 2、创建Swing容器重点练习面板（JPanel）、标签化窗格（JTabbledPane）、拆分窗格（JSplitPane）、工具栏（JToolbar）等容器，分别将它们从“组件面板”中拖入JFrame窗体中，注意观察它们的样子、属性设置等内容。 对于Swing容器，比较常用的共同属性有：background、border，对于工具栏，还有floatable、orientation可以设置，而其他一些容器，则有一些特有的属性可以设置。 （1）JPanel面板是最纯洁的一种容器，她就相当于一张白纸，可以将若干相关的组件布局在一起，形成一个组合体。JPanel默认是没有边框的，有时为了更清晰地展示界面，就需要对其进行边框、颜色等属性设置。 （2）JTabbedPane标签化窗格是能够将若干个不同的容器按照标签化的方式组织在一起的一种容器，用户可以通过点击标签实现各容器之间的快速切换，能够节省大量显示空间。 （3）JSplitPane拆分窗格是一种能够将若干容器按照横向或纵向方式进行布局的容器，并且可以通过拖拽分割符实现容器尺寸的改变。 （4）JToolbar工具栏是一种将若干常用的功能组织在一起以方便用户进行操作的容器，通常结合文本和图标以更加形象直观的方式进行展示，一般位于菜单栏的下方，也可以设置为可浮动的形式。 3、创建Swing控件这一部分是使用最多的内容，它们一般都是用户直接进行操作的组件。这里重点练习标签（JLabel）、按钮（JButton）、复选框（JCheckBox）、单选按钮（JRadioButton）、按钮组（ButtonGroup）、组合框（JComboBox）、列表（JList）、文本字段（JTextField）、文本区域（JTextArea）、口令字段（JPasswordField）、分隔符（JSeparator）、表（JTable）等组件的使用，分别将它们从“组件面板”中拖入JFrame窗体中的某些容器中，注意观察它们的样子、属性设置等内容。 （1）JLabel标签通常用来表示静态的文本或图标内容，用于提示某些组件的作用等。 （2）JButton按钮是一种大量使用的控件，它会触发动作事件以实现若干功能和操作。 （3）JCheckBox复选框是一种展示选中与否的组件，方便进行某个状态的设置。 （4）JRadioButton单选按钮也是一种展示选中与否的组件，与复选框不同的是，它常用于将若干互斥的状态或功能组织在一起，并通过按钮组实现，也可以不使用按钮组而采用编写代码的方式进行控制。 （5）ButtonGroup按钮组是一个将若干单选按钮形成一个组的特殊组件，其特殊之处在于它在界面上是不可见的。通过选定若干单选按钮并将它们的“buttonGroup”属性设置为同一个按钮组对象而实现将这些单选按钮形成互斥的一个组。 （6）JComboxBox组合框是一种将若干条目组织在一起，通过下拉列表的形式进行选择，通常只显示其中的一个条目，占用界面空间少。 （7）JList列表框也是一种将若干条目组织在一起的组件，它可以同时显示出多个条目，并结合滚动条实现条目的滚动显示，并能够以图标方式进行更加直观的展示。 （8）JTextField文本字段用于输入单行文本。 （9）JTextArea文本区域用于输入多行文本，该组件自动与滚动窗格相结合实现文本的横向和纵向滚动。 （10）JPasswordField口令字段用于输入口令的内容，它以设定的回显字符对实际输入的内容进行显示屏蔽。 （11）JSeparator分割符是将界面中不同的区域进行横向或纵向分割的组件，它能够使界面的区域划分看上去更加清晰。 （12）JTable表格是一种比较复杂的组件，它能够以二维表格的形式展示数据，并可以进行大量的属性设置，支持与滚动窗格的自动结合。 设计下列方法： public static void fitJTableColumns(JTable table, double[] columnWidths) 功能：将表格table中各列的宽度按照columnWidths数组中的值进行设置。表格在默认情况下各列的宽度是相同的，使用该方法可以使各列的宽度不同，以适应表格中数据的实际情况。 4、创建Swing菜单主要包括菜单栏（JMenuBar）、菜单（JMenu）、菜单项（JMenuItem）、菜单项/复选框（JCheckBoxMenuItem）、菜单项/单选按钮（JRadioButtonMenuItem）、分隔符（JSeparator）、弹出式菜单（JPopupMenu）等的使用。 （1）JMenuBar菜单栏是将若干菜单组织在一起的组件，它通常位于标题栏的下方。 （2）JMenu菜单是将若干菜单项、分割符等组织在一起的组件。 （3）JMenuItem菜单项有两种展示方式：一种是级联菜单，可以引出下一级菜单；另一种是终端菜单项，与一个具体的功能相对应。 有趣的是：JMenuItem是JMenu的父类！ （4）JCheckBoxMenuItem复选框菜单项与JCheckBox的特点相同，只是展示方式不同。 （5）JRadioButtonMenuItem单选按钮菜单项与JRadioButton的特点相同，只是展示方式不同。 （6）JPopupMenu弹出式菜单是一种用途非常广泛的组件，它通常通过右键单击进行显示，对于用户执行相关的功能带来了极大的方便。弹出式菜单也是一种在界面上是不可见的组件。 （7）JSeparator分割符与控件中的分隔符相同，它们是同一种组件，用于将不同用途的菜单项进行分割显示。 JFrame用于一个系统的主界面，对一个系统而言，一般只有一个。而JDialog则用于系统操作过程中的需要与用户进行数据交互的各个对话框，一个系统中往往会有若干个对话框。 对话框分为“有模式”对话框和“无模式”对话框两种，对于“有模式”对话框，其执行方式是阻塞型的，即当这种对话框显示时，不能操作其依附的父窗体，只有将该对话框关闭后其父窗体才进行响应。而“无模式”对话框则是不阻塞的，当这类对话框显示时，其所依附的父窗体依然能够进行响应。至于选择哪一种对话框，要根据具体情况而定。基本的原则是：如果操作流程中需要从对话框中获取数据来进行后续的操作，则需要使用“有模式”对话框，否则将不能得到对话框中的数据；若无此需要，可使用“无模式”对话框。在实际应用中，通常“有模式”对话框比“无模式”对话框用的要多。 JFrame与JDialog的设计基本一致，此处可选择其一熟悉界面设计的一般步骤和基本方法。下面以JFrame为例进行说明。 （3）设置属性一般情况下，JFrame窗体需要用户进行设置的属性不多，通常有： defaultCloseOperation：HIDE、EXIT_ON_CLOSE（默认设置）、DO_NOTHING、DISPOSE。若要在窗体关闭前实现用户的自定义操作，则需要设置为DO_NOTHING，但此时点击“关闭”按钮就不能关闭窗体了，需要自己添加相应的代码实现。 title：窗体的标题，默认没有。此处可设为自己喜欢的标题。 resizable：窗体尺寸是否可调整，默认为true。 2、创建Swing容器重点练习面板（JPanel）、标签化窗格（JTabbledPane）、拆分窗格（JSplitPane）、工具栏（JToolbar）等容器，分别将它们从“组件面板”中拖入JFrame窗体中，注意观察它们的样子、属性设置等内容。 对于Swing容器，比较常用的共同属性有：background、border，对于工具栏，还有floatable、orientation可以设置，而其他一些容器，则有一些特有的属性可以设置。 （1）JPanel面板是最纯洁的一种容器，她就相当于一张白纸，可以将若干相关的组件布局在一起，形成一个组合体。JPanel默认是没有边框的，有时为了更清晰地展示界面，就需要对其进行边框、颜色等属性设置。 （2）JTabbedPane标签化窗格是能够将若干个不同的容器按照标签化的方式组织在一起的一种容器，用户可以通过点击标签实现各容器之间的快速切换，能够节省大量显示空间。 （3）JSplitPane拆分窗格是一种能够将若干容器按照横向或纵向方式进行布局的容器，并且可以通过拖拽分割符实现容器尺寸的改变。 （4）JToolbar工具栏是一种将若干常用的功能组织在一起以方便用户进行操作的容器，通常结合文本和图标以更加形象直观的方式进行展示，一般位于菜单栏的下方，也可以设置为可浮动的形式。 3、创建Swing控件这一部分是使用最多的内容，它们一般都是用户直接进行操作的组件。这里重点练习标签（JLabel）、按钮（JButton）、复选框（JCheckBox）、单选按钮（JRadioButton）、按钮组（ButtonGroup）、组合框（JComboBox）、列表（JList）、文本字段（JTextField）、文本区域（JTextArea）、口令字段（JPasswordField）、分隔符（JSeparator）、表（JTable）等组件的使用，分别将它们从“组件面板”中拖入JFrame窗体中的某些容器中，注意观察它们的样子、属性设置等内容。 （1）JLabel标签通常用来表示静态的文本或图标内容，用于提示某些组件的作用等。 （2）JButton按钮是一种大量使用的控件，它会触发动作事件以实现若干功能和操作。 （3）JCheckBox复选框是一种展示选中与否的组件，方便进行某个状态的设置。 （4）JRadioButton单选按钮也是一种展示选中与否的组件，与复选框不同的是，它常用于将若干互斥的状态或功能组织在一起，并通过按钮组实现，也可以不使用按钮组而采用编写代码的方式进行控制。 （5）ButtonGroup按钮组是一个将若干单选按钮形成一个组的特殊组件，其特殊之处在于它在界面上是不可见的。通过选定若干单选按钮并将它们的“buttonGroup”属性设置为同一个按钮组对象而实现将这些单选按钮形成互斥的一个组。 （6）JComboxBox组合框是一种将若干条目组织在一起，通过下拉列表的形式进行选择，通常只显示其中的一个条目，占用界面空间少。 （7）JList列表框也是一种将若干条目组织在一起的组件，它可以同时显示出多个条目，并结合滚动条实现条目的滚动显示，并能够以图标方式进行更加直观的展示。 （8）JTextField文本字段用于输入单行文本。 （9）JTextArea文本区域用于输入多行文本，该组件自动与滚动窗格相结合实现文本的横向和纵向滚动。 （10）JPasswordField口令字段用于输入口令的内容，它以设定的回显字符对实际输入的内容进行显示屏蔽。 （11）JSeparator分割符是将界面中不同的区域进行横向或纵向分割的组件，它能够使界面的区域划分看上去更加清晰。 （12）JTable表格是一种比较复杂的组件，它能够以二维表格的形式展示数据，并可以进行大量的属性设置，支持与滚动窗格的自动结合。 设计下列方法： public static void fitJTableColumns(JTable table, double[] columnWidths) 功能：将表格table中各列的宽度按照columnWidths数组中的值进行设置。表格在默认情况下各列的宽度是相同的，使用该方法可以使各列的宽度不同，以适应表格中数据的实际情况。 4、创建Swing菜单主要包括菜单栏（JMenuBar）、菜单（JMenu）、菜单项（JMenuItem）、菜单项/复选框（JCheckBoxMenuItem）、菜单项/单选按钮（JRadioButtonMenuItem）、分隔符（JSeparator）、弹出式菜单（JPopupMenu）等的使用。 （1）JMenuBar菜单栏是将若干菜单组织在一起的组件，它通常位于标题栏的下方。 （2）JMenu菜单是将若干菜单项、分割符等组织在一起的组件。 （3）JMenuItem菜单项有两种展示方式：一种是级联菜单，可以引出下一级菜单；另一种是终端菜单项，与一个具体的功能相对应。 有趣的是：JMenuItem是JMenu的父类！ （4）JCheckBoxMenuItem复选框菜单项与JCheckBox的特点相同，只是展示方式不同。 （5）JRadioButtonMenuItem单选按钮菜单项与JRadioButton的特点相同，只是展示方式不同。 （6）JPopupMenu弹出式菜单是一种用途非常广泛的组件，它通常通过右键单击进行显示，对于用户执行相关的功能带来了极大的方便。弹出式菜单也是一种在界面上是不可见的组件。 （7）JSeparator分割符与控件中的分隔符相同，它们是同一种组件，用于将不同用途的菜单项进行分割显示。]]></content>
      <categories>
        <category>Java</category>
        <category>JavaClass</category>
        <category>JavaPrimary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GoalofHTML_HCC]]></title>
    <url>%2Fpost%2Fe0a1dfb0.html</url>
    <content type="text"><![CDATA[HTML编程改变世界！ 其实呢，我是个工程师！ Day DayUP！~ HCC，每日一句！ include: 导入静态网页 import :导入 js、css type file &lt; taglib name = ‘My’ /&gt; HTML 简介HTML 实例&lt;!DOCTYPE html&gt; 菜鸟教程(runoob.com) 我的第一个标题 我的第一个段落。 尝试一下 » 实例解析DOCTYPE 声明了文档类型位于标签 与 描述了文档类型位于标签 与 为可视化网页内容位于标签 与 作为一个标题使用位于标签 与 作为一个段落显示 &lt;!DOCTYPE html&gt; 在HTML5中也是描述了文档类型。 什么是HTML?HTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言: HyperText Markup LanguageHTML 不是一种编程语言，而是一种标记语言标记语言是一套标记标签 (markup tag)HTML 使用标记标签来描述网页HTML 文档包含了HTML 标签及文本内容HTML文档也叫做 web 页面HTML 标签HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 HTML 标签通常是成对出现的，比如 和 标签对中的第一个标签是开始标签，第二个标签是结束标签开始和结束标签也被称为开放标签和闭合标签&lt;标签&gt;内容&lt;/标签&gt; HTML 元素“HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思.但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例:HTML 元素: 这是一个段落。 HTML版本 从初期的网络诞生后，已经出现了许多HTML版本: 版本 发布时间 HTML 1991 HTML+ 1993 HTML 2.0 1995 HTML 3.2 1997 HTML 4.01 1999 XHTML 1.0 2000 HTML5 2012 XHTML5 2013 声明 声明有助于浏览器中正确显示网页。 网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。 doctype 声明是不区分大小写的，以下方式均可： 通用声明 HTML5 HTML 4.01 XHTML 1.0 查看完整网页声明类型 DOCTYPE 参考手册。 中文编码 目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8。 HTML 基础- 4个实例 标题、段落、超链接、图片这是一个链接 图像的名称和尺寸是以属性的形式提供的。 ［］< img >标签 代表 图片，img标签的作用是向网页中插入一张图片，并不是将图片绘制到网页中。 src 属性：“插入”图片到网页中去。 alt 属性：值可以是一段文字，当图片由于各种原因无法显示时，alt属性的值就会被显示在网页上。 width/height 属性：设置图片的宽度／高度；不适合用于图片，可用于纯色图的拉伸；单位可以是px，也可以是％，单位为％时是指占窗体宽高的百分比大小。 image 推荐< img >标签中加上“/”来关闭标签。 推荐使用PNG图片格式 当图片无法正确加载时会出现图片错误的图标： 可能导致图片错误的原因： 1. 路径名写错了 2. 引用的图片被删除了 3. 网络问题 像素：显示内容基本长度单位 pixel。 位图：图片中每一个像素都由4个数字（argb）组成（0-255），原则上不能拉伸因为会导致失真。 a：透明度；r：红色；g：绿色；b：蓝色 矢量图：可以随意拉伸。 通过图片的拉伸可以将一张很小的纯色图片冒充为一张大图，节约资源的加载。 绝对路径：使用图片在硬盘上的绝对位置来访问图片，通常是从根目录开始，向下一个目录一个目录的寻找；在开发网页的过程中，一般不会使用绝对路径 相对路径：指的是相对于当前网页的路径。 相对路径的起点就是 src的值就是路径。 “..” 在路径中代表当前网页所在目录的上一级目录 “.” 在路径中代表当前网页所在目录 HTML 元素语法 HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content） 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性 HTML 空元素 没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 就是没有关闭标签的空元素（ 标签定义换行）。 在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。 在开始标签中添加斜杠，比如 ，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。 即使 在所有浏览器中都是有效的，但使用 其实是更长远的保障。 不要忘记结束标签 即使您忘记了使用结束标签，大多数浏览器也会正确地显示 HTML： 这是一个段落 这是一个段落 以上实例在浏览器中也能正常显示，因为关闭标签是可选的。 但不要依赖这种做法。忘记使用结束标签会产生不可预料的结果或错误。 HTML 提示：使用小写标签 HTML 标签对大小写不敏感： 等同于 。许多网站都使用大写的 HTML 标签。 W3CSchool 使用的是小写标签，因为万维网联盟（W3C）在 HTML 4 中推荐使用小写，而在未来 (X)HTML 版本中强制使用小写。//以上注意 HTML 属性 属性实例 HTML 链接由 标签定义。链接的地址在 href 属性中指定： 实例 这是一个链接 HTML 属性常用引用属性值 属性值应该始终被包括在引号内。 双引号是最常用的，不过使用单引号也没有问题。 提示: 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：name='John "ShotGun" Nelson' http://www.runoob.com/tags/ref-standardattributes.html相关在线参考手册 HTML标题 标题很重要 请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成粗体或大号的文本而使用标题。 搜索引擎使用标题为您的网页的结构和内容编制索引。 因为用户可以通过标题来快速浏览您的网页，所以用标题来呈现文档结构是很重要的。 应该将 h1 用作主标题（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。 定义 HTML 文档 定义文档的主体 - 定义 HTML 标题 定义水平线 定义注释 HTML 段落 HTML 折行 如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 标签： 实例 这个段落演示了分行的效果 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。 HTML 输出- 使用提醒 我们无法确定 HTML 被显示的确切效果。屏幕的大小，以及对窗口的调整都可能导致不同的结果。 对于 HTML，您无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。 当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。 或者 HTML 文本格式化 通常标签 替换加粗标签 来使用, 替换 标签使用。 然而，这些标签的含义是不同的： 与 定义粗体或斜体文本。 或者 意味着你要呈现的文本是重要的，所以要突出显示。现今所有主要浏览器都能渲染各种效果的字体。不过，未来浏览器可能会支持更好的渲染效果。 Italic斜体 提示： 各种浏览器下accesskey快捷键的使用方法： IE浏览器 按住Alt键，点击accesskey定义的快捷键(焦点将移动到链接)，再按回车. FireFox浏览器 按住Alt+Shift键，点击accesskey定义的快捷键. Chrome浏览器 按住Alt键，点击accesskey定义的快捷键. Opera浏览器 按住Shift键，点击esc，出现本页定义的accesskey快捷键列表可供选择. Safari浏览器 按住Alt键，点击accesskey定义的快捷键. HTML 4.01 与 HTML5之间的差异 在 HTML5 中, accesskey 属性可用于任何 HTML 元素 (它会 验证任何HTML元素。但不一定是有用)。 在 HTML 4.01 中, accesskey 属性可使用于: , , , , , , 和 。 HTML 文本格式化标签 标签 描述 定义粗体文本 定义着重文字 定义斜体字 定义小号字 定义加重语气 定义下标字 定义上标字 定义插入字 定义删除字 HTML "计算机输出" 标签 标签 描述 定义计算机代码 定义键盘码 定义计算机代码样本 定义变量 定义预格式文本 HTML 引文, 引用, 及标签定义 标签 描述 定义缩写 定义地址 定义文字方向该段落文字从右到左显示。 定义长的引用 标签定义摘自另一个源的块引用。 浏览器通常会对 元素进行缩进。 如果标记是不需要段落分隔的短引用，请使用 在 HTML 4.01 中， 标签定义一段长引用。 在 HTML5 中， 标签定义摘自另一个源的块引用。 定义短的引用语 标签定义一个短的引用。 浏览器经常会在这种引用的周围插入引号。 定义引用、引证 标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。 注释：人名不属于作品的标题。 HTML 4.01 与 HTML5之间的差异 在 HTML5 中， 标签定义作品的标题。 在 HTML 4.01 中， 标签定义一个引用。 定义一个定义项目。定义项目 Coffee Tea Milk Coffee Tea Milk 显示: Coffee Tea Milk Coffee Tea Milk HTML 链接 HTML 使用超级链接与网络上的另一个文档相连。几乎可以在所有的网页中找到链接。点击链接可以从一张页面跳转到另一张页面。 HTML 链接 - target 属性 使用 target 属性，你可以定义被链接的文档在何处显示。 下面的这行会在新窗口打开文档： 实例 访问菜鸟教程! HTML 链接- id 属性 id属性可用于创建在一个HTML文档书签标记。 提示: 书签是不以任何特殊的方式显示，在HTML文档中是不显示的，所以对于读者来说是隐藏的。 实例 在HTML文档中插入ID: 有用的提示部分 在HTML文档中创建一个链接到"有用的提示部分(id="tips"）"： 访问有用的提示部分 或者，从另一个页面创建一个链接到"有用的提示部分(id="tips"）"： 访问有用的提示部分 ！实例： 图片链接 如何使用图片链接。 在当前页面链接到指定位置 如何使用书签 跳出框架 本例演示如何跳出框架，假如你的页面被固定在框架之内。 target="_top" 创建电子邮件链接 本例演示如何如何链接到一个邮件。（本例在安装邮件客户端程序后才能工作。） 建电子邮件链接 2 本例演示更加复杂的邮件链接。 基本的注意事项 - 有用的提示 注释： 请始终将正斜杠添加到子文件夹。假如这样书写链接：href="http://www.runoob.com/html"，就会向服务器产生两次 HTTP 请求。这是因为服务器会添加正斜杠到这个地址，然后创建一个新的请求，就像这样：href="http://www.runoob.com/html/"。 HTML头部 rel与rev属性相同,它们都是属于LinkTypes属性. rel 属性 -- rel属性,描述了当前页面与href所指定文档的关系, rel是relationship的英文缩写. rev 属性 -- rev属性,描述了href所指定文档与当前页面的关系, rel是reverse link的英文缩写. rel属性通常出现在a,link标签中。 １、rel是什么 rel属性通常用来描述链接之间的关系，也就是说目的地址(href) 跟源（站点）之间的关系。rel属性通常出现在a,link标签中。rel是relationship的英文缩写。 ２、rel的属性值有哪些 alternate -- 定义交替出现的链接 appendix -- 定义文档的附加信息 bookmark -- 书签 chapter -- 当前文档的章节 contents copyright -- 当前文档的版权 glossary -- 词汇 help -- 链接帮助信息 index -- 当前文档的索引 next -- 记录文档的下一页.(浏览器可以提前加载此页) nofollow -- 不被用于计算PageRank prev -- 记录文档的上一页.(定义浏览器的后退键) section -- 作为文档的一部分 start -- 通知搜索引擎,文档的开始 stylesheet -- 定义一个外部加载的样式表 subsection -- 作为文档的一小部分 me--告诉搜索引擎，这是自己的内容 home--告诉搜索引擎，这是返回首页 license--描述版权 friend--这是朋友的 tag--标签 same--相同的链接 其它还有更细的。我们这里先说这么多。另外，nofollow非w3标准定义的rel属性值,此值为Google,MSN等搜索引擎定义。 nofollow标签是一个用于指示某些搜索引擎的超链接，不应影响搜索引擎的索引中的链接目标的排名的HTML属性值。目的是尽量 减少垃圾链接对搜 索引擎的影响。Google就是支持这个标签属性。但并不是所有的搜索引擎都支持这个标签。目前支持此标签的 搜索引擎有谷歌、搜搜、有道、百度。不支持此 标签的搜索引擎有雅虎和搜狗。现在好多blog系统、论坛系统、dig系统是垃圾 链接大量存在的地方，所以这些系统的评论或发帖回帖代码里都自动添加了 nofollow标签，目的就是不让pr值传递给某些垃圾网站的链接。 ３、rel属性的好处 事实上，这个属性是一种html里面定义基于链接关系的微格式。它的好处是语义明确。这就是这些微格式带给我们最首要的好处。 它完全明白的告诉搜索引擎，这是什么，那是什么。也让访者知道，这些内容和博主自己的关系。有一种说法，如果你要想搜索引擎对 你好，你首先得把自己当作搜索引擎。从这个意义上来说，这个微格式，还是有一些存在的好处。 以前，我说见过一位博客朋友，硬是用这个属性，将自己的友情链接整出Ｎ种关系来～后来，他又取消了那些关系，统一成为一样的。我觉得，对于友情链接，不必要用这个属性。但是，对于站点上的其它链接，如果适当的用这个属性进行优化，效果应该还是有的。 原创文章请注明转载自princess博客，本文地址：http://www.seolhy.com/post/7.html HTML 元素 元素包含了所有的头部标签元素。在 元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。 可以添加在头部区域的元素标签为: , , , , , , and . HTML 元素 标签定义了不同文档的标题。 在 HTML/XHTML 文档中是必须的。 元素: 定义了浏览器工具栏的标题 当网页添加到收藏夹时，显示在收藏夹中的标题 显示在搜索引擎结果页面的标题 HTML 元素 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接: HTML 元素 标签定义了文档与外部资源之间的关系。 标签通常用于链接到样式表: HTML 元素 标签定义了HTML文档的样式文件引用地址. 在 元素中你需要指定样式文件来渲染HTML文档: body {background-color:yellow} p {color:blue} HTML 元素 meta标签描述了一些基本的元数据。 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。 META元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。 元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。 一般放置于 区域 标签- 使用实例 为搜索引擎定义关键词: 为网页定义描述内容: 定义网页作者: 每30秒中刷新当前页面: HTML 元素 标签用于加载脚本文件，如： JavaScript。 元素在以下章节会详细描述。 菜鸟教程(runoob.com) - 注意这里我们设置了图片的相对地址。能正常显示是因为我们在 head 部分设置了 base 标签， 该标签指定了页面上所有链接的默认 URL，所以该图片的访问地址为 "http://www.runoob.com/images/logo.png" 菜鸟教程 - 注意这个链接会在新窗口打开，即便它没有 target="_blank" 属性。 因为在 base 标签里我们已经设置了 target 属性的值为 "_blank"。 src="logo.png" //注意这里并么有添加斜杠!!! /logo.png src = "http://121.42.176.191/thinkphp/Uploads/images/male.jpg" 使用绝对路径就没有什么问题！ HTML 样式- CSS 如何使用CSS CSS 是在 HTML 4 开始使用的,是为了更好的渲染HTML元素而引入的. CSS 可以通过以下方式添加到HTML中: 1·内联样式- 在HTML元素中使用"style" 属性 2·内部样式表 -在HTML文档头部 区域使用 元素 来包含CSS 3·外部引用 - 使用外部 CSS 文件 最好的方式是通过外部引用CSS文件. 内联样式 当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。 This is a paragraph. HTML样式实例 - 背景颜色 背景色属性（background-color）定义一个元素的背景颜色： 实例 这是一个标题 这是一个段落。 尝试一下 » 早期背景色属性（background-color）是使用 bgcolor 属性定义。 尝试一下: 旧版HTML来设置背景方式 HTML 样式实例 - 字体, 字体颜色 ，字体大小 我们可以使用font-family（字体），color（颜色），和font-size（字体大小）属性来定义字体的样式: 实例 一个标题 一个段落。 尝试一下 » 现在通常使用font-family（字体），color（颜色），和font-size（字体大小）属性来定义文本样式，而不是使用标签。 HTML 样式实例 - 文本对齐方式 使用 text-align（文字对齐）属性指定文本的水平与垂直对齐方式： 实例 居中对齐的标题 这是一个段落。 文本对齐属性 text-align取代了旧标签 。 访问 runoob.com!访问连接去掉下划线！ 内部样式表 当单个文件需要特别样式时，就可以使用内部样式表。你可以在 部分通过 标签定义内部样式表: body {background-color:yellow;} p {color:blue;} 外部样式表 当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。 HTML 样式标签 标签 描述 定义文本样式 定义资源引用地址 已弃用的标签和属性 在HTML 4, 原来支持定义HTML元素样式的标签和属性已被弃用。这些标签将不支持新版本的HTML标签。 不建议使用的标签有: , , 不建议使用的属性: color 和 bgcolor. HTML 图像 是空标签所以只能有属性来定义img 排列图片 本例演示如何在文字中排列图像。 浮动图像 本例演示如何使图片浮动至段落的左边或右边。 设置图像链接 本例演示如何将图像作为一个链接使用。 创建图像映射 本例显示如何创建带有可供点击区域的图像地图。其中的每个区域都是一个超级链接。 HTML 图像标签 标签 描述 定义图像 定义图像地图 定义图像地图中的可点击区域 一个带图片的段落，图片浮动在这个文本的左边。 一个带图片的段落，图片浮动在这个文本的右边。 注意: 在这里我们使用了 CSS "float" 属性，在HTML 4中 align 属性已废弃，HTML5 已不支持该属性，可以使用 CSS 代替。 点击太阳或其他行星，注意变化： HTML 表格HTML 表格表格由 标签来定义。每个表格均有若干行（由 标签定义），每行被分割为若干单元格（由 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 表格实例 row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2 在浏览器显示如下：: row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2 HTML 表格和边框属性 如果不定义边框属性，表格将不显示边框。有时这很有用，但是大多数时候，我们希望显示边框。 使用边框属性来显示一个带有边框的表格： Row 1, cell 1 Row 1, cell 2 HTML 表格表头表格的表头使用 标签进行定义。大多数浏览器会把表头显示为粗体居中的文本： Header 1 Header 2&lt;/tr&gt; row 1, cell 1 row 1, cell 2&lt;/tr&gt; row 2, cell 1 row 2, cell 2&lt;/tr&gt;&lt;/table&gt;在浏览器显示如下： Header 1 Header 2row 1, cell 1 row 1, cell 2row 2, cell 1 row 2, cell 2—1：跨行或跨列的表格单元格。Telephone1&lt;/tr&gt; Telephone2—2.单元格间距(Cell spacing)本例演示如何使用 Cell spacing 增加单元格之间的距离。—3.单元格跨行,单元格间距，单元格边距单元格边距(Cell padding)本例演示如何使用 Cell padding 来创建单元格内容与其边框之间的空白。 HTML 列表HTML无序列表无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。无序列表使用 标签 Coffee Milk&lt;/ul&gt;浏览器显示如下： CoffeeMilkHTML 有序列表同样，有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于 标签。每个列表项始于 标签。列表项项使用数字来标记。 Coffee Milk&lt;/ol&gt;浏览器中显示如下： CoffeeMilkHTML 自定义列表自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 标签开始。每个自定义列表项以 开始。每个自定义列表项的定义以 开始。 Coffee - black hot drink Milk - white cold drink&lt;/dl&gt;浏览器显示如下： Coffee black hot drinkMilk white cold drink注意事项 - 有用提示提示: 列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。 标签定义及使用说明 标签定义 HTML 文档中的一个分隔区块或者一个区域部分。 标签常用于组合块级元素，以便通过 CSS 来对这些元素进行格式化。 提示和注释提示： 元素经常与 CSS 一起使用，用来布局网页。注释：默认情况下，浏览器通常会在 元素前后放置一个换行符。然而，您可以通过使用 CSS 改变这种情况。 HTML 4.01 与 HTML5之间的差异HTML5 中不支持 align 属性。在 HTML 4.01 中，align 属性 已废弃。 属性属性 值 描述align leftrightcenterjustify HTML5 不支持。HTML 4.01 已废弃。 规定 元素中的内容的对齐方式。 全局属性 标签支持 HTML 的全局属性。 事件属性 标签支持 HTML 的事件属性。 标签定义及使用说明 用于对文档中的行内元素进行组合。 标签没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化。如果不对 应用样式，那么 元素中的文本与其他文本不会任何视觉上的差异。 标签提供了一种将文本的一部分或者文档的一部分独立出来的方式。 提示和注释提示：被 元素包含的文本，您可以使用 CSS 对它定义样式，或者使用 JavaScript 对它进行操作。 HTML 4.01 与 HTML5之间的差异NONE. 全局属性 标签支持 HTML 的全局属性。 事件属性 标签支持 HTML 的事件属性。 HTML 布局网站布局大多数网站会把内容安排到多个列中（就像杂志或报纸那样）。大多数网站可以使用 或者 元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。 虽然我们可以使用HTML table标签来设计出漂亮的布局，但是table标签是不建议作为布局工具使用的 - 表格不是布局工具。 1.使用 元素div 元素是用于分组 HTML 元素的块级元素。2.HTML 标签是创建布局的一种简单的方式。大多数站点可以使用 或者 元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。即使可以使用 HTML 表格来创建漂亮的布局，但设计表格的目的是呈现表格化数据 - 表格不是布局工具！下面的例子使用三行两列的表格 - 第一和最后一行使用 colspan 属性来横跨两列：HTML 布局 - 有用的提示Tip: 使用 CSS 最大的好处是，如果把 CSS 代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局。如需学习更多有关 CSS 的知识，请访问我们的CSS 教程。Tip: 由于创建高级的布局非常耗时，使用模板是一个快速的选项。通过搜索引擎可以找到很多免费的网站模板（您可以使用这些预先构建好的网站布局，并优化它们）。 HTML 表单和输入HTML 表单用于搜集不同类型的用户输入。 HTML 表单表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签 来设置: . input 元素 . 注意属性有：1. 定义和用法target 属性规定在何处打开 action URL。 兼容性注释在 HTML 4.01 中，不赞成使用 form 元素的 target 属性；在 XHTML 1.0 Strict DTD 中，不支持该属性。 语法 属性值值 描述_blank 在新窗口中打开。_self 默认。在相同的框架中打开。_parent 在父框架集中打开。_top 在整个窗口中打开。framename 在指定的框架中打开。2. 定义和用法name 属性规定表单的名称。form 元素的 name 属性提供了一种在脚本中引用表单的方法。 语法 属性值值 描述name 表单的名称。3. 定义和用法method 属性规定如何发送表单数据（表单数据发送到 action 属性所规定的页面）。表单数据可以作为 URL 变量（method=”get”）或者 HTTP post （method=”post”）的方式来发送。 method 属性浏览器使用 method 属性设置的方法将表单中的数据传送给服务器进行处理。共有两种方法：POST 方法和 GET 方法。如果采用 POST 方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器。在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数。另一种情况是采用 GET 方法，这时浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔。一般浏览器通过上述任何一种方法都可以传输表单信息，而有些服务器只接受其中一种方法提供的数据。可以在 标签的 method （方法）属性中指明表单处理服务器要用方法来处理数据，使 POST 还是 GET。 POST 还是 GET？如果表单处理服务器既支持 POST 方法又支持 GET 方法，那么你该选择哪种方法呢？下面是有关这方面的一些规律： 如果希望获得最佳表单传输性能，可以采用 GET 方法发送只有少数简短字段的小表单。一些服务器操作系统在处理可以立即传递给应用程序的命令行参数时，会限制其数目和长度，在这种情况下，对那些有许多字段或是很长的文本域的表单来说，就应该采用 POST 方法来发送。如果你在编写服务器端的表单处理应用程序方面经验不足，应该选择 GET 方法。如果采用 POST 方法，就要在读取和解码方法做些额外的工作，也许这并不很难，但是也许你不太愿意去处理这些问题。如果安全性是个问题，那么我们建议选用 POST 方法。GET 方法将表单参数直接放在应用程序的 URL 中，这样网络窥探者可以很轻松地捕获它们，还可以从服务器的日志文件中进行摘录。如果参数中包含了信用卡帐号这样的敏感信息，就会在不知不觉中危及用户的安全。而 POST 应用程序就没有安全方面的漏洞，在将参数作为单独的事务传输给服务器进行处理时，至少还可以采用加密的方法。如果想在表单之外调用服务器端的应用程序，而且包括向其传递参数的过程，就要采用 GET 方法，因为该方法允许把表单这样的参数包括进来作为 URL 的一部分。而另一方面，使用 POST 样式的应用程序却希望在 URL 后还能有一个来自浏览器额外的传输过程，其中传输的内容不能作为传统 标签的内容。明确传递参数前面的一些建议也可以作为选择此种方式的一定解释。假设你有一个很简单的表单，其中只包含 x 和 y 这两个参数。在对这些元素的值进行编码时，它们的形式如下所示： x=28&amp;y=66如果表单采用了 method=GET，那么用来引用服务器端应用程序的 URL 将如下所示： http://www.example.com/example/program?x=28&amp;y=66在任何时候我们都可以创建一个传统的 标签，用它在调用带有所需参数值的表单，其形式如下所示： 唯一的问题是，分隔参数所用的 &amp; 符号也是字符实体中的插入符号。如果在 标签的 href 属性中放入一个 &amp; 符号，浏览器就会将其后面的字符替换成相应的字符实体。为了防止出现这种情况，我们必须用它的实体对等物来替换 &amp; 符号，也就是用 “&#38;” 或 “&amp;” 来替换。替换之后，上面的那个引用服务器应用程序的非表单示例将如下所示： 由于这样还是不能在 URL 中使用 &amp; 符号，并且有可能在将来带来混乱，因此我们鼓励服务器设置最后也能够接受用分号作为参数分隔符。您也可以看看自己的服务器文档，了解服务器是否支持这种功能。 语法 属性值值 描述_blank 在新窗口中打开。_self 默认。在相同的框架中打开。_parent 在父框架集中打开。_top 在整个窗口中打开。framename 在指定的框架中打开。4. 定义和用法必需的 action 属性规定当提交表单时，向何处发送表单数据。 语法 属性值值 描述URL 向何处发送表单数据。可能的值：绝对 URL - 指向其他站点（比如 src=”www.example.com/example.htm”）相对 URL - 指向站点内的文件（比如 src=”example.htm”） HTML 表单 - 输入元素多数情况下被用到的表单标签是输入标签（）。输入类型是由类型属性（type）定义的。大多数经常被用到的输入类型如下： 1文本域（Text Fields）文本域通过 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 First name: Last name: 浏览器显示如下： First name:Last name:注意:表单本身并不可见。同时，在大多数浏览器中，文本域的缺省宽度是20个字符。 2密码字段密码字段通过标签 来定义: 3单选按钮（Radio Buttons） 标签定义了表单单选框选项 Male Female&lt;/form&gt;4复选框（Checkboxes） 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。 I have a bike I have a car&lt;/form&gt;5提交按钮(Submit Button) 定义了提交按钮.当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。: Username: &lt;/form&gt;假如您在上面的文本框内键入几个字母，然后点击确认按钮，那么输入数据会传送到 “html_form_action.php” 的页面。该页面将显示出输入的结果。 更多实例单选按钮(Radio buttons)本例演示如何在 HTML 中创建单选按钮。复选框(Checkboxes)本例演示如何在 HTML 页中创建复选框。用户可以选中或取消选取复选框。简单的下拉列表本例演示如何在 HTML 页面中创建简单的下拉列表框。下拉列表框是一个可选列表。预选下拉列表本例演示如何创建一个简单的带有预选值的下拉列表。文本域(Textarea)本例演示如何创建文本域（多行文本输入控件）。用户可在文本域中写入文本。可写入字符的字数不受限制。创建按钮本例演示如何创建按钮。你可以对按钮上的文字进行自定义。 表单实例带边框的表单本例演示如何在数据周围绘制一个带标题的框。带有输入框和确认按钮的表单本例演示如何向页面添加表单。此表单包含两个输入框和一个确认按钮。带有复选框的表单此表单包含两个复选框和一个确认按钮。带有单选按钮的表单此表单包含两个单选框和一个确认按钮。从表单发送电子邮件此例演示如何从表单发送电子邮件。 HTML 表单标签New : HTML5新标签 标签 描述 定义供用户输入的表单 定义输入域 定义文本域 (一个多行的输入控件) 定义了 元素的标签，一般为输入标题 定义了一组相关的表单元素，并使用外框包含起来 定义了 元素的标题 定义了下拉选项列表 定义选项组 定义下拉列表中的选项 定义一个点击按钮 New 指定一个预先定义的输入控件选项列表 New 定义了表单的密钥对生成器字段 New 定义一个计算结果 HTML 框架通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。 Iframe - 设置高度与宽度height 和 width 属性用来定义iframe标签的高度与宽度。属性默认以像素为单位, 但是你可以指定其按比例显示 (如：”80%”). Iframe - 移除边框frameborder 属性用于定义iframe表示是否显示边框。设置属性值为 “0” 移除iframe的边框: 使用iframe来显示目录链接页面iframe可以显示一个目标链接的页面目标链接的属性必须使用iframe的属性，如下实例: RUNOOB.COM注意： 因为 a 标签的 target 属性是名为 iframe_a 的 iframe 框架，所以在点击链接时页面会显示在 iframe框架中! HTML 脚本JavaScript 使 HTML 页面具有更强的动态和交互性。 HTML 标签 标签用于定义客户端脚本，比如 JavaScript。 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件。JavaScript 最常用于图片操作、表单验证以及内容动态更新。下面的脚本会向浏览器输出”Hello World!”： 实例 document.write("Hello World!"); 尝试一下 » Tip: 学习更多关于Javascript教程，请查看JavaScript 教程! HTML 标签 标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时。 元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。只有在浏览器不支持脚本或者禁用脚本时，才会显示 元素中的内容： 实例 document.write("Hello World!") 抱歉，你的浏览器不支持 JavaScript!尝试一下 » JavaScript体验(来自本站javascript教程)JavaScript实例代码: JavaScript可以直接在HTML输出:document.write(“这是一个段落。“);尝试一下 » JavaScript事件响应: 点我！尝试一下 » JavaScript处理 HTML 样式:document.getElementById(“demo”).style.color=”#ff0000”;尝试一下 » HTML 脚本标签标签 描述 定义了客户端脚本 定义了不支持脚本浏览器输出的文本 HTML 字符实体HTML 中的预留字符必须被替换为字符实体。 一些在键盘上找不到的字符也可以使用字符实体来替换。 HTML 实体在 HTML 中，某些字符是预留的。在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 字符实体类似这样： &amp;entity_name;或&amp;#entity_number;如需显示小于号，我们必须这样写：&lt; 或 &#60; 或 &#060;提示： 使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。 不间断空格(Non-breaking Space)HTML 中的常用字符实体是不间断空格(&nbsp;)。浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用 &nbsp; 字符实体。 结合音标符发音符号是加到字母上的一个”glyph(字形)”。一些变音符号, 如 尖音符 ( ̀) 和 抑音符 ( ́) 。变音符号可以出现字母的上面和下面，或者字母里面，或者两个字母间。变音符号可以与字母、数字字符的组合来使用。以下是一些实例: 音标符 字符 Construct 输出结果 ̀ a a&#768; à ́ a a&#769; á̂ a a&#770; â ̃ a a&#771; ã ̀ O O&#768; Ò ́ O O&#769; Ó̂ O O&#770; Ô ̃ O O&#771; ÕHTML字符实体 实体名称对大小写敏感！显示结果 描述 实体名称 实体编号 空格 &nbsp; &#160;&lt; 小于号 &lt; &#60; 大于号 &gt; &#62;&amp; 和号 &amp; &#38;“ 引号 &quot; &#34;‘ 撇号 &apos; (IE不支持) &#39;￠ 分 &cent; &#162;£ 镑 &pound; &#163;¥ 日元 &yen; &#165;€ 欧元 &euro; &#8364;§ 小节 &sect; &#167;© 版权 &copy; &#169;® 注册商标 &reg; &#174;™ 商标 &trade; &#8482;× 乘号 &times; &#215;÷ 除号 &divide; &#247;查看完整的HTML实体：请点击 HTML 实体参考手册。 HTML 统一资源定位器(Uniform Resource Locators)URL 是一个网页地址。URL可以由字母组成，如”runoob.com”，或互联网协议（IP）地址： 192.68.20.50。大多数人进入网站使用网站域名来访问，因为 名字比数字更容易记住。 URL - 统一资源定位器Web浏览器通过URL从Web服务器请求页面。当您点击 HTML 页面中的某个链接时，对应的 标签指向万维网上的一个地址。一个统一资源定位器(URL) 用于定位万维网上的文档。一个网页地址实例: http://www.runoob.com/html/html-tutorial.html 语法规则: scheme://host.domain:port/path/filename说明: scheme - 定义因特网服务的类型。最常见的类型是 httphost - 定义域主机（http 的默认主机是 www）domain - 定义因特网域名，比如 runoob.com:port - 定义主机上的端口号（http 的默认端口号是 80）path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。filename - 定义文档/资源的名称常见的 URL Scheme以下是一些URL scheme： Scheme 访问 用于…http 超文本传输协议 以 http:// 开头的普通网页。不加密。https 安全超文本传输协议 安全网页，加密所有信息交换。ftp 文件传输协议 用于将文件下载或上传至网站。file 您计算机上的文件。 URL 字符编码URL 只能使用 ASCII 字符集.来通过因特网进行发送。由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。URL 不能包含空格。URL 编码通常使用 + 来替换空格。 在线实例如果您点击下面的”提交”按钮，浏览器会在发送输入之前对其进行 URL 编码。服务器上的页面会显示出接收到的输入。 试着输入一些字符，然后再次点击提交按钮。 URL 编码实例字符 URL 编码€ %80£ %A3© %A9® %AEÀ %C0Á %C1Â %C2Ã %C3Ä %C4Å %C5如需完整的 URL 编码参考，请访问 URL 编码参考手册。 HTML 颜色HTML 颜色由红色、绿色、蓝色混合而成。 颜色值HTML 颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。这个表格给出了由三种颜色混合而成的具体效果： 颜色值颜色(Color) 颜色十六进制(Color HEX) 颜色RGB(Color RGB) #000000 rgb(0,0,0) #FF0000 rgb(255,0,0) #00FF00 rgb(0,255,0) #0000FF rgb(0,0,255) #FFFF00 rgb(255,255,0) #00FFFF rgb(0,255,255) #FF00FF rgb(255,0,255) #C0C0C0 rgb(192,192,192) #FFFFFF rgb(255,255,255) 尝试一下 » 1600万种不同颜色三种颜色 红，绿，蓝的组合从0到255，一共有1600万种不同颜色(256 x 256 x 256)。在下面的颜色表中你会看到不同的结果，从0到255的红色，同时设置绿色和蓝色的值为0,随着红色的值变化，不同的值都显示了不同的颜色。 Red Light Color HEX Color RGB #000000 rgb(0,0,0) #080000 rgb(8,0,0) #100000 rgb(16,0,0) #180000 rgb(24,0,0) #200000 rgb(32,0,0) #280000 rgb(40,0,0) #300000 rgb(48,0,0) #380000 rgb(56,0,0) #400000 rgb(64,0,0) #480000 rgb(72,0,0) #500000 rgb(80,0,0) #580000 rgb(88,0,0) #600000 rgb(96,0,0) #680000 rgb(104,0,0) #700000 rgb(112,0,0) #780000 rgb(120,0,0) #800000 rgb(128,0,0) #880000 rgb(136,0,0) #900000 rgb(144,0,0) #980000 rgb(152,0,0) #A00000 rgb(160,0,0) #A80000 rgb(168,0,0) #B00000 rgb(176,0,0) #B80000 rgb(184,0,0) #C00000 rgb(192,0,0) #C80000 rgb(200,0,0) #D00000 rgb(208,0,0) #D80000 rgb(216,0,0) #E00000 rgb(224,0,0) #E80000 rgb(232,0,0) #F00000 rgb(240,0,0) #F80000 rgb(248,0,0) #FF0000 rgb(255,0,0) 灰暗色调以下展示了灰色到黑色的渐变 Gray Shades Color HEX Color RGB #000000 rgb(0,0,0) #080808 rgb(8,8,8) #101010 rgb(16,16,16) #181818 rgb(24,24,24) #202020 rgb(32,32,32) #282828 rgb(40,40,40) #303030 rgb(48,48,48) #383838 rgb(56,56,56) #404040 rgb(64,64,64) #484848 rgb(72,72,72) #505050 rgb(80,80,80) #585858 rgb(88,88,88) #606060 rgb(96,96,96) #686868 rgb(104,104,104) #707070 rgb(112,112,112) #787878 rgb(120,120,120) #808080 rgb(128,128,128) #888888 rgb(136,136,136) #909090 rgb(144,144,144) #989898 rgb(152,152,152) #A0A0A0 rgb(160,160,160) #A8A8A8 rgb(168,168,168) #B0B0B0 rgb(176,176,176) #B8B8B8 rgb(184,184,184) #C0C0C0 rgb(192,192,192) #C8C8C8 rgb(200,200,200) #D0D0D0 rgb(208,208,208) #D8D8D8 rgb(216,216,216) #E0E0E0 rgb(224,224,224) #E8E8E8 rgb(232,232,232) #F0F0F0 rgb(240,240,240) #F8F8F8 rgb(248,248,248) #FFFFFF rgb(255,255,255) Web安全色?数年以前，当大多数计算机仅支持 256 种颜色的时候，一系列 216 种 Web 安全色作为 Web 标准被建议使用。其中的原因是，微软和 Mac 操作系统使用了 40 种不同的保留的固定系统颜色（双方大约各使用 20 种）。我们不确定如今这么做的意义有多大，因为越来越多的计算机有能力处理数百万种颜色，不过做选择还是你自己。最初，216 跨平台 web 安全色被用来确保：当计算机使用 256 色调色板时，所有的计算机能够正确地显示所有的颜色。 000000 000033 000066 000099 0000CC 0000FF003300 003333 003366 003399 0033CC 0033FF006600 006633 006666 006699 0066CC 0066FF009900 009933 009966 009999 0099CC 0099FF00CC00 00CC33 00CC66 00CC99 00CCCC 00CCFF00FF00 00FF33 00FF66 00FF99 00FFCC 00FFFF330000 330033 330066 330099 3300CC 3300FF333300 333333 333366 333399 3333CC 3333FF336600 336633 336666 336699 3366CC 3366FF339900 339933 339966 339999 3399CC 3399FF33CC00 33CC33 33CC66 33CC99 33CCCC 33CCFF33FF00 33FF33 33FF66 33FF99 33FFCC 33FFFF660000 660033 660066 660099 6600CC 6600FF663300 663333 663366 663399 6633CC 6633FF666600 666633 666666 666699 6666CC 6666FF669900 669933 669966 669999 6699CC 6699FF66CC00 66CC33 66CC66 66CC99 66CCCC 66CCFF66FF00 66FF33 66FF66 66FF99 66FFCC 66FFFF990000 990033 990066 990099 9900CC 9900FF993300 993333 993366 993399 9933CC 9933FF996600 996633 996666 996699 9966CC 9966FF999900 999933 999966 999999 9999CC 9999FF99CC00 99CC33 99CC66 99CC99 99CCCC 99CCFF99FF00 99FF33 99FF66 99FF99 99FFCC 99FFFFCC0000 CC0033 CC0066 CC0099 CC00CC CC00FFCC3300 CC3333 CC3366 CC3399 CC33CC CC33FFCC6600 CC6633 CC6666 CC6699 CC66CC CC66FFCC9900 CC9933 CC9966 CC9999 CC99CC CC99FFCCCC00 CCCC33 CCCC66 CCCC99 CCCCCC CCCCFFCCFF00 CCFF33 CCFF66 CCFF99 CCFFCC CCFFFFFF0000 FF0033 FF0066 FF0099 FF00CC FF00FFFF3300 FF3333 FF3366 FF3399 FF33CC FF33FFFF6600 FF6633 FF6666 FF6699 FF66CC FF66FFFF9900 FF9933 FF9966 FF9999 FF99CC FF99FFFFCC00 FFCC33 FFCC66 FFCC99 FFCCCC FFCCFFFFFF00 FFFF33 FFFF66 FFFF99 FFFFCC FFFFFF HTML 颜色名目前所有浏览器都支持以下颜色名。141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。下表列出了所有颜色的值，包括十六进制值。 提示: 17标准颜色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。点击其中一个颜色名称（或一个十六进制值）就可以查看与不同文字颜色搭配的背景颜色。： 按颜色名排序按十六进制的值排序单击一个颜色名或者 16 进制值，就可以查看与不同文字颜色搭配的背景颜色。 Color Name HEX ColorAliceBlue #F0F8FFAntiqueWhite #FAEBD7Aqua #00FFFFAquamarine #7FFFD4Azure #F0FFFFBeige #F5F5DCBisque #FFE4C4Black #000000BlanchedAlmond #FFEBCDBlue #0000FFBlueViolet #8A2BE2Brown #A52A2ABurlyWood #DEB887CadetBlue #5F9EA0Chartreuse #7FFF00Chocolate #D2691ECoral #FF7F50CornflowerBlue #6495EDCornsilk #FFF8DCCrimson #DC143CCyan #00FFFFDarkBlue #00008BDarkCyan #008B8BDarkGoldenRod #B8860BDarkGray #A9A9A9DarkGreen #006400DarkKhaki #BDB76BDarkMagenta #8B008BDarkOliveGreen #556B2FDarkOrange #FF8C00DarkOrchid #9932CCDarkRed #8B0000DarkSalmon #E9967ADarkSeaGreen #8FBC8FDarkSlateBlue #483D8BDarkSlateGray #2F4F4FDarkTurquoise #00CED1DarkViolet #9400D3DeepPink #FF1493DeepSkyBlue #00BFFFDimGray #696969DodgerBlue #1E90FFFireBrick #B22222FloralWhite #FFFAF0ForestGreen #228B22Fuchsia #FF00FFGainsboro #DCDCDCGhostWhite #F8F8FFGold #FFD700GoldenRod #DAA520Gray #808080Green #008000GreenYellow #ADFF2FHoneyDew #F0FFF0HotPink #FF69B4IndianRed #CD5C5CIndigo #4B0082Ivory #FFFFF0Khaki #F0E68CLavender #E6E6FALavenderBlush #FFF0F5LawnGreen #7CFC00LemonChiffon #FFFACDLightBlue #ADD8E6LightCoral #F08080LightCyan #E0FFFFLightGoldenRodYellow #FAFAD2LightGray #D3D3D3LightGreen #90EE90LightPink #FFB6C1LightSalmon #FFA07ALightSeaGreen #20B2AALightSkyBlue #87CEFALightSlateGray #778899LightSteelBlue #B0C4DELightYellow #FFFFE0Lime #00FF00LimeGreen #32CD32Linen #FAF0E6Magenta #FF00FFMaroon #800000MediumAquaMarine #66CDAAMediumBlue #0000CDMediumOrchid #BA55D3MediumPurple #9370DBMediumSeaGreen #3CB371MediumSlateBlue #7B68EEMediumSpringGreen #00FA9AMediumTurquoise #48D1CCMediumVioletRed #C71585MidnightBlue #191970MintCream #F5FFFAMistyRose #FFE4E1Moccasin #FFE4B5NavajoWhite #FFDEADNavy #000080OldLace #FDF5E6Olive #808000OliveDrab #6B8E23Orange #FFA500OrangeRed #FF4500Orchid #DA70D6PaleGoldenRod #EEE8AAPaleGreen #98FB98PaleTurquoise #AFEEEEPaleVioletRed #DB7093PapayaWhip #FFEFD5PeachPuff #FFDAB9Peru #CD853FPink #FFC0CBPlum #DDA0DDPowderBlue #B0E0E6Purple #800080Red #FF0000RosyBrown #BC8F8FRoyalBlue #4169E1SaddleBrown #8B4513Salmon #FA8072SandyBrown #F4A460SeaGreen #2E8B57SeaShell #FFF5EESienna #A0522DSilver #C0C0C0SkyBlue #87CEEBSlateBlue #6A5ACDSlateGray #708090Snow #FFFAFASpringGreen #00FF7FSteelBlue #4682B4Tan #D2B48CTeal #008080Thistle #D8BFD8Tomato #FF6347Turquoise #40E0D0Violet #EE82EEWheat #F5DEB3White #FFFFFFWhiteSmoke #F5F5F5Yellow #FFFF00YellowGreen #9ACD32 HTML 颜色值颜色由红(R)、绿(G)、蓝(B)组成。 四级、实现1225！离散、情商、电路！设计PSHTML、PHP\CSS\mysql、javascript、JQUERY申请域名一定要·自己学好编程开发好项目！！！HCCACAN 信仰 行动 自己 家人 3wmale！ CSSLearning!||CSS3XHTML 是以 XML 格式编写的 HTML。 什么是 XHTML？XHTML 指的是可扩展超文本标记语言XHTML 与 HTML 4.01 几乎是相同的XHTML 是更严格更纯净的 HTML 版本XHTML 是以 XML 应用的方式定义的 HTMLXHTML 是 2001 年 1 月发布的 W3C 推荐标准XHTML 得到所有主流浏览器的支持今日的科技界存在一些不同的浏览器技术。其中一些在计算机上运行，而另一些可能在移动电话或其他小型设备上运行。小型设备往往缺乏解释“糟糕”的标记语言的资源和能力。所以 - 通过结合 XML 和 HTML 的长处，开发出了 XHTML。XHTML 是作为 XML 被重新设计的 HTML。与 HTML 相比最重要的区别： 文档结构XHTML DOCTYPE 是强制性的 中的 XML namespace 属性是强制性的 、、 以及 也是强制性的 元素语法XHTML 元素必须正确嵌套XHTML 元素必须始终关闭XHTML 元素必须小写XHTML 文档必须有一个根元素 属性语法XHTML 属性必须使用小写XHTML 属性值必须用引号包围XHTML 属性最小化也是禁止的下面的例子展示了带有最少的必需标签的 XHTML 文档：&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”“http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; Title of document&lt;/head&gt; ...... &lt;/html&gt; 如何从 HTML 转换到 XHTML向每张页面的第一行添加 XHTML &lt;!DOCTYPE&gt;向每张页面的 html 元素添加 xmlns 属性把所有元素名改为小写关闭所有空元素把所有属性名改为小写为所有属性值加引号 CSS 概述CSS 指层叠样式表 (Cascading Style Sheets)样式定义如何显示 HTML 元素样式通常存储在样式表中把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题外部样式表可以极大提高工作效率外部样式表通常存储在 CSS 文件中多个样式定义可层叠为一 样式解决了一个普遍的问题HTML 标签原本被设计为用于定义文档内容。通过使用 、、 这样的标签，HTML 的初衷是表达“这是标题”、“这是段落”、“这是表格”之类的信息。同时文档布局由浏览器来完成，而不使用任何的格式化标签。由于两种主要的浏览器（Netscape 和 Internet Explorer）不断地将新的 HTML 标签和属性（比如字体标签和颜色属性）添加到 HTML 规范中，创建文档内容清晰地独立于文档表现层的站点变得越来越困难。为了解决这个问题，万维网联盟（W3C），这个非营利的标准化联盟，肩负起了 HTML 标准化的使命，并在 HTML 4.0 之外创造出样式（Style）。所有的主流浏览器均支持层叠样式表。 样式表极大地提高了工作效率样式表定义如何显示 HTML 元素，就像 HTML 3.2 的字体标签和颜色属性所起的作用那样。样式通常保存在外部的 .css 文件中。通过仅仅编辑一个简单的 CSS 文档，外部样式表使你有能力同时改变站点中所有页面的布局和外观。由于允许同时控制多重页面的样式和布局，CSS 可以称得上 WEB 设计领域的一个突破。作为网站开发者，你能够为每个 HTML 元素定义样式，并将之应用于你希望的任意多的页面中。如需进行全局的更新，只需简单地改变样式，然后网站中的所有元素均会自动地更新。 多重样式将层叠为一个样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。 层叠次序当同一个 HTML 元素被不止一个样式定义时，会使用哪个样式呢？一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 4 拥有最高的优先权。 浏览器缺省设置外部样式表内部样式表（位于 标签内部）内联样式（在 HTML 元素内部）因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。 CSS 语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 selector {declaration1; declaration2; … declarationN }选择器通常是您需要改变样式的 HTML 元素。每条声明由一个属性和一个值组成。属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。 selector {property: value}下面这行代码的作用是将 h1 元素内的文字颜色定义为红色，同时将字体大小设置为 14 像素。在这个例子中，h1 是选择器，color 和 font-size 是属性，red 和 14px 是值。 h1 {color:red; font-size:14px;}下面的示意图为您展示了上面这段代码的结构： 提示：请使用花括号来包围声明。 值的不同写法和单位除了英文单词 red，我们还可以使用十六进制的颜色值 #ff0000： p { color: #ff0000; }为了节约字节，我们可以使用 CSS 的缩写形式： p { color: #f00; }我们还可以通过两种方法使用 RGB 值： p { color: rgb(255,0,0); } p { color: rgb(100%,0%,0%); }请注意，当使用 RGB 百分比时，即使当值为 0 时也要写百分比符号。但是在其他的情况下就不需要这么做了。比如说，当尺寸为 0 像素时，0 之后不需要使用 px 单位，因为 0 就是 0，无论单位是什么。 记得写引号提示：如果值为若干单词，则要给值加引号： p {font-family: “sans serif”;}多重声明：提示：如果要定义不止一个声明，则需要用分号将每个声明分开。下面的例子展示出如何定义一个红色文字的居中段落。最后一条规则是不需要加分号的，因为分号在英语中是一个分隔符号，不是结束符号。然而，大多数有经验的设计师会在每条声明的末尾都加上分号，这么做的好处是，当你从现有的规则中增减声明时，会尽可能地减少出错的可能性。就像这样： p {text-align:center; color:red;}你应该在每行只描述一个属性，这样可以增强样式定义的可读性，就像这样： p { text-align: center; color: black; font-family: arial;}空格和大小写大多数样式表包含不止一条规则，而大多数规则包含不止一个声明。多重声明和空格的使用使得样式表更容易被编辑： body { color: #000; background: #fff; margin: 0; padding: 0; font-family: Georgia, Palatino, serif; }是否包含空格不会影响 CSS 在浏览器的工作效果，同样，与 XHTML 不同，CSS 对大小写不敏感。不过存在一个例外：如果涉及到与 HTML 文档一起工作的话，class 和 id 名称对大小写是敏感的。 CSS 高级语法选择器的分组你可以对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开。在下面的例子中，我们对所有的标题元素进行了分组。所有的标题元素都是绿色的。 h1,h2,h3,h4,h5,h6 { color: green; } 继承及其问题根据 CSS，子元素从父元素继承属性。但是它并不总是按此方式工作。看看下面这条规则： body { font-family: Verdana, sans-serif; }根据上面这条规则，站点的 body 元素将使用 Verdana 字体（假如访问者的系统中存在该字体的话）。通过 CSS 继承，子元素将继承最高级元素（在本例中是 body）所拥有的属性（这些子元素诸如 p, td, ul, ol, ul, li, dl, dt,和 dd）。不需要另外的规则，所有 body 的子元素都应该显示 Verdana 字体，子元素的子元素也一样。并且在大部分的现代浏览器中，也确实是这样的。 继承是一个诅咒吗？如果你不希望 “Verdana, sans-serif” 字体被所有的子元素继承，又该怎么做呢？比方说，你希望段落的字体是 Times。没问题。创建一个针对 p 的特殊规则，这样它就会摆脱父元素的规则： body { font-family: Verdana, sans-serif; }td, ul, ol, ul, li, dl, dt, dd { font-family: Verdana, sans-serif; }p { font-family: Times, “Times New Roman”, serif; } CSS 派生选择器派生选择器通过依据元素在其位置的上下文关系来定义样式，你可以使标记更加简洁。在 CSS1 中，通过这种方式来应用规则的选择器被称为上下文选择器 (contextual selectors)，这是由于它们依赖于上下文关系来应用或者避免某项规则。在 CSS2 中，它们称为派生选择器，但是无论你如何称呼它们，它们的作用都是相同的。派生选择器允许你根据文档的上下文关系来确定某个标签的样式。通过合理地使用派生选择器，我们可以使 HTML 代码变得更加整洁。比方说，你希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生## 选择器： ## li strong { font-style: italic; font-weight: normal; }请注意标记为 的蓝色代码的上下文关系： 我是粗体字，不是斜体字，因为我不在列表当中，所以这个规则对我不起作用 我是斜体字。这是因为 strong 元素位于 li 元素内。 我是正常的字体。 &lt;/ol&gt;在上面的例子中，只有 li 元素中的 strong 元素的样式为斜体字，无需为 strong 元素定义特别的 class 或 id，代码更加简洁。再看看下面的 CSS 规则： strong { color: red; }h2 { color: red; }h2 strong { color: blue; } 下面是它施加影响的 HTML： The strongly emphasized word in this paragraph isred. This subhead is also red. The strongly emphasized word in this subhead isblue.上面这个必须要好好注意一下！~ CSS id 选择器id 选择器id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。id 选择器以 “#” 来定义。下面的两个 id 选择器，第一个可以定义元素的颜色为红色，第二个定义元素的颜色为绿色： red {color:red;} #green {color:green;}下面的 HTML 代码中，id 属性为 red 的 p 元素显示为红色，而 id 属性为 green 的 p 元素显示为绿色。 这个段落是红色。 这个段落是绿色。注意：id 属性只能在每个 HTML 文档中出现一次。想知道原因吗，请参阅 XHTML:网站重构。 id 选择器和派生选择器在现代布局中，id 选择器常常用于建立派生选择器。 sidebar p { font-style: italic; text-align: right; margin-top: 0.5em; }上面的样式只会应用于出现在 id 是 sidebar 的元素内的段落。这个元素很可能是 div——座椅建立起派生器 或者是表格单元，尽管它也可能是一个表格或者其他块级元素。它甚至可以是一个内联元素，比如 或者 ，不过这样的用法是非法的，因为不可以在内联元素 中嵌入 （如果你忘记了原因，请参阅 XHTML:网站重构）。 一个选择器，多种用法即使被标注为 sidebar 的元素只能在文档中出现一次，这个 id 选择器作为派生选择器也可以被使用很多次： sidebar p { font-style: italic; text-align: right; margin-top: 0.5em; } #sidebar h2 { font-size: 1em; font-weight: normal; font-style: italic; margin: 0; line-height: 1.5; text-align: right; }在这里，与页面中的其他 p 元素明显不同的是，sidebar 内的 p 元素得到了特殊的处理，同时，与页面中其他所有 h2 元素明显不同的是，sidebar 中的 h2 元素也得到了不同的特殊处理。 单独的选择器id 选择器即使不被用来创建派生选择器，它也可以独立发挥作用： sidebar { border: 1px dotted #000; padding: 10px; }根据这条规则，id 为 sidebar 的元素将拥有一个像素宽的黑色点状边框，同时其周围会有 10 个像素宽的内边距（padding，内部空白）。老版本的 Windows/IE 浏览器可能会忽略这条规则，除非你特别地定义这个选择器所属的元素： div#sidebar { border: 1px dotted #000; padding: 10px; } 赏心悦目，只在aclear.]]></content>
      <categories>
        <category>页面</category>
      </categories>
      <tags>
        <tag>正能量</tag>
        <tag>少年初心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP_ALi]]></title>
    <url>%2Fpost%2Fe834968b.html</url>
    <content type="text"><![CDATA[阿里云服务器下结合AMH面板——创建ThinkPHP项目（3.1.3上传）1.创建好lamp环境后，将thinkphp项目以压缩包的形式上传的相应的网站根目录下。2.THINPHP核心包中，修改conf，（在AMH创建好数据库之后）。添加数据库。3.访问会出现access denied的错误提示此问题是由于弹性Web托管主机不支持pathinfo函数导致的，如果有重写的需要请通过.htaccess来实现，也可以使用虚拟主机或ECS服务器，虚机可以支持pathinfo，ECS服务器可以自行配置环境。 或者直接利用兼容模式！ url的4种访问⽅方式 //重点!1.PATHINFO 模式 — 重点！！！！！！http://域名/项⽬目名/⼊⼝文件/模块名/⽅方法名/键1/值1/键2/值22.普通模式http://域名/项⽬目名/⼊⼝文件?m=模块名&amp;a=⽅方法名&amp;键1=值1&amp;键2=值23.REWRITE模式（需要调整Apache的 rewrite（即去掉井号！）然后添加.htaccess到项目根目录下）http://域名/项⽬目名/模块名/⽅方法名/键1/值1/键2/值24.兼容模式（ALi可以利用这个来通过传值访问相应的/模块/方法！！！）http://域名/项⽬目名/入⼝文件?s=模块名/⽅法名/键1/值1/键2/值2]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>thinkphpALi</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHPKJ_S07第十四课实现简单的登录]]></title>
    <url>%2Fpost%2F595a4a91.html</url>
    <content type="text"><![CDATA[将14教程的 Extend 添加到 THINPHP的 Extend 中—-手册 中有添加类库 验证码 ！！！ 注意各种手册的查询 dtd—-支持IE浏览器]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaClassOnline11，5_DeepIn]]></title>
    <url>%2Fpost%2F52dccdb0.html</url>
    <content type="text"><![CDATA[数据库的访问1.**大纲** 确定数据库 连接数据库 执行SQL 处理结果 关闭连接 2.**访问数据库的基本步骤** 1**、确定数据库** 2**、连接数据库** 3**、执行SQL** 4**、处理结果** 5**、关闭连接** 第 1 步：确定数据库■JDBC URL ■public static final String JDBCURL_QUESTIONLIB = “jdbc:derby:” + FOLDER_DATA + “/QuestionLib”; 第 2 步：连接数据库■Connection conn = DriverManager.getConnection(jdbcurl); //**可提供url、用户名、密码3个参数 ■Connection conn = DriverManager.getConnection(JDBCURL_QUESTIONLIB); ■Connection conn = DriverManager.getConnection(JDBCURL_QUESTIONLIB, “”, “”);** 第 3 步：执行SQL（1）使用Statement ■Statement stmt = conn.createStatement(); //**可提供2个参数 ~**参数1：结果集游标的滚动类型及对数据库变化的反映 **ResultSet.TYPE\_FORWARD\_ONLY**ResultSet.TYPE_SCROLL_INSENSITIVE **ResultSet.TYPE\_SCROLL\_SENSITIVE** ~**参数2：是否能用结果集对数据库进行更新**ResultSet.CONCUR_READ_ONLY `ResultSet.CONCUR_UPDATABLE ■执行查询（select） ■ResultSet rset = stmt.executeQuery(sql**语句); ■执行更新（insert；delete；update） ■int rows = stmt.executeUpdate(sql**语句); ■执行其它 ■boolean v = stmt.execute(sql**语句); Xv == true**：有结果集，可获得结果集进行处理 Xv == false**：无结果集 ————imely: （2）使用PreparedStatement //继承自Statement&lt;不浪费时间进行的快速&gt; ■PreparedStatement stmt = conn.prepareStatement(sql); //**可提供2个参数 ■PreparedStatement stmt = conn.prepareStatement(“select * from choice where knowledge=? and difficulty=?”, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY); ■stmt.setXxx(1, x); stmt.setXxx(2, x); ■执行查询（select） ■ResultSet rset = stmt.executeQuery(); ■执行更新（insert；delete；update） ■int rows = stmt.executeUpdate(); ■执行其它 ■boolean v = stmt.execute(); （3）使用CallableStatement //继承自PreparedStatement ■CallableStatement stmt = conn.prepareCall(sql); 第 4 步：处理结果■使用 ResultSet 接口提供的方法对结果集数据进行处理 ■说明 ■主要操作：① 记录指针；② 获取数据 1.记录指针：开始指向表头行，可进行移动（只能向前；前后皆可） 2.获取数据：对于记录指针指向的行，可以使用列号或列名获取数据 ■使用列号时列号从 1 开始计 ■只能读取一次，不能重复读取，可存储在一个变量中重复使用 列名1 列名2 列名3 列名4 …… 数据1 数据2 数据3 数据4 …… …… …… …… …… …… 数据1 数据2 数据3 数据4 …… ResultSet 学会掌握并且分清楚 JDK中的方法，指针开始的地方！返回值等用途！！！ ■记录指针 ■boolean next(); ■boolean previous(); ■boolean first(); ■boolean last(); ■void beforeFirst(); ■void afterLast(); ■boolean absolute(int); ■boolean relative(int); ■boolean isBeforeFirst(); ■boolean isAfterLast(); ■boolean isFirst(); ■boolean isLast(); …… ■记录指针 ■boolean next(); ■boolean previous(); ■boolean first(); ■boolean last(); ■void beforeFirst(); ■void afterLast(); ■boolean absolute(int); ■boolean relative(int); ■boolean isBeforeFirst(); ■boolean isAfterLast(); ■boolean isFirst(); ■boolean isLast(); ■…… 第 5 步：关闭连接■conn.close(); ■ _对于一个Statement对象stmt，执行查询后得到一个ResultSet结果集rset1，若再次使用stmt执行查询后得到另一个结果集rset2，则rset1会自动关闭。_ _要想保持两个结果集都不关闭，就需要使用两个Statement对象分别执行各自的查询。_]]></content>
      <categories>
        <category>Java</category>
        <category>JavaClass</category>
        <category>JavaPrimary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaClassOnline11，3D_JDBC]]></title>
    <url>%2Fpost%2F6acfb9da.html</url>
    <content type="text"><![CDATA[心得：在用IDEA操作JDBC数据库时：&lt;连接 Derby — （Embedded）&gt; 1.uesrname_password_连接上之后。可以自行针对数据库进行操作。 2.但是只有当我们断开连接数据库才可以，用程序连接和操作数据库。 3.还有当我们用程序更新完成我们的数据库后，可能会连接失败！！！查看不了最新的数据库！ 解决：已经断开了连接—-forgot schemas—接下来我们才可以—查看或者修改表！！！ 问题：数据库操作，不注意自己学习手册：rlset.setInt（1，？）；rlset.setInt（2，？）； 还有可能不同版本的ide配置不同版本的Jdk会和数据库产生不同的效果（并不能用的呀！） 课堂学习1.大纲 Java DB 建立数据库 JDBC**体系结构** JDBC URL 基本**SQL**语句 ₪各种**数据库产品 ■MySQL ■Microsoft SQL Server ■Microsoft Excel ■Oracle ■Java DB ■……** 2.JAVA DB₪有关网址 ■http://www.oracle.com/technetwork/java/javadb/overview/index.html ■http**://db.apache.org/derby/ ₪访问模式 ■嵌入**模式 ■不需要服务器支持，只支持单用户 ■类库：**derby.jar ■网络模式 ■需要服务器支持，支持多用户 ■类库：**derbyclient.jar ₪在相应的**DBMS（DataBase Management System，数据库管理系统）环境中完成数据库的创建工作** 1.设置数据库位置“服务”**à“数据库”à“Java DB”à“属性”à“数据库位置”à “浏览”**à 选择“**data**”文件夹 à**“确定” -》 aDriverManager驱动管理：告知他 利用哪一类的驱动然后我们掉用他对相应的API（连接，方法，声明，返回值）2.创建数据库 “Java DB”à“创建数据库”à“数据库名称（QuestionLib）”**à “用户名”**à“口令”à“确认口令”à**“确定”3.连接数据库“**jdbc:derby://localhost:1527/QuestionLib [APP上的]”à**“连接”4.创建表“**APP”à“表”à“创建表”à“表名（Choice）”à “添加列（description，VARCHAR，1000，空值）”à “添加列（ standardanswer，VARCHAR，4，空值）”**à “添加列（**knowledge，INTEGER，0，空值）”**à “添加列（**difficulty**， INTEGER**，0，空值）”à “确定”5.录入数据 “Choice”à“查看数据”à“插入记录”**à 输入数据 à**“添加”à“确定”** —JDBC URL ₪文件可以通过**String类型（name）或File类型（file**）表示₪数据库也是文件（有组织的若干文件），数据库如何表示？₪JDBC URL₪jdbc**:derby://localhost:1527/**QuestionLib₪jdbc:subprotocol:subname■jdbc**：主协议**；固定■subprotocol**：子协议；由 DBMS 类型确定，如：derby■subname**：数据库信息；由具体的 DB 确定X数据源方式**：控制面板→管理工具→数据源(ODBC)X直接方式：直接给出数据库的相关**信息 JDK db -- bin 可执行的可链接的 lib 开发得库创建库创建表 工作簿（建立一个结构）里有工作表（创建拥有的内容） 表里面现在是空的（添加数据，或者poi添加） **从出题的****Excel****文件中****读取试题****：** **public static List&lt;****ChoiceQuestion****\&gt;** **readQuestionFromExcel****(String** **name)** **throws** **IOException** 7 。。。3列 ₪文件可以通过**String类型（name）或File类型（file**）表示₪数据库也是文件（有组织的若干文件），数据库如何表示？₪JDBC URL₪jdbc**:derby://localhost:1527/**QuestionLib₪jdbc:subprotocol:subname■jdbc**：主协议**；固定■subprotocol**：子协议；由 DBMS 类型确定，如：derby■subname**：数据库信息；由具体的 DB 确定X数据源方式**：控制面板→管理工具→数据源(ODBC)X直接方式：直接给出数据库的相关**信息 序 条目 模式 表示 1 QuestionLib （试题库**）** 嵌入模式 public static final String JDBCURL_QUESTIONLIB = “**jdbc:derby:” + FOLDER_DATA + “/QuestionLib**”; 网络模式 public static final String JDBCURL_QUESTIONLIB = “**jdbc:derby://localhost:1527/QuestionLib**”; 3.基本**SQL**语句zixue!!!16]]></content>
      <categories>
        <category>Java</category>
        <category>JavaClass</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习色彩搭配必备]]></title>
    <url>%2Fpost%2Faa4b4ffa.html</url>
    <content type="text"><![CDATA[色彩是设计的基础，对色彩的把握从开始就给了设计作品一个基调，所以一切的开始十分重要。色彩学有些教材总在教你哪种颜色去搭配哪种颜色，其实这些说法都不是一定的，重要的是你如何去组合，如何去搭配！而这一切的一切都不在书上，而是要你去观察，观察自然，自然是最好的老师。只不过我们太自以为了解了自然，但是从来没有用心去观察。看血染样的黄昏，去看棉花糖漂移的蓝天，一切华丽的色彩其实就在你身边。下面给出的搭配图片都来自于自然，来自于身边。图片来自于design-seeds，网站自立于收集身边的色彩搭配，遗憾的是大陆的童鞋不能访问！]]></content>
      <categories>
        <category>PS</category>
        <category>Snail</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POI+Set_JavaClass_1028]]></title>
    <url>%2Fpost%2F90507ed9.html</url>
    <content type="text"><![CDATA[POI与Excel文件+集合1.大纲 表示文件 建立考生库 POI 集合类 读取**Excel**文件 写入**Excel**文件 考生库 成绩库 实验15 学习SQL 进行简单的语句，方法调用，进行操作、解析格式（相当于大型的插件！） 使用 Microsoft Excel 在 data 文件夹中建立考生库 Examinee.xls**，其中有一个考生信息表 Examinee**，按照下面的表结构录入考生的信息 数字想在excel中 呈字符形式就用 单引号 ‘ org.apache.poi.hssf**.* 实现 xls 的！ http://poi.apache.org/ HSSF**（Horrible Spread Sheet Format） （可怕的电子表格格式**） 注意读取时行号 都从零开始；但是第一行又是考号！！！5—〉4 2.HSSF（Horrible Spread Sheet Format）（可怕的电子表格格式） 包 类**/**接口 功能支持 org.apache.poi.hssf**.* HSSFWorkbook 工作簿 HSSFSheet 工作表必须建立 sheet1位置的名称 HSSFRow 行 HSSFCell 单元格 3.使用**POI**读取具体：请查看文档：·1读取**Excel**文件： String**类型的文件名name或File类型的文件对象**file FileInputStream in = new FileInputStream**(name); //或file** HSSFWorkbook workbook = new HSSFWorkbook**(in); //**工作簿 HSSFSheet sheet = workbook.getSheet**(工作表名); //**工作表 HSSFRow row = sheet.getRow**(行号); //行，从0**开始计 HSSFCell cell = row.getCell**(列号); //单元格，从0**开始计 Xxx xxx = cell.getXxxCellValue**(); //按类型获取数据，如：String，Numeric** in.close**();** ·2使用**POI写入Excel**文件1 String**类型的文件名name或File类型的文件对象**file 2 FileOutputStream out = new FileOutputStream**(name); //或file** 3 HSSFWorkbook workbook = new HSSFWorkbook**(); //**工作簿 4 HSSFSheet sheet = workbook.createSheet**(工作表名); //**工作表 HSSFRow row = sheet.createRow**(行号); //行，从0**开始计 HSSFCell cell = row.createCell**(列号); //单元格，从0**开始计 cell.setCellType**(类型); //如CellType.STRING，CellType.NUMERIC cell.setCellValue(值**); //**按类型设置数据，如：String、**double workbook.write**(out); //**写入 5 out.close**();** 4.ArrayList**的基本使用方法***List&lt;Integer&gt;** **list** **= new** **ArrayList****&lt;&gt;();** **int**** n = 10; for (****int** **i****=0;** **i****&lt;n;** **i****++) {** **list.add****(i+1); }** l**int**** sum = 0; for (****int****x : list) {** **// for (****int** **i****=0;** **i****&lt;****list.size****();** **i****++)** ** sum += x; }** l**list.clear****();** l**泛****型** l**菱形****推断** ![%e6%8d%95%e8%8e%b71028](http://123.206.69.206/wp-content/uploads/2016/10/捕获1028-300x212.png) java.util.List 注意拥有： 泛型：限制内部类型的范围！ 1.一种类型&lt;&gt;直接放2. super 上限 extends下限 boolean add**(Ee) Appends the specified element to the end of this list (optional operation).** void add**(int index, E element**) Inserts the specified element at the specified position in this list (optional operation). void clear**() Removes all of the elements from this list (optional operation).** boolean contains**(Object o**) Returns** true if this list contains the specified element.** E get**(int index**) Returns the element at the specified position in this list. boolean isEmpty**() Returns** true if this list contains no elements. Iterator**&lt;E&gt;** iterator**() Returns an iterator over the elements in this list in proper sequence.** E remove**(int index**) Removes the element at the specified position in this list (optional operation). boolean remove**(Object o**) Removes the first occurrence of the specified element from this list, if it is present. E set**(int index, E element**) Replaces the element at the specified position in this list with the specified element. int size**() Returns the number of elements in this list.** class MyException extends Exception { //创建自定义异常类 String message; //定义String类型变量 public MyException(String ErrorMessagr) { //父类方法 message = ErrorMessagr![搜索](https://gss0.bdstatic.com/70cFsjip0QIZ8tyhnq/img/iknow/qb/select-search.png); } public String getMessage(){ //覆盖getMessage()方法 return message; } } public class Captor { //创建类 static int quotient(int x,int y) throws MyException{//定义方法抛出异常 if(y &lt; 0){ //判断参数是否小于0 throw new MyException(&quot;除数不能是负数&quot;);//异常信息 } return x/y;//返回值 } public static void main(String args\[\]){ //主方法 try{ //try语句包含可能发生异常的语句 int result = quotient(3,-1);//调用方法quotient() }catch (MyException e) { //处理自定义异常 System.out.println(e.getMessage()); //输出异常信息 } catch (ArithmeticException e) { //处理ArithmeticException异常 System.out.println(&quot;除数不能为0&quot;);//输出提示信息 } catch (Exception e) { //处理其他异常 System.out.println(&quot;程序发生了其他的异常&quot;); //输出提示信息 } }]]></content>
      <categories>
        <category>Java</category>
        <category>JavaClass</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件与异常+字符流+字节流_Java_1027,34]]></title>
    <url>%2Fpost%2F2142367c.html</url>
    <content type="text"><![CDATA[文件与异常1. 大纲 File （文件；表示；使用） 文件选择器 （**JFileChooser**） 文件过滤器 （**FileNameExtensionFilter；FileFilter**） 一个类 （**JOptionPane**） 异常 （概念；体系；结构；自定义 2.文件和文件夹表示■java.io.File ■格式 ■File file = new File(**文件名**); //**将外部文件与内部对象建立联系 ■举例 ■File file = new File(“Note.txt”); //相对文件名 ■File file = new File(“d:/JavaProjects**/HelloWorld.java”); //**绝对**文件名 ■通过**File对象能够操作对应的文件或文件夹 ！！ ■如何得到File对象？ ■直接通过文件名创建：**File file = new File(**文件名**); ■通过文件选择**器得到：由JFileChooser**类提供支持 ■通过参数传递得到：**void method(File file) { … } ■File**对象的使用 ■length(); //long len = file.length**(); ■getAbsolutePath**(); getName**(); getParent**(); ■exists(); ■isFile**(); isDirectory**(); isHidden**(); ■list(); listFiles**(); ■mkdir**(); mkdirs**(); ■delete(); renameTo**(File dest**); 可**查阅JDK帮助文档详细进行了解** 3.文件选择器₪类：**javax.swing.JFileChooser ₪基本步骤** 操作 示意性代码 1**、创建对象** JFileChooser chooser = new JFileChooser**(); //**可带参数，用于指定路径 2**、设置对象** •chooser.**setCurrentDirectory**(File dir**); •setFileSelectionMode(int mode); //FILES_ONLY，DIRECTORIES_ONLY，FILES_AND_DIRECTORIES •setMultiSelectionEnabled(boolean b); •setFileFilter(FileFilter filter); addChoosableFileFilter(FileFilter filter); //**添加 •setSelectedFile**(File file);** 3**、显示对话框** •int**v = chooser.showOpenDialog(父组件对象**); //**显示打开对话框 •int**v = chooser.show**SaveDialog(父组件对象); //**显示保存对话框 4**、判断返回值** if (v == JFileChooser.**APPROVE_OPTION**) { … } //**取值：APPROVE_OPTION，CANCEL_OPTION，**ERROR_OPTION 5**、获取文件** •File getCurrentDirectory**(); •File getSelectedFile**(); //File file = chooser.**getSelectedFile**(); •File[] getSelectedFiles**(); //**可选择多个文件时使用 6**、处理文件** 读取；写入；其他 4.文件过滤器■类：**javax.swing.filechooser.FileFilter ■这是一个抽象类，抽象方法有 ■public abstract boolean**accept(File f); //**可接受文件的条件** ■public abstract String getDescription**(); //**对文件的描述性文字自定义文件过滤器—基本步骤： 操作 示意性代码 1**、定义类** public class XxxFilter**extends FileFilter** { public XxxFilter**(…) { … } //**构造方法 public boolean** accept(File file) { return …; //使用file**参数构造文件接受条件 } public String getDescription**() { return …; } }** 2**、创建对象** XxxFilter fiter = new XxxFilter**();** 3**、应用对象** chooser.setFilter**(filter); //chooser.addChoosableFileFilter(filter); int v = chooser.showOpenDialog**(…); …… ==文件扩展名过滤器₪类：**javax.swing.filechooser.FileNameExtensionFilter ₪父类：**FileFilter ₪基本步骤 操作 示意性代码 1**、创建** FileNameExtensionFilter filter = new FileNameExtensionFilter**(“Java File”, “java”, “class”);** 2**、应用** chooser.**setFilter**(filter); 综合 示例 JFileChooser chooser = new JFileChooser**(“d:/JavaProjects“); FileNameExtensionFilter f1 = new FileNameExtensionFilter(“Java文件 [.java]“, “java”); FileNameExtensionFilter f2 = new FileNameExtensionFilter(“Class文件 [.class]“, “class”); chooser.addChoosableFileFilter**(f1); chooser.addChoosableFileFilter**(f2); int v = chooser.showOpenDialog**(…); …… 5.javax.swing.JOptionPane₪JOptionPane**提供了以下几个常用方法：** static void showMessageDialog**(Component parentComponent, Objectmessage, String title, intmessageType)** static String showInputDialog**(Component parentComponent, Object message)** static int showConfirmDialog**(Component parentComponent, Object message, String**title, int**optionType**) messageType optionType return value ( int ) ERROR_MESSAGE INFORMATION_MESSAGE WARNING_MESSAGE QUESTION_MESSAGE PLAIN_MESSAGE DEFAULT_OPTION YES_NO_OPTION YES_NO_CANCEL_OPTION OK_CANCEL_OPTION YES_OPTION NO_OPTION CANCEL_OPTION OK_OPTION CLOSED_OPTION 6.异常处理《₪在调用某个方法时，有时能**正常**执行，有时则出现异常：■int d1 = Integer.parseInt**(“123”);■int d2 = Integer.parseInt(“123a”);■访问值为null的对象的成员■数组越界访问■字符串越界访问■……₪当出现异常时应该能进行适当的处理， 否则程序会异常终止而影响健壮性₪Java提供了一种简便、通用的异常处理方式**》 异常处理程序结构 try {_ //_**_可能__会出现异常的__方法调用语句_ } catch (**异常类 e1) { //**异常处理代码，如： //获取信息：e1.getMessage()**; //**显示调用：e1.printStackTrace(); } catch (**异常类 e2) { //**异常处理代码 } …… { //**异常处理代码} finally { //**最后的处理代码 }** [caption id=”attachment_227” align=”alignnone” width=”300”] 异常类型[/caption] P.S.自定义**异常**类：₪当需要**JDK**中并未涵盖的异常时，需要自定义异常类 public class XxxException**extends Exception** {public XxxException**() { //**无参构造方法 }public XxxException**(String message) { //**提供异常信息的构造方法 super(message); }}自定义异常方法：public void f(int x) throws XxxException, … { …… if (布尔表达式) { throw new XxxException(…); } ……} 字符流1.创建文件夹和文件 （data；Notes.txt；Paper.properties） 表示文件夹和文件 （定义成员变量） 文件操作基本步骤 （5个基本步骤） 文本文件 （读；写） 属性文件 （读；写） P.S. 创建文件夹 data 创建文件 Note.txt Paper.properties 2.文件读写的基本步骤: 1**、获取要操作的文件** 2**、创建基本读写对象** 3**、创建实际读写对象** 4**、读写处理** 5**、关闭** 3.文本文件读取:₪基本步骤1.String**类型的文件名name或File类型的文件对象**file2.FileReader fin = new FileReader**(name); //或file3.BufferedReader in = new BufferedReader**(fin);4.while (true) { String line = in.readLine**(); //还有其它一些读取**方法 if (line == null) { //**已到达文件末尾 break; } /* 对line进行处理 */ }**5.in.close**(); //**关闭 zhuyi写入文本文件内容基本步骤String类型的文件名name或File类型的文件对象fileFileWriter fout = new FileWriter(fileName); //或fileBufferedWriter out = new BufferedWriter(fout);while (条件) { out.write(待写入的字符串) //还有其它一些写入方法 out.newLine(); //写入换行符 }out.close(); //关闭** public static String readTextFile(File file) throws IOException {到底在哪里处理异常？1、就地解决 try - catch2、交给上级 声明抛出 4.属性文件_属性文件是一种带格式的文本文件_ _扩展名_ _properties_ _文件格式_ _属性名=属性值_ _说明_ _以“#”开头的行为注释行_ _可在行尾使用“\\”进行续行_ 读取基本步骤String类型的文件名name或File类型的文件对象fileFileReader fin = new FileReader(fileName); //或fileProperties properties = new Properties(); properties.load(fin);String value = properties.getProperty(key); …… //参数key为属性名，如：”title”，赋值号左边的value为属性值 //返回值类型为String，有时需要转换为其它类型in.close();写入基本步骤Properties properties = new Properties();Object xxx = properties.setProperty(key, value); …… //参数中的key为属性名，value为属性值，类型都是String //返回值xxx是key原来的属性值String类型的文件名name或File类型的文件对象fileFileWriter fout = new FileWriter(fileName); //或fileproperties.store(fout, comments); * 字节流 创建和表示文件夹 基本字节流文件的读写 数据字节流文件的读写 对象字节流文件与序列化 随机访问文件 若要把一个对象序列化（即可把整个对象输出到文件中），则需要使该对象对应的类支持可序列化。最简单的支持可序列化的方式是为类声明实现Serializable接口。 Serializable接口定义在io包中，需要使用import语句将其导入。该接口是一个标志性接口，其中没有方法的定义，所以实现该接口时不需要实现任何方法，只要使用implements进行声明即可。 对于一个支持可序列化的类，其中引用类型的成员变量所对应的类也要支持可序列化。 在Paper类中，存在String、Date、Examinee和ChoiceQuestion类型的成员变量，所以它们都需要支持可序列化。对于String和Date，它们已经声明实现了Serializable接口，而对于Examinee和ChoiceQuestion，则需要声明实现Serializable接口。 如果一个类声明实现了Serializable接口，则其子类会继承这种功能，所以在子类声明时不再需要声明实现Serializable接口。所以这里采用为ChoiceQuestion类的父类Question声明实现Serializable接口的方式。 1基本字节文件的读/ 基本步骤 String类型的文件名name或File类型的文件对象file FileInputStream fi = new FileInputStream(name); //或file BufferedInputStream in = new BufferedInputStream(fi); //可选 / 使用相应类提供的方法读取数据并进行处理 / int read() 读一个字节并返回，-1表示到达文件尾。 int read(byte[] b) 读最多b.length个字节到数组b中，并返回实际读取的字节数，-1表示到达文件尾。 in.close(); //关闭 1.2.基本字节文件的写 基本步骤 String类型的文件名name或File类型的文件对象file FileOutputStream fo = new FileOutputStream(name /, true /); //或file BufferedOutputStream out = new BufferedOutputStream(fo); //可选 / 处理数据并使用相应类提供的方法写入数据 / void write(int b) 写一个字节b。 void write(byte[] b) 写数组b中的b.length个字节。 out.close(); //关闭 2.1数据字节文件的读 基本步骤 String类型的文件名name或File类型的文件对象file FileInputStream fi = new FileInputStream(name); //或file DataInputStream in = new DataInputStream(fi); / 使用相应类提供的方法读取数据并进行处理 / int read() 读一个字节并返回，-1表示到达文件尾。 int read(byte[] b) 读最多b.length个字节存入数组b中，并返回实际读取的字节数，-1表示到达文件尾。 xxx readXxx() 按基本类型xxx读一个数。如：int a = in.readInt(); in.close(); //关闭 2.2数据字节文件的写 基本步骤 String类型的文件名name或File类型的文件对象file FileOutputStream fo = new FileOutputStream(name /, true /); //或file DataOutputStream out = new DataOutputStream(fo); / 处理数据并使用相应类提供的方法写入数据 / void write(int b) 写一个字节b。 void write(byte[] b) 写数组b中的b.length个字节。 void writeXxx(xxx d) 按基本类型xxx写一个数。如：out.writeInt(10); out.close(); //关闭 3.1对象字节文件的读 基本步骤 String类型的文件名name或File类型的文件对象file FileInputStream fi = new FileInputStream(name); //或file ObjectInputStream in = new ObjectInputStream(fi); / 使用相应类提供的方法读取数据并进行处理 / int read() 读一个字节并返回，-1表示到达文件尾。 int read(byte[] b) 读最多b.length个字节存入数组b中，并返回实际读取的字节数，-1表示到达文件尾。 xxx readXxx() 按基本类型xxx读取一个数。如：int a = in.readInt(); Object readObject() 读取一个对象。 如：Paper paper = (Paper) in.readObject(); in.close(); //关闭 3.2对象字节文件的写 基本步骤 String类型的文件名name或File类型的文件对象file FileOutputStream fo = new FileOutputStream(name /, true /); //或file ObjectOutputStream out = new ObjectOutputStream(fo); / 处理数据并使用相应类提供的方法写入数据 / void write(int b) 写一个字节b。 void write(byte[] b) 写数组b中的b.length个字节。 void writeXxx(xxx d) 按基本类型xxx写一个数。如：out.writeInt(10); void writeObject(Object obj) 写一个对象。out.writeObject(paper); out.close(); //关闭 注意：将对象写入到文件中保存（持久化） 前提条件 对象所属的类要实现可序列化接口 java.io.Serializable 标志性接口 接口中没有方法的定义 一个类只需声明实现Serializable接口即可支持其对象的可序列化 注意类中所包含的成员也要支持可序列化 若父类已声明实现Serializable接口，则其子类不需再次声明 4.BOSS++随机访问文件 基本步骤 String类型的文件名name或File类型的文件对象file 确定读写模式mode; // “r” or “rw” RandomAccessFile io = new RandomAccessFile(name, mode); //或file / 使用RandomAccessFile类提供的方法读写数据 / int read() 读一个字节并返回，-1表示到达文件尾。 int read(byte[] b) 读最多b.length个字节存入数组b中，并返回实际读取的字节数，-1表示到达文件尾。 xxx readXxx() 按基本类型xxx读一个数。如：int a = in.readInt(); void write(int b) 写一个字节b。 void write(byte[] b) 写数组b中的b.length个字节。 void writeXxx(xxx d) 按基本类型xxx写一个数。如：out.writeInt(10); void seek(long pos) 定位文件指针 io.close(); //关闭 实现文件的复制： 字节流：copy 如果一次读不完，分批读 8k by b Object readObject**() 读取一个对象。 如：**Paper paper = (Paper) in.readObject**();** l**String.format****(&quot;%s/%****s.paper****&quot;,** **Config.FOLDER_PAPERLIB****,** **myId****);** l**Config.FOLDER_PAPERLIB** **\+ &quot;/&quot; \+** **myId** **\+ &quot;.paper“** p**“data/****paperlib****/****20150010001****.paper”** ----照片实现 得到试卷 void seek**(**long pos**) 定位文件指针** 往前往前移动 后移动 i-1 * 4 再readInt 查找JDK 建立文件夹 getSavcFile 在manin 方法中实现 inputstream 如何 name dir props.load(new FileInputStream(“db.properties”)); 是读取当前目录的db.properties文件 getClass.getResourceAsStream(“db.properties”); 是读取当前类所在位置一起的db.properties文件 getClass.getResourceAsStream(“/db.properties”); 是读取ClassPath的根的db.properties文件,注意ClassPath如果是多个路径或者jar文件的,只要在任意一个路径目录下或者jar文件里的根下都可以,如果存在于多个路径下的话,按照ClassPath中的先后顺序,使用先找到的,其余忽略. ————— 如果你只是输入文件名，那java虚拟机默认是执行java XXXX命令所在的目录 例如: C:\\test&gt;java test 那db.properties就是C:\\test\\db.properties]]></content>
      <categories>
        <category>Java</category>
        <category>JavaClass</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHPKJ_S06视图第十三]]></title>
    <url>%2Fpost%2F49835057.html</url>
    <content type="text"><![CDATA[1第十三课 一、模板的使⽤用 （重点） a、规则 模板⽂文件夹下\[TPL\]/\[分组⽂文件夹/\]\[模板主题⽂文件夹/\]和模块名同名的⽂文件夹\[Index\]/和 ⽅方法名同名的⽂文件\[index\].html（.tpl） 更更换模板⽂文件的后缀名（修改配置⽂文件） &apos;TMPL\_TEMPLATE\_SUFFIX&apos;=&gt;&apos;.html&apos;,//更更改模板⽂文件后缀名 b、修改模板⽂文件⽬目录层次 &apos;TMPL\_FILE\_DEPR&apos;=&gt;&apos;_&apos;,//修改模板⽂文件⽬目录层次 c、模板主题 &apos;DEFAULT\_THEME&apos;=&gt;&apos;your&apos;,//设置默认模板主题 需要在TPL下⾯面新建⼀一个your⽂文件夹作为模板主题⽂文件夹 如何动态修改模板主题？ 1、在后台准备⼀一个功能，修改config.php⽂文件中的默认模板项 2、通过url传递 t=主题 参数可以修改不不同的模板 &apos;DEFAULT\_THEME&apos;=&gt;&apos;your&apos;,//设置默认模板主题 &apos;TMPL\_DETECT\_THEME&apos;=&gt;true,//⾃自动侦测模板主题 &apos;THEME_LIST&apos;=&gt;&apos;your,my&apos;,//⽀支持的模板主题列列表 二、输出模板内容 （重点） a、display 1.display中没有参数 $this-&gt;display(); 2.可以带参数 $this-&gt;display(本模块⽂文件夹下的其他模板⽂文件); $this-&gt;display(&apos;index2&apos;); $this-&gt;display(其他⽂文件夹下的模板⽂文件); $this-&gt;display(&apos;Public:error&apos;);//注意，仅仅需要在Tpl下有Public文件夹以及其中的error.html即可，不需要一定有Public模块 $this-&gt;display(其他主题下的 ⽂文件夹下的 模板⽂文件);//需要开启主题⽀支持 $this-&gt;display(&apos;my:Index:index&apos;); $this-&gt;display(一个url路路径); $this-&gt;display(&apos;./Public/error.html&apos;);//因为 IndexActionFunction 是个主入口文件，所以是被 ./（当前目录）调用的在Home文件夹层的 index.php！ 此处为第四种方法！ $this-&gt;display(&apos;./Public/error.html&apos;,&apos;utf-8&apos;,&apos;text/xml&apos;);//注意显示模板的方法++其中的有三个参数的作用和用途！ $this-&gt;show($content);// （ &apos; &lt;b&gt; *** &lt;/b&gt; &apos; ） 3.fetch⽅方法 获得模板⽂文件中的内容，以字符串串形式返回 $content=$this-&gt;fetch(&apos;Public:error&apos;); $this-&gt;show($content); 4.show⽅方法 不需要模板⽂文件，可以直接输出模板内容 $content=$this-&gt;fetch(&apos;Public:error&apos;);//将模板文件 返回一个字符串 然后通过SHOW方法输出！ dump($content); $content=str_replace(&apos;h1&apos;,&apos;i&apos;,$content); $this-&gt;show($content); 三、模板中的赋 值 （重点） &#123;$name&#125;!!! //html //$this-&gt;assign(&apos;name&apos;,&apos;赵桐正&apos;); $this-&gt;name=&apos;赵桐正2&apos;; $this-&gt;display(); 四、模板替换 （重点）//自己会 利用重新编译的 页面 可以自己查看源代码 ![](http://images.cnitblog.com/i/609445/201407/261439440418357.jpg) \_\_PUBLIC\_\_：会被替换成当前⽹网站的公共⽬目录 通常是 /Public/ \_\_ROOT\_\_： 会替换成当前⽹网站的地址（不不含域名） \_\_APP\_\_： 会替换成当前项⽬目的URL地址 （不不含域名） \_\_GROUP\_\_：会替换成当前分组的URL地址 （不不含域名）// \_\_URL\_\_： 会替换成当前模块的URL地址（不不含域名） \_\_ACTION\_\_：会替换成当前操作的URL地址 （不不含域名） \_\_SELF\_\_： 会替换成当前的⻚页⾯面URL 更更换模板变量量规则，修改配置项 &apos;TMPL\_PARSE\_STRING&apos;=&gt;array( //添加⾃自⼰己的模板变量量规则 &apos;\_\_CSS\_\_&apos;=&gt;\_\_ROOT\_\_.&apos;/Public/Css&apos;, //之前 &apos;/thinkphp/Public/Css&apos;; 用了常量替换 --且 . 是他字符串连接符 &apos;\_\_JS\_\_&apos;=&gt;\_\_ROOT\_\_.&apos;/Public/Js&apos;, ),]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHPKJ_S06视图第十二课程]]></title>
    <url>%2Fpost%2F4d34d30a.html</url>
    <content type="text"><![CDATA[12345⼀一、模板的使⽤用 （重点） a、规则##### 模板⽂文件夹下\[TPL\]（Index.php）/\[分组⽂文件夹/\]\[模板主题⽂文件夹/\]和模块名同名的⽂文件夹\[Index\]/和⽅方法名同名的⽂文件\[index\].html（.tpl）更更换模板⽂文件的后缀名（修改配置⽂文件） &apos;TMPL\_TEMPLATE\_SUFFIX&apos;=&gt;&apos;.html&apos;,//更更改模板⽂文件后缀名 b、修改模板⽂文件⽬目录层次 &apos;TMPL\_FILE\_DEPR&apos;=&gt;&apos;_&apos;,//修改模板⽂文件⽬目录层次//Index\_index.html 可以防止文件目录太深太复杂 c、模板主题 &apos;DEFAULT\_THEME&apos;=&gt;&apos;your&apos;,//设置默认模板主题//ThinkPHP并没有但是 可以创建，就是他们默认放置的【文件夹】 需要在TPL下⾯面新建⼀一个your⽂文件夹作为模板主题⽂文件夹 如何动态修改模板主题？ 1、在后台准备⼀一个功能，修改config.php⽂文件中的默认模板项 2、通过url传递 t=主题 参数可以修改不不同的模板 &apos;DEFAULT\_THEME&apos;=&gt;&apos;your&apos;,//设置默认模板主题 动态更改，传参，模板主题· &apos;TMPL\_DETECT\_THEME&apos;=&gt;true,//⾃自动侦测模板主题 &apos;THEME\_LIST&apos;=&gt;&apos;your,my&apos;,//⽀支持的模板主题列列表 ⼆二、输出模板内容 （重点） a、display 1.display中没有参数 $this-&gt;display(); 2.可以带参数 $this-&gt;display(本模块⽂文件夹下的其他模板⽂文件); $this-&gt;display(&apos;index2&apos;); $this-&gt;display(其他⽂文件夹下的模板⽂文件); $this-&gt;display(&apos;Public:error&apos;);//注意，仅仅需要在Tpl下有Public⽂文件夹以及其 中的error.html即可，不不需要⼀一定有Public模块 $this-&gt;display(其他主题下的 ⽂文件夹下的 模板⽂文件);//需要开启主题⽀支持 $this-&gt;display(‘my:Index:index&apos;);]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHPKJ_S05]]></title>
    <url>%2Fpost%2F8df09641.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233一、ThinkPHP注意：* 命名规范 使用ThinkPHP开发的过程中应该尽量遵循下列命名规范： 类文件都是以.class.php为后缀（这里是指的ThinkPHP内部使用的类库文件，不代表外部加载的类 库文件），使用驼峰法命名，并且首字母大写，例如 DbMysql.class.php ； 类的命名空间地址和所在的路径地址一致，例如 Home\\Controller\\UserController 类所在的路径 应该是 Application/Home/Controller/UserController.class.php ； 确保文件的命名和调用大小写一致，是由于在类Unix系统上面，对大小写是敏感的（而ThinkPHP 在调试模式下面，即使在Windows平台也会严格检查大小写）； 类名和文件名一致（包括上面说的大小写一致），例如 UserController 类的文件命名是 UserController.class.php ， InfoModel类的文件名是 InfoModel.class.php ， 并且不同的类库 的类命名有一定的规范； 函数、配置文件等其他类库文件之外的一般是以 .php 为后缀（第三方引入的不做要求）； 函数的命名使用小写字母和下划线的方式，例如 get\_client\_ip ； 方法的命名使用驼峰法，并且首字母小写或者使用下划线“_”，例如 getUserName ， \_parseType ，通常下划线开头的方法属于私有方法； 属性的命名使用驼峰法，并且首字母小写或者使用下划线“\_”，例如 tableName 、 \_instance ，通常下划线开头的属性属于私有属性； 以双下划线“\_\_”打头的函数或方法作为魔法方法，例如 \_\_call 和 \_\_autoload ； 常量以大写字母和下划线命名，例如 HAS\_ONE 和 MANY\_TO\_MANY ； 配置参数以大写字母和下划线命名，例如 HTML\_CACHE\_ON ； 语言变量以大写字母和下划线命名，例如 MY\_LANG ，以下划线打头的语言变量通常用于系统语言 变量，例如 \_CLASS\_NOT\_EXIST\_ ； 对变量的命名没有强制的规范，可以根据团队规范来进行； ThinkPHP的模板文件默认是以 .html 为后缀（可以通过配置修改）； 数据表和字段采用小写加下划线方式命名，并注意字段名不要以下划线开头，例如 think\_user 表 和 user\_name 字段是正确写法，类似 _username 这样的数据表字段可能会被过滤。* 再来通过要知道通过“ThinkPHP完全开发手册3.2.3”来自我查找，并且学会结合视频与代码教程。* 再来http://localhost/thinkphp/index.php/Index/show * 11111111111111111111前台入口文件/Index模板下的/show方法！ （还有Index方法（模板不过是c层下控制的一个方法！二、十一课连贯操作： ⼀一、常⽤用连贯操作 1.where 帮助我们设置查询条件 2.order 对结果进⾏行行排序 $arr=$m-&gt;order(&apos;id desc&apos;)-&gt;select(); $arr=$m-&gt;order(array(&apos;id&apos;=&gt;&apos;desc&apos;,&apos;sex&apos;=&gt;&apos;asc&apos;))-&gt;select(); 3.limit 限制结果 limit(2,5) limit(&apos;2,5&apos;) limit(10)//limit(0,10) 从零开始！限制结果数量例如获取满足要求的10个用户，如下调用即可：$User = M(&apos;User&apos;);$User-&gt;where(&apos;status=1&apos;)-&gt;field(&apos;id,name&apos;)-&gt;limit(10)-&gt;select();limit方法也可以用于写操作，例如更新满足要求的3条数据：$User = M(&apos;User&apos;);$User-&gt;where(&apos;score=100&apos;)-&gt;limit(3)-&gt;save(array(&apos;level&apos;=&gt;&apos;A&apos;));分页查询用于文章分页查询是limit方法比较常用的场合，例如：$Article = M(&apos;Article&apos;);$Article-&gt;limit(&apos;10,25&apos;)-&gt;select();表示查询文章数据，从第10行开始的25条数据（可能还取决于where条件和order排序的影响 这个暂且不提）。你也可以这样使用，作用是一样的：$Article = M(&apos;Article&apos;);$Article-&gt;limit(10,25)-&gt;select();对于大数据表，尽量使用limit限制查询结果，否则会导致很大的内存开销和性能问题。4.field 设置查询字段 field(&apos;username as name,id&apos;) field(array(&apos;username&apos;=&gt;&apos;name&apos;,&apos;id&apos;) field(&apos;id&apos;,true) //获取除了了id以外的所有字段$arr = $m -&gt; order( array( &apos;id&apos;=&gt;&apos;asc&apos;,&apos;sex&apos;=&gt;&apos;desc&apos; ) ) -&gt;limit( 5,20 ) -&gt; field( &apos;username as name,id,sex&apos; ) -&gt; select() ;//-&gt;field( &apos;username&apos; ); field 来设置字符段 dump( $arr ); 5.table 6.group 7.having ⼆二、补充（也可以自己在ThinkPHP手册上自己区去查看 alias ⽤用于给当前数据表定义别名 字符串串 page ⽤用于查询分⻚页（内部会转换成limit） 字符串串和数字 join* ⽤用于对查询的join⽀支持 字符串串和数组 union* ⽤用于对查询的union⽀支持 字符串串、数组和对象 distinct ⽤用于查询的distinct⽀支持 布尔值 lock ⽤用于数据库的锁机制 布尔值 cache ⽤用于查询缓存 ⽀支持多个参数（以后在缓存部分再详细描述） relation ⽤用于关联查询（需要关联模型扩展⽀支持） 字符串串 validate ⽤用于数据⾃自动验证 数组 auto ⽤用于数据⾃自动完成 数组 filter ⽤用于数据过滤 字符串串 scope* ⽤用于命名范围 字符串串、数组 补充部分会在以后在详细探讨 系统支持的连贯操作方法有： 连贯操作 作用 支持的参数类型 where* 用于查询或者更新条件的定义 字符串、数组和对象 table 用于定义要操作的数据表名称 字符串和数组 alias 用于给当前数据表定义别名 字符串 data 用于新增或者更新数据之前的数据对象赋值 数组和对象 field 用于定义要查询的字段（支持字段排除） 字符串和数组 order 用于对结果排序 字符串和数组 limit 用于限制查询结果数量 字符串和数字 page 用于查询分页（内部会转换成limit） 字符串和数字 group 用于对查询的group支持 字符串 having 用于对查询的having支持 字符串 join* 用于对查询的join支持 字符串和数组 union* 用于对查询的union支持 字符串、数组和对象 distinct 用于查询的distinct支持 布尔值 lock 用于数据库的锁机制 布尔值 cache 用于查询缓存 支持多个参数 relation 用于关联查询（需要关联模型支持） 字符串 result 用于返回数据转换 字符串 validate 用于数据自动验证 数组 auto 用于数据自动完成 数组 filter 用于数据过滤 字符串 scope* 用于命名范围 字符串、数组 bind* 用于数据绑定操作 数组或多个参数 token 用于令牌验证 布尔值 comment 用于SQL注释 字符串 index 用于数据集的强制索引（3.2.3新增） 字符串 strict 用于数据入库的严格检测（3.2.3新增） 布尔值 ThinkPHP3.2.3完全开发手册]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[split()zhuanWay]]></title>
    <url>%2Fpost%2Faa4d05c8.html</url>
    <content type="text"><![CDATA[它是java.lang包中的String.split()方法，返回是一个数组 我在应用中用到一些，给大家总结一下，仅供大家参考： 1、如果用“.”作为分隔的话，必须是如下写法：String.split(“\\.“),这样才能正确的分隔开，不能用String.split(“.”); 2、如果用“|”作为分隔的话，必须是如下写法：String.split(“\\|“),这样才能正确的分隔开，不能用String.split(“|”); “.”和“|”都是转义字符，必须得加”\\”; 3、如果在一个字符串中有多个分隔符，可以用“|”作为连字符，比如：“acount=? and uu =? or n=?”,把三个都分隔出来，可以用String.split(“and|or”); 使用String.split方法分隔字符串时，分隔符如果用到一些特殊字符，可能会得不到我们预期的结果。 我们看jdk doc中说明 public String[] split(String regex) Splits this string around matches of the given regular expression. 参数regex是一个 regular-expression的匹配模式而不是一个简单的String，他对一些特殊的字符可能会出现你预想不到的结果，比如测试下面的代码： 用竖线 | 分隔字符串，你将得不到预期的结果 String[] aa = “aaa|bbb|ccc”.split(“|”); //String[] aa = “aaa|bbb|ccc”.split(“\\|“); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“—“+aa[i]); } 用竖 分隔字符串运行将抛出java.util.regex.PatternSyntaxException异常，用加号 + 也是如此。 String[] aa = “aaa\bbb*ccc”.split(““); //String[] aa = “aaa|bbb|ccc”.split(“\\\“); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“—“+aa[i]); } 显然，+ 不是有效的模式匹配规则表达式，用”\\\“ “\\+“转义后即可得到正确的结果。 “|” 分隔串时虽然能够执行，但是却不是预期的目的，”\\|“转义后即可得到正确的结果。 还有如果想在串中使用””字符，则也需要转义.首先要表达”aaaa\\bbbb”这个串就应该用”aaaa\\\bbbb”,如果要分隔就应该这样才能得到正确结果： String[] aa = “aaa\\\bbb\\\bccc”.split(“\\\\\”); 第一种方法： string s=abcdeabcdeabcde; string[] sArray=s.Split(‘c’) ; foreach(string i in sArray) Console.WriteLine(i.ToString()); 输出下面的结果: ab deab deab de 第二种方法： 我们看到了结果是以一个指定的字符进行的分割。使用另一种构造方法对多个字符进行分割: string s=”abcdeabcdeabcde”; string[] sArray1=s.Split(new char[3]{‘c’,’d’,’e’}) ; foreach(string i in sArray1) Console.WriteLine(i.ToString()); 可以输出下面的结果： ab ab ab 第三种方法： 除了以上的这两种方法以外,第三种方法是使用正则表达式。新建一个控制台项目。然后先添加 using System.Text.RegularExpressions; System.Text.RegularExpressions string content=agcsmallmacsmallgggsmallytx; string[]resultString=Regex.Split(content,small,RegexOptions.IgnoreCase) foreach(string i in resultString) Console.WriteLine(i.ToString()); 输出下面的结果: agc mac ggg ytx 第四种方法： string str1=我*是*一*个*教*师; string[] str2; str1=str1.Replace(*,) ; str2=str1.Split() ; foreach(string i in str2) Console.WriteLine(i.ToString()); 第五种方法： string str1=我是*一*个*教*师; 我希望显示的结果为:我是一个教师。 我如果采用上面的第四种方法来做就会产生下面的错误：我 是一个教师。中间有空格输出，所以输出结果并不是希望的结果，这就又回到了正则表达式了，这时可以采用下面的第五种方法： string str1=我是*一*个*教*师; string[] str2 = System.Text.RegularExpressions.Regex.Split(str1,@[]+); foreach(string i in str2) Console.WriteLine(i.ToString()); 这里通过[]+ 巧妙的完成了我们的目标。 [zhuan]http://blog.sina.com.cn/s/blog_915ffce701011tu1.html]]></content>
      <categories>
        <category>Java</category>
        <category>JavaPrimary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java, swing jFileChooser showSaveDialog保存文件]]></title>
    <url>%2Fpost%2F8d959731.html</url>
    <content type="text"><![CDATA[public void mouseClicked(MouseEvent arg0) { javax.swing.JFileChooser jfc = new javax.swing.JFileChooser(){ public String paramString() { return “drhdrhdrh”; } };// 这里新建一个chooser FileFilter filter = new FileFilter() { public boolean accept(File f){ return f.isDirectory() || (f.isFile() &amp;&amp; ( f.getName().endsWith(“.htm”) || f.getName().endsWith(“.HTM”) || f.getName().endsWith(“.html”) ||f.getName().endsWith(“.HTML”) )); // 新建一个文件类型过滤器 }public String getDescription() { return “保存为HTML文件格式”; } }; jfc.setFileFilter(filter); int i = jfc.showSaveDialog(jContentPane); // 打开保存文件对话框String fname = null; if(i == javax.swing.JFileChooser.APPROVE_OPTION){ File f = jfc.getSelectedFile();// 注意这里，和下面一句, 如果这里并没有选取中任何的文件，//下面的jfc.getName(f)将会返回手输入的文件名fname = jfc.getName(f); if(fname != null &amp;&amp; fname.trim().length()&gt;0) { //trim 忽略前后导空白，返回字符串的副本！ if(fname.endsWith(“.htm”) || fname.endsWith(“.HTM”) || fname.endsWith(“.html”)|| fname.endsWith(“.HTML”)) ; else { fname = fname.concat(“.htm”);//末尾添加字符串 } }if(f.isFile()) fname = f.getName(); f = jfc.getCurrentDirectory();// 取得要保存的文件的目录,其实getSelectedFile();//已经包括了文件路径,这里这样是让大家更易了解f = new File(f.getPath().concat(File.separator).concat(fname));if(f.exists()) { i = javax.swing.JOptionPane.showConfirmDialog(jContentPane,“该文件已经存在，确定要覆盖吗？”);if(i == javax.swing.JOptionPane.YES_OPTION) ; else return ; } try { f.createNewFile(); java.io.FileWriter fw = new java.io.FileWriter(f); fw.write(getJtp_html().getText()); fw.close();// 向要保存的文件写数据 }catch(Exception ex) { javax.swing.JOptionPane.showMessageDialog(jContentPane, “出错：” + ex.getMessage()); return ; } }} Labels: java, swing jFileChooser showSaveDialog 保存文件 使用 swing的文件对话来保存的话,必须要注意几个地方, chooser.getSelectedFile(); 这个函数返回的 是对话框选中的文件,但如果对话框类型是showSaveDialog的话,那么这里返回的值是你要保存的文件,这个文件可能存在,可能不存在,就是你在对话框中输入的文件名了, 既然知道了文件,如果不存在,就新建一个,然后向文件写入数据,这样就可以实现保存了.不要以为chooser会 自动帮你读数据并存进去,这些都要自已用代码实现. 下面这个列子是将jTextPanel中数据保存到 html文件中.]]></content>
      <categories>
        <category>ExamTest</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JOptionPane的使用]]></title>
    <url>%2Fpost%2F5af0c5c3.html</url>
    <content type="text"><![CDATA[JOptionPane是一种对话框的便捷使用形式，要比JDialog使用起来方便，但是类型确实固定的几种，而JDialog确实可以自定义首先介绍JOptionPane的四个静态方法即可以利用类名直接调用的 1、showMessageDialog 显示消息对话框 @这个函数共有5个参数，分别为： Component parent指的是这个消息对话框所属的载体，一般为窗口。 Object message是指所要显示的提示信息。 String title 窗体名称 int messageType 消息显示的格式： ERROR_MESSAGE INFORMATION_MESSAGE WARNING_MESSAGE QUESTION_MESSAGE PLAIN_MESSAGE 所谓的消息显示格式及是显示的图标不同，其余的都是一样的 Icon icon 消息的图标，有人可能要问这个和上一个有什么区别， 区别就是可以自定义，而上个messageType只有那几个形式。 @虽然参数有这么多但是方法重载后有3种表现形式： showMessageDialog(parent, message) 默认的消息显示类型是INFORMATION_MESSAGE类型 showMessageDialog(parent, message, title, messageType) showMessageDialog(parent, message, title, messageType, icon) @此函数无返回值 注： 由此引申出来一个静态函数showInternalMessageDialog，参数和表现形式都和showMessageDialog一样，唯一区别就是内部对话框完全显示在所属框架内。 2、showConfirmDialog 显示确认对话框 @这个函数的参数和showMessageDialog是一样的，但是比它多出一个参数为： int optionType,这个参数表示对话框的选择类型，有 DEFAULT_OPTION YES_NO_OPTION YES_NO_CANCEL_OPTION OK_CANCEL_OPTION 所谓不同解释显示的button的不同 @同上showConfirmDialog也有三种重载形式 showConfirmDialog(parent, message, title, optionType, messageType, icon) showConfirmDialog(parent, message, title, optionType, messageType) showConfirmDialog(parent, message)默认的optionType是YES_NO_CANCEL_OPTION 注：同时也有showInternalConfirmDialog @此函数的返回值是一个整数 3、showInputDialog 显示输入对话框 @这个函数的四个参数和showMessageDialog是相同的，但多出两个参数： Object[] value 这是提供用户选择的一组值，是对象数组，例如 new String[] {“we”, “you”, “our”},当为null时，表示为用户可以任意输入，有JTextField来实现 Object default 这是程序的开始的默认值 @重载有种形式 showInputDialog(parent, message, title, messageType, icon, values, default) 例如：JOptionPane.showInputDialog(null, “woahsi”,”jljjk”,JOptionPane.ERROR_MESSAGE,null, new String[] {“df”, “dfdf”, “dfdfdf”}, “dfdf”); showInputDialog(parent, message, title, messageType) showInputDialog(parent, message) 默认的messageType是QUESTION_MESSAGE showInputDialog(message) 和上边相比这个没有父框架 showInputDialog(parent, message, default) 多了个默认值 showInputDialog(message, default) 同上相比是没有父框架 @返回值是一个字符串 注： 同上也有showInternalInputDialog但只有三种重载形式 showInternalInputDialog(parent, message, title, messageType, icon, values, default) showInternalInputDialog(parent, message, title, messageType) showInternalInputDialog(parent, message) 4、showOptionDialog 显示选择对话框 这个函数是messageType和OptionDialog以及InputDialog的结合体,只不过是用按钮来显示 形式是： showOptionDialog(parent, message, title, optionType, messageType, icon, values, default) JOptionPane.showOptionDialog(null, “woahsi”, “nihao”, JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE, null, new String[] {“d”, “f”}, “f”); 默认是‘f’键 转自： http://www.cnblogs.com/fantasy01/p/3911488.html]]></content>
      <categories>
        <category>Java</category>
        <category>JavaPrimary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ 中 *& 符号连用意思（BST相关）！]]></title>
    <url>%2Fpost%2Fbd0a08fe.html</url>
    <content type="text"><![CDATA[类似于void &amp; fun (int &amp; a)这样的函数。 指针的引用，指针它也是一个变量，&amp;就和普通变量的引用一样，也可以理解为指针变量的别名。如LZ的例子之中，int&amp; a，那么在函数里面对a的值进行改变，那么在调用函数时传入的参数的指针值也会改变 再实际点的例子，LZ的void&amp; fun(int&amp; a);调用时，有一个指针int* pointer = NULL;，然后fun(pointer)，在fun里面对a重新赋值，a = &amp;other，那样子外面pointer的值也就变成了&amp;other int fun(int&amp; p){ p = 10; return p;// 返回的是指针P指向的内容}int fun(){ int a = 100; return &a; // 返回a 的拷贝}int main(){ int c = 20; int p = &c; int a = fun(p); cout &lt;&lt;”当前 \p = “ &lt;&lt; *p &lt;&lt;endl &lt;&lt; “当前 a = “ &lt;&lt; a &lt;&lt;endl; cout &lt;&lt;”当前 &amp;p = “ &lt;&lt; &amp;p &lt;&lt;endl &lt;&lt; “当前 &amp;c = “ &lt;&lt; &amp;c &lt;&lt;endl; int x = fun(); int y = &x; // int a = fun(p); cout &lt;&lt;”当前 \y = “ &lt;&lt; *y &lt;&lt;endl; // a = fun(y); cout &lt;&lt;”当前 &amp;y = “ &lt;&lt; &amp;y &lt;&lt;endl &lt;&lt; “当前 &amp;x = “ &lt;&lt; &amp;x &lt;&lt;endl;//当前 p = 10//当前 a = 10//当前 y = 100//当前 &amp;y = 0x6afef0 //注意C++中三者区别 此为指针引用！别名，可改值//当前 &amp;y = 0x6afeec//当前 &amp;x = 0x6afef0// int p = NULL;// int a = testFun(p);// cout &lt;&lt;”当前 *p = “ &lt;&lt; *p &lt;&lt;endl;//// cout &lt;&lt;”当前 a = “ &lt;&lt; a &lt;&lt;endl;////// fun(p);// cout &lt;&lt;”当前 \p = “ &lt;&lt; *p &lt;&lt;endl; return 0;} Weiss BST： /* Function: BinarySreachTree\_In\_Weiss Compiler: Code::Blocks svn gcc Developer: Jiahao Zhang Date: October 19,2016 Version: 2.0 Reference:DSAA in C++ 4th Author: Weiss Publisher: Edition: 4th Pages:132 -- 142 */ // //几点，体会与相关项。 Weiss中的数据结构在读的时候，最好先掌握--《双语版C++程序设计》By【苏格兰】Paul Kelly 苏小红 合著 //STL-- 中会在 ADT 中重写相关类的的东西！ 文件流，位的操作。 &amp;&amp; &amp;* 相关问题的理解！ // //Alarm：关注Weiss中的安全性 public来调用 private 方法的用法！！！ // //&amp;&amp; 表征对于临时变量的处理和理解！ &amp;* 表征对于二维指针式的 存储的指针的指针？ //自己的简单实现 pre in post ； 注意visit 指示表整一个意思在这，递归的代表！]]></content>
      <categories>
        <category>C++Go</category>
        <category>D.S.</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Keyboard‘s shortcut]]></title>
    <url>%2Fpost%2Fab73c629.html</url>
    <content type="text"><![CDATA[课时一 移动工具快捷键V 2.右键选择图层 第一个为当前选择图层 3.按住alt可以复制当前图层 4.多个图层可以生成一个图层组，当选择组时，可以同时移动一个组 5.显示变换控件，显示当前我们在移动哪个图层 6.对齐和分布 图层间关系和位置的调整，必须选择两个以上的图层 课时二 自由变换工具：Ctrl+T，用来改变图层位置大小。当使用自由变换时，它的xy轴会不停变换，执行完毕时 双击或者回车键 拉伸自由变换框上的节点可以改变图像的大小 按住shift键可以避免拖拽变形 shift+alt拖拽会以中心节点变换 半圆形的双箭头会改变它的角度 右键 斜切 扭曲 透视 变形 会改变图像的形状 翻转 旋转 都可以选择 移动作用：可以直接移动，可以按住Ctrl键移动。 退出操作可以点击Esc键。 shift+alt键，拖拽会以中心节点来变换图像。 单击右键，下拉菜单，有多种图片角度变换操作。 课时三 矩形选框工具 快键键：M 选区 对画面选择进行特定操作工作的区域 只改变本区域内的内容 取消选区 ctrl+d 反选：Ctrl+Shift+I 绘制正方形 按住shift 即可画出正方形 shift+alt 绘制出以鼠标为中心点的图形 羽化 令选区内外衔接的部分虚化达到渐变的效果 将鼠标放置于选区中心或按住空格键可以直接拖动选区 存储选区 可以单独存储下来事毕可以载入选区 剪切选区：可以剪切选区，从背景中脱离出来。 课时四 椭圆选框工具：M（和矩形选框工具相同） Ctrl+Delete 背景色填充 Alt+Delete 前景色填充 消除锯齿：椭圆选框工具可以用，边缘可以变得平缓，去掉锯齿。 调整边缘，可以帮助便于抠图。 按住空格键可以移动选区 用来抠图，调整边缘进行修改图，然后保存 课时五 套索工具 Lasso tool 快捷键L Move Tool 移动工具。 快捷键V Marquee tool 矩形选框工具。快捷键M 套索工具 快捷键：L 多边形套索工具：不规则区域 选区以直线连接的形式出现，更便于操作。 用放大镜把图片放大，按住Alt键，选择一个点，一点一点画出选区，选区以直线形式出现。同时配合空格键，改变位置。如果点不对，按delate键撤回。 选区回到开始的点，形成一个回路。 椭圆选框工具：快捷键：M 规则区域，功能95%与矩形工具类似。可用来抠图、选择、绘制 按住Shift，画出的是正圆 按住Shit，画的同时，配合空格键，可调整选区的位置。空格键移动选区的。 清除锯齿：可使选区的边缘更圆滑。 课时六 多边形套索工具 碧桃所工具功能强大。 属于做选区的一种工具，属于不规则区域的一种。 做出的选区以直线连接的形式出现，便于操作。 配合空格键使用，后悔了，按Delete键撤回，最终形成一个闭合回路，右键：调整边缘，输出到带有图层蒙版的图层，确定，即抠图成功。 课时七 磁性套索工具：比多边形套索工具功能更强大（自动确定锚点，无需点击鼠标进行选择。不能识别时，可以手动定位锚点，确定到我们想要的图像上，撤回选择 del 键即可。做选区时需要耐心，选区完毕后右键选择调整边缘，并且可以进行羽化。） 宽 度：锚点四周范围的大小 对比度：磁性套索工具对选区的反差，反差越大越精确。 频 率：锚点出现的频率，出现的频率越高，越精确。 拖动鼠标，会自动出现一些锚点，如果有的不能识别锚点，点击鼠标左键生成一个锚点。按住delate键撤销一个锚点，配合空格键，不要松开鼠标左键，改变方向。最后回到开始的点，形成一个闭合回路，点击鼠标左键，就可以形成想要的选区。 调整边缘：把叶子抠出来 属性栏：有3点不同，决定所做区域的效果 宽 度：做一个锚点，锚点四周范围的大小由宽度决定 范 围：0-40px 对比度：磁性套索工具对图像边缘的反差，反差越大，选区的范围越准确。 范 围：0-100 课时八 魔棒工具，工具栏第四个，做选区，不规则，不同是可以快速选区图像当中某一区域，而且它可以自动识别，点一下，可自动选区周围同一颜色的区域。 属性栏： 1、取样大小，指像素的大小，下拉菜单 2、容差，指用于控制的色彩范围，所选值越大，可选颜色的范围就越大 3、消除锯齿，是是选区周围边缘更圆滑 4、连续，指可以选区相邻的图像区域，开连续就只选点的周围连续的同一颜色区域，不开则是选择一个图像中与所点的颜色相同的所有区域。 5、对所有图层取样，有多几个图层，不开的时候，我们点选只对我们操作的图层起作用，开的话，对所有可见图层图像起作用 选择一个区域后，右键会出现一个下拉菜单： 1、添加到选区，即加选，配合取样点的值的改变可加选区域，意味着取样点像素的大小 2、从选区中减去，类上 3、交叉选区 4、扩大选区，扩大根据取样点的值改变 5、选取相似，类似与所选区域颜色的地方都会选中 6、取消选择（ctrl+D） 画笔选取器： 大小 可以调节画笔笔触的大小 硬度 羽化 硬度值越小 边缘越柔和 角度和圆度 调节笔触 自动增强 自动增强所选区域 课时九 快速选择工具 快捷键：W 魔棒工具的下拉菜单下，做选区，不规则，要做选区时，点击左键不松，然后移动鼠标，大致选中区域。 属性栏： 1、新选区 2、加选 3、减选，前三个，类似之前，不同的是不是箭头了是画笔 4、画笔选取器： 大小——单位像素，画笔笔触的大小； 硬度——与羽化的概念相似，硬度值越小，选区边缘越柔和； 间距——这一个选区与下一个选区间的距离； 角度、圆度——指笔触的角度和形状。 5、对所有图层取样，同上 6、自动增强，自动增强选区边缘； 取消选择：Ctrl+D 反选：Ctrl+shift+L; 在所选区上点击右键出下拉菜单也同上。 课时十 裁剪工具：C 工具箱第五项，用来裁剪图像，二次构图。 可以选择是否删除多余的像素。裁剪工具里面的网格也可以随意更换，设置网格的样式或有无。 裁剪工具有拉直功能，即画线，然后以该直线为基准，图片发生移动。 点击工具栏第五项后，图像周围就会框住，上面出现属性栏。 属性栏： 1.原始比例：根据所需设置裁剪画面的大小；点击清除取消设置；宽高分辨率—可以设置宽、高的厘米以及分辨率的数值下面是已设置的 ，也可以自己拖拉 2、拉直：矫正画面位置，用一条线调整需要拉直的画面，双击鼠标左键两下画面就裁剪成功。 3、设置裁剪工具的叠加选项，有下拉菜单，指我们想以什么样的形式（三等分、网格、黄金比例等）去裁图，辅助我们去裁图。 4、设置其他裁切选项，下拉菜单，可以选择裁剪方式，选择。 5.删除裁剪的像素：真假裁剪 课时十一 切片工具（C）：将大图像划分为小图像 一、属性栏： 1.样式 2.基于参考线的切片 二、功能（在切片上点击鼠标右键）： 1.删除切片 2.编辑切片选项 3.提升到用户切片 用户切片（我们手动划出的切片） 延伸切片（系统自动生成的切片） 4.划分切片、组合切片 5.置为顶层、前移一层、后移一层、置为底层 三、存储切片： “文件”—存储为Web格式—存储—格式选项“HTML和图像”—保存 url：为切片指定一个连接地址 目标：在哪个窗口中打开 信息文本：鼠标移上去后状态栏中显示的注释 art标记：当图片无法正常显示时的替换文字 XY：切片左上角的坐标 WH：切片的长度和宽度 课时十二 切片选择工具： 先切片工具做出一个选区，再选择切片选择工具，可以编辑切片。 快捷键：C 属性栏：置为顶层： 前移一层： 后移一层： 提升： 属性栏可以改变切片之间上下层的关系，当我们选择两个或以上的切片时菜可用（可以选择一个切片，按住shift键再选择另一个），但是至此上面三个工具仍未点亮，而是后面的“提升”亮了，原因是它们只适用于用户切片，对于衍生切片是无作用的，所以要将衍生切片变为用户切片，这时只需选择衍生切片，点击“提升”（或点击鼠标右键，选择“提升到用户切片”即完成变换，这是即可使用以上几项来改变位置。 1.改变切片上下层关系，针对用户切片，至少2个切片，提升后标签灰变蓝 衍生切片变成用户切片后（选中衍生切片，点击提升，变成用户切片。或者，鼠标右键，提升到用户切片），属性栏中的属性可被点亮使用。 2.划分切片 3.隐藏自动切片（自动切片=延伸切片） 4.切片选项，可以移动切片 课时十三 吸管工具（I）：绘制图像&amp;显示颜色信息 一、绘制图像设置前景色：点选颜色设置前景色：Alt+点选颜色 二、显示颜色信息 “窗口”—“信息”面板 三、属性栏：选取点：像素大小样本：图层选择显示取样环展开 按住Alt键，点选图片上任意颜色，则拾色器上显示对应背景颜色 新建图层快捷键：Shift + Ctrl +N 油漆桶快捷键：G 课时十四 颜色取样工具作用：辅助照片调节，防止高光或者暗部被过分调节。取点位置在高光和暗部，最多四个取样点。 调节色彩平衡：Control+B 曲线调节亮度：Control+M 调节色相和饱和度：Control+U 反向展开:Control+I 课时十五 标尺工具（I）—-属于吸管工具 使用：测量画面数据点击鼠标左键, X、Y代表起点的坐标轴，W宽，H高，A角度， L1线长， L2起点处+Alt+点击—拖动使用 测量比例：厘米换成像素改变标尺单位：“编辑”—“首选项”—“单位与标尺” 拉直图层：拉直图像中的斜线，图像会旋转展开 l2:alt＋测量另一条线的长度 标尺工具可以拉直图层展开 课时十六 污点修复画笔工具 快捷键：Z。—用来快速移除照片中的东西和其他不理想的地方。 模式：改变画笔产生特殊的效果 近似匹配：根据图像周围像素进行修复。 创建纹理：根据图像周围纹理自动创建一个相似纹理。 内容识别：根据周围像素智能识别现在的区域。展开 课时17 修复画笔工具Z 1. 按住Alt键点按来定义修复图像的源点；修复时，取样源出会出现”+”来提醒取样源位置 2. 画笔：大小，硬度，间距，角度+圆度 3. 切换仿制源面板：用于存储取样源，最多存储5个。 4. 取样： 在载入的图像上取样 5. 图案：将系统或自己载入的图案复制到图像上，图案颜色会被系统自动识别为图像相近颜色，只保留图案纹理 6. 对其：“+”十字光标会随着修复笔触移动，相对关系；不勾选是绝对关系 课时十八 修补工具 用一块画面的效果修补另一块画面的效果。 用别处需补此处，或用此处修补别处。 蚂蚁线选区 取消选取ctrl+D 源和目标的区别：勾选源——拖动选区，用别处修补此处。 勾选目标——拖动选区，用此处修补别处。 透明：只是修补一般的感觉，纹理之间会出现一些变化。 使用图案：选区变为图案的样子，系统会自动识别选取的原颜色。 课时十九 红眼工具：用来去除人眼中不正常的颜色 快捷键：j 切换工具：shift+j 选中红眼工具，调整瞳孔大小的值为50%，变暗量50%，点确定，看一下。如果不行再调。 瞳孔大小：调整的力度，越大调整的越多。 变暗量：是去除红眼位置的明暗度。 两者之间的关系，是相向的，配合使用。 课时二十 画笔工具、铅笔工具 【B】 1.画笔预设-&gt;预设管理器； 2.切换画笔面板； 3.流量-类似毛笔墨汁的多少，痕迹大小 课时二十一 画笔面板 大小抖动：控制画笔在绘制过程中，尺寸波动的幅度。 画笔笔尖形状：间距拉大，画出来直线由一个一个圆组成 形状动态有一下工具模块： 控制： 渐隐：逐渐消隐 最小直径：控制变化的范围 散布：控制画笔偏离时，绘制画笔的偏离程度。 两轴：在x 和 y 轴散布，不选在x轴 数量：值越大，画笔越稠密，值越小，画笔越稀疏 数量抖动：控制绘画时，画笔数量波动幅度。 纹理： 缩放：值越大，纹理越松散，值越小，纹理越密集 亮度：控制纹理的明暗度。 对比度：控制纹理的对比度 模式：纹理与画笔叠加的模式 深度：值越大，纹理效果越明显 最小深度：最浅浓度，值越大，显示波动越小。 深度抖动：纹理浓度波动的程度 双重画笔：画笔与画笔之间的混合效果。 颜色动态： 前景/背景抖动：值越大，越接近背景色，值越小，越接近前景色 色相抖动：值越大，越接近背景色，值越小，越接近前景色 纯度：明艳度 传递： 不透明度抖动：改变画笔的不透明度 画笔笔试：控制笔触效果。 杂色：画笔会添加一些杂点在上面 湿边：产生类似水珠的效果 建立:结合工具栏上的工具，点击会增大范围 平滑：使绘制出的线条平滑 保护纹理：将对所有有纹理的画笔预设应用，使他们有相同图案和笔触 课时二十二 铅笔工具 ctrl+N 新建 与画笔工具区别： 1.铅笔工具比画笔工具绘制出的图像边缘更粗糙 2.缩到最小，铅笔工具绘制出的图像远远清晰于画笔图像 3.铅笔工具没法改变硬度 自动抹除：勾选上，前景色代表画笔的颜色，若在前景色绘制的区域重复绘制会变成背景色。 课时二十三 &lt;颜色替换工具&gt;——将指定的颜色区域替换工具转换成特定的颜色； 1.模式——色相-颜色名称； 饱和度-鲜艳程度； 颜色=色相+饱和度； 明度-明暗程度； 2.Alt选色后涂选；（针对模式） 3.取样——连续：拖动时可以对颜色连续取样，所有颜色都被涂到； 一次：只替换第一次点按取样的颜色（按住鼠标左键不放拖动） 背景色板：只替换背景色的区域 3.限制——不连续，连续（距离鼠标最近的颜色区域，隔断不能替换）；查找边缘：增大锐化程度。 课时二十四 &lt;混合器画笔工具&gt;—— 画面颜色与指定颜色混合 或 可以将画面的颜色进行混合 1.画笔载入 ： 指定颜色混合；(点击鼠标左键拖) 2.载入、清理、只载入纯色-Alt点击取样 避免 —（包括颜色和图案） 3.每次描边后载入画笔 ： 不然自动变透明 4.每次描边后清理画笔（画笔载入 状态下） ： 保持纯色—保证画笔清洁度 5.潮湿—画布所取的油彩量；载入—混合器的油彩量；混合 ： 即混合比例=潮湿+载入]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SublimeAdragon_primary]]></title>
    <url>%2Fpost%2F40a1ebd1.html</url>
    <content type="text"><![CDATA[Ctrl+D，Ctrl+Alt+A 然后按Cmd-Shift-v (Win: Ctrl-Shift-v) 进行自适应缩进的粘贴：自适应缩进的复制粘贴 Command，Control - -Ctrl Emmet 多处编辑功能： Ps：这个功能至关重要，我都不敢回想接触 Sublime Text 以前是怎么活过来的。 Ctrl + F 调出查找功能、Ctrl + Shift + F 调出查找并替换功能应该不用讲了。 [转自互联网dada]——————————————License 接下来教大家如何注册破解Sublime Text 2.0.2。 复制代码如下：（32、64位通用） ——- BEGIN LICENSE ——- Andrew Weber Single User License EA7E-855605 813A03DD 5E4AD9E6 6C0EEB94 BC99798F 942194A6 02396E98 E62C9979 4BB979FE 91424C9D A45400BF F6747D88 2FB88078 90F5CC94 1CDC92DC 8457107A F151657B 1D22E383 A997F016 42397640 33F41CFC E1D0AE85 A0BBD039 0E9C8D55 E1B89D5D 5CDB7036 E56DE1C0 EFCC0840 650CD3A6 B98FC99C 8FAC73EE D2B95564 DF450523 ——— END LICENSE ——— 在打开的页面中就能看到 Sublime Text 3 和 Sublime Text 2 的安装代码。 ==========Sublime Text 3========== import urllib.request,os,hashlib; h = pf2297e1a458f27d836c04bb0cbaf282’ + ‘d0e7a3098092775ccb37ca9d6b2e4b7d’; pf = ‘Package Control.sublime-package’; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( ‘http://packagecontrol.io/‘ + pf.replace(‘ ‘, ‘%20’)).read(); dh = hashlib.sha256(by).hexdigest(); print(‘Error validating download (got %s instead of %s), please try manual install’ % (dh, h)) if dh != h else open(os.path.join( ipp, pf), ‘wb’ ).write(by) ==========Sublime Text 2========== import urllib2,os,hashlib; h = ‘eb2297e1a458f27d836c04bb0cbaf282’ + ‘d0e7a3098092775ccb37ca9d6b2e4b7d’; pf = ‘Package Control.sublime-package’; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( ‘http://packagecontrol.io/‘ + pf.replace(‘ ‘, ‘%20’)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), ‘wb’ ).write(by) if dh == h else None; print(‘Error validating download (got %s instead of %s), please try manual install’ % (dh, h) if dh != h else ‘Please restart Sublime Text to finish installation’) （Ctrl+~ 打开控制台） ——若安装错误： 打开sublime，选择Preferences &gt; Browse Packages 返回到文件夹上一级，进入Installed Packages 删除 Package Control.sublime-package 重新安装package contro Ctrl+Shift+P 调出 Preference—package control — Install package 直接安装 1/如果不想通过Package Control，也可以直接下载好想要的插件，然后打开菜单栏里的“Preferences”—-&gt;”Browse Packages”，打开包的位置 2/然后将下载的好插件直接放置到Packages目录，重启Sublime Text3 插件就会安装成功了。 TAG插件—http://download.csdn.net/detail/ni_cu/7944965 Emmet添加web前端css的代码神器！ 初始化比如输入“!”或“html:5”，然后按Tab键： html:5 或!：用于HTML5文档类型 html:xt：用于XHTML过渡文档类型 html:4s：用于HTML4严格文档类型 轻松添加类、id、文本和属性：“.”class；“#”id。 1.p.bar#foo，会自动生成： Html代码 2.通过输入h1{foo}和a[href=#] 1.foo 2. 3. 嵌套 现在你只需要1行代码就可以实现标签的嵌套。 ：子元素符号，表示嵌套的元素 +：同级标签符号 ^：可以使该符号前的标签提升一行 效果如下图所示： 4. 分组 你可以通过嵌套和括号来快速生成一些代码块，比如输入(.foo&gt;h1)+(.bar&gt;h2)，会自动生成如下代码： Html代码 &lt;/div&gt; &lt;/div&gt; 5. 隐式标签 声明一个带类的标签，只需输入div.item，就会生成。 在过去版本中，可以省略掉div，即输入.item即可生成。现在如果只输入.item，则Emmet会根据父标签进行判定。比如在中输入.item，就会生成。 下面是所有的隐式标签名称： li：用于ul和ol中 tr：用于table、tbody、thead和tfoot中 td：用于tr中 option：用于select和optgroup中 6. 定义多个元素 要定义多个元素，可以使用符号。比如，ul&gt;li3可以生成如下代码： Html代码 &lt;/ul&gt; 7. 定义多个带属性的元素 如果输入 ul&gt;li.item$*3，将会生成如下代码： Html代码 &lt;/ul&gt; 【转http://www.iteye.com/news/27580】 MORE——————最后面—— Alignment 等号对齐//有些鸡肋按Ctrl+Alt+A，可以是凌乱的代码以等号为准左右对其，适合有代码洁癖的朋友。 插件下载： https://github.com/kevinsperrine/sublime_alignment/tree/python3 可以用自带的——设置好快捷键就行了！打开Sublime软件 PreFerences —-&gt; Key Bindings -User 如图添加下面代码:{“keys”: [“alt+shift+f”], “command”: “reindent”}其中 alt+shift+f 是我自己定义的 你可以定义任意的快捷键 但是不要和系统的快捷键有冲突系统的快捷键查看 PreFerences —-&gt; Key Bindings - Default然后保存 就可以了然后你可以选中的要格式的代码 在按你的快捷键 就可以轻松实现格式化代码了 Clipboard-history 粘贴板历史记录有了这个插件，便可方便使用sublime text 3里的粘贴板历史记录内容，快捷键Ctrl+Shift+V可调出该历史记录面板，按方向键选择想要粘贴的历史记录。不过这是sublime text 2下的插件，Ctrl+Shift+D清除粘贴板历史记录好像不能生效，不过重启sublime也可清除粘贴板的历史记录。 插件下载： https://github.com/kemayo/sublime-text-2-clipboard-history Sublime CodeIntel代码自动提示 /* Features ————Supports all the languages Komodo Editor supports for Code Intelligence (CIX, CodeIntel2): JavaScript, Mason, XBL, XUL, RHTML, SCSS, Python, HTML, Ruby, Python3, XML, Sass, XSLT, Django, HTML5, Perl, CSS, Twig, Less, Smarty, Node.js, Tcl, TemplateToolkit, PHP. Provides the following features: Jump to Symbol Definition - Jump to the file and line of the definition of a symbol. Imports autocomplete - Shows autocomplete with the available modules/symbols in real time. Function Call tooltips - Displays information in the status bar about the working function. + Shortcuts for jump to definition have changed: For Mac OS X: Jump to definition = ``Control+Click`` Jump to definition = ``Control+Command+Alt+Up`` Go back = ``Control+Command+Alt+Left`` Manual CodeIntel = ``Control+Shift+space`` For Linux: Jump to definition = ``Super+Click`` Jump to definition = ``Control+Super+Alt+Up`` Go back = ``Control+Super+Alt+Left`` Manual CodeIntel = ``Control+Shift+space`` For Windows: Jump to definition = ``Alt+Click`` Jump to definition = ``Control+Windows+Alt+Up`` Go back = ``Control+Windows+Alt+Left`` Manual CodeIntel = ``Control+Shift+space`` Notes ——- Restart Sublime Text after reading this / SublimeLinter一个支持lint语法的插件，可以高亮linter认为有错误的代码行，也支持高亮一些特别的注释，比如“TODO”，这样就可以被快速定位。（IntelliJ IDEA的TODO功能很赞，这个插件虽然比不上，但是也够用了吧） BracketHighlighter高亮显示匹配的括号、引号和标签BracketHighlighter这个插件能在左侧高亮显示匹配的括号、引号和标签，能匹配的[] , () , {} , “” , ‘’ , 等甚至是自定义的标签，当看到密密麻麻的代码分不清标签之间包容嵌套的关系时，这款插件就能很好地帮你理清楚代码结构，快速定位括号，引号和标签内的范围。 插件下载： https://github.com/facelessuser/BracketHighlighter/tree/BH2ST3 ColorPicker通常，如果你想使用一个颜色选择器则可能打开 Photoshop 或 GIMP。而在 Sublime Text 中，你可以使用内置的颜色选择器。安装完成后，只要按下Ctrl / Cmd + Shift + C 快捷键。 ZenCoding 不得不用的一款前端开发方面的插件，Write less , show more.安装后可直接使用，Tab键触发，Alt+Shift+W是个代码机器。 Prefixr 写 CSS可自动添加 -webkit 等私有词缀，Ctrl+Alt+X触发。 Tag Html格式化，右键Auto-Format Tags on Ducument。一般是用ctrl +Alt +F 触发，若触发不了，查看是不是html文件，是否选中，是否有快捷键冲突！ Theme – Soda 完美的编码主题，用过的都说好，Setting user里面添加”theme”: “Soda Dark.sublime-theme” GBK to UTF8 将文件编码从GBK转黄成UTF8，菜单 – File里面找 SFTP 直接编辑 FTP 或 SFTP 服务器上的文件，绝对FTP浮云 WordPress 集成一些WordPress的函数，对于像我这种经常要写WP模版和插件的人特别有用 PHPTidy 整理排版PHP代码 YUI Compressor 压缩JS和CSS文件 Ctags 函数跳转，我的电脑上是Alt+点击 函数名称，会跳转到相应的函数 DocBlockr 注释插件，生成幽美的注释。标准的注释，包括函数名、参数、返回值等，并以多行显示，省去手动编写。 ftpsync FTP ssh上传配置，安装成功配置一下host等就可以了！ ======前端神器 SideBarEnhancements**侧边栏增强**SideBarEnhancements本是增强侧边栏的插件，这里将教大家如何用来做sublime text 3浏览器预览插件，并可自定义浏览器预览的快捷键。 安装此插件，点击工具栏的preferences &gt; package setting &gt; side bar &gt; Key Building-User，键入以下代码，这里设置按Ctrl+Shift+C复制文件路径，按F1~F5分别在firefox，chrome，IE，safari，opera浏览器预览效果，当然你也可以自己定义喜欢的快捷键，最后注意代码中的浏览器路径要以自己电脑里的文件路径为准。 [ { “keys”:[“ctrl+shift+c”], “command”:”copy_path”}, //firefox { “keys”:[“f1”], “command”:”side_bar_files_open_with”, “args”:{ “paths”:[], “application”:”C:\\\software\\\Browser\\\Mozilla Firefox\\\firefox.exe”, “extensions”:”.“//匹配任何文件类型 }}, //chrome { “keys”:[“f2”], “command”:”side_bar_files_open_with”, “args”:{ “paths”:[], “application”:”C:\\\Users\\\Mr.DenGo\\\AppData\\\Local\\\Google\\\Chrome\\\Application\\\chrome.exe”, “extensions”:”.“}}, //ie { “keys”:[“f3”], “command”:”side_bar_files_open_with”, “args”:{ “paths”:[], “application”:”C:\\\Program Files\\\Internet Explorer\\\iexplore.exe”, “extensions”:”.“}}, //safari { “keys”:[“f4”], “command”:”side_bar_files_open_with”, “args”:{ “paths”:[], “application”:”C:\\\software\\\Browser\\\Safari\\\safari.exe”, “extensions”:”.“}}, //opera { “keys”:[“f5”], “command”:”side_bar_files_open_with”, “args”:{ “paths”:[], “application”:”C:\\\software\\\Browser\\\opera\\\opera.exe”, “extensions”:”.“}}] *语法及标签缩写方法如下： 后代：&gt;缩写：nav&gt;ul&gt;li 兄弟：+缩写：div+p+bq #### 上级：^ **缩写**：div+div>p>span+em^bq 缩写：div+div&gt;p&gt;span+em^^bq #### 分组：() **缩写**：div>(header>ul>li*2>a)+footer>p 缩写：(div&gt;dl&gt;(dt+dd)*3)+footer&gt;p #### 乘法：* **缩写**：ul>li*5 #### 自增符号：$ **缩写**：ul>li.item$*5 **缩写**：h$\[title=item$\]{Header $}*3 Header 1 Header 2 Header 3 **缩写**：ul>li.item$$$*5 **缩写**：ul>li.item$@-*5 **缩写**：ul>li.item$@3*5 #### ID和类属性 **缩写**：#header 缩写：.title 缩写：form#search.wide 缩写：p.class1.class2.class3 自定义属性缩写：p[title=”Hello world”] 缩写：td[rowspan=2 colspan=3 title] 缩写：[a=’value1’ b=”value2”] 文本：{}缩写：a{Click me} Click me 缩写：p&gt;{Click }+a{here}+{ to continue} Click here to continue 隐式标签缩写：.class 缩写：em&gt;.class 缩写：ul&gt;.class 缩写：table&gt;.row&gt;.col HTML_所有未知的缩写都会转换成标签，例如，foo → _ 缩写：! &lt;!doctype html&gt; Document 缩写：a 缩写：a:link 缩写：a:mail 缩写：abbr 缩写：acronym 缩写：base 缩写：basefont 缩写：br 缩写：frame 缩写：hr 缩写：bdo 缩写：bdo:r 缩写：bdo:l 缩写：col 缩写：link 缩写：link:css 缩写：link:print 缩写：link:favicon 缩写：link:touch 缩写：link:rss 缩写：link:atom 缩写：meta 缩写：meta:utf 缩写：meta:win 缩写：meta:vp 缩写：meta:compat 缩写：style 缩写：script 缩写：script:src 缩写：img 缩写：iframe 缩写：embed 缩写：object 缩写：param 缩写：map 缩写：area 缩写：area:d 缩写：area:c 缩写：area:r 缩写：area:p 缩写：form 缩写：form:get 缩写：form:post 缩写：label 缩写：input 缩写：inp 缩写：input:hidden _别名：input[type=hidden name]_ 缩写：input:h _别名：input:hidden_ 缩写：input:text, input:t _别名：inp_ 缩写：input:search _别名：inp[type=search]_ 缩写：input:email _别名：inp[type=email]_ 缩写：input:url _别名：inp[type=url]_ 缩写：input:password _别名：inp[type=password]_ 缩写：input:p _别名：input:password_ 缩写：input:datetime _别名：inp[type=datetime]_ 缩写：input:date _别名：inp[type=date]_ 缩写：input:datetime-local _别名：inp[type=datetime-local]_ 缩写：input:month _别名：inp[type=month]_ 缩写：input:week _别名：inp[type=week]_ 缩写：input:time _别名：inp[type=time]_ 缩写：input:number _别名：inp[type=number]_ 缩写：input:color _别名：inp[type=color]_ 缩写：input:checkbox _别名：inp[type=checkbox]_ 缩写：input:c _别名：input:checkbox_ 缩写：input:radio _别名：inp[type=radio]_ 缩写：input:r _别名：input:radio_ 缩写：input:range _别名：inp[type=range]_ 缩写：input:file _别名：inp[type=file]_ 缩写：input:f _别名：input:file_ 缩写：input:submit 缩写：input:s _别名：input:submit_ 缩写：input:image 缩写：input:i _别名：input:image_ 缩写：input:button 缩写：input:b _别名：input:button_ 缩写：isindex 缩写：input:reset _别名：input:button[type=reset]_ 缩写：select 缩写：option 缩写：textarea 缩写：menu:context _别名：menu[type=context]&gt;_ 缩写：menu:c _别名：menu:context_ 缩写：menu:toolbar _别名：menu[type=toolbar]&gt;_ 缩写：menu:t _别名：menu:toolbar_ 缩写：video 缩写：audio 缩写：html:xml 缩写：keygen 缩写：command 缩写：bq _别名：blockquote_ 缩写：acr _别名：acronym_ 缩写：fig _别名：figure_ 缩写：figc _别名：figcaption_ 缩写：ifr _别名：iframe_ 缩写：emb _别名：embed_ 缩写：obj _别名：object_ 缩写：src _别名：source_ 缩写：cap _别名：caption_ 缩写：colg _别名：colgroup_ 缩写：fst, fset _别名：fieldset_ 缩写：btn _别名：button_ 缩写：btn:b _别名：button[type=button]_ 缩写：btn:r _别名：button[type=reset]_ 缩写：btn:s _别名：button[type=submit]_ 本文内容来自互联网整理，原文链接：http://www.w3cplus.com/tools/emmet-cheat-sheet.html http://www.iteye.com/news/27580 感谢原创作者分享。]]></content>
      <categories>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javastatic顶级类_TimeZhouSomething]]></title>
    <url>%2Fpost%2F25a08695.html</url>
    <content type="text"><![CDATA[一个”.Java”源文件中是否可以包括多个类？ 是的。 一个”.java”源文件中是否可以包括多个public修饰的类？ 可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。我说的是不包括内部类，因为内部类可 以被public修饰，所以在不包括内部类的情况下一个类中只能有一个类被public修饰符修饰。 这是内部类的情况： Java代码 public class Hello { int a = 2; public static void main(String[] args) { new Hello().new newHello().count(); } public class newHello { public void count() { new Hello().a = 1; System.out.println(“aaa”); } } } 这也是内部类的情况： Java代码 public class Hello { int a = 2; public static void main(String[] args) { new Hello().new newHello().count(); } protected class newHello { public void count() { new Hello().a = 1; System.out.println(“aaa”); } } } 这是静态内部类： Java代码 public class Hello { static int a = 2; public static void main(String[] args) { new newHello().count(); // new Hello().new newHello().count(); // System.out.println(new Hello().new newHello().b); System.out.println(new newHello().b); } public static class newHello { int b = 3; public void count() { System.out.println(a); } } } 这是外部类的情况: Java代码 public class Hello { int a = 2; public static void main(String[] args) { new Hello().new newHello().count(); System.out.println(new Hello().new newHello().b); } public class newHello { int b = 3; public void count() { System.out.println(a); } } } class Hello2 { public void test() { System.out.println(new Hello().a); System.out.println(new Hello().a); } } 总结： 与.java文件名相同的类是顶级类，顶级类里面的类是内部类，内部类可以被修饰符修饰。 顶级类以外的类不可以被修饰符修饰。 顶级类通过本身对象.内部类对象.属性或者方法调用内部类属性方法。 内部类可以直接用顶级类里面的全局变量。 静态内部类相当于一个单独的类。调用是通过对象调用的。 本文转自：http://woshixushigang.iteye.com/blog/1149013 一个嵌套顶级类不能访问任何外部类的实例成员（即所有的非静态字段和非静态方法）。 使用嵌套顶级类，你不可以访问外部类的实例字段或者调用该类的实例方法。要访问实例成员，Java支持内部类。内部类和嵌套顶级类相似，不同的地方是你不会在内部内的声明前加上static关键字。我们以下就讨论一下内部类，先从实例内部类开始 当你在其它类的外面声明一个类时，Java就认为该类是一个顶级类。如果你在一个顶级类中声明一个类，并且在该嵌套类的声明前加上static的修饰符，你就得到了一个嵌套顶级类。以下的代码段声明了一个顶级类和一个嵌套顶级类：class TopLevelClass{static class NestedTopLevelClass{}}]]></content>
      <categories>
        <category>Java</category>
        <category>JavaPrimary</category>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[D.S.BinarySearchTree||Pre，In，Post Order）&&InYin]]></title>
    <url>%2Fpost%2F50ec8655.html</url>
    <content type="text"><![CDATA[注意结合二叉树： Pre，In，Post Order 利用：return || 递归倒序思考 || 或者 建立后从前到后处理！！！ template void BinaryTree::PreOrder( BinTreeNode subTree,void( \visit )(BinTreeNode *p ) ){ if( subTree != NULL ){ visit( subTree ); PreOrder( subTree-&gt;leftChild ,visit); PreOrder( subTree-&gt;rightChild,visit ); }}template void BinaryTree::InOrder( BinTreeNode subTree,void( \visit )(BinTreeNode *p ) ){//中序遍历以 subTree为根的子树 if( subTree != NULL ) { InOrder( subTree-&gt;leftChild,visit ); visit(subTree); InOrder( subTree-&gt;rightChild,visit ); }}template void BinaryTree::PostOrder( BinTreeNode subTree,void( \visit )(BinTreeNode *p ) ){ if( subTree != NULL ) { PostOrder( subTree-&gt;leftChild,visit ); PostOrder( subTree-&gt;rightChild,visit ); visit( subTree ); }} 后序遍历的应用： template int BinaryTree::Size( BinTreeNode* subTree ) const{//计算以 subTree 为根的二叉树的的结点个数 if( subTree == NULL ) return 0; else return 1 + Size( subTree-&gt;leftChild ) + Size( subTree-&gt;rightChild );}//+Height 前序遍历的应用： template BinTreeNode BinaryTree::Copy( BinTreeNode orignode ){//给出一个 以origin为根的二叉树的副本 if( orignode == NULL ) return NULL; BinTreeNode temp = new BinTreeNode; temp-&gt;data = orignode-&gt;data; temp-&gt;leftChild = Copy( orignode-&gt;leftChild ); temp-&gt;rightChild = Copy( orignode-&gt;rightChild ); return temp;}template int operator==( const BinaryTree&amp; s, const BinaryTree&amp; t ){ return ( equal( s.root,t.root ) ) ? true :false ;}template bool equal( BinTreeNode a,BinTreeNode b ){ if( a == NULL &amp;&amp; b == NULL ) return true; else if( a != NULL &amp;&amp; b != NULL &amp;&amp; a-&gt;data ==b-&gt;data &amp;&amp; equal(a-&gt;leftChild ,b-&gt;leftChild ) &amp;&amp; equal( a-&gt;rightChild,b-&gt;rightChild ) ) return true; else return false;}template void BinaryTree::CreateBinTree( istream&amp; in,BinTreeNode &amp; subTree){ T item; if( !in.eof() ) { in &gt;&gt; item; if( item != RefValue ){ subTree = new BinTreeNode; subTree-&gt;data = item; if ( subTree == NULL ){ cerr &lt;&lt; “ 存储分配错误！ “ &lt;&lt; endl;exit(1); } CreateBinTree( in,subTree-&gt;leftChild ); CreateBinTree( in,subTree-&gt;rightChild ); } else subTree == NULL; }}template void PrintBTree(BinTreeNode BT){// 以广义表的形式输出二叉树的算法 if( BT != NULL ){ cout &lt;&lt; BT-&gt;data; if( BT-&gt;leftChild != NULL || BT-&gt;rightChild != NULL ){ cout &lt;&lt; “(“; PrintBTree(BT-&gt;leftChild); cout &lt;&lt; “,”; PrintBTree(BT-&gt;rightChild); cout &lt;&lt; “)”; } }}int main(){ //BinTreeNode root; //istream in; BinaryTree testNone; //Errorz! testNone.CreateBinTree( root ); cin &gt;&gt; testNone; cout &lt;&lt; “录入完成！” &lt;&lt; endl; PrintBTree(testNone.getRoot()); cout &lt;&lt; “Hello world!” &lt;&lt; endl; return 0;} 递归是一种算法结构，回溯是一种算法思想 一个递归就是在函数中调用函数本身来解决问题 回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”，意思就是对已经知道错误的结果没必要再枚举接下来的答案了，比如一个有序数列1,2,3,4,5，我要找和为5的所有集合，从前往后搜索我选了1，然后2，然后选3 的时候发现和已经大于预期，那么4,5肯定也不行，这就是一种对搜索过程的优化。]]></content>
      <categories>
        <category>C++Go</category>
        <category>D.S.</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Weiss‘s &&临时构造变量！]]></title>
    <url>%2Fpost%2Fa080f466.html</url>
    <content type="text"><![CDATA[1，最通用的模板交换函数模式：创建临时对象，调用对象的赋值操作符。 template void swap ( T&amp; a, T&amp; b ) { T c(a); a=b; b=c; } 需要构建临时对象，一个拷贝构造，两次赋值操作。 临时对象相关C++中的临时对象（拷贝构造函数）（一）我们知道在C++的创建对象是一个费时，费空间的一个操作。有些固然是必不可少，但还有一些对象却在我们不知道的情况下被创建了。通常以下三种情况会产生临时对象： 1，以值的方式给函数传参； 2，类型转换； 3，函数需要返回一个对象时； 现在我们依次看这三种情况： 一，以值的方式给函数传参。 我们知道给函数传参有两种方式。1，按值传递；2，按引用传递。按值传递时，首先将需要传给函数的参数，调用拷贝构造函数创建一个副本，所有在函数里的操作都是针对这个副本的，也正是因为这个原因，在函数体里对该副本进行任何操作，都不会影响原参数。我们看以下例子： #include class CTemp { public: int a; int b; public: CTemp(CTemp&amp; t){ printf(“Copy function!\\n”);a = t.a;b = t.b;}; CTemp(int m = 0,int n = 0); virtual ~CTemp(){}; public: int GetSum(CTemp ts); }; CTemp::CTemp(int m , int n) { printf(“Construct function!\\n”); a = m;b=n; printf(“a = %d\\n”,a); printf(“b = %d\\n”,b); } int CTemp::GetSum(CTemp ts) { int tmp = ts.a + ts.b; ts.a = 1000; //此时修改的是tm的一个副本 return tmp; } //———————Main函数————————- void main() { CTemp tm(10,20); printf(“Sum = %d \\n”,tm.GetSum(tm)); printf(“tm.a = %d \\n”,tm.a); } ———————————————————————————— Output: Construct function! a = 10 b = 20 Copy function! Sum = 30 tm.a = 10 ——————————————————————————— 我们看到有调用了拷贝构造函数，这是tm在传给GetSum做参数时： 1，调用拷贝构造函数来创建一个副本为GetSum函数体内所用。 2，在GetSum函数体内对tm副本进行的修改并没有影响到tm本身。 解决办法： 针对第一种情况的解决办法是传入对象引用(记住：引用只是原对象的一个别名(Alias))，我们将GetSum代码修改如下： int CTemp::GetSum(CTemp&amp; ts) { int tmp = ts.a + ts.b; ts.a = 1000; //此时通过ts这个引用参考(refer to)对象本身 return tmp; } ————————————————————————————— Output: Construct function! a = 10 b = 20 Sum = 30 tm.a = 1000 ———————————————————————————— 可以通过输出看本，通过传递常量引用，减少了一次临时对象的创建。这个改动也许很小，但对多继承的对象来说在构建时要递归调用所有基类的构造函数，这对于性能来说是个很大的消耗，而且这种消耗通常来说是没有必要的。 二，类型转换生成的临时对象。 我们在做类型转换时，转换后的对象通常是一个临时对象。编译器为了通过编译会创建一起我们不易察觉的临时对象。再次修改如上main代码： void main() { CTemp tm(10,20),sum; sum = 1000; //调用CTemp(int m = 0,int n = 0)构造函数 printf(“Sum = %d \\n”,tm.GetSum(sum)); } C++中的临时对象（拷贝构造函数）（二）三，函数返回一个对象。 当函数需要返回一个对象，他会在栈中创建一个临时对象，存储函数的返回值。看以下代码: #include &lt;stdio.h&gt; class CTemp { public: int a; public: CTemp(CTemp&amp; t) //Copy Ctor! { printf(&quot;Copy Ctor!\\n&quot;); a = t.a; }; CTemp&amp; operator=(CTemp&amp; t) //Assignment Copy Ctor! { printf(&quot;Assignment Copy Ctor!\\n&quot;); a = t.a; return \*this; } CTemp(int m = 0); virtual ~CTemp(){}; }; CTemp::CTemp(int m) //Copy Ctor! { printf(&quot;Construct function!\\n&quot;); a = m; printf(&quot;a = %d\\n&quot;,a); } CTemp Double(CTemp&amp; ts) { CTemp tmp; //构建一个临时对象 tmp.a = ts.a\*2; return tmp; } //-------------Main函数----------------- void main() { CTemp tm(10),sum; printf(&quot;\\n\\n&quot;); sum = Double(tm); printf(&quot;\\n\\nsum.a = %d \\n&quot;,sum.a); } --------------------------------------------------------- Output: Construct function! a = 10 Construct function! a = 0 Construct function! a = 0 Copy Ctor! Assignment Copy Ctor! sum.a = 20 -------------------------------------------------------- 我特地加宽了语句: sum = Double(tm); 这条语句竟生成了两个对象，Horrible! 我们现在将这条语句逐步分解一下： 1,我们显式创建一个tmp临时对象, 语句：CTemp tmp; 2,将temp对象返回，返回过程中调用Copy cotr创建一个返回对象, 语句：return tmp; 3,将返回结果通过调用赋值拷贝函数,赋给sum 语句: sum = 函数返回值;(该步并没有创建对象，只是给sum赋值) tm.Double返回一个用拷贝构造函数生成的临时对象，并用该临时对象给sum赋值. 上面的第1步创建对象可以不用创建，我们可以直接对返回值进行操作，有些C++编译器中会有一种优化，叫做(NRV,named return value).不过本人使用的VC++6.0并没有这个启用这个优化。 第2步创建的返回对象是难以避免的，你或许想可以返回一个引用，但你别忘记了在函数里创建的局部对象，在返回时就被销毁了。这时若再引用该对象会产生未预期的行为。(C#中解决了这个问题)。 解决方法： 我们将对象直接操作(Manipulate)返回对象,再结合上面的减少临时对象的方法，将函数Double的代码，及main函数中的代码修改如下： CTemp Double(CTemp&amp; ts) { return ts.a*2; } //---------Main函数----------- void main() { CTemp tm(10); printf(&quot;\\n\\n&quot;); CTemp sum = Double(tm); printf(&quot;\\n\\nsum.a = %d \\n&quot;,sum.a); } -------------------------------------------------------- Output: Construct function! a = 10 Construct function! a = 20 sum.a = 20 ------------------------------------------------------- 发现减少了一次构造函数调用(tmp)，一次拷贝构造函数(tmp拷贝给返回对象)调用和一次赋值拷贝函数调用.(Assignment Copy Ctor),这是因为： 返回对象直接使用为sum预留的空间，所以减少了返回临时对象的生成——返回对象即是sum，返回对象的创建即是sum对象的创建.多么精妙!]]></content>
      <categories>
        <category>C++Go</category>
        <category>D.S.</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[转]Java传值与传引用]]></title>
    <url>%2Fpost%2F3cc73f06.html</url>
    <content type="text"><![CDATA[1. 简单类型是按值传递的 Java方法的参数是简单类型的时候，是按值传递的 (pass by value)。这一点我们可以通过一个简单的例子来说明： [java] view plain copy print? /例 1 / /** @(#) Test.java @author fancy */ public class Test { public static void test(boolean test) { test = ! test; System.out.println(“In test(boolean): test = “ + test); } public static void main(String[] args) { boolean test = true; System.out.println(“Beforetest(boolean) : test = “ + test); test(test); System.out.println(“Aftertest(boolean) : test = “ + test); } } 运行结果： [plain] view plain copy print? Beforetest(boolean) : test = true In test(boolean) : test = false After test(boolean) : test = true 不难看出，虽然在 test(boolean) 方法中改变了传进来的参数的值，但对这个参数源变量本身并没有影响，即对 main(String[]) 方法里的 test 变量没有影响。那说明，参数类型是简单类型的时候，是按值传递的。以参数形式传递简单类型的变量时，实际上是将参数的值作了一个拷贝传进方法函数的，那么在方法函数里再怎么改变其值，其结果都是只改变了拷贝的值，而不是源值。 2. 什么是引用 Java是传值还是传引用，问题主要出在对象的传递上，因为 Java 中简单类型没有引用。既然争论中提到了引用这个东西，为了搞清楚这个问题，我们必须要知道引用是什么。 简单的说，引用其实就像是一个对象的名字或者别名 (alias)，一个对象在内存中会请求一块空间来保存数据，根据对象的大小，它可能需要占用的空间大小也不等。访问对象的时候，我们不会直接是访问对象在内存中的数据，而是通过引用去访问。引用也是一种数据类型，我们可以把它想象为类似 C 语言中指针的东西，它指示了对象在内存中的地址——只不过我们不能够观察到这个地址究竟是什么。 如果我们定义了不止一个引用指向同一个对象，那么这些引用是不相同的，因为引用也是一种数据类型，需要一定的内存空间来保存。但是它们的值是相同的，都指示同一个对象在内存的中位置。比如 [java] view plain copy print? Stringa = “Hello”; String b = a; 这里，a和 b 是不同的两个引用，我们使用了两个定义语句来定义它们。但它们的值是一样的，都指向同一个对象”Hello”。也许你还觉得不够直观，因为 String 对象的值本身是不可更改的 (像 b = “World”; b = a; 这种情况不是改变了 “World” 这一对象的值，而是改变了它的引用b 的值使之指向了另一个 String 对象 a)。那么我们用 StringBuffer 来举一个例子： [java] view plain copy print? /例 2 / /** @(#) Test.java @author fancy */ public class Test { public static void main(String[] args) { StringBuffer a = newStringBuffer(“Hello”); StringBuffer b = a; b.append(“, World”); System.out.println(“a is “+ a); } } 运行结果： [java] view plain copy print? ais Hello, World 这个例子中 a 和 b 都是引用，当改变了 b 指示的对象的值的时候，从输出结果来看，a 所指示的对象的值也改变了。所以，a 和b 都指向同一个对象即包含 “Hello” 的一个 StringBuffer 对象。 这里我描述了两个要点： 引用是一种数据类型，保存了对象在内存中的地址，这种类型即不是我们平时所说的简单数据类型也不是类实例(对象)； 不同的引用可能指向同一个对象，换句话说，一个对象可以有多个引用，即该类类型的变量。 3. 对象是如何传递的呢 关于对象的传递，有两种说法，即“它是按值传递的”和“它是按引用传递的”。这两种说法各有各的道理，但是它们都没有从本质上去分析，即致于产生了争论。 既然现在我们已经知道了引用是什么东西，那么现在不妨来分析一下对象作是参数是如何传递的。还是先以一个程序为例： [java] view plain copy print? /例 3 / /** @(#) Test.java @author fancy */ public class Test { public static void test(StringBuffer str) { str.append(“, World!”); } public static void main(String[] args) { StringBuffer string = newStringBuffer(“Hello”); test(string); System.out.println(string); } } 运行结果： [java] view plain copy print? Hello,World! test(string)调用了 test(StringBuffer) 方法，并将 string 作为参数传递了进去。这里 string 是一个引用，这一点是勿庸置疑的。前面提到，引用是一种数据类型，而且不是对象，所以它不可能按引用传递，所以它是按值传递的，它么它的值究竟是什么呢？是对象的地址。 由此可见，对象作为参数的时候是按值传递的，对吗？错！为什么错，让我们看另一个例子： [java] view plain copy print? /例 4 / /** @(#) Test.java @author fancy */ public class Test { public static void test(String str) { str = “World”; } public static void main(String[] args) { String string = “Hello”; test(string); System.out.println(string); } } 运行结果： [plain] view plain copy print? Hello 为什么会这样呢？因为参数 str 是一个引用，而且它与 string 是不同的引用，虽然它们都是同一个对象的引用。str= “World” 则改变了 str 的值，使之指向了另一个对象，然而 str 指向的对象改变了，但它并没有对 “Hello” 造成任何影响，而且由于 string 和 str 是不同的引用，str 的改变也没有对 string 造成任何影响，结果就如例中所示。 其结果是推翻了参数按值传递的说法。那么，对象作为参数的时候是按引用传递的了？也错！因为上一个例子的确能够说明它是按值传递的。 结果，就像光到底是波还是粒子的问题一样，Java 方法的参数是按什么传递的问题，其答案就只能是：即是按值传递也是按引用传递，只是参照物不同，结果也就不同。 4. 正确看待传值还是传引用的问题 要正确的看待这个问题必须要搞清楚为什么会有这样一个问题。 实际上，问题来源于 C，而不是 Java。 C语言中有一种数据类型叫做指针，于是将一个数据作为参数传递给某个函数的时候，就有两种方式：传值，或是传指针，它们的区别，可以用一个简单的例子说明： [java] view plain copy print? /例 5 / /** @(#) test.c @author fancy */ void SwapValue(int a, int b) { int t = a; a = b; b = t; } void SwapPointer(int a, int b) { int t = * a; a = * b; b = t; } void main() { int a = 0, b = 1; printf(“1 : a = %d, b = %d/n”, a, b); SwapValue(a, b); printf(“2 : a = %d, b = %d/n”, a, b); SwapPointer(&amp;a, &amp;b); printf(“3 : a = %d, b = %d/n”, a, b); } 运行结果： [plain] view plain copy print? 1: a = 0, b = 1 2 : a = 0, b = 1 3 : a = 1, b = 0 大家可以明显的看到，按指针传递参数可以方便的修改通过参数传递进来的值，而按值传递就不行。 当Java 成长起来的时候，许多的 C 程序员开始转向学习 Java，他们发现，使用类似 SwapValue 的方法仍然不能改变通过参数传递进来的简单数据类型的值，但是如果是一个对象，则可能将其成员随意更改。于是他们觉得这很像是 C 语言中传值/传指针的问题。但是 Java 中没有指针，那么这个问题就演变成了传值/传引用的问题。可惜将这个问题放在 Java 中进行讨论并不恰当。 讨论这样一个问题的最终目的只是为了搞清楚何种情况才能在方法函数中方便的更改参数的值并使之长期有效。 Java中，改变参数的值有两种情况，第一种，使用赋值号“=”直接进行赋值使其改变，如例 1 和例4；第二种，对于某些对象的引用，通过一定途径对其成员数据进行改变，如例 3。对于第一种情况，其改变不会影响到方法该方法以外的数据，或者直接说源数据。而第二种方法，则相反，会影响到源数据——因为引用指示的对象没有变，对其成员数据进行改变则实质上是改变的该对象。 5. 如何实现类似 swap 的方法 传值还是传引用的问题，到此已经算是解决了，但是我们仍然不能解决这样一个问题：如果我有两个 int 型的变量 a 和 b，我想写一个方法来交换它们的值，应该怎么办？ 结论很让人失望——没有办法！因此，我们只能具体情况具体讨论，以经常使用交换方法的排序为例： [java] view plain copy print? /*例 6 / /** @(#) Test.java @author fancy */ public class Test { public static void swap(int[] data, int a, int b) { int t = data[a]; data[a] = data[b]; data[b] = t; } public static void main(String[] args) { int[] data = new int[10]; for (int i = 0; i &lt; 10; i++) { data[i] =(int) (Math.random() * 100); System.out.print(“ “ + data[i]); } System.out.println(); for (int i = 0; i &lt; 9; i++) { for (int j =i; j &lt; 10; j++) { if (data[i] &gt; data[j]) { swap(data, i, j); } } } for (int i = 0; i &lt; 10; i++) { System.out.print(“ “ + data[i]); } System.out.println(); } } 运行结果(情况之一)： [plain] view plain copy print? 7869 94 38 95 31 50 97 84 1 1 31 38 50 69 78 84 94 95 97 swap(int[]data, int a, int b) 方法在内部实际上是改变了data 所指示的对象的成员数据，即上述讨论的第二种改变参数值的方法。希望大家能够举一反三，使用类似的方法来解决相关问题。 http://blog.csdn.net/houpuhope/article/details/7449377]]></content>
      <categories>
        <category>ExamTest</category>
        <category>Java</category>
        <category>JavaPrimary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[比较字符串的方法]]></title>
    <url>%2Fpost%2Fe8f1e3a.html</url>
    <content type="text"><![CDATA[可以讲字符串转换为字符数组，举个简单的例子如下，你一看就懂： public class MyTest1 {public static void main(String[] args) {String str = “I am a String”;char arr[] = str.toCharArray();for (int i = 0; i &lt; arr.length; i++)System.out.println(“arr[“ + i + “]=” + arr[i]);}} public class TT{ private static int compare(String f, String s) { int count = 0; for ( int i = 0; i &lt; f.length (); i++ ) { for ( int j = 0; j &lt; s.length (); j++ ) { if (f.charAt (i) == s.charAt (j)) { count++; } } } return count; } public static void main ( String[] args ) { System.out.println (compare (“67821”, “12345”)); }}]]></content>
      <categories>
        <category>ExamTest</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工业设计以及GPUCPU，RAMROM，SSD，960M]]></title>
    <url>%2Fpost%2Fd13ca383.html</url>
    <content type="text"><![CDATA[1，CPU一定要选择正常电压版，比如4200M而不是4200U，不然你会哭惨的。有钱的话一定上I7。 2，内存尽量8G，部分笔记本为了节省成本都用4G的，可以再买4G的条添上组个双通道，在处理大文件时有显著提升。 3，散热一定要好！而且至少一年应该清理一次灰尘，前段时间我帮同学拆了4台惠普和1台dell……就是散热再好的电脑，一年之后里面灰尘多的也惨不忍睹，抓紧找个懂电脑的或者看教程自己拆开清理一下灰尘，涂新的硅脂……不然渲染的时候很有可能会过热烧坏电脑的。 4，有很多笔记本的显示器色彩偏差很大，如果可以尽量买台显示器放在寝室里，外接显示器使用……不然你调出来的颜色肯呢个换个地方就是另外一种色彩了…… 5.可以扩展SSD的话最好自己或者找人扩展下SSD——win电脑会起飞的（如果其他配置也能跟上的话）！！！ 6：无论是多好的笔记本or台式机都仅仅是一个工具而已，最重要的还是应用这种工具的技术……还有自己创作产品的思维，不要本末倒置，一些人用几千块的电脑做出来的产品照样能获大奖，有些人抱着几万的apple却毫无想法。 说到苹果，也有很多人在问学设计要不要买苹果电脑呢有钱就买呗而且苹果的不低于1w5的机子能用？至少要买视网膜屏幕+i7配置的才能和6000块的家用本子的性能拉开差距……苹果的好处在于屏幕色彩准and设计令人舒适，macos上的设计软件也很丰富，系统使用也挺方便……不过多少人买来是为了真正用心做设计的呢，其实普通人没必要去追求苹果，windows家用本足以，而且学校教软件都是以windows系统为例吧，如果不缺钱，上苹果or工作站。 作者：王洋子豪 链接：http://www.zhihu.com/question/19903344/answer/13779421 来源：知乎 著作权归作者所有，转载请联系作者获得授权。 首先需要解释CPU和GPU这两个缩写分别代表什么。CPU即中央处理器，GPU即图形处理器。其次，要解释两者的区别，要先明白两者的相同之处：两者都有总线和外界联系，有自己的缓存体系，以及数字和逻辑运算单元。一句话，两者都为了完成计算任务而设计。 两者的区别在于存在于片内的缓存体系和数字逻辑运算单元的结构差异：CPU虽然有多核，但总数没有超过两位数，每个核都有足够大的缓存和足够多的数字和逻辑运算单元，并辅助有很多加速分支判断甚至更复杂的逻辑判断的硬件；GPU的核数远超CPU，被称为众核（NVIDIA Fermi有512个核）。每个核拥有的缓存大小相对小，数字逻辑运算单元也少而简单（GPU初始时在浮点计算上一直弱于CPU）。从结果上导致CPU擅长处理具有复杂计算步骤和复杂数据依赖的计算任务，如分布式计算，数据压缩，人工智能，物理模拟，以及其他很多很多计算任务等。GPU由于历史原因，是为了视频游戏而产生的（至今其主要驱动力还是不断增长的视频游戏市场），在三维游戏中常常出现的一类操作是对海量数据进行相同的操作，如：对每一个顶点进行同样的坐标变换，对每一个顶点按照同样的光照模型计算颜色值。GPU的众核架构非常适合把同样的指令流并行发送到众核上，采用不同的输入数据执行。在2003-2004年左右，图形学之外的领域专家开始注意到GPU与众不同的计算能力，开始尝试把GPU用于通用计算（即GPGPU）。之后NVIDIA发布了CUDA，AMD和Apple等公司也发布了OpenCL，GPU开始在通用计算领域得到广泛应用，包括：数值分析，海量数据处理（排序，Map-Reduce等），金融分析等等。 简而言之，当程序员为CPU编写程序时，他们倾向于利用复杂的逻辑结构优化算法从而减少计算任务的运行时间，即Latency。当程序员为GPU编写程序时，则利用其处理海量数据的优势，通过提高总的数据吞吐量（Throughput）来掩盖Lantency。目前，CPU和GPU的区别正在逐渐缩小，因为GPU也在处理不规则任务和线程间通信方面有了长足的进步。另外，功耗问题对于GPU比CPU更严重。 总的来讲，GPU和CPU的区别是个很大的话题，甚至可以花一个学期用32个学时十几次讲座来讲，所以如果提问者有更具体的问题，可以进一步提出。我会在我的知识范围内尝试回答。 一个Latency oriented 一个Throughput oriented CPU会利用较高的主频、cache、分支预测等技术，使处理每条指令所需的时间尽可能少，从而减低具有复杂跳转分支程序执行所需的时间 GPU则通过数量丧心病狂的流处理器实现大量线程并行，使同时走一条指令的数据变多，从而提高数据的吞吐量 举个GPU通用计算教材上比较常见的例子，一个向量相加的程序，你可以让CPU跑一个循环，每个循环对一个分量做加法，也可以让GPU同时开大量线程，每个并行的线程对应一个分量的相加。CPU跑循环的时候每条指令所需时间一般低于GPU，但GPU因为可以开大量的线程并行地跑，具有SIMD（准确地说是SIMT）的优势。 作者：杨囧囧 链接：http://www.zhihu.com/question/19903344/answer/90733894 来源：知乎 著作权归作者所有，转载请联系作者获得授权。 当你操作电脑的时候，为了完成某项工作，需要电脑帮你工作，就像计算某个题目那样。 计算题目，理解题目并且整理出解题的步骤以及解法，那是CPU的事情。 但是解题的过程需要用到的众多计算，则需要一帮不需要很高逻辑理解力的计算者完成，他们只需要负责其中很简单但是数量又很大的简单运算就行了，最后他们把各自运算的结果交出来给CPU整理，那么这群计算者就是GPU。 这就是一个博士带着100个小学生的意思了 作者：feng sam 链接：http://www.zhihu.com/question/19903344/answer/24298251 来源：知乎 著作权归作者所有，转载请联系作者获得授权。 http://tieba.baidu.com/p/3093825862]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[yum和apt-get的区别&&apt操作方法&&tar解压方法]]></title>
    <url>%2Fpost%2F1103402e.html</url>
    <content type="text"><![CDATA[yum和apt-get有什么区别一般来说著名的linux系统基本上分两大类： 1.RedHat系列：Redhat、Centos、Fedora等 //红帽 2.Debian系列：Debian、Ubuntu等 //Debian — 通用操作系统 RedHat 系列 1 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数” 2 包管理工具 yum 3 支持tar包 Debian系列 1 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数” 2 包管理工具 apt-get 3 支持tar包 tar 只是一种压缩文件格式，所以，它只是把文件压缩打包而已。 rpm 相当于windows中的安装文件，它会自动处理软件包之间的依赖关系。 优缺点来说，rpm一般都是预先编译好的文件，它可能已经绑定到某种CPU或者发行版上面了。 tar一般包括编译脚本，你可以在你的环境下编译，所以具有通用性。 如果你的包不想开放源代码，你可以制作成rpm，如果开源，用tar更方便了。 tar一般都是源码打包的软件，需要自己解包，然后进行安装三部曲，./configure, make, make install. 来安装软件。 rpm是redhat公司的一种软件包管理机制，直接通过rpm命令进行安装删除等操作，最大的优点是自己内部自动处理了各种软件包可能的依赖关系。 ———————————————— .rpm形式的二进制软件包[centos] 安装：rpm -ivh .rpm 卸载：rpm -e packgename rpm -q nginx 查看是否已经安装 升级：rpm -Uvh xxx 查询： 查询所有安装的包： rpm -qa 查询某个包：rpm -qa | grep xxx rpm -qi xxx 查询软件的安装路径：rpm -ql xxx rpm -qc xxx 查询某个文件是那个rpm包产生：rpm -qf /etc/yum.conf rpm -qpi xxx rpm -qa|grep php 查看已安装的RMP包 安装：rpm -ivh xxx 移除：rpm -e xxx 升级：rpm -Uvh xxx 查询： 查询所有安装的包： rpm -qa 查询某个包：rpm -qa | grep xxx rpm -qi xxx 查询软件的安装路径：rpm -ql xxx rpm -qc xxx 查询某个文件是那个rpm包产生：rpm -qf /etc/yum.conf rpm -qpi xxx ———————————————— src.rpm 源代码分发软件包的安装与卸载 Linux软件的源代码分发是指提供了该软件所有程序源代码的发布形式，需要用户自己编译成可执行的二进制代码并进行安装，其优点是配置灵活，可以随意去掉或保留某些功能/模块，适应多种硬件/操作系统平台及编译环境，缺点是难度较大，一般不适合初学者使用。 1、.src.rpm形式的源代码软件包 安装：rpm -rebuild .src.rpm cd /usr/src/dist/RPMS rpm -ivh .rpm 卸载：rpm -e packgename 说明：rpm –rebuild .src.rpm命令将源代码编译并在/usr/src/dist/RPMS下生成二进制的rpm包，然后再安装该二进制包即可。packgename如前所述。 ————————————————dpkg【ubuntu】 dpkg -l | grep ‘php’ 使用dpkg -l 来查看已经安装了的软件 dpkg 是Debian[待宾] Package 的简写。为 Debian 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自Debian的Linux 发行版都使用 dpkg，例如 Ubuntu、Knoppix 等。 以下是一些 Dpkg 的普通用法： 1、dpkg -i 安装一个 Debian 软件包，如你手动下载的文件。 2、dpkg -c 列出 的内容。 3、dpkg -I 从 中提取包裹信息。 4、dpkg -r 移除一个已安装的包裹。 5、dpkg -P 完全清除一个已安装的包裹。和 remove 不同的是，remove 只是删掉数据和可执行文件，purge 另外还删除所有的配制文件。 6、dpkg -L 列出 安装的所有文件清单。同时请看 dpkg -c 来检查一个 .deb 文件的内容。 7、dpkg -s 显示已安装包裹的信息。同时请看 apt-cache 显示 Debian 存档中的包裹信息，以及 dpkg -I 来显示从一个 .deb 文件中提取的包裹信息。 8、dpkg-reconfigure 重新配制一个已经安装的包裹，如果它使用的是 debconf (debconf 为包裹安装提供了一个统一的配制界面)。 ———————————————— 使用yum和apt-get。软件管理方法的升级. yum的配置文件是/etc/yum.conf 1. 我们来先讲Redhat的yum 这种高级的包管理. yum install gcc [centos] 更新：yum update 安装：yum install xxx 移除：yum remove xxx 清除已经安装过的档案（/var/cache/yum/）：yum clean all 搜寻：yum search xxx 列出所有档案：yum list 查询档案讯息：yum info xxx #sudo -s #LANG=C #yum -y install gcc gcc-c autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libpng libpng-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel 用YUM安装软件包 yum -y 命令：yum install 用YUM删除软件包 命令：yum remove yum -y remove httpd 命令：yum search 列出所有可安装的软件包 命令：yum list yum list php 列出所有可更新的软件包 命令：yum list updates 列出所有已安装的软件包 命令：yum list installed 列出所有已安装但不在 Yum Repository 內的软件包 命令：yum list extras 列出所指定的软件包 命令：yum list yum = Yellow dog Updater, Modified 主要功能是更方便的添加/删除/更新RPM包. 它能自动解决包的倚赖性问题. 它能便于管理大量系统的更新问题 yum特点 可以同时配置多个资源库(Repository) 简洁的配置文件(/etc/yum.conf 自动解决增加或删除rpm包时遇到的倚赖性问题 使用方便 保持与RPM数据库的一致性 yum安装 CentOS 自带(yum-.noarch.rpm) #rpm -ivh yum-.noarch.rpm 在第一次启用yum之前首先需要导入系统的RPM-GPG-KEY： #rpm —import /usr/share/doc/centos-release-3(4)/RPM-GPG-KEY-CentOS-3(4) yum指令 注:当第一次使用yum或yum资源库有更新时,yum会自动下载 所有所需的headers放置于/var/cache/yum目录下,所需时间可能较长. rpm包的更新 检查可更新的rpm包 #yum check-update 更新所有的rpm包 #yum update 更新指定的rpm包,如更新kernel和kernel source #yum update kernel kernel-source 大规模的版本升级,与yum update不同的是,连旧的淘汰的包也升级 #yum upgrade rpm包的安装和删除 安装rpm包,如xmms-mp3 #yum install xmms-mp3 删除rpm包,包括与该包有倚赖性的包 #yum remove licq 注:同时会提示删除licq-gnome,licq-qt,licq-text yum暂存(/var/cache/yum/)的相关参数 清除暂存中rpm包文件 #yum clean packages 清除暂存中rpm头文件 #yum clearn headers 清除暂存中旧的rpm头文件 #yum clean oldheaders 清除暂存中旧的rpm头文件和包文件 #yum clearn 或#yum clearn all 注:相当于yum clean packages + yum clean oldheaders 包列表 列出资源库中所有可以安装或更新的rpm包 #yum list 列出资源库中特定的可以安装或更新以及已经安装的rpm包 #yum list mozilla#yum list mozilla 注:可以在rpm包名中使用匹配符,如列出所有以mozilla开头的rpm包 列出资源库中所有可以更新的rpm包 #yum list updates 列出已经安装的所有的rpm包 #yum list installed 列出已经安装的但是不包含在资源库中的rpm包 #yum list extras 注:通过其它网站下载安装的rpm包 rpm包信息显示(info参数同list) 列出资源库中所有可以安装或更新的rpm包的信息 #yum info 列出资源库中特定的可以安装或更新以及已经安装的rpm包的信息 #yum info mozilla#yum info mozilla 注:可以在rpm包名中使用匹配符,如列出所有以mozilla开头的rpm包的信息 列出资源库中所有可以更新的rpm包的信息 #yum info updates 列出已经安装的所有的rpm包的信息 #yum info installed 列出已经安装的但是不包含在资源库中的rpm包的信息 #yum info extras 注:通过其它网站下载安装的rpm包的信息 搜索rpm包 搜索匹配特定字符的rpm包 #yum search mozilla 注:在rpm包名,包描述等中搜索 搜索有包含特定文件名的rpm包 #yum provides realplay 增加资源库 例如:增加rpm.livna.org作为资源库 安装Livna.org rpms GPG key #rpm —import http://rpm.livna.org/RPM-LIVNA-GPG-KEY 检查GPG Key # rpm -qa gpg-pubkey* 显示Key信息 #rpm -qi gpg-pubkey-a109b1ec-3f6e28d5 (注:如果要删除Key,使用#rpm -e gpg-pubkey-a109b1ec-3f6e28d5) yum常用的命令 # yum install xxx 安装xxx软件 # yum info xxx 查看xxx软件的信息 # yum remove xxx 删除软件包 # yum list 列出软件包 # yum clean 清除缓冲和就的包 # yum provides xxx 以xxx为关键字搜索包（提供的信息为关键字） # yum search xxx 搜索软件包（以名字为关键字） # yum groupupdate xxx # yum grouplist xxx # yum groupremove xxx 这三个都是一组为单位进行升级 列表和删除的操作。。比如 “Mysql Database”就是一个组会同时操作相关的所有软件包； # yum update 系统升级 # yum list available 列出所有升级源上的包； # yum list updates 列出所有升级源上的可以更新包； # yum list installed 列出已经安装的包； # yun update kernel 升级内核； yum常用的源 1) 自动选择最快的源 由于yum中有的mirror速度是非常慢的，如果yum选择了这个mirror，这个时候yum就会非常慢，对此，可以下载fastestmirror插件，它会自动选择最快的mirror： #yum install yum-fastestmirror 配置文件：（一般不用动）/etc/yum/pluginconf.d/fastestmirror.conf 你的yum镜像的速度测试记录文件：/var/cache/yum/timedhosts.txt (2)使用图形界面的yum 如果觉得命令行的yum不方便，那么可以使用图形化的yumex，这个看起来更方便，因为可以自由地选择软件仓库： #yum install yumex 然后在系统工具中就可以看到yum extender了。实际上系统自带的“添加/删除程序“也可以实现图形化的软件安装，但有些yumex的功能它没有。 2.讲讲Ubuntu中的高级包管理方法apt-get配置文件/etc/apt/sources.list 对于Server版， 推荐使用aptitude来查看，安装、删除deb包 sudo apt-get install aptitude 然后执行 sudo aptitude 进入管 理 也可以使用命令： aptitude update 更新可用的包列表 aptitude upgrade 升级可用的包 aptitude dist-upgrade 将系统升级到新的发行版 aptitude install pkgname 安装包 aptitude remove pkgname 删除包 aptitude purge pkgname 删除包及其配置文件 aptitude search string 搜索包 aptitude show pkgname 显示包的详细信息 aptitude clean 删除下载的包文件 aptitude autoclean 仅删除过期的包文件 考虑到系统的兼容性,并且上面的东东比较都大,不找最新版本了，直接用apt-get install XXX 来安装.因为我们的Ubuntu是dailyBulid的,所以光盘的内容基本上都是最新的了,无需重新下载.一定要最新版本的话，不妨先apt-get update 来更新一下软件的仓库,然后再 apt-get install. 常用的APT命令参数： apt-cache search package 搜索包 apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package 安装包 sudo apt-get install package - - reinstall 重新安装包 sudo apt-get -f install 修复安装”-f = ——fix-missing” sudo apt-get remove package 删除包 sudo apt-get remove package - - purge 删除包，包括删除配置文件等 sudo apt-get update 更新源 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-get dselect-upgrade 使用 dselect 升级 apt-cache depends package 了解使用依赖 apt-cache rdepends package 是查看该包被哪些包依赖 sudo apt-get build-dep package 安装相关的编译环境 apt-get source package 下载该包的源代码 sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖 sudo apt-get remove libreoffice-common、 sudo apt-get install wps-office sudo apt-get install flashplugin-installer 下列软件包是自动安装的并且现在不需要了： fonts-opensymbol fonts-stix libabw-0.1-1v5 libboost-date-time1.58.0 libboost-iostreams1.58.0 libcdr-0.1-1 libclucene-contribs1v5 libclucene-core1v5 libcmis-0.5-5v5 libcolamd2.9.1 libe-book-0.1-1 libeot0 libetonyek-0.1-1 libexttextcat-2.0-0 libexttextcat-data libfreehand-0.1-1 liblangtag-common liblangtag1 libmhash2 libmspub-0.1-1 libmwaw-0.3-3 libmythes-1.2-0 libneon27-gnutls libodfgen-0.1-1 liborcus-0.10-0v5 libpagemaker-0.0-0 libraptor2-0 librasqal3 librdf0 librevenge-0.0-0 libsuitesparseconfig4.4.6 libvisio-0.1-1 libwpd-0.10-10 libwpg-0.3-3 libwps-0.4-4 libyajl2 lp-solve uno-libs3 ure 使用’sudo apt autoremove’来卸载它(它们)。 安装IDEA 在IDEA官网下载Ubuntu的镜像 先把你下载到的 ideaIU-2016.2.4.tar.gz 移动到你平时存放软件的目录下，然后进行解压，我电脑是放在 /opt 下。 sudo tar zxvf /home/jhz/下载/ideaIU-2016.2.4.tar.gz -C /opt， 解压出来的目录名称是：idea-IU-162.2032.8，可能在解压过程中你需要 sudo 命令权限，或者是切换到 root 账号下。如果你是切换到 root 用户下就一定要注意，解压完记得再切回来你常用的账户，不然等下生成的 IntelliJ IDEA 配置文件是放在 /home/root 下，这样就跟你常用的那个用户没啥关系了。 在假设你已经通过终端切换到了你常用的用户下之后，现在用终端进入解压目录下的 bin 子目录 下，然后在终端下运行启动命令：./idea.sh，运行的效果如上图箭头所示。剩下的配置步骤就跟 Windows 基本一样了，所以这里不多讲。 licence server 可用.·激活」http://www.iteblog.com/idea/key.php OK linux下tar命令解压到指定的目录tar zxvf /bbs.tar.zip -C /zzz/bbs //把根目录下的bbs.tar.zip解压到/zzz/bbs下，前提要保证存在/zzz/bbs这个目录 这个和cp命令有点不同，cp命令如果不存在这个目录就会自动创建这个目录！ 附：用tar命令打包 例：将当前目录下的zzz文件打包到根目录下并命名为zzz.tar.gz #tar zcvf /zzz.tar.gz ./zzz ———————————————————————————————————————————- tar 解压缩命令 tar -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 # tar -cf all.tar .jpg 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 # tar -rf all.tar .gif 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 # tar -uf all.tar logo.gif 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 # tar -tf all.tar 这条命令是列出all.tar包中所有文件，-t是列出文件的意思 # tar -xf all.tar 这条命令是解出all.tar包中所有文件，-x是解开的意思 压缩 tar –cvf jpg.tar .jpg //将目录里所有jpg文件打包成tar.jpg tar –czf jpg.tar.gz .jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar –cjf jpg.tar.bz2 .jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar –cZf jpg.tar.Z .jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z rar a jpg.rar .jpg //rar格式的压缩，需要先下载rar for linux zip jpg.zip .jpg //zip格式的压缩，需要先下载zip for linux 解压 tar –xvf file.tar //解压 tar包 tar -xzvf file.tar.gz //解压tar.gz tar -xjvf file.tar.bz2 //解压 tar.bz2 tar –xZvf file.tar.Z //解压tar.Z unrar e file.rar //解压rar unzip file.zip //解压zip 总结 1、.tar 用 tar –xvf 解压 2、.gz 用 gzip -d或者gunzip 解压 3、.tar.gz和.tgz 用 tar –xzf 解压 4、.bz2 用 bzip2 -d或者用bunzip2 解压 5、.tar.bz2用tar –xjf 解压 6、.Z 用 uncompress 解压 7、.tar.Z 用tar –xZf 解压 8、.rar 用 unrar e解压 9、.zip 用 unzip 解压]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu16.04</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[10,7Java00]]></title>
    <url>%2Fpost%2F7dd88298.html</url>
    <content type="text"><![CDATA[一、final 相关final 用于声明属性、方法和类，分别表示属性一旦被分配内存空间就必须初始化并且以后不可变、方法一旦定义必须有实现代码并且子类里不可被覆盖、类一旦定义不能被定义为抽象类或是接口，因为不可被继承。 重点是【一旦被分配内存空间】。 你既可以：1234567891011121314public class Test&#123; public final int a = 1; // 在声明时初始化 public Test()&#123; &#125;&#125;也可以：public class Test&#123; public final int a; public Test()&#123; a = 1; // 在构造函数里初始化 &#125;&#125; 为什么可以在构造函数里初始化呢？因为当类被加载进内存的时候，这个属性并没有给其分配内存空间，而只是定义了一个变量，只有当类被实例化的时候这个属性才被分配内存空间，而实例化的时候同时执行了构造函数，所以属性被初始化了，也就符合了当它被分配内存空间的时候就需要初始化，以后不再改变的条件。 所以：一般初始化时赋值，或者在构造函数里赋值。 再补充点 1.在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。下面就从这三个方面来了解一下final关键字的基本用法。 1.修饰类 当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。 2.修饰方法 下面这段话摘自《Java编程思想》第四版第143页： “使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“ 因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。 注：类的private方法会隐式地被指定为final方法。 3.修饰变量 修饰变量是final用得最多的地方，也是本文接下来要重点阐述的内容。首先了解一下final变量的基本语法： 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 举个例子： 上面的一段代码中，对变量i和obj的重新赋值都报错了。 4.final修饰的索引，对象不能改变，但是对象的内容可以改变。 例如： final A a = new A(); a.value = 2; 这样是可以的，但是如果再从新赋值a就报错了：a = new A(); endofline 二、浅谈Java中的对象和对象引用对象的使用：1234567891011121.**赋值**■**对象****名** **=** **对象名****;** **//****兼容：****同类或子****类！！！！！！！！！！！！！！！！！！**■**ChoiceQuestion****cq1 =** **new** **ChoiceQuestion****(…);**■**Question q1 = cq1;**■**ChoiceQuestion** **cq2 = q1****;** **//****ChoiceQuestion**** cq2 = (****ChoiceQuestion****)** **q1;**■**Question q2 = new Question(…);** **//Question q2 = new** **ChoiceQuestion****(…);**2.**访问成员变量**■**实例变量：** **对象名****.****变量名** **//new** **int****\[\] &#123;1,2,3&#125;.length**■**类变量：** **类****名****.****变量名** **//****Math.PI**3.**访问成员方法**■**实例方法：** **对象名****.****方法名****(****实参表****)** **//****q.getDescription****()**■**类方法：** **类****名****.****方法名****(****实参表****)** **//****Math.random****()** {}在Java中，有一组名词经常一起出现，它们就是“对象和对象引用”，很多朋友在初学Java的时候可能经常会混淆这2个概念，觉得它们是一回事，事实上则不然。今天我们就来一起了解一下对象和对象引用之间的区别和联系。 1.何谓对象？ 在Java中有一句比较流行的话，叫做“万物皆对象”，这是Java语言设计之初的理念之一。要理解什么是对象，需要跟类一起结合起来理解。下面这段话引自《Java编程思想》中的一段原话： “按照通俗的说法，每个对象都是某个类（class）的一个实例（instance），这里，‘类’就是‘类型’的同义词。” 从这一句话就可以理解到对象的本质，简而言之，它就是类的实例，比如所有的人统称为“人类”，这里的“人类”就是一个类（物种的一种类型），而具体到每个人，比如张三这个人，它就是对象，就是“人类”的实例。 2.何谓对象引用？ 我们先看一段话： “每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。” 这段话来自于《Java编程思想》，很显然，从这段话可以看出对象和对象引用不是一回事，是两个完全不同的概念。举个例子，我们通常会用下面这一行代码来创建一个对象： 1 Person person = new Person(“张三”); 有人会说，这里的person是一个对象，是Person类的一个实例。 也有人会说，这里的person并不是真正的对象，而是指向所创建的对象的引用。 到底哪种说法是对的？我们先不急着纠结哪种说法是对的，再看两行代码： 1 2 Person person; person = new Person(“张三”); 这两行代码实现的功能和上面的一行代码是完全一样的。大家都知道，在Java中new是用来在堆上创建对象用的，如果person是一个对象的话，那么第二行为何还要通过new来创建对象呢？由此可见，person并不是所创建的对象，是什么？上面的一段话说的很清楚，“操纵的标识符实际是指向一个对象的引用”，也就是说person是一个引用，是指向一个可以指向Person类的对象的引用。真正创建对象的语句是右边的new Person(“张三”); 再看一个例子：Person person;person = new Person(“张三”);person = new Person(“李四”); 这里让person先指向了“张三”这个对象，然后又指向了“李四”这个对象。也就是说，Person person，这句话只是声明了一个Person类的引用，它可以指向任何Person类的实例。这个道理就和下面这段代码一样： int a;a=2;a=3; 这里先声明了一个int类型的变量a，先对a赋值为2，后面又赋值为3.也就是说int类型的变量a，可以让它的值为2，也可以为3，只要是合法的int类型的数值即可。 也就是说，一个引用可以指向多个对象，而一个对象可不可以被多个引用所指呢？答案当然是可以的。 比如： Person person1 = new Person(“张三”);Person person2 = person1; person1和person2都指向了“张三”这个对象。 关于对象和对象引用的区别和联系暂时就讲这么多了，感兴趣的朋友可以查阅相关文档和资料。 作者：海子 出处：http://www.cnblogs.com/dolphin0520/ 本博客中未标明转载的文章归作者海子和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 ①**封装（****Encapsulation****）** ②**继承（****Inheritance****）** ③**多态（****Polymorphism****）** &amp;左值引用（常量，静态！） 与 &amp;&amp; 右值引用 （存在一会就消失的重载，copy！）]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[转]带你认识Photoshop的混合模式]]></title>
    <url>%2Fpost%2F8c577a79.html</url>
    <content type="text"><![CDATA[如果你要经常使用Photoshop，那么你需要了解Photoshop一个简单却不容易理解的特性——混合模式。在Photoshop众多酷炫功能中，这是个很容易被人忽略的功能，但是看完这篇文章之后，希望会引起你的注意。 混合模式在哪里？ 混合模式容易被忽略的最大原因就是它所处的位置——在图层面板右上部的角落里。 混合模式是什么？ 你可以将混合模式按照下拉菜单中的分组来将它们分为不同类别：变暗模式、变亮模式、饱和度模式、差集模式和颜色模式。 现在你知道了混合模式的分类，那么便很容易理解何时使用相关的模式来达到自己想要的效果了。 什么时候使用混合模式？ 混合模式有非常广泛的用途，学会了混合模式，那些现成的照片滤镜便显得多余了。让我们来看一个使用混合模式调整照片色调的例子： 我们可以在原图片的上方新建一层，填充颜色，然后设置混合模式就可以调整成我们想要的色调了，这种方式可以代替色相/饱和度或其他照片滤镜。选中混合模式之后，你可以使用键盘上的上下箭头来快速调整不同的模式。 混合模式是没有修改选项的，事实证明你也不需要这些选项，只是改变图层的不透明度和填充度就可以了。如果你觉得每个混合模式的效果都不满意，那么你可以使用图层不透明度和填充的选项了。 正如混合模式的名字，你可以将多个图层混合创造出各种惊人的效果。 混合模式近距离接触： 1.正常模式（Normal） 在“正常”模式下，“混合色”的显示与不透明度的设置有关。当“不透明度”为100%，也就是说完全不透明时，“结果色”的像素将完全由所用的“混合色”代替；当“不透明度”小于100%时，混合色的像素会透过所用的颜色显示出来，显示的程度取决于不透明度的设置与“基色”的颜色，如下图所示是将“不透明度”设为60%后的效果。 2. 溶解模式(Dissolve) 在“溶解”模式中，主要是在编辑或绘制每个像素时，使其成为“结果色”。但是，根据任何像素位置的不透明度，“结果色”由“基色”或“混合色”的像素随机替换。因此，“溶解”模式最好是同Photoshop中的一些着色工具一同使用效果比较好，如“画笔”、“仿制图章”、“橡皮擦”工具等，也可以使用文字。 当“混合色”没有羽化边缘，而且具有一定的透明度时，“混合色”将溶入到“基色”内。如果“混合色”没有羽化边缘，并且“不透明度”为100%，那么“溶解”模式不起任何作用。下图是将“混合色”的“不透明度”设为50%后产生的效果，否则“混合色”和“结果色”是不会有太大的区别的，只是边缘有一点变化。 3. 变暗模式(Darken) 在“变暗”模式中，查看每个通道中的颜色信息，并选择“基色”或“混合色”中较暗的颜色作为“结果色”。比“混合色”亮的像素被替换，比“混合色”暗的像素保持不变。“变暗”模式将导致比背景颜色更淡的颜色从“结果色”中被去掉了，如下图所示可以看到，亮色的天空被比它颜色深的玻璃的颜色替换掉了。 4. 正片叠底模式(Multiply) 在“正片叠底”模式中，查看每个通道中的颜色信息，并将“基色”与“混合色”复合。“结果色”总是较暗的颜色。任何颜色与黑色复合产生黑色。任何颜色与白色复合保持不变。当用黑色或白色以外的颜色绘画时，绘画工具绘制的连续描边产生逐渐变暗的过渡色。其实“正片叠底”模式就是从“基色”中减去“混合色”的亮度值，得到最终的“结果色”。如果在“正片叠底”模式中使用较淡的颜色对图像的“结果色”是没有影响的。 利用“正片叠底”模式可以形成一种光线穿透图层的幻灯片效果。其实就是将“基色”颜色与“混合色”颜色的数值相乘，然后再除以255，便得到了“结果色”的颜色值。例如，红色与黄色的“结果色”是橙色，红色与绿色的“结果色”是褐色，红色与蓝色的“结果色”是紫色等。 5. 颜色加深模式(Color Burn) 在“颜色加深”模式中，查看每个通道中的颜色信息，并通过增加对比度使基色变暗以反映混合色，如果与白色混合的话将不会产生变化，如下图所示除了背景上的较淡区域消失，且图像区域呈现尖锐的边缘特性之外，“颜色加深”模式创建的效果和“正片叠底”模式创建的效果比较类似。 6. 线性加深模式(Linear Burn) 在“线性加深”模式中，查看每个通道中的颜色信息，并通过减小亮度使“基色”变暗以反映混合色。如果“混合色”与“基色”上的白色混合后将不会产生变化。 7. 变亮模式(Lighten) 在“变亮”模式中，查看每个通道中的颜色信息，并选择“基色”或“混合色”中较亮的颜色作为“结果色”。比“混合色”暗的像素被替换，比“混合色”亮的像素不变。 在这种与“变暗”模式相反的模式下，较淡的颜色区域在最终的“合成色”中占主要地位。较暗区域并不出现在最终结“合成色”中。 8. 滤色模式(Screen) “滤色”模式与“正片叠底”模式正好相反，它将图像的“基色”颜色与“混合色”颜色结合起来产生比两种颜色都浅的第三种颜色，如下图所示。其实就是并将“混合色”的互补色与“基色”复合。“结果色”总是较亮的颜色。用黑色过滤时颜色保持不变。用白色过滤将产生白色。无论在“滤色”模式下用着色工具采用一种颜色，还是对“滤色”模式指定一个层，合并的“结果色”始终是相同的合成颜色或一种更淡的颜色。 9. 颜色减淡模式(Color Dodge) 在“颜色减淡”模式中，查看每个通道中的颜色信息，并通过减小对比度使基色变亮以反映混合色。与黑色混合则不发生变化。除了指定在这个模式的层上边缘区域更尖锐，以及在这个模式下着色的笔划之外，“颜色减淡”模式类似于“滤色”模式创建的效果，如下图所示。另外，不管何时定义“颜色减淡”模式混合“混合色”与“基色”像素，“基色”上的暗区域都将会消失。 10. 线性减淡模式(Linear Dodge) 在“线性减淡”模式中，查看每个通道中的颜色信息，并通过增加亮度使基色变亮以反映混合色，如下图所示。但是大家可不要与黑色混合，那样是不会发生变化的。 11. 叠加模式(Overlay) “叠加”模式把图像的“基色”颜色与“混合色”颜色相混合产生一种中间色。“基色”内颜色比“混合色”颜色暗的颜色使“混合色”颜色倍增，比“混合色”颜色亮的颜色将使“混合色”颜色被遮盖，而图像内的高亮部分和阴影部分保持不变，因此对黑色或白色像素着色时“叠加”模式不起作用。“叠加”模式以一种非艺术逻辑的方式把放置或应用到一个层上的颜色同背景色进行混合，然而，却能得到有趣的效果。背景图像中的纯黑色或纯白色区域无法在“叠加”模式下显示层上的“叠加”着色或图像区域。背景区域上落在黑色和白色之间的亮度值同“叠加”材料的颜色混合在一起，产生最终的合成颜色。 12. 柔光模式(Soft Light) “柔光”模式会产生一种柔光照射的效果。如果“混合色”颜色比“基色颜色的像素更亮一些，那么“结果色”将更亮；如果“混合色”颜色比“基色”颜色的像素更暗一些，那么“结果色”颜色将更暗，使图像的亮度反差增大。 13.强光模式(Hard Light) “强光”模式将产生一种强光照射的效果。如果“混合色”颜色“基色”颜色的像素更亮一些，那么“结果色”颜色将更亮；如果“混合色”颜色比“基色”颜色的像素更暗一些，那么“结果色”将更暗。除了根据背景中的颜色而使背景色是多重的或屏蔽的之外，这种模式实质上同“柔光”模式是一样的。它的效果要比“柔光”模式更强烈一些，同“叠加”一样，这种模式也可以在背景对象的表面模拟图案或文本。 14. 亮光模式(Vivid Light) 通过增加或减小对比度来加深或减淡颜色，具体取决于混合色。如果混合色（光源）比 50% 灰色亮，则通过减小对比度使图像变亮。如果混合色比 50% 灰色暗，则通过增加对比度使图像变暗 15. 线性光模式(Linear Light) 通过减小或增加亮度来加深或减淡颜色，具体取决于混合色。如果混合色（光源）比 50% 灰色亮，则通过增加亮度使图像变亮。如果混合色比 50% 灰色暗，则通过减小亮度使图像变暗。 16. 点光模式(Pin Light) “点光”模式其实就是替换颜色，其具体取决于“混合色”。如果“混合色”比 50% 灰色亮，则替换比“混合色”暗的像素，而不改变比“混合色”亮的像素。如果“混合色”比 50% 灰色暗，则替换比“混合色”亮的像素，而不改变比“混合色”暗的像素。这对于向图像添加特殊效果非常有用。 17. 差值模式(Diference) 在“差值”模式中，查看每个通道中的颜色信息，“差值”模式是将从图像中“基色”颜色的亮度值减去“混合色”颜色的亮度值，如果结果为负，则取正值，产生反相效果。由于黑色的亮度值为0，白色的亮度值为255，因此用黑色着色不会产生任何影响，用白色着色则产生被着色的原始像素颜色的反相。“差值”模式创建背景颜色的相反色彩。例如，在“差值”模式下，当把蓝色应用到绿色背景中时将产生一种青绿组合色。“差值”模式适用于模拟原始设计的底片，而且尤其可用来在其背景颜色从一个区域到另一区域发生变化的图像中生成突出效果。 18. 排除模式(Exclusion) “排除”模式与“差值”模式相似，但是具有高对比度和低饱和度的特点。比用“差值”模式获得的颜色要柔和、更明亮一些。建议你在处理图像时，首先选择“差值”模式，若效果不够理想，可以选择“排除”模式来试试。其中与白色混合将反转“基色”值，而与黑色混合则不发生变化。其实无论是“差值”模式还是“排除”模式都能使人物或自然景色图像产生更真实或更吸引人的图像合成。 19. 色相模式(Hue) “色相”模式只用“混合色”颜色的色相值进行着色，而使饱和度和亮度值保持不变。当“基色”颜色与“混合色”颜色的色相值不同时，才能使用描绘颜色进行着色，如下图所示。但是要注意的是“色相”模式不能用于灰度模式的图像。 20.饱和度模式(Saturation) “饱和度”模式的作用方式与“色相”模式相似，它只用“混合色”颜色的饱和度值进行着色，而使色相值和亮度值保持不变。当“基色”颜色与“混合色”颜色的饱和度值不同时，才能使用描绘颜色进行着色处理，如图31所示。 在无饱和度的区域上（也就是灰色区域中）用“饱和度”模式是不会产生任何效果的。 21. 颜色模式(Color) “颜色”模式能够使用“混合色”颜色的饱和度值和色相值同时进行着色，而使“基色”颜色的亮度值保持不变。“颜色”模式模式可以看成是“饱合度”模式和“色相”模式的综合效果。该模式能够使灰色图像的阴影或轮廓透过着色的颜色显示出来，产生某种色彩化的效果。这样可以保留图像中的灰阶，并且对于给单色图像上色和给彩色图像着色都会非常有用。 22. 亮度模式(Luminosity) “亮度”模式能够使用“混合色”颜色的亮度值进行着色，而保持“基色”颜色的饱和度和色相数值不变。其实就是用“基色”中的“色相”和“饱和度”以及“混合色”的亮度创建“结果色”。此模式创建的效果是与“颜色”模式创建的效果相反。 PS：http://www.shejipai.cn/blending-modes.html 设计派 南辰]]></content>
      <categories>
        <category>PS</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[新人手册！初级设计师应该掌握的9个工作习惯（【转】推荐新人阅读）]]></title>
    <url>%2Fpost%2F5a53fc94.html</url>
    <content type="text"><![CDATA[9个设计习惯，都是简单但长期坚持后能看到效果的，建议新人阅读。 1，养成随改随存的好习惯谁敢说自己的电脑不会卡机不会死机？所以建议大家经常保持Ctrl+S的标准手势。 2，对图层进行整理为主要的图层命名以及建立图层组，将源文件整理的“干净、整洁”是每个设计师应该养成的良好习惯，这样在你过了很久再回来修改文件，也不会浪费更多的时间。 3，画矢量图形就用形状和路径工具通常大家在绘制矩形的时候会怎么绘制呢？其实好多种方法，个人觉得这里使用形状工具是最上上的选择。路径和形状工具的好处在于，你在经历了各种修改之后，图形依然不会损失质量。 4，记住常用的快捷键适当的记住一些常备的快捷键，可以更好的加快设计速度。 Cmd/Ctrl + T – 自由变换 Cmd/Ctrl + S – 保存文件 Cmd/Ctrl + A – 选择全部 Cmd/Ctrl + D – 取消选择 Cmd/Ctrl + I – 颜色反相 Cmd/Ctrl + Shift + I – 选区反相 Cmd/Ctrl + 点击图层缩略图 – 选择所选图层的选区 Cmd/Ctrl + Option/Alt + A – 选择所有图层 Option/Alt+ 点击两个图层之间 – 剪贴蒙版 Cmd/Ctrl+ G – 图层编组 Cmd/Ctrl+ Shift + G – 取消图层编组 5，备份好设计初稿和过程稿设计师经常碰到这样的情况：例如先前按照需求设计出的作品结果被一顿神改，改的最后我会自问一句“这是我做的？”大家有木有这样的经历？ 这里建议大家将自己的设计初稿、过程稿、确定稿，最终定稿文件都单独保存起，以后可以留作对比，观察每个文件细节和处理的进步。 比较可恨的是，当你遇到这样的客户，“确实不怎么样，还是用以前的吧！”你就傻眼了吧？呵呵。 6，将PS 的历史记录设置的数大一点我一般都是100，因为你也不知道你做的到里的时候就会觉得不对劲想回去重做，这时你发现……尤其是你在用过了橡皮擦之后你懂得吧？ 7，习惯将看到的网站好的设计作品保存并整理很多设计师都是从不断的看不断的临摹中成长起来的，很多时候需要设计一个作品前也要看一些参考网站设计，那这时候有一个自己整理的网页设计图库岂不美哉？这就靠你平时的积累了，看到好的网站建议使用浏览器的”整个网页保存为图片”将网页保存为无损png格式。 整理时建议按照行业、颜色、风格分类保存，这样便于日后查找参考。 8，使用智能对象很多设计师明知智能对象很有用，但就是不常用，甚至是不用。实际上，智能对象的优点在于，它可以保留图像的源内容及其所有原始特性，从而让您能够做出各种调整，但是原始图像是不会被破坏的。你还可以恢复之前的对象。 使用智能对象，会保留像素图像的特性。当图层中的内容表现效果最佳（质量最棒）时，非常适宜于转换为智能对象。这样调整大小、选择时便不会损失画质了。 9，使用调整图层图层中的调整图层相对独立，想怎么改，就怎么改，混合模式、不透明度、设置，都可以修改，比原图层直接修改有效多了。这是个很不好的习惯。如果有一天客户说“我觉得还是上次那个颜色效果更好”，这时候你就知道不用调整图层的坏处了。如果直接在原图层内修改，破坏性的编辑，以后修改起来不方便。而调整图层则解决了这个问题。 而且， 要记住，调整图层会影响位于它下面的所有图层。 欢迎关注作者的微信公众号：]]></content>
      <categories>
        <category>PS</category>
        <category>设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[长期使用（PS学习）]]></title>
    <url>%2Fpost%2F8e991c5c.html</url>
    <content type="text"><![CDATA[关于 颜色设置-指定配置文件：指定配置文件，会以在图像中嵌入目标配置文件。常用在配置文件丢失的情况下使用，图像指定的配置文件与原图不同这会产生很大的偏差，谨慎使用“ 指定配置文件” 命令。 你的显示器没较准的时候连26各字母都不是 ，较准后 就有了准确的26个字母，但用的是你这台显示器的方言。ps中的srgb或adobe rgb好比国际上的英语。你用方言的话不是不可以，必须内嵌翻译器（保存的时候icc打勾）别人有翻译器的才好翻译你的语言。 两者的区别，简单来说是：sRGB的能记录的色彩较少但应用范围最广，而Adobe RGB能记录更多的色彩细节、更专业。目前在网页浏览方面,只支持sRGB,不支持Adobe RGB。一些非专业美图、看图软件也只支持sRGB。这样一来,使用Adobe RGB拍摄的照片,在网页里或美图软件里看到的色彩会变了样。解决色彩空间兼容的方法：①如果在拍照前已经明确该照片不会用于印刷输出，只用作网络媒介，那用Adobe RGB的意义不大，直接在相机的色彩空间里选sRGB就行了。②如果相机里设置为Adobe RGB，照片要上传到网络，就要把照片的色彩空间改为sRGB。可以在打开RAW文件时，直接由Adobe RGB转为sRGB。 v z bx d 2.27AI课程记录_此处仅为辅助+F盘笔记想要创建渐变色板，有两种方法，第一种方法就是使用鼠标选中渐变设置面板上的渐变图标不放手，直接拖动到色板的合适位置再松手，这样渐变色板就成功创建了 第二种方法，在软件左边工具栏里，用鼠标选中填色渐变图标不放手，直接拖动到色板的合适位置再松手，这样也可以创建渐变色板 需要注意的是，如果我们直接在画布上选中图形，用鼠标选中不放手，直接拖动到色板上的，我们就可以这次在色板上显示的图标跟前面两次的图标不一样了,因为这样做创建的不是渐变色板，而是图案色板 此时，我们再次选择显示渐变色板，就可以看到六种渐变色板，比原来多出了两种了，而那两种就是我们刚才创建的渐变色板。 通道 ctrl 选择通道 确定选区！路径 ctrl+Enterctrl+J+++++++++++++++++++++++++++++++++++alt 加 路径选择工具 可以在同一个组中复制路径 工作路径 — 区别于） 路径1/2 通道：注意 黑色：没有 白色：全都有 灰色：半透明 机制抠图课程目标：解决掌握通道还原抠图、调整边缘抠图、通道调节抠图。难点：1.烟雾、火焰 2.毛发 3.半透明/透明材质List1：火焰抠图——通道还原大法1、Ctrl+J复制图层，“通道”调板将“红、绿、蓝”通道分别复制一个。 ——-备份、不破坏源通道2、按住Ctrl键点击“红”通道缩略图，得到选区。（注意此时选中RGB通道） ——载入选区3、“图层”调板新建“红”图层，Alt+Del填充红色。（绿、蓝：重复步骤2、3） ——填充颜色4、按住Shift键同时选中“红”、“绿”、“蓝”图层，混合模式：滤色。 —-滤色（过滤颜色、留出效果）5、Ctrl+Shift+Alt+E 盖印图像（将下面图层进行合并）。 —-盖印（保留制作步骤）6、新建蓝色图层作为背景，对比明显。 ——加背景、对比效果List2：发丝抠图—调整边缘抠图1、Ctrl+J复制图层，快速选择工具选择大概轮廓（多选发丝）。 ——创建选区2、点击工具属性栏中的“调整边缘按钮”，用“调整半径”工具在发丝边缘涂抹，（黑底、勾选“智能半径”、调整“半径”和“平滑”，勾选“净化颜色”、选择“新建带有图层蒙版的图层”，其他参数默认）。可以少量多次执行，这样更细致自然。 ———调整边缘处理3、白色笔刷将缺失的部分在蒙版上恢复。 —-细节处理List3：婚纱抠图—通道抠图1、Ctrl+J复制图层，复制“绿”通道。 ——复制通道、不破坏源通道2、Ctrl+L 色阶增加颜色反差。 —-增加反差3、快速选择工具，选择背景，Alt+Del填充为黑色。 —-填充通道4、创建人物选区白色画笔（硬度：100）全部涂成白色，注意透明的婚纱保留灰度颜色即可，加深工具、减淡工具。 —-细节处理5、按住Ctrl键点击“绿 副本”通道缩略图，得到选区。（注意此时选中RGB通道） —-创建选区新建图层蒙版。6、选择背景素材复制粘贴到人物下层，减淡工具涂抹。 ——细节处理 赏心悦目，只在aclear.]]></content>
      <categories>
        <category>页面</category>
      </categories>
      <tags>
        <tag>正能量</tag>
        <tag>少年初心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[U盘安装 Ubuntu 16.04LTS教程]]></title>
    <url>%2Fpost%2F5a075045.html</url>
    <content type="text"><![CDATA[Ubuntu 每年发布两个版本，目前最新正式版版本也升到了 16.04。Ubuntu 16.04 开发代号为“Xenial Xerus”，为第六个长期支持（LTS）版本，其主要特色是引入了新的 snap 包格式和 LXD 纯容器 hypervisor。 Ubuntu 16.04 LTS正式发布下载，长达5年技术支持 http://www.linuxidc.com/Linux/2016-04/130508.htm Ubuntu 16.04 的其他特点包括： 支持 IBM LinuxONE 及 z Systems 的 s390x 架构 引入新的 Ubuntu MATE 社区版本 Linux 内核更新到 4.4.6，包含 ZFS on Linux 桌面版本的 GTK、Qt 均已升级至最新版本，包含 Firefox 45、Chromium 48、LibreOffice 5.1、Python 3.5 等 服务器版本包含 OpenStack Mitaka、Juju 2.0、LXD 2.0、NGINX 1.9.15、Docker 1.10、PHP 7.0、MySQL 5.7 等 下面我们来看看Ubuntu 16.04 U盘安装图文教程，希望对Linux新手有所帮助。您可以直接从此U盘尝试Ubuntu，而不用对您的电脑做任何更改。如果您已经准备完毕，您也可以与现有系统并存（或者替代）方式将Ubuntu安装到您的电脑上。此过程无需耗时太久。 准备工具：1.Universal USB Installer。2.Ubuntu 16.04 LTS镜像。 3.U盘。 在Windows下的安装就不说了，安装后打开。 在Setp 1选择Ubuntu，我选择的是64位的。 在Setp 2选择 ubuntu-16.04-desktop-amd64.iso文件 在Setp 3选择 U盘，U盘在哪里呢，在这里 http://www.linuxidc.com/Linux/2014-04/100149.htm 然后点击 Create 当把ubuntu-16.04-desktop-amd64.iso文件全部写入U盘后，在BIOS里设置为U盘启动。 启动后就会出现这个画面 选择第一选项 Try Ubuntu without installing 或 第二选项 Install Ubuntu 直接安装。 另外后面的请参照本Po的另外文章安装： http://123.206.69.206/index.php/2016/10/02/windows10disk-linuxubuntu16-04lts_alarm.html/ 转载至 Linux公社！]]></content>
      <categories>
        <category>计算机基础--安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web_Scang资源网址推荐！]]></title>
    <url>%2Fpost%2Fda734f35.html</url>
    <content type="text"><![CDATA[WP插件：http://im.acirno.com/category/wordpress/wordpress-plugins/page/2/ PS字体等好的资源下载：http://font.chinaz.com/zaozigongfang.html 今晚 强烈推荐：http://www.uisdc.com/ 优设！！！]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04下/boot空间不足解决方法]]></title>
    <url>%2Fpost%2F40179c77.html</url>
    <content type="text"><![CDATA[其实咱们在Ubuntu安装的开始分区时，或者选择 “/“ || “swap” 即可。若选择添加”/home”,”/boot”（考虑到grub2放置在里面，防止双系统在重装系统时跑偏）150M—300M—500M。 在安装 Ubuntu的时候 ， 给/boot文件目录分配空间的时候，是100M，/boot可以单独分成一个区，也可以不单独分，在/（根目录）下也会自动为其创建一个boot目录。顺便提一下，Linux分区是树结构的，/为根目录，在其目录下会分各个执行不同工作的目录，所以在分区的时候完全可以只分一个根分区和一个swap（虚拟内存）分区。如果分的细微一点，为/boot单独分区的话，100M足够，boot文件里面存放的是系统引导文件和内核的一些东西，这些东西100M是足够容纳的。而大家都知道Linux内核一直在更新，更新后，旧的内核就不再使用，但旧的内核文件还在boot里面，占据着空间，更新几次过后boot文件就会被占满，显示boot磁盘空间不足。这时为了更新需要将不用的内核文件删除，释放空间。 1： 在终端下察看已经安装的旧的内核： ctrl+alt+t——&gt;进入终端——&gt;输入命令： dpkg —get-selections|grep linux 如下： linux-后面带image的是旧的内核。因为我已经将旧的内核删除了，所以后面显示deinstall，不删除的话是install。 我们要做的就是将后面带image的Linux内核删除。 2：查看当前版本号：uname -a 3:删除操作： sudo apt-get remove linux-image-(版本号)（就是 上面带image的版本） 有卸载不完全的（有提示），可以用 sudo apt-get autoremove来删除。 4：sudo update-grub //试用 转/参考：http://www.linuxidc.com/Linux/2015-05/117401.htm]]></content>
      <categories>
        <category>计算机基础--安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件夹操作-chmod命令详细用法sudo chmod等文件夹操作方法]]></title>
    <url>%2Fpost%2F7e8d55c1.html</url>
    <content type="text"><![CDATA[cd .. cd / cd ~ (到达/home/用户名) pwd：pwd 命令查看您当前所处的路径 ls cp：cp命令用来复制文件。例如：”cp file foo”命令将会创建一个”file”的精确的副本，并命名为”foo”, 而 “file”不会有任何变化。 如果是复制目录，那就得用”cp -r directory foo”（递归地复制）。(只对cp进行简单操作,cp [选项]… 源文件… 目录:cp text1 ~/useforplay/file2或者如果在同一个目录下的,可以直接cp text1 file2) mv：mv命令将文件移动到另一个位置或者给文件更名。看下面的例子：”mv file foo”命令会将文件”file”更名为”foo”。”mv foo ~/Desktop”会将文件”foo”移动到桌面目录，但不会更名。如果想更名，你必须要指定一个新的名字。(mv的操作方式应当等同于cp方法,我没有尝试过) 如果在用mv命令的时候前面加上了sudo，那么“~“这个符号将可以正常使用，终端会把他替换成你自己（普通用户）的home目录。而如果你用 ”sudo -i“或者”sudo -s“打开了一个root用户的终端，那么这时”~“将指代root用户的home目录，而非你自己的。 rm：这个命令用来移动或删除文件。对于非空的目录(ubuntu中的目录就是文件夹)，用这个命令不能删除。 ubuntu删除文件提示没有权限 ：sudo rm 文件名如果是文件夹sudo rm 文件夹 -r 删除文件夹和文件夹下的所有内容要小心,删除后不可恢复！ rmdir：命令rmdir用来删除“空”目录。要删除目录和其中的所有内容，则需使用rm -r。 mkdir：mkdir 命令用来创建目录。例如：”mkdir music”将会创建一个 music 目录。(如果不在当前目录下,可以通过mkdir ~/useforplay/file3来实现,如果在当前目录新建,则可直接mkdir file3) man：man 命令用来显示其它命令的手册页。执行 “man man”可以查看到 man自己的信息。通过 “Man &amp; Getting Help”能够分页显示更多的信息。(我试过了,但是他挑出来几百页的东西后,我直接hold不住了). tar命令详解使用 格式： tar 选项 文件目录列表 功能： 对文件目录进行打包备份 选项： -c 建立新的归档文件 -r 向归档文件末尾追加文件 -x 从归档文件中解出文件 可以这样记忆，创建新的文件是c，追加在原有文件上用r，从文件中解压出用x -O 将文件解开到标准输出 -v 处理过程中输出相关信息 -f 对普通文件操作 －－－似乎一直都要用f，不然的话，可能会不显示 -z 调用gzip来压缩归档文件，与-x联用时调用gzip完成解压缩 -Z 调用compress来压缩归档文件，与-x联用时调用compress完成解压缩 -t ：查看 tarfile 里面的文件！ 特别注意，在参数的下达中， c/x/t 仅能存在一个！不可同时存在！ -p ：使用原文件的原来属性（属性不会依据使用者而变） -P ：可以使用绝对路径来压缩！ -N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中！ —exclude FILE：在压缩的过程中，不要将 FILE 打包！ 例如： 1.将当前目录下所有.txt文件打包并压缩归档到文件this.tar.gz，我们可以使用 tar czvf this.tar.gz ./*.txt 2.将当前目录下的this.tar.gz中的文件解压到当前目录我们可以使用 tar xzvf this.tar.gz ./ 在linux下修改文件的名字有很多种方法，常用的有mv和rename。 一，mv（掌握！） mv fromfile tofile 如把文件a.txt得命名为b.txt，可以是mv a.txt b.txt。 mv一次只能重命名一个文件，而且，它是移动命令。如果tofile已经存在的话，会直接装原文件覆盖，从而造成文件的丢失。当然有选项可以对已存在的文件进行提示，还是决定看看rename吧。 例子：将目录A重命名为B mv A B 例子：将/a目录移动到/b下，并重命名为c mv /a /b/c 二，rename(暂时先了解) Linux的 rename 命令有两个版本(C语言和Perl语言)，早期的Linux发行版基本上使用的是C语言版本，现在系统几乎都是Perl语言版本了(支持正则处理，功能更强大)[1]。可以通过命令man rename打开rename帮助文档查看版本，如果第一行内容如下，则是Perl语言版本。 RENAME(1) Perl Programmers Reference Guide RENAME(1) 鉴于Perl语言版本是主流，本文只介绍该版本下rename的用法。Perl语言版本的rename命令格式如下： rename [ -v ] [ -n ] [ -f ] perlexpr [ files ] -v(verbose)打印被成功重命名的文件 -n(no-act)只是显示将被重命名的文件，而不重命名(重命名之前可以用-n确认需要重命名的文件) -f(force)覆盖已经存在的文件 perlexprPerl语言格式的正则表达式 files需要被替换的文件(比如.c、.h)，如果没给出文件名，将从标准输入读 先举个例子来感受下，比如将当前目录下所有*.nc文件名称中Sam3字串替换成Stm32，命令如下： rename -n ‘s/Sam3/Stm32/‘ .nc /确认需要重命名的文件*/ rename -v ‘s/Sam3/Stm32/‘ .nc /执行修改，并列出已重命名的文件*/ 整个命令的重点在于Perl语言正则表达式，下一部分将予以较详细的介绍。 perlexpr参数介绍：Perl正则表达式——三种形式 匹配：m// (可以省略m，直接写成/regexp/) 替换：s/// 转化：tr/// rename命令常用到替换和转化两种(用匹配也没意义)。转换跟替换不同，替换是将replacement整个字符串替换pattern字符串，而转换则是用replacement逐个字符替换pattern逐个字符，结果依赖于replacement与pattern字符个数(见下述分析)。(1)替换替换表达方式如下[3]，还有一系列参数，貌似不怎么用得着。 s/PATTERN/REPLACEMENT/egimosx eEvaluate the right side as an expression. gMatch globally, i.e. all occurrences. iCase-insensitive pattern matching. mTreat string as multiple lines. oOnly compile pattern once, even if variables within it change. sTreat string as single line. xUse extended regular expressions (2)转化转化有两种等价表达方式，如下： tr/SEARCHLIST/REPLACEMENTLIST/cds y/SEARCHLIST/REPLACEMENTLIST/cds cComplement the SEARCHLIST. dDelete found but unreplaced characters. sSquash duplicate replaced characters. 转化同替换不同，用REPLACEMENTLIST逐个字符替换SEARCHLIST逐个字符，比如’tr/Sam/Stm/‘，用S替代S，t替代a，m替代m。结果依赖于两者字符长短，下面以文件名FastSpiSam3C.nc为例进行说明： jelline@jelline:~$ rename -n ‘tr/Sam3/Stm/‘ FastSpiSam3C.nc /替换字符短，用最后一个字符m替换3/ FastSpiSam3C.nc renamed as FtstSpiStmmC.nc jelline@jelline:~$ rename -n ‘tr/Sam3/Stm32/‘ FastSpiSam3C.nc /替换字符长，多出字符被忽略/ FastSpiSam3C.nc renamed as FtstSpiStm3C.nc [ files ]参数介绍：支持通配符——三种? 可替代单个字符 * 可替代多个字符 [charset] 可替代charset集中的任意单个字符 使用通配符即可对所有符合条件的文件名进行批量修改。 实例 1 **将所有.nc文件中Sam3替换成Stm32* rename -v ‘s/Sam3/Stm32/‘ .nc /执行修改，并列出已重命名的文件*/ 2 去掉文件后缀名(比如去掉.bak) rename ‘s/\.bak$//‘ *.bak 3 将文件名改为小写 rename ‘y/A-Z/a-z/‘ * 4 去掉文件名的空格 rename ‘s/[ ]+//g’ * 5 文件开头加入字符串(比如jelline) rename ‘s/^/jelline/‘ * 6 文件末尾加入字符串(比如jelline) rename ‘s/$/jelline/‘ * 更详细的rename命令参考： http://blog.chinaunix.net/uid-9112803-id-2377271.html 转载参考： http://blog.csdn.net/zhaoweixing1989/article/details/8954452 http://blog.chinaunix.net/uid-28458801-id-4205443.html http://blog.csdn.net/inuyasha1121/article/details/51644269 Ubuntu 更改文件夹权限 Ubuntu的许多操作是在终端中进行的，通过sudo命令管理的文件是由root持有权限的，一般用户是无法改变的。在图形界面上，我们可以通过属性中的权限选项夹进行操作。但是一旦文件的属性显示当前用户没有读写权力时，无法在图形界面上修改权限。 常用方法如下： sudo chmod 600 ××× （只有所有者有读和写的权限） sudo chmod 644 ××× （所有者有读和写的权限，组用户只有读的权限） sudo chmod 700 ××× （只有所有者有读和写以及执行的权限） sudo chmod 666 ××× （每个人都有读和写的权限） sudo chmod 777 ××× （每个人都有读和写以及执行的权限） 其中×××指文件名（也可以是文件夹名，不过要在chmod后加-ld）。 解释一下，其实整个命令的形式是 sudo chmod -（代表类型）×××（所有者）×××（组用户）×××（其他用户） 三位数的每一位都表示一个用户类型的权限设置。取值是0～7，即二进制的[000]~[111]。 这个三位的二进制数的每一位分别表示读、写、执行权限。 如000表示三项权限均无，而100表示只读。这样，我们就有了下面的对应： 0 [000] 无任何权限 4 [100] 只读权限 6 [110] 读写权限 7 [111] 读写执行权限 现在看上面的几个常用用法就非常清楚了。试着自己来修改权限吧 ！最后同时附上查询文件（或文件夹）权限的命令 ls -l 文件名称 （文件夹将-l改为-ld）。 原文地址:http://liufeng2008.blogspot.com/2008/08/ubuntu.html chmod命令详细用法 指令名称 : chmod 使用权限 : 所有使用者 使用方式 : chmod [-cfvR] [—help] [—version] mode file… 说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。 参数 : mode : 权限设定字串，格式如下 : [ugoa…][[+-=][rwxX]…][,…]，其中 u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 -c : 若该档案权限确实已经更改，才显示其更改动作 -f : 若该档案权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更) —help : 显示辅助说明 —version : 显示版本 范例 :将档案 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt 将档案 file1.txt 设为所有人皆可读取 : chmod a+r file1.txt 将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : chmod ug+w,o-w file1.txt file2.txt 将 ex1.py 设定为只有该档案拥有者可以执行 : chmod u+x ex1.py 将目前目录下的所有档案与子目录皆设为任何人可读取 : chmod -R a+r * 此外chmod也可以用数字来表示权限如 chmod 777 file 语法为：chmod abc file 其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 r=4，w=2，x=1 若要rwx属性则4+2+1=7； 若要rw-属性则4+2=6； 若要r-x属性则4+1=7。 范例： chmod a=rwx file 和 chmod 777 file 效果相同 chmod ug=rwx,o=x file 和 chmod 771 file 效果相同 若用chmod 4755 filename可使此程序具有root的权限 原文地址:http://bbs.chinaunix.net/viewthread.php?tid=240097]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu16.04</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows10下硬盘安装 linux`Ubuntu16.04LTS（长期支持版本）及注意事项]]></title>
    <url>%2Fpost%2Fd327ea79.html</url>
    <content type="text"><![CDATA[Ubuntukylin-15.10-enhanced-release-amd64在生存9个月后，今年已经对其停止维护与安全更新。然而，Ubuntu 16.04 LTS早已正式发布下载，长达5年技术支持。Ubuntu 每年发布两个版本，目前最新正式版版本也升到了 16.04。Ubuntu 16.04 开发代号为“Xenial Xerus”，为第六个长期支持（LTS）版本，其主要特色是引入了新的 snap 包格式和 LXD 纯容器 hypervisor。 Ubuntu 16.04 的其他特点包括：支持 IBM LinuxONE 及 z Systems 的 s390x 架构 引入新的 Ubuntu MATE 社区版本 Linux 内核更新到 4.4.6，包含 ZFS on Linux 桌面版本的 GTK、Qt 均已升级至最新版本，包含 Firefox 45、Chromium 48、LibreOffice 5.1、Python 3.5 等 服务器版本包含 OpenStack Mitaka、Juju 2.0、LXD 2.0、NGINX 1.9.15、Docker 1.10、PHP 7.0、MySQL 5.7 等 ubuntu-16.04-desktop-amd64.iso /32 位 下载资源详见MORE——&gt; 具体安装教程： p本人，U盘、硬盘在上年安装过15.10，终于在设置win10引导时 15.10殒命。现在要利用ubuntu-16.04-desktop-amd64.iso &amp; EasyBCD 在win10硬盘下安装16.04. 1.由于事先已分盘73G空闲在15.10.首先 在win10下利用我的电脑—管理—硬盘管理中 删除卷——15.10东西（数据是无价的，里面数据已经为空）。 P.S.如果是没有压缩过盘符，分过区的朋友可以在F分区上点右键，选择“压缩卷”，在”输入压缩空间量”里写上你想压缩出的空间（按照 M 为单位计算）,然后点压缩按钮，这样就会出现一个空白区域。 2.下载EasyBCD和Ubuntu 16.04 的ubuntu-16.04-desktop-amd64.iso镜像文件。 下面把准备好的ubuntu-16.04-desktop-amd64.iso镜像文件用压缩软件或者虚拟光驱打开， 找到casper文件夹，把里面的 “.disk”文件夹、initrd.lz和vmlinuz.efi解压到F分区(别的分区也可以)。 3.下面打开EasyBCD软件，来给要安装的ubuntu镜像文件加一个启动安装的“入口” 依次按图提示点击： 然后就会出现一个menu.lst文件，把以下内容写进menu.lst title Install Ubuntu root (hd0,6) kernel (hd0,6)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-16.04-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8 initrd (hd0,6)/initrd.lz menu.lst有几个问题需要注意 (1) (hd0,6)的6表示ubuntu-16.04-desktop-amd64.iso，initrd.lz和vmlinuz.efi 三个文件存放的位置，因为我放在F分区，应该这样写： 如果是放在C盘就写0，D盘就写4,在E盘就写5,因为我放在F盘，所以我写的是6 (2) vmlinuz.efi 一定要写上扩展名efi,网上好多教程都没写扩展名，不写扩展名重启后会提示找不到文件 (3) ubuntu-16.04-desktop-amd64.iso是你的iso的名字，别写成我的了，这个要改成你的。 4.重启电脑 你就会看到有2个 启动菜单，选择 NeoGrub 引导加载器 这个选项。 然后稍等一会， 就会进入想要安装的 Ubuntu桌面了。 5.进入ubuntu桌面后， 记得按Ctrl+Alt+T 打开终端，输入命令:sudo umount -l /isodevice这一命令取消掉对光盘所在 驱动器的挂载： （注意，这里的-l是L的小写，-l 与 /isodevice 有一个空格！！！！！！），否则分区界面找不到分区。 6.下面就点击桌面 安装Ubuntu 16.04开始安装: 不选 因为否则会安装、等待的时间比较长！ 选安装类型，我们用其他选项。 这样我们可以自定义。 P.S.当弹出来，是否 卸载加载的sda时 选择否即可。 接下来就是分区： 这样您可以自己创建、调整分区、或者为 Ubuntu 选择多个分区。 网上有推进分区的方案如下(以30G为例)： / 20G ext4（根分区可以大点） SWAP 2G /home 8G ext4（剩下的给/home） 如果跟我学，就（73G）分配4个区间： 第一次分区： “空闲”处点“+”，进行如下设置：挂载点：“/” 大小：57344MB 新分区的类型：逻辑分区（如果选择主分区可能会因此 空闲的空间变为“不可用”！） 新分区的位置：空间起始位置 用于：EXT4日志文件系统 第二次分区： “空闲”处，继续点“+”，如下设置， 挂载点：（不设置） 大小：4096MB 新分区的类型：逻辑分区 新分区的位置：空间起始位置 用于：交换空间 第三次分区： “空闲”处，继续点“+”，如下设置， 挂载点：/boot （网上有的说不需要设置这项，但双系统引导时需要，先不要去理解这些） 大小：151MB 新分区的类型：逻辑分区 新分区的位置：空间起始位置 用于：EXT4日志文件系统 第四次分区： “空闲”处，继续点“+”，如下设置， 挂载点：/home 大小：剩余全部空间，剩下显示多少，就多少 新分区的类型：逻辑分区 新分区的位置：空间起始位置 用于：EXT4日志文件系统 第四次分区完成后请不要点“安装”！！！ 第四次分区完成后请不要点“安装”！！！ 第四次分区完成后请不要点“安装”！！！ 记得在下图所示的“安装启动引导器的设备：”选项中选择/boot所在盘符，这里的是/dev/sda10，至此，点击“安装”，一直等到出现安装完成重启的提示，重启就好了，还有的说自动联网的，最好拔下网线，安装过程中会下载语言包等文件，会要一些时间，认为可以安装好后再下载，有空的就联网安装吧。这里选择不联网安装。 然后你会发现，重启之后仍然是Windows，这时候你多半会骂这是哪个傻逼写的，不懂还在这里瞎逼逼。耐心点，看下一步~ 7.安装 EasyBCD，这个软件是用于系统配置创建多重启动系统的引导文件，也就是新创建一个启动文件，可以让你的电脑在启动的时候，有进入何种系统的选择。 “添加新条目” -“Linux/BSD”-类型“Grub 2”驱动器“自动定位和加载”-“添加条目”，保存后重启计算机，计算机会提示你选择Windows还是“NeoSmart Linux”，选择后者，大功告成。 之后你就可以删除之前的安装配置文件了：1）EasyBCD—添加新条目—NeoGrub； 2）删除win10 F盘中的 “.disk”文件夹、initrd.lz和vmlinuz.efi 以及Ubuntu16.04 ISO包。 至此 可以完成Windows10下硬盘安装 linux`Ubuntu16.04LTS（长期支持版本）。并且由win10引导！一定可以成功！请仔细查看、揣摩本文档的细节，也可多查看帮助文档。谢谢。 参考下载： Ubuntu 16.04 LTS官方镜像下载： 32位：http://releases.ubuntu.com/16.04/ubuntu-16.04-desktop-i386.iso 64位：http://releases.ubuntu.com/16.04/ubuntu-16.04-desktop-amd64.iso Ubuntu 16.04 LTS 今日发布 Canonical公布系统新特性 http://www.linuxidc.com/Linux/2016-04/130466.htm Ubuntu 16.04 LTS值得关注的新特性和改进盘点 http://www.linuxidc.com/Linux/2016-04/130136.htm 将Ubuntu 15.10升级到Ubuntu 16.04 http://www.linuxidc.com/Linux/2016-03/129158.htm Ubuntu 16.04安装Lua游戏引擎Love http://www.linuxidc.com/Linux/2016-03/129108.htm Ubuntu 16.04 需要你的帮助，让 GNOME Software 更美观 http://www.linuxidc.com/Linux/2016-03/129237.htm 更多Ubuntu相关信息见Ubuntu 专题页面 http://www.linuxidc.com/topicnews.aspx?tid=2 本文永久更新链接地址：http://www.linuxidc.com/Linux/2016-04/130508.htm 参考： Linux公社 http://blog.csdn.net/zwyjg/article/details/16371349 引导默认地： /boot sudo umount -l /isodevice 否 不卸载挂载 以上请详细阅读文中、自己多揣摩、提高思路、能力。]]></content>
      <categories>
        <category>计算机基础--安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IDEA关于导出JAR包与添加JAR包]]></title>
    <url>%2Fpost%2F685c5390.html</url>
    <content type="text"><![CDATA[一、Jar包 Java —IDEA 导出java可执行jar包保证自己的Java代码是没有问题的，在IDEA里面是可以正常运行的，然后，按下面步骤：打开File -&gt; Project Structure -&gt; Artifacts，点击“+”，选择“Jar”，选择Empty或From modules with dependencies，后者会把在项目中用到的Jar包解压开，当成项目的一部分，打包到最后的Jar包中。但是这样会有一个问题，即，如果项目中引用的Jar包有签名过，最后打包成的Jar包运行时会抛出错误：“java.lang.SecurityException: Invalid signature file digest for Manifest main attributes”因此，笔者选择的是Empty，然后在“Output Layout”中，把自己要打包的文件、文件夹添加进去。对于外部引用的包，笔者全部放在lib目录下，因此，在Class Path中，把依赖的jar包添加进去，例如：lib/javax.servlet-3.0.0.v201112011016.jar lib/jetty-all-9.1.5.v20140505.jar lib/json-simple-1.1.1.jar设置好Main Class，这就不用多说了。点击OK。回到IDEA，选择Build -&gt; Build Artifacts，成功生成Jar包。生成的Jar包位于上图设置的Output directory。使用命令java -jar xxxxx.jar来执行jar包。P.S.1.菜单：File-&gt;project stucture2.在弹窗最左侧选中Artifacts-&gt;”+”,选jar，选择from modules with dependencies，然后会有配置窗口出现，配置完成后，勾选Build on make &gt;ok保存3.然后菜单：Build-&gt;make project4.最后在项目目录下去找输出的jar包（路径在你添加Artifacts的时候设置的路径）D:\\JAVA\\myJavaPro\\JavaLib\\out\\artifacts\\JavaLib_jar 二、IDEA 项目下 添加Jar包 点击 File -&gt; Project Structure（快捷键 Ctrl + Alt + Shift + s），点击Project Structure界面左侧的“Modules”。 在 “Dependencies” 标签界面下，点击右边绿色的 “+”号，选择第一个选项“JARs or directories…”，选择相应的jar包，点“OK”，jar包添加成功。 点“OK”回到项目界面，IntelliJ IDEA自动提示需要添加import语句，利用 Alt+Enter 键快速添加import语句之后，项目能够成功编译。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHPKJ_S04]]></title>
    <url>%2Fpost%2Ffaf7a6d7.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576一、普通查询方式 a、字符串 $arr=$m-&gt;where(&quot;sex=0 and username=&apos;gege&apos;&quot;)-&gt;find(); b、数组 $data\[&apos;sex&apos;\]=0; $data\[&apos;username&apos;\]=&apos;gege&apos;; $arr=$m-&gt;where($data)-&gt;find(); 注意：这种方式默认是and的关系，如果使用or关系，需要添加数组值 $data\[&apos;sex&apos;\]=0; $data\[&apos;username&apos;\]=&apos;gege&apos;; $data\[&apos;_logic&apos;\]=&apos;or&apos;;二、表达式查询方式 $data\[&apos;id&apos;\]=array(&apos;lt&apos;,6); $arr=$m-&gt;where($data)-&gt;select(); EQ 等于 NEQ不等于 GT 大于 EGT大于等于 LT 小于 ELT小于等于 LIKE 模糊查询 $data\[&apos;username&apos;\]=array(&apos;like&apos;,&apos;%ge&apos;); $arr=$m-&gt;where($data)-&gt;select(); NOTLIKE $data\[&apos;username&apos;\]=array(&apos;notlike&apos;,&apos;%ge%&apos;); //notlike中间没有空格 $arr=$m-&gt;where($data)-&gt;select(); 注意：如果一个字段要匹配多个通配符 $data\[&apos;username&apos;\]=array(&apos;like&apos;,array(&apos;%ge%&apos;,&apos;%2%&apos;,&apos;%五%&apos;),&apos;and&apos;);//如果没有第三个值，默认关系是or关系 $arr=$m-&gt;where($data)-&gt;select(); BETWEEN $data\[&apos;id&apos;\]=array(&apos;between&apos;,array(5,7)); $arr=$m-&gt;where($data)-&gt;select(); //SELECT * FROM \`tp_user\` WHERE ( (\`id\` BETWEEN 5 AND 7 ) ) $data\[&apos;id&apos;\]=array(&apos;not between&apos;,array(5,7));//注意，not 和 between中间一定要有空格 $arr=$m-&gt;where($data)-&gt;select(); IN $data\[&apos;id&apos;\]=array(&apos;in&apos;,array(4,6,7)); $arr=$m-&gt;where($data)-&gt;select(); //SELECT * FROM \`tp_user\` WHERE ( \`id\` IN (4,6,7) ) $data\[&apos;id&apos;\]=array(&apos;not in&apos;,array(4,6,7)); $arr=$m-&gt;where($data)-&gt;select(); //SELECT * FROM \`tp_user\` WHERE ( \`id\` NOT IN (4,6,7) )三、区间查询 $data\[&apos;id&apos;\]=array(array(&apos;gt&apos;,4),array(&apos;lt&apos;,10));//默认关系是 and 的关系 //SELECT * FROM \`tp_user\` WHERE ( (\`id\` &gt; 4) AND (\`id\` &lt; 10) ) $data\[&apos;id&apos;\]=array(array(&apos;gt&apos;,4),array(&apos;lt&apos;,10),&apos;or&apos;) //关系就是or的关系 $data\[&apos;name&apos;\]=array(array(&apos;like&apos;,&apos;%2%&apos;),array(&apos;like&apos;,&apos;%五%&apos;),&apos;gege&apos;,&apos;or&apos;);四、统计查询 count() //获取个数 max(&apos;id&apos;) //获取最大数 min //获取最小数 avg //获取平均数 sum //获取总和 tongshang五、SQL直接查询 a、query 主要数处理读取数据的 成功返回数据的结果集 失败返回boolean false $m=M(); $result=$m-&gt;query(&quot;select * from tp_user where id &gt;50&quot;); var_dump($result); b、execute 用于更新个写入操作 成功返回影响行数 失败返回boolean false $m=M(); $result=$m-&gt;execute(&quot;insert into tp_user(\`username\`) values(&apos;ztz3&apos;)&quot;); var_dump($result); //已经插入与P.S. **在 PHP 中，有两种基本的输出方法：echo 和 print。** echo 和 print 之间的差异：* echo - 能够输出一个以上的字符串* print - 只能输出一个字符串，并始终返回 1提示：echo 比 print 稍快，因为它不返回任何值。有无括号均可使用（同时请注意字符串中能包含 HTML 标记）! Eg: echo &quot;&lt;h2&gt;PHP is fun!&lt;/h2&gt;&quot;; echo &quot;Hello world!&lt;br&gt;&quot;; echo &quot;I&apos;m about to learn PHP!&lt;br&gt;&quot;; echo &quot;This&quot;, &quot; string&quot;, &quot; was&quot;, &quot; made&quot;, &quot; with multiple parameters.&quot;; $txt1=&quot;Learn PHP&quot;; $txt2=&quot;W3School.com.cn&quot;; $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;SAAB&quot;); echo $txt1; echo &quot;&lt;br&gt;&quot;; echo &quot;Study PHP at $txt2&lt;br&gt;&quot;; echo &quot;My car is a &#123;$cars\[2\]&#125;&quot;; echo &quot;&lt;h2&gt;PHP is fun!&lt;/h2&gt;&quot;; echo &quot;Hello world!&lt;br&gt;&quot;; echo &quot;I&apos;m about to learn PHP!&lt;br&gt;&quot;; echo &quot;This&quot;, &quot; string&quot;, &quot; was&quot;, &quot; made&quot;, &quot; with multiple parameters.&quot;; $txt1=&quot;Learn PHP&quot;; $txt2=&quot;W3School.com.cn&quot;; $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;SAAB&quot;); echo $txt1; echo &quot;&lt;br&gt;&quot;; echo &quot;Study PHP at $txt2&lt;br&gt;&quot;; echo &quot;My car is a &#123;$cars\[2\]&#125;&quot;;]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHPKJ_S03--查询方式的一般使用]]></title>
    <url>%2Fpost%2F141a14e7.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647一、普通查询方式 a、字符串 $arr=$m-&gt;where(&quot;sex=0 and username=&apos;gege&apos;&quot;)-&gt;find(); //不推荐使用 b、数组 $data\[&apos;sex&apos;\]=0; $data\[&apos;username&apos;\]=&apos;gege&apos;; $arr=$m-&gt;where($data)-&gt;find(); //建议 存数组，查找数组 来输出。规范化输出 注意：这种方式默认是and的关系，如果使用or关系，需要添加数组值 $data\[&apos;sex&apos;\]=0; $data\[&apos;username&apos;\]=&apos;gege&apos;; $data\[&apos;_logic&apos;\]=&apos;or&apos;;二、表达式查询方式 $data\[&apos;id&apos;\]=array(&apos;lt&apos;,6); $arr=$m-&gt;where($data)-&gt;select(); EQ 等于 NEQ不等于 GT 大于 EGT大于等于 LT 小于 ELT小于等于 LIKE 模糊查询 $data\[&apos;username&apos;\]=array(&apos;like&apos;,&apos;%ge&apos;);//% 通配符 前后包含多个字符！ $arr=$m-&gt;where($data)-&gt;select(); NOTLIKE $data\[&apos;username&apos;\]=array(&apos;notlike&apos;,&apos;%ge%&apos;); //notlike中间没有空格 $arr=$m-&gt;where($data)-&gt;select(); 注意：如果一个字段要匹配多个通配符 $data\[&apos;username&apos;\]=array(&apos;like&apos;,array(&apos;%ge%&apos;,&apos;%2%&apos;,&apos;%五%&apos;),&apos;and&apos;);//如果没有第三个值，默认关系是or关系 $arr=$m-&gt;where($data)-&gt;select(); //gege 李四2 王五 默认输出！ BETWEEN $data\[&apos;id&apos;\]=array(&apos;between&apos;,array(5,7)); //输出 5--7 之间的！ $arr=$m-&gt;where($data)-&gt;select(); //SELECT * FROM \`tp_user\` WHERE ( (\`id\` BETWEEN 5 AND 7 ) ) $data\[&apos;id&apos;\]=array(&apos;not between&apos;,array(5,7));//注意，not 和 between中间一定要有空格 $arr=$m-&gt;where($data)-&gt;select(); IN $data\[&apos;id&apos;\]=array(&apos;in&apos;,array(4,6,7)); //数组 包含一堆输出！即可！ $arr=$m-&gt;where($data)-&gt;select(); //SELECT * FROM \`tp_user\` WHERE ( \`id\` IN (4,6,7) ) $data\[&apos;id&apos;\]=array(&apos;not in&apos;,array(4,6,7)); $arr=$m-&gt;where($data)-&gt;select(); //SELECT * FROM \`tp_user\` WHERE ( \`id\` NOT IN (4,6,7) )三、区间查询四、统计查询五、SQL直接查询 P.S.昨天做的 \_\_URL\_\_ 并不稳定！！！ select()可以获取 某个表里所有数据，并以数组形式返回！ find(1) //要加入id号 where - - getField(&apos;uesername&apos;) //获取字段为 username的信息！]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHPKJ_S02]]></title>
    <url>%2Fpost%2F139403e2.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;script&gt; hidden &lt;form action = &quot;\_\_URL\_\_create&quot; method =&apos;post&apos; &gt;&lt;!-- create 不再生成个脚本文件了，直接添加方法创建C 中 直接用 --&gt; 利用 “\_\_URL\_\_ ”动态的寻找 域名（项目）到模块的部分！ $_POST\[\] UserAction.class.php&lt;?php// 本类由系统自动生成，仅供测试用途class UserAction extends Action &#123; public function index()&#123; $m = M(&apos;User&apos;); $arr = $m -&gt; select(); //var_dump($arr); $this -&gt; assign( &apos;data&apos;,$arr ); $this -&gt; display(); &#125; public function del()&#123; $m = M(&apos;User&apos;); $id = $_GET\[&apos;id&apos;\]; $count = $m -&gt;delete($id); if($count &gt; 0)&#123; $this -&gt; success(&apos; 数据删除成功! &apos;); &#125; else &#123; $this -&gt;error(&apos; 数据删除失败！ &apos;); &#125; &#125; /**负责显示修改页面！ */ public function modify() &#123; $id = $_GET\[&apos;id&apos;\]; $m = M(&apos;User&apos;); $arr = $m -&gt; find($id); $this -&gt; assign(&apos;data&apos;,$arr); $this -&gt; display(); &#125; public function update() &#123; $m = M(&apos;User&apos;); $data\[&apos;id&apos;\] = $_POST\[&apos;id&apos;\]; $data\[&apos;username&apos;\] = $_POST\[&apos;username&apos;\]; $data\[&apos;sex&apos;\] = $_POST\[&apos;sex&apos;\]; $count = $m-&gt;save($data); //好像是 返回修改的多少！ if($count &gt; 0)&#123; $this -&gt; success(&apos;数据修改成功！&apos;,&apos;index&apos;); &#125; else&#123; $this -&gt; error(&apos;数据修改失败！&apos;); &#125; &#125; /** 负责 产生新增用户的界面！！ */ public function add() &#123; $this -&gt; display(); &#125; public function create() &#123; $m =M(&apos;User&apos;); $m -&gt; username = $_POST\[&apos;username&apos;\]; $m -&gt; sex = $_POST\[&apos;sex&apos;\]; $idNum = $m -&gt; add(); // 会返回一个 id number if( $idNum &gt; 0) &#123; $this -&gt; success( &apos;数据添加成功！&apos; ,&apos;index&apos; ); &#125;else &#123; $this -&gt; error(&apos;数据添加失败！&apos;); &#125; &#125; public function show() &#123; //echo &quot;欢迎你:&quot;-$\_GET\[&apos;name&apos;\]-&apos;你的年龄是：&apos;-$\_GET\[&apos;age&apos;\]; //$this-&gt; display(); &#125; &#125;index.html&lt;html&gt; &lt;head&gt; &lt;meta http-equiv-&quot;content-type&quot; content=&quot;text/html;charset-utf-8&quot;&gt; &lt;title&gt;Index&lt;/title&gt; &lt;script&gt; function jump()&#123; window.location= &quot;/thinkphp/index.php/User/add&quot;; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border = &apos;1&apos; width = &quot;500&quot; align = &apos;center&apos; &gt; &lt;tr&gt; &lt;th &gt;id&lt;/th&gt; &lt;th &gt;username&lt;/th&gt; &lt;th &gt;sex&lt;/th&gt; &lt;th &gt;操作 &lt;/th&gt; &lt;/tr&gt; &lt;volist name = &apos;data&apos; id = &apos;vo&apos;&gt; &lt;tr&gt; &lt;td &gt;&#123;$vo.id &#125;&lt;/td&gt; &lt;td &gt;&#123;$vo.username&#125;&lt;/td&gt; &lt;td &gt;&#123;$vo.sex&#125;&lt;/td&gt; &lt;td &gt;&lt;a href= &quot;/thinkphp/index.php/User/del/id/&#123;$vo.id&#125;&quot; &gt;删除&lt;/a&gt; | &lt;a href=&quot;/thinkphp/index.php/User/modify/id/&#123;$vo.id&#125;&quot; &gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/volist&gt; &lt;/table&gt; &lt;center&gt; &lt;button onclick = &quot;jump()&quot; &gt;添加用户&lt;/button&gt;&lt;!-- Java script --&gt; &lt;/center&gt; &lt;!-- &lt;h1&gt;Hello World！&lt;/h1&gt; &#123;$data&#125; --&gt; &lt;!\-\- 我是在html注释内 --&gt; &lt;/body&gt; &lt;/html&gt;modify.html&lt;html&gt; &lt;head&gt; &lt;meta http-equiv-&quot;content-type&quot; content=&quot;text/html;charset-utf-8&quot;&gt; &lt;title&gt;Modify&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; if(&#123;$data.sex &#125;== 0 )&#123; &lt;!\-\- alert(0); --&gt; document.getElementsByName(&apos;sex&apos;)\[1\].checked = &apos;checked&apos;; &#125;else&#123; document.getElementsByName(&apos;sex&apos;)\[0\].checked = &apos;checked&apos;; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action = &quot;/thinkphp/index.php/User/update&quot; method =&apos;post&apos; &gt; &lt;input type = &apos;hidden&apos; name = &apos;id&apos; value = &quot;&#123;$data.id&#125;&quot; /&gt; &lt;!-- 隐藏域 --&gt; 姓名：&lt;input type = &quot;text&quot; name = &apos;username&apos; value = &quot;&#123;$data.username&#125;&quot;/&gt;&lt;/br&gt; 性别：男&lt;input type = &quot;radio&quot; name = &apos;sex&apos; value = &apos;1&apos; &gt; 女&lt;input type = &quot;radio&quot; name = &apos;sex&apos; value = &apos;0&apos;/&gt;&lt;/br&gt; &lt;input type = &apos;submit&apos; value = &quot;提交修改&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;add.html&lt;html&gt; &lt;head&gt; &lt;meta http-equiv-&quot;content-type&quot; content=&quot;text/html;charset-utf-8&quot;&gt; &lt;title&gt;Add&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action = &quot;/thinkphp/index.php/User/create&quot; method =&apos;post&apos; &gt;&lt;!-- create 不再生成个脚本文件了，直接添加方法创建C 中 直接用 --&gt; &lt;!-- &lt;input type = &apos;hidden&apos; name = &apos;id&apos; value = &quot;&#123;$data.id&#125;&quot; /&gt; 隐藏域 --&gt; 姓名：&lt;input type = &quot;text&quot; name = &apos;username&apos; /&gt;&lt;/br&gt; 性别：男&lt;input type = &quot;radio&quot; name = &apos;sex&apos; value = &apos;1&apos; &gt; 女&lt;input type = &quot;radio&quot; name = &apos;sex&apos; value = &apos;0&apos;/&gt;&lt;/br&gt; &lt;input type = &apos;submit&apos; value = &quot;添加新用户&quot;/&gt; &lt;!\-\- 添加新用户后 form 调用 action 利用 method 进行方法操作！ --&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;CURD php+html 了解了 Control 层的 1.对 M层的 数据调用 2.对 V层的前端 html 的书写 3. modify（）// 负责页面的书写 调用回 C 使用update方法----&lt;不再生成个脚本文件了 ！ -- update（）// form 标签是个关键！ 负责更新 M 4. add() //页面 --create()// 添加入 M层 数据！ 同 3.！！！ 5.注意返回的数值！！来检测 成功与否。 6.最后的跳转一定注意！]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHPKJ_S01]]></title>
    <url>%2Fpost%2F8a9d5258.html</url>
    <content type="text"><![CDATA[D:\\wamp\\www\\thinkphp\\Home\\Lib\\Action D:\\wamp\\www\\thinkphp\\Home\\Lib\\Model D:\\wamp\\www\\thinkphp\\Home\\Tpl 123456789&lt;volist name = &apos;data&apos; id = &apos;vo&apos;&gt; &lt;tr&gt; &lt;td &gt;&#123;$vo.id &#125;&lt;/td&gt; &lt;td &gt;&#123;$vo.username&#125;&lt;/td&gt; &lt;td &gt;&#123;$vo.sex&#125;&lt;/td&gt; &lt;td &gt;&lt;a href = &quot;/thinkphp/index.php/User/del/id/&#123;$vo.id&#125;&quot; &gt;删除&lt;/a&gt; | 修改&lt;/td&gt; &lt;/tr&gt; &lt;/volist&gt; ThinkPHP作为面向对象的框架， 全部 由C层 控制台来控制输入输出。调用模板、数据库！1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;meta http-equiv-&quot;content-type&quot; content=&quot;text/html;charset-utf-8&quot;&gt; &lt;title&gt;Modify&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; if(&#123;$data.sex &#125;== 0 )&#123; alert(0); document.getElementsByName(&apos;sex&apos;)\[1\].checked = true; &#125;else&#123; document.getElementsByName(&apos;sex&apos;)\[0\].checked = &apos;checked&apos;; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; 姓名：&lt;input type = &quot;text&quot; name = &apos;username&apos; value = &quot;&#123;$data.username&#125;&quot;/&gt;&lt;/br&gt; 性别：男&lt;input type = &quot;radio&quot; name = &apos;sex&apos; value = &apos;1&apos; &gt; 女&lt;input type = &quot;radio&quot; name = &apos;sex&apos; value = &apos;0&apos;/&gt;&lt;/br&gt; &lt;input type = &apos;submit&apos; value = &quot;提交修改&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>ThinkPHP</category>
        <category>ThinkphpPri</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The classes using methodnow]]></title>
    <url>%2Fpost%2F19126c73.html</url>
    <content type="text"><![CDATA[Math. Arrarys. Arrays (Java Platform SE 6)// &lt;![CDATA[ function windowTitle() { if (location.href.indexOf(‘is-external=true’) == -1) { parent.document.title=”Arrays (Java Platform SE 6)”; } } // ]]&gt; static [String](../../java/lang/String.html &quot;java.lang 中的类&quot;) **[toString](../../java/util/Arrays.html#toString(int[]))**(int[] a) 返回指定数组内容的字符串表示形式。 java中String字符串转化为数字：转换为浮点型： 使用Double或者Float的parseDouble或者parseFloat方法进行转换 String s = ``&quot;123.456 &quot;``; ``//要确保字符串为一个数值，否则会出异常 double d = Double.parseDouble(s); float f = Float.parseFloat(s); 转换为整型： 使用Integer的parseInt方法进行转换。 int i = Integer.parseInt([String]);``//[String]待转换的字符串 java.lang.String ！字符串的比较public boolean equals(Object obj)== 与 equalsString s1 = “abc”; String s2 = “abc”; boolean v1 = s1 == s2; boolean v2 = s1.equals(s2);！“” 与 null“”是一个值为空的字符串（值存在）null是一个空引用（值不存在）！关于“”、“ ”和null之间关系的描述中正确的是：A、“”和“ ”等价 B、“”和null等价 C、“ ”和null等价 D、互不相同内容不可变！ boolean equals(String str) str：要作比较的字符串对象。 返回：如果和 String 相等则为 true；否则为 false。 例如字符串“abc” 和一个新的字符串“abc” 比较的结果为“true” 因为它们内容相同。 ， 注意： equals()方法比较的是对象的内容（区分字母的大小写格式），但是如果使用“==”双等 号操作符比较两个对象时， 比较的是两个对象的内存地址， 所以它们不相等 （即使内容相同， 不同对象的内存地址也是不相同的） **%s字符串类型“mingrisoft”%c字符类型‘m’%b布尔类型true%d整数类型（十进制）99%x整数类型（十六进制）FF%o整数类型（八进制）77%f浮点类型99.99%a十六进制浮点类型FF.35AE%e指数类型9.38e+5%g通用浮点类型（f和e类型中较短的） %h散列码 %%百分比类型％%n换行符 %tx日期与时间类型（x代表不同的日期与时间转换符 str=String.format(“Hi,%s:%s.%s”, “王南”,”王力”,”王张”);Other：Date date=new Date(); // 创建日期对象 String str=String.format(Locale.US,”英文月份简称：%tb”,date);** java.lang.StringBuffer**（StringBuilder**）** [StringBuffer](mk:@MSITStore:D:\prince@z\JDK_API_1_6_zh_CN.CHM::/java/lang/StringBuffer.html &quot;java.lang 中的类&quot;) **[append](mk:@MSITStore:D:\prince@z\JDK_API_1_6_zh_CN.CHM::/java/lang/StringBuffer.html#append(boolean))**( [StringBuilder](mk:@MSITStore:D:\prince@z\JDK_API_1_6_zh_CN.CHM::/java/lang/StringBuilder.html &quot;java.lang 中的类&quot;) **[append](mk:@MSITStore:D:\prince@z\JDK_API_1_6_zh_CN.CHM::/java/lang/StringBuilder.html#append(boolean))**(boolean b) 将 boolean 参数的字符串表示形式追加到序列。 查找JDK！ADD java.text.Simple**DateFormat** Tc：String pattern = “**yyyy.MM.dd-HH:mm:ss**”;SimpleDateFormat fmt = new SimpleDateFormat**(pattern**);String str = fmt.format**(new Date()); //**2016.01.01-10:20:0 /** SimpleDateFormat函数语法： G 年代标志符 y 年** M 月 d 日 h 时 在上午或下午 (1~12) H 时 在一天中 (0~23) m 分 s 秒 S 毫秒 E 星期 D 一年中的第几天 F 一月中第几个星期几 w 一年中第几个星期 *W 一月中第几个星期 a 上午 / 下午 标记符 k 时 在一天中 (1~24) K 时 在上午或下午 (0~11) z 时区 / System.out.println(myFmt4.format(now)); System.out.println(now.toGMTString()); System.out.println(now.toLocaleString()); System.out.println(now.toString()); 一年中的第 351 天 一年中第51个星期 一月中第3个星期 在一天中17时 CST时区** 16 Dec 2004 09:24:27 GMT2004-12-16 17:24:27Thu Dec 16 17:24:27 CST 2004 java.lang.Math.random java.util.Random Java中存在着两种Random函数：一、java.lang.Math.Random;调用这个Math.Random()函数能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围是[0.0,1.0)的左闭右开区间，返回值是一个伪随机选择的数，在该范围内（近似）均匀分布。例如下面的实验代码Java中的Random（）函数编译通过后运行结果如下图Java中的Random（）函数观察会发现代码的用一个循环10次循环输出num的取值，均随机分布在[0,3)之间！在使用Math.Random()的时候需要注意的地方时该函数是返回double类型的值，所以在要赋值给其他类型的变量的时候注意需要进行塑形转换。二、java.util.Random;在Java的API帮助文档中，总结了一下对这个Random()函数功能的描述：1、java.util.Random类中实现的随机算法是伪随机，也就是有规则的随机，所谓有规则的就是在给定种(seed)的区间内随机生成数字；2、相同种子数的Random对象，相同次数生成的随机数字是完全相同的；3、Random类中各方法生成的随机数字都是均匀分布的，也就是说区间内部的数字生成的几率均等；下面Random()的两种构造方法1.Random()：创建一个新的随机数生成器。2.Random(long seed)：使用单个 long 种子创建一个新的随机数生成器。我们可以在构造Random对象的时候指定种子（这里指定种子有何作用，请接着往下看），如：Random r1 = new Random(20);或者默认当前系统时间对应的相对时间有关的数字作为种子数:Random r1 = new Random();需要说明的是：你在创建一个Random对象的时候可以给定任意一个合法的种子数，种子数只是随机算法的起源数字，和生成的随机数的区间没有任何关系。如下面的Java代码：Random rand =new Random(25);int i;i=rand.nextInt(100);初始化时25并没有起直接作用（注意：不是没有起作用）,rand.nextInt(100);中的100是随机数的上限,产生的随机数为0-100的整数,不包括100。下面是Java.util.Random()方法摘要1.protected int next(int bits)：生成下一个伪随机数。2.boolean nextBoolean()：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的boolean值。3.void nextBytes(byte[] bytes)：生成随机字节并将其置于用户提供的 byte 数组中。4.double nextDouble()：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分布的 double值。5.float nextFloat()：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分布float值。6.double nextGaussian()：返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的double值，其平均值是0.0标准差是1.0。7.int nextInt()：返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。8.int nextInt(int n)：返回一个伪随机数，它是取自此随机数生成器序列的、在（包括和指定值（不包括）之间均匀分布的int值。9.long nextLong()：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。10.void setSeed(long seed)：使用单个 long 种子设置此随机数生成器的种子。方法摘要也就这些，下面给几个例子：1.生成[0,1.0)区间的小数：double d1 = r.nextDouble();2.生成[0,5.0)区间的小数：double d2 = r.nextDouble() 5;3.生成[1,2.5)区间的小数：double d3 = r.nextDouble() 1.5 + 1;4.生成-231到231-1之间的整数：int n = r.nextInt();5.生成[0,10)区间的整数：int n2 = r.nextInt(10);//方法一n2 = Math.abs(r.nextInt() % 10);//方法二前面曾讲到过构造Random对象的时候指定种子的问题，到底指定种子有什么作用呢，这里直接用代码例子来做说明：Java中的Random（）函数在定义的时候分别指定了相同的种子之后，在分别用r1和r2去[0,30)的随机数，结果编译执行后悔发现结果都是呈现AABB型的，说明r1和r2取的随机数是一模一样的（下图为实验截图）。Java中的Random（）函数如果我改动代码，改成下面这样：Java中的Random（）函数再编译输出后，就再也不会得到AABB型的结果，根据代码的区别，就可以知道指定种子数，和不指定种子数的区别在于哪里了。Java中的Random（）函数最后再来简单对比一下这两个随机函数到底的特点：1.java.Math.Random()实际是在内部调用java.util.Random()的,它有一个致命的弱点，它和系统时间有关，也就是说相隔时间很短的两个random比如:double a = Math.random()；double b = Math.random();即有可能会得到两个一模一样的double。2.java.util.Random()在调用的时候可以实现和java.Math.Random()一样的功能，而且他具有很多的调用方法，相对来说比较灵活。所以从总体来看，使用java.util.Random()会相对来说比较灵活一些 import java.text.SimpleDateFormat;import java.util.Date;import java.util.Random;/*** Created by z2829 on 2016/9/25.*/public class JavaLib { public static String formatTime(int second) { int h,m,s; h = second / 3600; m = (second % 3600) / 60; s = second % 3600 % 60; String str = String.format(&quot;hh:mm:ss&quot;,h,m,s); return str; } public static String formatDate(Date date, String pattern) { SimpleDateFormat fom = new SimpleDateFormat(pattern); return fom.format(date); } public static int[] randomNumbers(int num, int max) { int arr\[\] = new int\[num\]; boolean flag = true; Random r = new Random(); arr\[0\] = -1; for ( int i = 0; i &lt; num;i++ ) { int t = r.nextInt(max); for (int j = 0; j &lt; arr.length;j++) { if (t == arr\[j\]){ flag = false;break; } } if (flag) { arr\[i\] = t; } } return arr; } java.lang.Object protected Object clone() Creates and returns a copy of this object. boolean equals(Object obj) Indicates whether some other object is “equal to” this one. protected void finalize() Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. Class&lt;?&gt; getClass() Returns the runtime class of this Object. int hashCode() Returns a hash code value for the object. String toString() Returns a string representation of the object. IDEA生成jar 1. 选中Java项目工程名称，在菜单中选择 File-&gt;project structure… (快捷键Ctrl+Alt+Shift+S)。2. 在弹出的窗口中左侧选中”Artifacts“，点击”+“选择jar，然后选择”from modules with dependencies“。选择Empty或From modules with dependencies，后者会把在项目中用到的Jar包解压开，当成项目的一部分，打包到最后的Jar包中。但是这样会有一个问题，即，/如果项目中引用的Jar包有签名过，最后打包成的Jar包运行时会抛出错误：“java.lang.SecurityException: Invalid signature file digest for Manifest main attributes”/若选择的是Empty，然后在“Output Layout”中，把自己要打包的文件、文件夹添加进去。对于外部引用的包，笔者全部放在lib目录下，因此，在Class Path中，把依赖的jar包添加进去，例如：lib/javax.servlet-3.0.0.v201112011016.jar lib/jetty-all-9.1.5.v20140505.jar lib/json-simple-1.1.1.jar4.设置好Main Class，这就不用多说了。 点击OK。 5、回到IDEA，选择Build -&gt; Build Artifacts，成功生成Jar包。生成的Jar包位于上图设置的Output directory。]]></content>
      <categories>
        <category>Java</category>
        <category>JavaPrimary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础--项目开发起点]]></title>
    <url>%2Fpost%2Fecafb38f.html</url>
    <content type="text"><![CDATA[任何类都可以有main（）方法 项目，包，类。修饰符 左右开弓 package ；import ； 1、 项目名全部小写2、 包名全部小写3、 类名首字母大写，如果类名由多个单词组成，每个单词的首字母都要大写。如：public class MyFirstClass{}4、 变量名、方法名首字母小写，如果名称由多个单词组成，每个单词的首字母都要大写。如：int index=0; public void toString(){} 5、 常量名全部大写如：public static final String GAME_COLOR=”RED”;6、所有命名规则必须遵循以下规则：1)、名称只能由字母、数字、下划线、$符号组成；2)、不能以数字开头！！！3)、名称不能使用JAVA中的关键字；4)、坚决不允许出现中文及拼音命名。 类项目，案例 char charAt( ) compareTo(String anotherString)]]></content>
      <categories>
        <category>Java</category>
        <category>JavaPrimary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Idea调试快捷键]]></title>
    <url>%2Fpost%2Ff98cb447.html</url>
    <content type="text"><![CDATA[ctrl+shift+F10 运行 shift+F10：编译 左侧点击成红点：shift+F9：调试 F9：调试窗口的小三角，执行到下一个断点 shift+F8：逐过程step over（如果当前行有方法调用，这个方法将被执行完毕返回，然后到下一行） shift+F7：逐语句step into向下执行一行。如果该行有自定义方法，则运行进入自定义方法（不进入官方类库的方法） alt+shift+F7：Force step into调试的时候能进入任何方法。 alt+shift+F8：step out，确定某个方法没有问题时，跳出该方法 Drop Frame：返回某个方法的调用处重新执行 ctrl+shift+F8 ：view breakpoints查看断点，可以设置一些属性。 Condition；Variable。 1.println（）%d? is?”is”:”is not” 2.assert is == true； 3.设置断点 4.单步调试（调试整个项目/文件）]]></content>
      <categories>
        <category>Java</category>
        <category>JavaPrimary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[STLvector]]></title>
    <url>%2Fpost%2F55bd62d4.html</url>
    <content type="text"><![CDATA[STL的一些源函数的代码，可查： http://www.cplusplus.com include include include using namespace std;using std::vector;/int main(){ int arr[] = { 1,2,3,4,5,6,7,0 }; vector vec(arr,arr+8);for ( size_t i = 0; i &lt; vec.size() ;i++ ) { std::cout &lt;&lt; vec[i];}std::cout &lt;&lt; std::endl; for(vector::iterator it = vec.begin(); it != vec.end();++it){std::cout &lt;&lt; it;}std::cout &lt;&lt; std::endl;cout &lt;&lt; “Hello world!” &lt;&lt; endl; return 0;}/int main() //using reverse{ int arr[] = { 1,2,3,4,5,0}; vector vec(arr,arr+6);for( size_t i = 0; i &lt; vec.size();i++){cout &lt;&lt; vec[i];} cout &lt;&lt; endl;reverse(vec.begin(),vec.end()); //为这一行新增#include for(vector::iterator it = vec.begin(); it != vec.end();++it){cout &lt;&lt; it;} return 0;}/*size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。在用下标访问元素时，vector使用vector::size_type作为下标类型，而数组下标的正确类型则是size_t。vector使用的下标实际也是size_t，源码是typedef size_t size_type。 在C++中，设计 size_t 就是为了适应多个平台的 。size_t的引入增强了程序在不同平台上的可移植性。size_t是针对系统定制的一种数据类型，一般是整型，因为C/C++标准只定义一最低的位 数，而不是必需的固定位数。而且在内存里，对数的高位对齐存储还是低位对齐存储各系统都不一样。为了提高代码的可移植性，就有必要定义这样的数据类型。一 般这种类型都会定义到它具体占几位内存等。当然，有些是编译器或系统已经给定义好的。经测试发现，在32位系统中size_t是4字节的，而在64位系统中，size_t是8字节的，这样利用该类型可以增强程序的可移植性。 / //portable 便携式，可移植的 vector empty()—true if the container size is 0, false otherwise front()/back() — return reference! push_back(reference)/pop_back() — jin chu! begin()/end() — return iterator! at(0) — access elements! f00.swap(bar); 往 set 里增加一个元素，区别在于新元素的构造上。emplace 使用直接构造，insert 使用复制构造。 std::vector myvector; int sum (0); myvector.push_back (100); myvector.push_back (200); myvector.push_back (300); // vector::iterator it = myvector.end(); // while ( it != myvector.begin()) // { sum += myvector.back(); myvector.pop_back(); sum += myvector.back(); myvector.pop_back(); sum += myvector.back(); // } std::cout &lt;&lt; “The elements of myvector add up to “ &lt;&lt; sum &lt;&lt; ‘\\n’; std::cout &lt;&lt; “The elements of myvector front element to “ &lt;&lt; myvector.at(0) &lt;&lt; ‘\\n’;]]></content>
      <categories>
        <category>C++Go</category>
        <category>D.S.</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++this,Pointer]]></title>
    <url>%2Fpost%2F3d35418f.html</url>
    <content type="text"><![CDATA[一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。 例如，调用date.SetMonth(9) &lt;===&gt; SetMonth(&amp;date, 9)，this帮助完成了这一转换 . this指针是类的一个自动生成、自动隐藏的私有成员，它存在于类的非静态成员函数中，指向被调用函数所在的对象。全局仅有一个this指针，当一个对象被创建时，this指针就存放指向对象数据的首地址。 根据以下程序来说明this指针 #include using namespace std; class Point { private: int x,y; public: Point(int a,int b) { x=a; y=b; } void MovePoint(int a,int b) { x+=a; y+=b; } void print() { cout&lt;&lt;”x=”&lt;]]></content>
      <categories>
        <category>C++Go</category>
        <category>D.S.</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linuxCentOS lamp + wordpress （+ phpmyadmin）的解决方案]]></title>
    <url>%2Fpost%2Fe88577ed.html</url>
    <content type="text"><![CDATA[CentOS lamp + wordpress + phpmyadmin xshell + xftp组合运用。重装过系统无数遍 T^T，终于OK了！ 第一步：更新系统内核（不想更新可以跳过本步）。 php mysql 更新 yum -y update 如果执行失败，可以执行修复命令： rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY* 第二步：安装Apache,Mysql, PHP环境 1.安装Apache 在终端中输入下面的命令就可以安装Apache了： sudo yum install httpd 注：sudo的意思是用root用户做什么操作。要点击y就确认下载安装了，非常方便。 然后用下面的命令来启动服务： sudo service httpd start 另可选择安装Apache的扩展 执行命令： sudo yum -y install httpd-manual mod_ssl mod_perl mod_auth_mysql 2.安装Mysql sudo yum install mysql-server sudo service mysqld start 3.安装PHP以及PHP组件 sudo yum install php php-mysql 用上面这个命令就可以下载安装PHP了。 yum install php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc 这里简单的安装了7个组件，你也可以搜索所有的PHP组件，用下面的命令 yum search php- 4.开机默认启动Apache和Mysql服务 sudo chkconfig httpd on sudo chkconfig mysqld on 这两个命令来选择开机启动Apache和Mysql. 5.可以选择测试PHP是否安装成功 1 sudo nano /var/www/html/info.php 你可以用上面的命令来新建一个info.php文件，nano是简单的文本编辑工具，还有vim。 输入简单的测试PHP命令： &lt;?phpphpinfo();?&gt; 然后输入Ctrl o进行保存，点击回车确认。再输入Ctrl x进行退出。 然后在浏览器中，输入IP地址/info.php，就可以看到PHP的信息了！ 第三步：设置mysql数据库root帐号密码 mysqladmin -u root password ‘_mysql的管理员密码_’ 其次 为wordpress创建数据库 1. mysql -u root -p 2. CREATE DATABASE wordpress;Query OK, 1 row affected (0.00 sec) 3. CREATE USER wordpressUser@localhost;Query OK, 0 rows affected (0.00 sec) 4. SET PASSWORD FOR wordpresskUser@localhost= PASSWORD(“password”);Query OK, 0 rows affected (0.00 sec) 5. GRANT ALL PRIVILEGES ON wordpress.* TO wordpressUser@localhost IDENTIFIED BY ‘password’;Query OK, 0 rows affected (0.00 sec) 6. FLUSH PRIVILEGES; 7. exit; 第四步：安装WordPress 1.两种方式得到Wordpress 首先你可以去wordpress官方网站看下最新的wordpress的下载地址多少。比如wordpress 4.5.3的下载地址是： https://cn.wordpress.org/wordpress-4.5.3-zh_CN.zip 先用mkdir命令随便建立一个目录，这里使用wordpress，在该目录下用wget来请求wordpress的下载地址，这里用： wget http://cn.wordpress.org/wordpress-3.9-zh_CN.zipunzip wordpress-3.8-zh_CN.zip 用unzip 来解压zip文件。 然后编辑wp-config-sample.php文件，主要修改数据库信息。 nano wp-config-sample.php /** MySQL数据库名 /define(‘DB_NAME’, ‘wordpress’);/\* MySQL数据库用户名 /define(‘DB_USER’, ‘root’);/\* MySQL数据库密码 /define(‘DB_PASSWORD’, ‘_password_’);/\* MySQL主机（不用修改） */define(‘DB_HOST’, ‘localhost’); 数据库名字、数据库的用户名和密码都是之前一步填的，这里要填入。 记得ctrl + o 保存文件的时候，选择文件名为wp-config.php。 然后把所有的文件复制到/var/www/html 目录下。用 cp -rf wordpress/* /var/www/html/ 另可以：这样就把wordpress搞妥了，不过有些同学可能对命令操作有点恐惧，在Windows下可以用FileZilla软件，来把本地的文件上传到VPS中。FileZilla在文件的站点管理器中，选择新建站点，配置界面的协议选择SFTP。 上传速度大概只有50-60KB/S 2. service httpd restart 通过上面的两步，访问IP地址，一个崭新的Wordpress就可以建立了。访问你注册的域名应该就可以安装wordpress了。]]></content>
      <categories>
        <category>服务器</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>即用</tag>
      </tags>
  </entry>
</search>
